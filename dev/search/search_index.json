{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/overview/","title":"Overview","text":""},{"location":"api/overview/#anomaly","title":"anomaly","text":"<p>Anomaly detection.</p> <p>Estimators in the <code>anomaly</code> module have a bespoke API. Each anomaly detector has a <code>score_one</code> method instead of a <code>predict_one</code> method. This method returns an anomaly score. Normal observations should have a low score, whereas anomalous observations should have a high score. The range of the scores is relative to each estimator.</p> <p>Anomaly detectors are usually unsupervised, in that they analyze the distribution of the features they are shown. But River also has a notion of supervised anomaly detectors. These analyze the distribution of a target variable, and optionally include the distribution of the features as well. They are useful for detecting labelling anomalies, which can be detrimental if they learned by a model.</p> <ul> <li>GaussianScorer</li> <li>HalfSpaceTrees</li> <li>OneClassSVM</li> <li>QuantileFilter</li> <li>ThresholdFilter</li> </ul>"},{"location":"api/overview/#base","title":"base","text":"<ul> <li>AnomalyDetector</li> </ul>"},{"location":"api/overview/#bandit","title":"bandit","text":"<p>Multi-armed bandit (MAB) policies.</p> <p>The bandit policies in River are meant to have a generic API. This allows them to be used in a variety of contexts. Within River, they are used for model selection (see <code>model_selection.BanditRegressor</code>).</p> <p>Classes</p> <ul> <li>EpsilonGreedy</li> <li>ThompsonSampling</li> <li>UCB</li> </ul> <p>Functions</p> <ul> <li>evaluate</li> </ul>"},{"location":"api/overview/#base_1","title":"base","text":"<ul> <li>Policy</li> </ul>"},{"location":"api/overview/#envs","title":"envs","text":"<ul> <li>CandyCaneContest</li> <li>KArmedTestbed</li> </ul>"},{"location":"api/overview/#base_2","title":"base","text":"<p>Base interfaces.</p> <p>Every estimator in <code>river</code> is a class, and as such inherits from at least one base interface. These are used to categorize, organize, and standardize the many estimators that <code>river</code> contains.</p> <p>This module contains mixin classes, which are all suffixed by <code>Mixin</code>. Their purpose is to provide additional functionality to an estimator, and thus need to be used in conjunction with a non-mixin base class.</p> <p>This module also contains utilities for type hinting and tagging estimators.</p> <ul> <li>Base</li> <li>Classifier</li> <li>Clusterer</li> <li>DriftAndWarningDetector</li> <li>DriftDetector</li> <li>Ensemble</li> <li>Estimator</li> <li>MiniBatchClassifier</li> <li>MiniBatchRegressor</li> <li>MiniBatchSupervisedTransformer</li> <li>MiniBatchTransformer</li> <li>MultiOutputMixin</li> <li>Regressor</li> <li>SupervisedTransformer</li> <li>Transformer</li> <li>Wrapper</li> <li>WrapperEnsemble</li> </ul>"},{"location":"api/overview/#cluster","title":"cluster","text":"<p>Unsupervised clustering.</p> <ul> <li>CluStream</li> <li>DBSTREAM</li> <li>DenStream</li> <li>KMeans</li> <li>STREAMKMeans</li> <li>TextClust</li> </ul>"},{"location":"api/overview/#compat","title":"compat","text":"<p>Compatibility tools.</p> <p>This module contains adapters for making <code>river</code> estimators compatible with other libraries, and vice-versa whenever possible. The relevant adapters will only be usable if you have installed the necessary library. For instance, you have to install scikit-learn in order to use the <code>compat.convert_sklearn_to_river</code> function.</p> <p>Classes</p> <ul> <li>River2SKLClassifier</li> <li>River2SKLClusterer</li> <li>River2SKLRegressor</li> <li>River2SKLTransformer</li> <li>SKL2RiverClassifier</li> <li>SKL2RiverRegressor</li> </ul> <p>Functions</p> <ul> <li>convert_river_to_sklearn</li> <li>convert_sklearn_to_river</li> </ul>"},{"location":"api/overview/#compose","title":"compose","text":"<p>Model composition.</p> <p>This module contains utilities for merging multiple modeling steps into a single pipeline. Although pipelines are not the only way to process a stream of data, we highly encourage you to use them.</p> <p>Classes</p> <ul> <li>Discard</li> <li>FuncTransformer</li> <li>Grouper</li> <li>Pipeline</li> <li>Prefixer</li> <li>Renamer</li> <li>Select</li> <li>SelectType</li> <li>Suffixer</li> <li>TargetTransformRegressor</li> <li>TransformerProduct</li> <li>TransformerUnion</li> </ul> <p>Functions</p> <ul> <li>pure_inference_mode</li> <li>warm_up_mode</li> </ul>"},{"location":"api/overview/#conf","title":"conf","text":"<p>Conformal predictions. This modules contains wrappers to enable conformal predictions on any regressor or classifier.</p> <ul> <li>Interval</li> <li>RegressionJackknife</li> </ul>"},{"location":"api/overview/#covariance","title":"covariance","text":"<p>Online estimation of covariance and precision matrices.</p> <ul> <li>EmpiricalCovariance</li> <li>EmpiricalPrecision</li> </ul>"},{"location":"api/overview/#datasets","title":"datasets","text":"<p>Datasets.</p> <p>This module contains a collection of datasets for multiple tasks: classification, regression, etc. The data corresponds to popular datasets and are conveniently wrapped to easily iterate over the data in a stream fashion. All datasets have fixed size. Please refer to <code>river.synth</code> if you are interested in infinite synthetic data generators.</p> <ul> <li>AirlinePassengers</li> <li>Bananas</li> <li>Bikes</li> <li>ChickWeights</li> <li>CreditCard</li> <li>Elec2</li> <li>HTTP</li> <li>Higgs</li> <li>ImageSegments</li> <li>Insects</li> <li>Keystroke</li> <li>MaliciousURL</li> <li>MovieLens100K</li> <li>Music</li> <li>Phishing</li> <li>Restaurants</li> <li>SMSSpam</li> <li>SMTP</li> <li>SolarFlare</li> <li>TREC07</li> <li>Taxis</li> <li>TrumpApproval</li> <li>WaterFlow</li> </ul>"},{"location":"api/overview/#base_3","title":"base","text":"<ul> <li>Dataset</li> <li>FileDataset</li> <li>RemoteDataset</li> <li>SyntheticDataset</li> </ul>"},{"location":"api/overview/#synth","title":"synth","text":"<p>Synthetic datasets.</p> <p>Each synthetic dataset is a stream generator. The benefit of using a generator is that they do not store the data and each data sample is generated on the fly. Except for a couple of methods, the majority of these methods are infinite data generators.</p> <ul> <li>Agrawal</li> <li>AnomalySine</li> <li>ConceptDriftStream</li> <li>Friedman</li> <li>FriedmanDrift</li> <li>Hyperplane</li> <li>LED</li> <li>LEDDrift</li> <li>Logical</li> <li>Mixed</li> <li>Mv</li> <li>Planes2D</li> <li>RandomRBF</li> <li>RandomRBFDrift</li> <li>RandomTree</li> <li>SEA</li> <li>STAGGER</li> <li>Sine</li> <li>Waveform</li> </ul>"},{"location":"api/overview/#drift","title":"drift","text":"<p>Concept Drift Detection.</p> <p>This module contains concept drift detection methods. The purpose of a drift detector is to raise an alarm if the data distribution changes. A good drift detector method is the one that maximizes the true positives while keeping the number of false positives to a minimum.</p> <ul> <li>ADWIN</li> <li>DDM</li> <li>DriftRetrainingClassifier</li> <li>EDDM</li> <li>HDDM_A</li> <li>HDDM_W</li> <li>KSWIN</li> <li>PageHinkley</li> <li>PeriodicTrigger</li> </ul>"},{"location":"api/overview/#dummy","title":"dummy","text":"<p>Dummy estimators.</p> <p>This module is here for testing purposes, as well as providing baseline performances.</p> <ul> <li>NoChangeClassifier</li> <li>PriorClassifier</li> <li>StatisticRegressor</li> </ul>"},{"location":"api/overview/#ensemble","title":"ensemble","text":"<p>Ensemble learning.</p> <p>Broadly speaking, there are two kinds of ensemble approaches. There are those that copy a single model several times and aggregate the predictions of said copies. This includes bagging as well as boosting. Then there are those that are composed of an arbitrary list of models, and can therefore aggregate predictions from different kinds of models.</p> <ul> <li>ADWINBaggingClassifier</li> <li>ADWINBoostingClassifier</li> <li>AdaBoostClassifier</li> <li>AdaptiveRandomForestClassifier</li> <li>AdaptiveRandomForestRegressor</li> <li>BOLEClassifier</li> <li>BaggingClassifier</li> <li>BaggingRegressor</li> <li>EWARegressor</li> <li>LeveragingBaggingClassifier</li> <li>SRPClassifier</li> <li>SRPRegressor</li> <li>StackingClassifier</li> <li>VotingClassifier</li> </ul>"},{"location":"api/overview/#evaluate","title":"evaluate","text":"<p>Model evaluation.</p> <p>This module provides utilities to evaluate an online model. The goal is to reproduce a real-world scenario with high fidelity. The core function of this module is <code>progressive_val_score</code>, which allows to evaluate a model via progressive validation.</p> <p>This module also exposes \"tracks\". A track is a predefined combination of a dataset and one or more metrics. This allows a principled manner to compare models with each other. For instance, the <code>RegressionTrack</code> contains several datasets and metrics to evaluate regression models. There is also a bare <code>Track</code> class to implement a custom track. The <code>benchmarks</code> directory at the root of the River repository uses these tracks.</p> <p>Classes</p> <ul> <li>BinaryClassificationTrack</li> <li>MultiClassClassificationTrack</li> <li>RegressionTrack</li> <li>Track</li> </ul> <p>Functions</p> <ul> <li>iter_progressive_val_score</li> <li>progressive_val_score</li> </ul>"},{"location":"api/overview/#facto","title":"facto","text":"<p>Factorization machines.</p> <ul> <li>FFMClassifier</li> <li>FFMRegressor</li> <li>FMClassifier</li> <li>FMRegressor</li> <li>FwFMClassifier</li> <li>FwFMRegressor</li> <li>HOFMClassifier</li> <li>HOFMRegressor</li> </ul>"},{"location":"api/overview/#feature_extraction","title":"feature_extraction","text":"<p>Feature extraction.</p> <p>This module can be used to extract information from raw features. This includes encoding categorical data as well as looking at interactions between existing features. This differs from the <code>processing</code> module in that the latter's purpose is rather to clean the data so that it may be processed by a particular machine learning algorithm.</p> <ul> <li>Agg</li> <li>BagOfWords</li> <li>PolynomialExtender</li> <li>RBFSampler</li> <li>TFIDF</li> <li>TargetAgg</li> </ul>"},{"location":"api/overview/#feature_selection","title":"feature_selection","text":"<p>Feature selection.</p> <ul> <li>PoissonInclusion</li> <li>SelectKBest</li> <li>VarianceThreshold</li> </ul>"},{"location":"api/overview/#imblearn","title":"imblearn","text":"<p>Sampling methods.</p> <ul> <li>ChebyshevOverSampler</li> <li>ChebyshevUnderSampler</li> <li>HardSamplingClassifier</li> <li>HardSamplingRegressor</li> <li>RandomOverSampler</li> <li>RandomSampler</li> <li>RandomUnderSampler</li> </ul>"},{"location":"api/overview/#linear_model","title":"linear_model","text":"<p>Linear models.</p> <ul> <li>ALMAClassifier</li> <li>BayesianLinearRegression</li> <li>LinearRegression</li> <li>LogisticRegression</li> <li>PAClassifier</li> <li>PARegressor</li> <li>Perceptron</li> <li>SoftmaxRegression</li> </ul>"},{"location":"api/overview/#base_4","title":"base","text":"<ul> <li>GLM</li> </ul>"},{"location":"api/overview/#metrics","title":"metrics","text":"<p>Evaluation metrics.</p> <p>All the metrics are updated one sample at a time. This way we can track performance of predictive methods over time.</p> <p>Note that all metrics have a <code>revert</code> method, enabling them to be wrapped in <code>utils.Rolling</code>. This allows computirng rolling metrics:</p>    <p>from river import metrics, utils</p> <p>y_true = [True, False, True, True] y_pred = [False, False, True, True]</p> <p>metric = utils.Rolling(metrics.Accuracy(), window_size=3)</p> <p>for yt, yp in zip(y_true, y_pred): ...     print(metric.update(yt, yp)) Accuracy: 0.00% Accuracy: 50.00% Accuracy: 66.67% Accuracy: 100.00%</p>    <ul> <li>Accuracy</li> <li>AdjustedMutualInfo</li> <li>AdjustedRand</li> <li>BalancedAccuracy</li> <li>ClassificationReport</li> <li>CohenKappa</li> <li>Completeness</li> <li>ConfusionMatrix</li> <li>CrossEntropy</li> <li>F1</li> <li>FBeta</li> <li>FowlkesMallows</li> <li>GeometricMean</li> <li>Homogeneity</li> <li>Jaccard</li> <li>LogLoss</li> <li>MAE</li> <li>MCC</li> <li>MSE</li> <li>MacroF1</li> <li>MacroFBeta</li> <li>MacroJaccard</li> <li>MacroPrecision</li> <li>MacroRecall</li> <li>MicroF1</li> <li>MicroFBeta</li> <li>MicroJaccard</li> <li>MicroPrecision</li> <li>MicroRecall</li> <li>MultiFBeta</li> <li>MutualInfo</li> <li>NormalizedMutualInfo</li> <li>Precision</li> <li>R2</li> <li>RMSE</li> <li>RMSLE</li> <li>ROCAUC</li> <li>Rand</li> <li>Recall</li> <li>SMAPE</li> <li>Silhouette</li> <li>VBeta</li> <li>WeightedF1</li> <li>WeightedFBeta</li> <li>WeightedJaccard</li> <li>WeightedPrecision</li> <li>WeightedRecall</li> </ul>"},{"location":"api/overview/#base_5","title":"base","text":"<ul> <li>BinaryMetric</li> <li>ClassificationMetric</li> <li>Metric</li> <li>Metrics</li> <li>MultiClassMetric</li> <li>RegressionMetric</li> <li>WrapperMetric</li> </ul>"},{"location":"api/overview/#multioutput","title":"multioutput","text":"<p>Metrics for multi-output learning.</p> <ul> <li>ExactMatch</li> <li>MacroAverage</li> <li>MicroAverage</li> <li>MultiLabelConfusionMatrix</li> <li>PerOutput</li> </ul>"},{"location":"api/overview/#base_6","title":"base","text":"<ul> <li>MultiOutputClassificationMetric</li> <li>MultiOutputRegressionMetric</li> </ul>"},{"location":"api/overview/#misc","title":"misc","text":"<p>Miscellaneous.</p> <p>This module essentially regroups some implementations that have nowhere else to go.</p> <ul> <li>SDFT</li> <li>Skyline</li> </ul>"},{"location":"api/overview/#model_selection","title":"model_selection","text":"<p>Model selection.</p> <p>This module regroups a variety of methods that may be used for performing model selection. An model selector is provided with a list of models. These are called \"experts\" in the expert learning literature. The model selector's goal is to perform at least as well as the best model. Indeed, initially, the best model is not known. The performance of each model becomes more apparent as time goes by. Different strategies are possible, each one offering a different tradeoff in terms of accuracy and computational performance.</p> <p>Model selection can be used for tuning the hyperparameters of a model. This may be done by creating a copy of the model for each set of hyperparameters, and treating each copy as a separate model. The <code>utils.expand_param_grid</code> function can be used for this purpose.</p> <ul> <li>BanditRegressor</li> <li>GreedyRegressor</li> <li>SuccessiveHalvingClassifier</li> <li>SuccessiveHalvingRegressor</li> </ul>"},{"location":"api/overview/#base_7","title":"base","text":"<ul> <li>ModelSelectionClassifier</li> <li>ModelSelectionRegressor</li> </ul>"},{"location":"api/overview/#multiclass","title":"multiclass","text":"<p>Multi-class classification.</p> <ul> <li>OneVsOneClassifier</li> <li>OneVsRestClassifier</li> <li>OutputCodeClassifier</li> </ul>"},{"location":"api/overview/#multioutput_1","title":"multioutput","text":"<p>Multi-output models.</p> <ul> <li>ClassifierChain</li> <li>MonteCarloClassifierChain</li> <li>ProbabilisticClassifierChain</li> <li>RegressorChain</li> </ul>"},{"location":"api/overview/#naive_bayes","title":"naive_bayes","text":"<p>Naive Bayes algorithms.</p> <ul> <li>BernoulliNB</li> <li>ComplementNB</li> <li>GaussianNB</li> <li>MultinomialNB</li> </ul>"},{"location":"api/overview/#neighbors","title":"neighbors","text":"<p>Neighbors-based learning.</p> <p>Also known as lazy methods. In these methods, generalisation of the training data is delayed until a query is received.</p> <ul> <li>KNNClassifier</li> <li>KNNRegressor</li> <li>NearestNeighbors</li> </ul>"},{"location":"api/overview/#neural_net","title":"neural_net","text":"<p>Neural networks.</p> <ul> <li>MLPRegressor</li> </ul>"},{"location":"api/overview/#activations","title":"activations","text":"<ul> <li>Identity</li> <li>ReLU</li> <li>Sigmoid</li> </ul>"},{"location":"api/overview/#optim","title":"optim","text":"<p>Stochastic optimization.</p> <ul> <li>AMSGrad</li> <li>AdaBound</li> <li>AdaDelta</li> <li>AdaGrad</li> <li>AdaMax</li> <li>Adam</li> <li>Averager</li> <li>FTRLProximal</li> <li>Momentum</li> <li>Nadam</li> <li>NesterovMomentum</li> <li>RMSProp</li> <li>SGD</li> </ul>"},{"location":"api/overview/#base_8","title":"base","text":"<ul> <li>Initializer</li> <li>Loss</li> <li>Optimizer</li> <li>Scheduler</li> </ul>"},{"location":"api/overview/#initializers","title":"initializers","text":"<p>Weight initializers.</p> <ul> <li>Constant</li> <li>Normal</li> <li>Zeros</li> </ul>"},{"location":"api/overview/#losses","title":"losses","text":"<p>Loss functions.</p> <p>Each loss function is intended to work with both single values as well as numpy vectors.</p> <ul> <li>Absolute</li> <li>BinaryFocalLoss</li> <li>BinaryLoss</li> <li>Cauchy</li> <li>CrossEntropy</li> <li>EpsilonInsensitiveHinge</li> <li>Hinge</li> <li>Huber</li> <li>Log</li> <li>MultiClassLoss</li> <li>Poisson</li> <li>Quantile</li> <li>RegressionLoss</li> <li>Squared</li> </ul>"},{"location":"api/overview/#schedulers","title":"schedulers","text":"<p>Learning rate schedulers.</p> <ul> <li>Constant</li> <li>InverseScaling</li> <li>Optimal</li> </ul>"},{"location":"api/overview/#preprocessing","title":"preprocessing","text":"<p>Feature preprocessing.</p> <p>The purpose of this module is to modify an existing set of features so that they can be processed by a machine learning algorithm. This may be done by scaling numeric parts of the data or by one-hot encoding categorical features. The difference with the <code>feature_extraction</code> module is that the latter extracts new information from the data</p> <ul> <li>AdaptiveStandardScaler</li> <li>Binarizer</li> <li>FeatureHasher</li> <li>LDA</li> <li>MaxAbsScaler</li> <li>MinMaxScaler</li> <li>Normalizer</li> <li>OneHotEncoder</li> <li>PredClipper</li> <li>PreviousImputer</li> <li>RobustScaler</li> <li>StandardScaler</li> <li>StatImputer</li> <li>TargetStandardScaler</li> </ul>"},{"location":"api/overview/#proba","title":"proba","text":"<p>Probability distributions.</p> <ul> <li>Beta</li> <li>Gaussian</li> <li>Multinomial</li> </ul>"},{"location":"api/overview/#base_9","title":"base","text":"<ul> <li>BinaryDistribution</li> <li>ContinuousDistribution</li> <li>DiscreteDistribution</li> </ul>"},{"location":"api/overview/#reco","title":"reco","text":"<p>Recommender systems module.</p> <p>Recommender systems (recsys for short) is a large topic. This module is far from comprehensive. It simply provides models which can contribute towards building a recommender system.</p> <p>A typical recommender system is made up of a retrieval phase, followed by a ranking phase. The output of the retrieval phase is a shortlist of the catalogue of items. The items in the shortlist are then usually ranked according to the expected preference the user will have for each item. This module focuses on the ranking phase.</p> <p>Models which inherit from the <code>Ranker</code> class have a <code>rank</code> method. This allows sorting a set of items for a given user. Each model also has a <code>learn_one(user, item, y, context)</code> which allows learning user preferences. The <code>y</code> parameter is a reward value, the nature of which depends is specific to each and every recommendation task. Typically the reward is a number or a boolean value. It is up to the user to determine how to translate a user session into training data.</p> <ul> <li>Baseline</li> <li>BiasedMF</li> <li>FunkMF</li> <li>RandomNormal</li> </ul>"},{"location":"api/overview/#base_10","title":"base","text":"<ul> <li>Ranker</li> </ul>"},{"location":"api/overview/#rules","title":"rules","text":"<p>Decision rules-based algorithms.</p> <ul> <li>AMRules</li> </ul>"},{"location":"api/overview/#sketch","title":"sketch","text":"<p>Data containers and collections for sequential data.</p> <p>This module has summary and sketch structures that operate with constrained amounts of memory and processing time.</p> <ul> <li>Counter</li> <li>HeavyHitters</li> <li>Histogram</li> <li>Set</li> </ul>"},{"location":"api/overview/#stats","title":"stats","text":"<p>Running statistics</p> <ul> <li>AbsMax</li> <li>AutoCorr</li> <li>BayesianMean</li> <li>Count</li> <li>Cov</li> <li>EWMean</li> <li>EWVar</li> <li>Entropy</li> <li>IQR</li> <li>Kurtosis</li> <li>Link</li> <li>MAD</li> <li>Max</li> <li>Mean</li> <li>Min</li> <li>Mode</li> <li>NUnique</li> <li>PeakToPeak</li> <li>PearsonCorr</li> <li>Quantile</li> <li>RollingAbsMax</li> <li>RollingIQR</li> <li>RollingMax</li> <li>RollingMin</li> <li>RollingMode</li> <li>RollingPeakToPeak</li> <li>RollingQuantile</li> <li>SEM</li> <li>Shift</li> <li>Skew</li> <li>Sum</li> <li>Var</li> </ul>"},{"location":"api/overview/#base_11","title":"base","text":"<ul> <li>Bivariate</li> <li>Univariate</li> </ul>"},{"location":"api/overview/#stream","title":"stream","text":"<p>Streaming utilities.</p> <p>The module includes tools to iterate over data streams.</p> <p>Classes</p> <ul> <li>Cache</li> <li>TwitchChatStream</li> <li>TwitterLiveStream</li> </ul> <p>Functions</p> <ul> <li>iter_arff</li> <li>iter_array</li> <li>iter_csv</li> <li>iter_libsvm</li> <li>iter_pandas</li> <li>iter_sklearn_dataset</li> <li>iter_sql</li> <li>shuffle</li> <li>simulate_qa</li> </ul>"},{"location":"api/overview/#time_series","title":"time_series","text":"<p>Time series forecasting.</p> <p>Classes</p> <ul> <li>ForecastingMetric</li> <li>HoltWinters</li> <li>HorizonAggMetric</li> <li>HorizonMetric</li> <li>SNARIMAX</li> </ul> <p>Functions</p> <ul> <li>evaluate</li> <li>iter_evaluate</li> </ul>"},{"location":"api/overview/#base_12","title":"base","text":"<ul> <li>Forecaster</li> </ul>"},{"location":"api/overview/#tree","title":"tree","text":"<p>This module implements incremental Decision Tree (iDT) algorithms for handling classification and regression tasks.</p> <p>Each family of iDT will be presented in a dedicated section.</p> <p>At any moment, iDT might face situations where an input feature previously used to make a split decision is missing in an incoming sample. In this case, the most traversed path is selected to pass down the instance. Moreover, in the case of nominal features, if a new category arises and the feature is used in a decision node, a new branch is created to accommodate the new value.</p> <p>1. Hoeffding Trees</p> <p>This family of iDT algorithms use the Hoeffding Bound to determine whether or not the incrementally computed best split candidates would be equivalent to the ones obtained in a batch-processing fashion.</p> <p>All the available Hoeffding Tree (HT) implementation share some common functionalities:</p> <ul> <li> <p>Set the maximum tree depth allowed (<code>max_depth</code>).</p> </li> <li> <p>Handle Active and Inactive nodes: Active learning nodes update their own internal state to improve predictions and monitor input features to perform split attempts. Inactive learning nodes do not update their internal state and only keep the predictors; they are used to save memory in the tree (<code>max_size</code>).</p> </li> <li> <p>Enable/disable memory management.</p> </li> <li> <p>Define strategies to sort leaves according to how likely they are going to be split. This enables deactivating non-promising leaves to save memory.</p> </li> <li> <p>Disabling \u2018poor\u2019 attributes to save memory and speed up tree construction. A poor attribute is an input feature whose split merit is much smaller than the current best candidate. Once a feature is disabled, the tree stops saving statistics necessary to split such a feature.</p> </li> <li> <p>Define properties to access leaf prediction strategies, split criteria, and other relevant characteristics.</p> </li> </ul> <p>2. Stochastic Gradient Trees</p> <p>Stochastic Gradient Trees (SGT) directly optimize a loss function, rather than relying on split heuristics to guide the tree growth. F-tests are performed do decide whether a leaf should be expanded or its prediction value should be updated.</p> <p>SGTs can deal with binary classification and single-target regression. They also support dynamic and static feature quantizers to deal with numerical inputs.</p> <ul> <li>ExtremelyFastDecisionTreeClassifier</li> <li>HoeffdingAdaptiveTreeClassifier</li> <li>HoeffdingAdaptiveTreeRegressor</li> <li>HoeffdingTreeClassifier</li> <li>HoeffdingTreeRegressor</li> <li>LabelCombinationHoeffdingTreeClassifier</li> <li>SGTClassifier</li> <li>SGTRegressor</li> <li>iSOUPTreeRegressor</li> </ul>"},{"location":"api/overview/#base_13","title":"base","text":"<p>This module defines generic branch and leaf implementations. These should be used in River by each tree-based model. Using these classes makes the code more DRY. The only exception for not doing so would be for performance, whereby a tree-based model uses a bespoke implementation.</p> <p>This module defines a bunch of methods to ease the manipulation and diagnostic of trees. Its intention is to provide utilities for walking over a tree and visualizing it.</p> <ul> <li>Branch</li> <li>Leaf</li> </ul>"},{"location":"api/overview/#splitter","title":"splitter","text":"<p>This module implements the Attribute Observers (AO) (or tree splitters) that are used by the Hoeffding Trees (HT). It also implements the feature quantizers (FQ) used by Stochastic Gradient Trees (SGT). AOs are a core aspect of the HTs construction, and might represent one of the major bottlenecks when building the trees. The same holds for SGTs and FQs. The correct choice and setup of a splitter might result in significant differences in the running time and memory usage of the incremental decision trees.</p> <p>AOs for classification and regression trees can be differentiated by using the property <code>is_target_class</code> (<code>True</code> for splitters designed to classification tasks). An error will be raised if one tries to use a classification splitter in a regression tree and vice-versa. Lastly, AOs cannot be used in SGT and FQs cannot be used in Hoeffding Trees. So, care must be taken when choosing the correct feature splitter.</p> <ul> <li>DynamicQuantizer</li> <li>EBSTSplitter</li> <li>ExhaustiveSplitter</li> <li>GaussianSplitter</li> <li>HistogramSplitter</li> <li>QOSplitter</li> <li>Quantizer</li> <li>Splitter</li> <li>StaticQuantizer</li> <li>TEBSTSplitter</li> </ul>"},{"location":"api/overview/#utils","title":"utils","text":"<p>Shared utility classes and functions</p> <p>Classes</p> <ul> <li>Rolling</li> <li>SortedWindow</li> <li>TimeRolling</li> <li>VectorDict</li> </ul> <p>Functions</p> <ul> <li>dict2numpy</li> <li>expand_param_grid</li> <li>log_method_calls</li> <li>numpy2dict</li> </ul>"},{"location":"api/overview/#math","title":"math","text":"<p>Mathematical utility functions (intended for internal purposes).</p> <p>A lot of this is experimental and has a high probability of changing in the future.</p> <ul> <li>argmax</li> <li>chain_dot</li> <li>clamp</li> <li>dot</li> <li>dotvecmat</li> <li>matmul2d</li> <li>minkowski_distance</li> <li>norm</li> <li>outer</li> <li>prod</li> <li>sherman_morrison</li> <li>sigmoid</li> <li>sign</li> <li>softmax</li> <li>woodbury_matrix</li> </ul>"},{"location":"api/overview/#norm","title":"norm","text":"<ul> <li>normalize_values_in_dict</li> <li>scale_values_in_dict</li> </ul>"},{"location":"api/overview/#pretty","title":"pretty","text":"<p>Helper functions for making things readable by humans.</p> <ul> <li>humanize_bytes</li> <li>print_table</li> </ul>"},{"location":"api/overview/#random","title":"random","text":"<ul> <li>poisson</li> </ul>"},{"location":"api/anomaly/GaussianScorer/","title":"GaussianScorer","text":"<p>Univariate Gaussian anomaly detector.</p> <p>This is a supervised anomaly detector. It fits a Gaussian distribution to the target values. The anomaly score is then computed as so: </p> \\[score = 2 * \\mid CDF(y) - 0.5 \\mid\\] <p>This makes it so that the anomaly score is between 0 and 1.</p>"},{"location":"api/anomaly/GaussianScorer/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size \u2013 defaults to <code>None</code></p> <p>Set this to fit the Gaussian distribution over a window of recent values.</p> </li> <li> <p>grace_period \u2013 defaults to <code>100</code></p> <p>Number of samples before which a 0 is always returned. This is handy because the Gaussian distribution needs time to stabilize, and will likely produce overly high anomaly score for the first samples.</p> </li> </ul>"},{"location":"api/anomaly/GaussianScorer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import anomaly\n\n&gt;&gt;&gt; rng = random.Random(42)\n&gt;&gt;&gt; detector = anomaly.GaussianScorer()\n\n&gt;&gt;&gt; for y in (rng.gauss(0, 1) for _ in range(100)):\n...     detector = detector.learn_one(None, y)\n\n&gt;&gt;&gt; detector.score_one(None, -3)\n0.999477...\n\n&gt;&gt;&gt; detector.score_one(None, 3)\n0.999153...\n\n&gt;&gt;&gt; detector.score_one(None, 0)\n0.052665...\n\n&gt;&gt;&gt; detector.score_one(None, 0.5)\n0.383717...\n</code></pre>"},{"location":"api/anomaly/GaussianScorer/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>_ </li> <li>y     (Union[bool, str, int, numbers.Number])    </li> </ul> <p>Returns</p> <p>SupervisedAnomalyDetector:     self</p>   score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds a normal observation.</p> <p>Parameters</p> <ul> <li>_ </li> <li>y     (Union[bool, str, int, numbers.Number])    </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p>"},{"location":"api/anomaly/HalfSpaceTrees/","title":"HalfSpaceTrees","text":"<p>Half-Space Trees (HST).</p> <p>Half-space trees are an online variant of isolation forests. They work well when anomalies are spread out. However, they do not work well if anomalies are packed together in windows. </p> <p>By default, this implementation assumes that each feature has values that are comprised between 0 and 1. If this isn't the case, then you can manually specify the limits via the <code>limits</code> argument. If you do not know the limits in advance, then you can use a <code>preprocessing.MinMaxScaler</code> as an initial preprocessing step. </p> <p>The current implementation builds the trees the first time the <code>learn_one</code> method is called. Therefore, the first <code>learn_one</code> call might be slow, whereas subsequent calls will be very fast in comparison. In general, the computation time of both <code>learn_one</code> and <code>score_one</code> scales linearly with the number of trees, and exponentially with the height of each tree. </p> <p>Note that high scores indicate anomalies, whereas low scores indicate normal observations.</p>"},{"location":"api/anomaly/HalfSpaceTrees/#parameters","title":"Parameters","text":"<ul> <li> <p>n_trees \u2013 defaults to <code>10</code></p> <p>Number of trees to use.</p> </li> <li> <p>height \u2013 defaults to <code>8</code></p> <p>Height of each tree. Note that a tree of height <code>h</code> is made up of <code>h + 1</code> levels and therefore contains <code>2 ** (h + 1) - 1</code> nodes.</p> </li> <li> <p>window_size \u2013 defaults to <code>250</code></p> <p>Number of observations to use for calculating the mass at each node in each tree.</p> </li> <li> <p>limits (Dict[Hashable, Tuple[float, float]]) \u2013 defaults to <code>None</code></p> <p>Specifies the range of each feature. By default each feature is assumed to be in range <code>[0, 1]</code>.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number seed.</p> </li> </ul>"},{"location":"api/anomaly/HalfSpaceTrees/#attributes","title":"Attributes","text":"<ul> <li> <p>size_limit</p> <p>This is the threshold under which the node search stops during the scoring phase.  The value .1 is a magic constant indicated in the original paper.</p> </li> </ul>"},{"location":"api/anomaly/HalfSpaceTrees/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import anomaly\n\n&gt;&gt;&gt; X = [0.5, 0.45, 0.43, 0.44, 0.445, 0.45, 0.0]\n&gt;&gt;&gt; hst = anomaly.HalfSpaceTrees(\n...     n_trees=5,\n...     height=3,\n...     window_size=3,\n...     seed=42\n... )\n\n&gt;&gt;&gt; for x in X[:3]:\n...     hst = hst.learn_one({'x': x})  # Warming up\n\n&gt;&gt;&gt; for x in X:\n...     features = {'x': x}\n...     hst = hst.learn_one(features)\n...     print(f'Anomaly score for x={x:.3f}: {hst.score_one(features):.3f}')\nAnomaly score for x=0.500: 0.107\nAnomaly score for x=0.450: 0.071\nAnomaly score for x=0.430: 0.107\nAnomaly score for x=0.440: 0.107\nAnomaly score for x=0.445: 0.107\nAnomaly score for x=0.450: 0.071\nAnomaly score for x=0.000: 0.853\n</code></pre> <p>The feature values are all comprised between 0 and 1. This is what is assumed by the model by default. In the following example, we construct a pipeline that scales the data online and ensures that the values of each feature are comprised between 0 and 1.</p> <pre><code>&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     preprocessing.MinMaxScaler(),\n...     anomaly.HalfSpaceTrees(seed=42)\n... )\n\n&gt;&gt;&gt; auc = metrics.ROCAUC()\n\n&gt;&gt;&gt; for x, y in datasets.CreditCard().take(2500):\n...     score = model.score_one(x)\n...     model = model.learn_one(x)\n...     auc = auc.update(y, score)\n\n&gt;&gt;&gt; auc\nROCAUC: 91.15%\n</code></pre> <p>You can also use the <code>evaluate.progressive_val_score</code> function to evaluate the model on a data stream.</p> <pre><code>&gt;&gt;&gt; from river import evaluate\n\n&gt;&gt;&gt; model = model.clone()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     dataset=datasets.CreditCard().take(2500),\n...     model=model,\n...     metric=metrics.ROCAUC(),\n...     print_every=1000\n... )\n[1,000] ROCAUC: 88.43%\n[2,000] ROCAUC: 89.28%\nROCAUC: 91.15%\n</code></pre>"},{"location":"api/anomaly/HalfSpaceTrees/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>AnomalyDetector:     self</p>   score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p>"},{"location":"api/anomaly/HalfSpaceTrees/#references","title":"References","text":"<ol> <li> <p>Tan, S.C., Ting, K.M. and Liu, T.F., 2011, June. Fast anomaly detection for streaming data. In Twenty-Second International Joint Conference on Artificial Intelligence. \u21a9</p> </li> </ol>"},{"location":"api/anomaly/OneClassSVM/","title":"OneClassSVM","text":"<p>One-class SVM for anomaly detection.</p> <p>This is a stochastic implementation of the one-class SVM algorithm, and will not exactly match its batch formulation. </p> <p>It is encouraged to scale the data upstream with <code>preprocessing.StandardScaler</code>, as well as use <code>feature_extraction.RBFSampler</code> to capture non-linearities.</p>"},{"location":"api/anomaly/OneClassSVM/#parameters","title":"Parameters","text":"<ul> <li> <p>nu \u2013 defaults to <code>0.1</code></p> <p>An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. You can think of it as the expected fraction of anomalies.</p> </li> <li> <p>optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the weights.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/anomaly/OneClassSVM/#attributes","title":"Attributes","text":"<ul> <li>weights</li> </ul>"},{"location":"api/anomaly/OneClassSVM/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import anomaly\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = anomaly.QuantileFilter(\n...     anomaly.OneClassSVM(nu=0.2),\n...     q=0.995\n... )\n\n&gt;&gt;&gt; auc = metrics.ROCAUC()\n\n&gt;&gt;&gt; for x, y in datasets.CreditCard().take(2500):\n...     score = model.score_one(x)\n...     is_anomaly = model.classify(score)\n...     model = model.learn_one(x)\n...     auc = auc.update(y, is_anomaly)\n\n&gt;&gt;&gt; auc\nROCAUC: 74.68%\n</code></pre> <p>You can also use the <code>evaluate.progressive_val_score</code> function to evaluate the model on a data stream.</p> <pre><code>&gt;&gt;&gt; from river import evaluate\n\n&gt;&gt;&gt; model = model.clone()\n&gt;&gt;&gt;\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     dataset=datasets.CreditCard().take(2500),\n...     model=model,\n...     metric=metrics.ROCAUC(),\n...     print_every=1000\n... )\n[1,000] ROCAUC: 74.40%\n[2,000] ROCAUC: 74.60%\nROCAUC: 74.68%\n</code></pre>"},{"location":"api/anomaly/OneClassSVM/#methods","title":"Methods","text":"learn_many   learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>AnomalyDetector:     self</p>   score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p>"},{"location":"api/anomaly/QuantileFilter/","title":"QuantileFilter","text":"<p>Threshold anomaly filter.</p>"},{"location":"api/anomaly/QuantileFilter/#parameters","title":"Parameters","text":"<ul> <li> <p>anomaly_detector</p> <p>An anomaly detector.</p> </li> <li> <p>q (float)</p> <p>The quantile level above which to classify an anomaly score as anomalous.</p> </li> <li> <p>protect_anomaly_detector \u2013 defaults to <code>True</code></p> <p>Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift.</p> </li> </ul>"},{"location":"api/anomaly/QuantileFilter/#attributes","title":"Attributes","text":"<ul> <li>q</li> </ul>"},{"location":"api/anomaly/QuantileFilter/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import anomaly\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     preprocessing.MinMaxScaler(),\n...     anomaly.QuantileFilter(\n...         anomaly.HalfSpaceTrees(seed=42),\n...         q=0.95\n...     )\n... )\n\n&gt;&gt;&gt; report = metrics.ClassificationReport()\n\n&gt;&gt;&gt; for x, y in datasets.CreditCard().take(2000):\n...     score = model.score_one(x)\n...     is_anomaly = model['QuantileFilter'].classify(score)\n...     model = model.learn_one(x)\n...     report = report.update(y, is_anomaly)\n\n&gt;&gt;&gt; report\n               Precision   Recall   F1       Support\n&lt;BLANKLINE&gt;\n       0      99.95%   94.49%   97.14%      1998\n       1       0.90%   50.00%    1.77%         2\n&lt;BLANKLINE&gt;\n   Macro      50.42%   72.25%   49.46%\n   Micro      94.45%   94.45%   94.45%\nWeighted      99.85%   94.45%   97.05%\n&lt;BLANKLINE&gt;\n                 94.45% accuracy\n</code></pre>"},{"location":"api/anomaly/QuantileFilter/#methods","title":"Methods","text":"classify <p>Classify an anomaly score as anomalous or not.</p> <p>Parameters</p> <ul> <li>score     (float)    </li> </ul> <p>Returns</p> <p>bool:     A boolean value indicating whether the anomaly score is anomalous or not.</p>   learn_one <p>Update the anomaly filter and the underlying anomaly detector.</p> <p>Parameters</p> <ul> <li>args </li> </ul> <p>Returns</p> <p>self</p>   score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>args </li> </ul> <p>Returns</p> <p>An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p>"},{"location":"api/anomaly/ThresholdFilter/","title":"ThresholdFilter","text":"<p>Threshold anomaly filter.</p>"},{"location":"api/anomaly/ThresholdFilter/#parameters","title":"Parameters","text":"<ul> <li> <p>anomaly_detector</p> <p>An anomaly detector.</p> </li> <li> <p>threshold (float)</p> <p>A threshold above which to classify an anomaly score as anomalous.</p> </li> <li> <p>protect_anomaly_detector \u2013 defaults to <code>True</code></p> <p>Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift.</p> </li> </ul>"},{"location":"api/anomaly/ThresholdFilter/#examples","title":"Examples","text":"<p>Anomaly filters can be used as part of a pipeline. For instance, we might want to filter out anomalous observations so as not to corrupt a supervised model. As an example, let's take the <code>datasets.WaterFlow</code> dataset. Some of the samples have anomalous target variables because of human interventions. We don't want our model to learn these values.</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import time_series\n\n&gt;&gt;&gt; dataset = datasets.WaterFlow()\n&gt;&gt;&gt; metric = metrics.SMAPE()\n\n&gt;&gt;&gt; period = 24  # 24 samples per day\n\n&gt;&gt;&gt; model = (\n...     anomaly.ThresholdFilter(\n...         anomaly.GaussianScorer(\n...             window_size=period * 7,  # 7 days\n...             grace_period=30\n...         ),\n...         threshold=0.995\n...     ) |\n...     time_series.HoltWinters(\n...         alpha=0.3,\n...         beta=0.1,\n...         multiplicative=False\n...     )\n... )\n\n&gt;&gt;&gt; time_series.evaluate(\n...     dataset,\n...     model,\n...     metric,\n...     horizon=period\n... )\n+1  SMAPE: 4.220171\n+2  SMAPE: 4.322648\n+3  SMAPE: 4.418546\n+4  SMAPE: 4.504986\n+5  SMAPE: 4.57924\n+6  SMAPE: 4.64123\n+7  SMAPE: 4.694042\n+8  SMAPE: 4.740753\n+9  SMAPE: 4.777291\n+10 SMAPE: 4.804558\n+11 SMAPE: 4.828114\n+12 SMAPE: 4.849823\n+13 SMAPE: 4.865871\n+14 SMAPE: 4.871972\n+15 SMAPE: 4.866274\n+16 SMAPE: 4.842614\n+17 SMAPE: 4.806214\n+18 SMAPE: 4.763355\n+19 SMAPE: 4.713455\n+20 SMAPE: 4.672062\n+21 SMAPE: 4.659102\n+22 SMAPE: 4.693496\n+23 SMAPE: 4.773707\n+24 SMAPE: 4.880654\n</code></pre>"},{"location":"api/anomaly/ThresholdFilter/#methods","title":"Methods","text":"classify <p>Classify an anomaly score as anomalous or not.</p> <p>Parameters</p> <ul> <li>score     (float)    </li> </ul> <p>Returns</p> <p>bool:     A boolean value indicating whether the anomaly score is anomalous or not.</p>   learn_one <p>Update the anomaly filter and the underlying anomaly detector.</p> <p>Parameters</p> <ul> <li>args </li> </ul> <p>Returns</p> <p>self</p>   score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>args </li> </ul> <p>Returns</p> <p>An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p>"},{"location":"api/anomaly/base/AnomalyDetector/","title":"AnomalyDetector","text":"<p>An anomaly detector.</p>"},{"location":"api/anomaly/base/AnomalyDetector/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>AnomalyDetector:     self</p>   score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p>"},{"location":"api/bandit/EpsilonGreedy/","title":"EpsilonGreedy","text":"<p>\\(\\varepsilon\\)-greedy bandit policy.</p> <p>Performs arm selection by using an \\(\\varepsilon\\)-greedy bandit strategy. An arm is selected at each step. The best arm is selected (1 - \\(\\varepsilon\\))% of the time. </p> <p>Selection bias is a common problem when using bandits. This bias can be mitigated by using burn-in phase. Each model is given the chance to learn during the first <code>burn_in</code> steps.</p>"},{"location":"api/bandit/EpsilonGreedy/#parameters","title":"Parameters","text":"<ul> <li> <p>epsilon (float)</p> <p>The probability of exploring.</p> </li> <li> <p>decay \u2013 defaults to <code>0.0</code></p> <p>The decay rate of epsilon.</p> </li> <li> <p>reward_obj \u2013 defaults to <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>burn_in \u2013 defaults to <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/EpsilonGreedy/#attributes","title":"Attributes","text":"<ul> <li> <p>current_epsilon</p> <p>The value of epsilon after factoring in the decay rate.</p> </li> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/EpsilonGreedy/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import gym\n&gt;&gt;&gt; from river import bandit\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; env = gym.make(\n...     'river_bandits/CandyCaneContest-v0'\n... )\n&gt;&gt;&gt; _ = env.reset(seed=42)\n&gt;&gt;&gt; _ = env.action_space.seed(123)\n\n&gt;&gt;&gt; policy = bandit.EpsilonGreedy(epsilon=0.9, seed=101)\n\n&gt;&gt;&gt; metric = stats.Sum()\n&gt;&gt;&gt; while True:\n...     action = next(policy.pull(range(env.action_space.n)))\n...     observation, reward, terminated, truncated, info = env.step(action)\n...     policy = policy.update(action, reward)\n...     metric = metric.update(reward)\n...     if terminated or truncated:\n...         break\n\n&gt;&gt;&gt; metric\nSum: 775.\n</code></pre>"},{"location":"api/bandit/EpsilonGreedy/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     (List[Union[int, str]])    </li> </ul>   update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul>"},{"location":"api/bandit/EpsilonGreedy/#references","title":"References","text":"<ol> <li> <p>\u03b5-Greedy Algorithm - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9</p> </li> </ol>"},{"location":"api/bandit/ThompsonSampling/","title":"ThompsonSampling","text":"<p>Thompson sampling.</p> <p>Thompson sampling is often used with a Beta distribution. However, any probability distribution can be used, as long it makes sense with the reward shape. For instance, a Beta distribution is meant to be used with binary rewards, while a Gaussian distribution is meant to be used with continuous rewards. </p> <p>The randomness of a distribution is controlled by its seed. The seed should not set within the distribution, but should rather be defined in the policy parametrization. In other words, you should do this: </p> <p><code>policy = ThompsonSampling(dist=proba.Beta(1, 1), seed=42)</code> </p> <p>and not this: </p> <p><code>policy = ThompsonSampling(dist=proba.Beta(1, 1, seed=42))</code></p>"},{"location":"api/bandit/ThompsonSampling/#parameters","title":"Parameters","text":"<ul> <li> <p>dist (river.proba.base.Distribution)</p> <p>A distribution to sample from.</p> </li> <li> <p>burn_in \u2013 defaults to <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/ThompsonSampling/#attributes","title":"Attributes","text":"<ul> <li> <p>dist</p> </li> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/ThompsonSampling/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import gym\n&gt;&gt;&gt; from river import bandit\n&gt;&gt;&gt; from river import proba\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; env = gym.make(\n...     'river_bandits/CandyCaneContest-v0'\n... )\n&gt;&gt;&gt; _ = env.reset(seed=42)\n&gt;&gt;&gt; _ = env.action_space.seed(123)\n\n&gt;&gt;&gt; policy = bandit.ThompsonSampling(dist=proba.Beta(), seed=101)\n\n&gt;&gt;&gt; metric = stats.Sum()\n&gt;&gt;&gt; while True:\n...     action = next(policy.pull(range(env.action_space.n)))\n...     observation, reward, terminated, truncated, info = env.step(action)\n...     policy = policy.update(action, reward)\n...     metric = metric.update(reward)\n...     if terminated or truncated:\n...         break\n\n&gt;&gt;&gt; metric\nSum: 820.\n</code></pre>"},{"location":"api/bandit/ThompsonSampling/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     (List[Union[int, str]])    </li> </ul>   update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul>"},{"location":"api/bandit/ThompsonSampling/#references","title":"References","text":"<ol> <li> <p>An Empirical Evaluation of Thompson Sampling \u21a9</p> </li> </ol>"},{"location":"api/bandit/UCB/","title":"UCB","text":"<p>Upper Confidence Bound (UCB) bandit policy.</p> <p>Due to the nature of this algorithm, it's recommended to scale the target so that it exhibits sub-gaussian properties. This can be done by using a <code>preprocessing.TargetStandardScaler</code>.</p>"},{"location":"api/bandit/UCB/#parameters","title":"Parameters","text":"<ul> <li> <p>delta (float)</p> <p>The confidence level. Setting this to 1 leads to what is called the UCB1 policy.</p> </li> <li> <p>reward_obj \u2013 defaults to <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>burn_in \u2013 defaults to <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> </ul>"},{"location":"api/bandit/UCB/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/UCB/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import gym\n&gt;&gt;&gt; from river import bandit\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; env = gym.make(\n...     'river_bandits/CandyCaneContest-v0'\n... )\n&gt;&gt;&gt; _ = env.reset(seed=42)\n&gt;&gt;&gt; _ = env.action_space.seed(123)\n\n&gt;&gt;&gt; policy = bandit.UCB(delta=100)\n\n&gt;&gt;&gt; metric = stats.Sum()\n&gt;&gt;&gt; while True:\n...     action = next(policy.pull(range(env.action_space.n)))\n...     observation, reward, terminated, truncated, info = env.step(action)\n...     policy = policy.update(action, reward)\n...     metric = metric.update(reward)\n...     if terminated or truncated:\n...         break\n\n&gt;&gt;&gt; metric\nSum: 726.\n</code></pre>"},{"location":"api/bandit/UCB/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     (List[Union[int, str]])    </li> </ul>   update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul>"},{"location":"api/bandit/UCB/#references","title":"References","text":"<ol> <li> <p>Lai, T. L., &amp; Robbins, H. (1985). Asymptotically efficient adaptive allocation rules. Advances in applied mathematics, 6(1), 4-22. \u21a9</p> </li> <li> <p>Upper Confidence Bounds - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9</p> </li> <li> <p>The Upper Confidence Bound Algorithm - Bandit Algorithms \u21a9</p> </li> </ol>"},{"location":"api/bandit/evaluate/","title":"evaluate","text":"<p>Benchmark a list of policies on a given Gym environment.</p> <p>This is a high-level utility function for benchmarking a list of policies on a given Gym environment. For example, it can be used to populate a <code>pandas.DataFrame</code> with the contents of each step of each episode.</p>"},{"location":"api/bandit/evaluate/#parameters","title":"Parameters","text":"<ul> <li> <p>policies (List[river.bandit.base.Policy])</p> <p>A list of policies to evaluate. The policy will be reset before each episode.</p> </li> <li> <p>env ('gym.Env')</p> <p>The Gym environment to use. One copy will be made for each policy at the beginning of each episode.</p> </li> <li> <p>pull_func (Callable[[river.bandit.base.Policy, ForwardRef('gym.Env')], Union[int, str]])</p> <p>A function that takes a policy and an environment as arguments and returns the arm that was pulled. This function is called at each time step for each policy. This is required because there is no standard way to pull an arm in Gym environments.</p> </li> <li> <p>reward_stat (river.stats.base.Univariate) \u2013 defaults to <code>None</code></p> <p>A univariate statistic to keep track of the rewards. This statistic will be reset before each episode. Note that this is not the same as the reward object used by the policies. It's just a statistic to keep track of each policy's performance. If <code>None</code>, <code>stats.Sum</code> is used.</p> </li> <li> <p>n_episodes (int) \u2013 defaults to <code>20</code></p> <p>The number of episodes to run.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility. A random number generator will be used to seed differently the environment before each episode.</p> </li> </ul>"},{"location":"api/bandit/evaluate/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import gym\n&gt;&gt;&gt; from river import bandit\n\n&gt;&gt;&gt; def pull_func(policy, env):\n...     return next(policy.pull(range(env.action_space.n)))\n\n&gt;&gt;&gt; trace = bandit.evaluate(\n...     policies=[\n...         bandit.UCB(delta=1),\n...         bandit.EpsilonGreedy(epsilon=0.1, seed=42),\n...     ],\n...     env=gym.make(\n...         'river_bandits/CandyCaneContest-v0',\n...         max_episode_steps=100\n...     ),\n...     pull_func=pull_func,\n...     n_episodes=5,\n...     seed=42\n... )\n\n&gt;&gt;&gt; for step in trace:\n...     print(step)\n...     break\n{'episode': 0, 'step': 0, 'policy_idx': 0, 'action': 0, 'reward': 0.0, 'reward_stat': 0.0}\n</code></pre> <p>The return type of this function is a generator. Each step of the generator is a dictionary. You can pass the generator to a <code>pandas.DataFrame</code> to get a nice representation of the results.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; trace = bandit.evaluate(\n...     policies=[\n...         bandit.UCB(delta=1),\n...         bandit.EpsilonGreedy(epsilon=0.1, seed=42),\n...     ],\n...     env=gym.make(\n...         'river_bandits/CandyCaneContest-v0',\n...         max_episode_steps=100\n...     ),\n...     pull_func=pull_func,\n...     n_episodes=5,\n...     seed=42\n... )\n\n&gt;&gt;&gt; trace_df = pd.DataFrame(trace)\n&gt;&gt;&gt; trace_df.sample(5, random_state=42)\n     episode  step  policy_idx  action  reward  reward_stat\n521        2    60           1      25     0.0         36.0\n737        3    68           1      40     1.0         20.0\n740        3    70           0      70     1.0         33.0\n660        3    30           0      30     1.0         13.0\n411        2     5           1      35     1.0          5.0\n</code></pre> <p>The length of the dataframe is the number of policies times the number of episodes times the maximum number of steps per episode.</p> <pre><code>&gt;&gt;&gt; len(trace_df)\n1000\n\n&gt;&gt;&gt; (\n...     trace_df.policy_idx.nunique() *\n...     trace_df.episode.nunique() *\n...     trace_df.step.nunique()\n... )\n1000\n</code></pre>"},{"location":"api/bandit/base/Policy/","title":"Policy","text":"<p>Bandit policy base class.</p>"},{"location":"api/bandit/base/Policy/#parameters","title":"Parameters","text":"<ul> <li> <p>reward_obj (Union[river.stats.base.Statistic, river.metrics.base.Metric, river.proba.base.Distribution]) \u2013 defaults to <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>burn_in \u2013 defaults to <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> </ul>"},{"location":"api/bandit/base/Policy/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/base/Policy/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     (List[Union[int, str]])    </li> </ul>   update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul>"},{"location":"api/bandit/envs/CandyCaneContest/","title":"CandyCaneContest","text":"<p>Candy cane contest Kaggle competition.</p>"},{"location":"api/bandit/envs/CandyCaneContest/#parameters","title":"Parameters","text":"<ul> <li> <p>n_machines \u2013 defaults to <code>100</code></p> <p>Number of vending machines.</p> </li> <li> <p>reward_decay \u2013 defaults to <code>0.03</code></p> <p>The multiplicate rate at which the expected reward of each vending machine decays.</p> </li> </ul>"},{"location":"api/bandit/envs/CandyCaneContest/#attributes","title":"Attributes","text":"<ul> <li> <p>np_random</p> <p>Returns the environment's internal :attr:<code>_np_random</code> that if not set will initialise with a random seed.</p> </li> <li> <p>render_mode</p> </li> <li> <p>spec</p> </li> <li> <p>unwrapped</p> <p>Returns the base non-wrapped environment.  Returns:     Env: The base non-wrapped gym.Env instance</p> </li> </ul>"},{"location":"api/bandit/envs/CandyCaneContest/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import gym\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; env = gym.make('river_bandits/CandyCaneContest-v0')\n&gt;&gt;&gt; _ = env.reset(seed=42)\n&gt;&gt;&gt; _ = env.action_space.seed(123)\n\n&gt;&gt;&gt; metric = stats.Sum()\n&gt;&gt;&gt; while True:\n...     action = env.action_space.sample()\n...     observation, reward, terminated, truncated, info = env.step(action)\n...     metric = metric.update(reward)\n...     if terminated or truncated:\n...         break\n\n&gt;&gt;&gt; metric\nSum: 734.\n</code></pre>"},{"location":"api/bandit/envs/CandyCaneContest/#methods","title":"Methods","text":"close <p>Override close in your subclass to perform any necessary cleanup.</p> <p>Environments will automatically :meth:<code>close()</code> themselves when garbage collected or when the program exits.</p>   render <p>Compute the render frames as specified by render_mode attribute during initialization of the environment.</p> <p>The set of supported modes varies per environment. (And some third-party environments may not support rendering at all.) By convention, if render_mode is:  - None (default): no render is computed. - human: render return None.   The environment is continuously rendered in the current display or terminal. Usually for human consumption. - rgb_array: return a single frame representing the current state of the environment.   A frame is a numpy.ndarray with shape (x, y, 3) representing RGB values for an x-by-y pixel image. - rgb_array_list: return a list of frames representing the states of the environment since the last reset.   Each frame is a numpy.ndarray with shape (x, y, 3), as with <code>rgb_array</code>. - ansi: Return a strings (str) or StringIO.StringIO containing a   terminal-style text representation for each time step.   The text can include newlines and ANSI escape sequences (e.g. for colors).  Note:     Make sure that your class's metadata 'render_modes' key includes     the list of supported modes. It's recommended to call super()     in implementations to use the functionality of this method.</p>   reset <p>Resets the environment to an initial state and returns the initial observation.</p> <p>This method can reset the environment's random number generator(s) if <code>seed</code> is an integer or if the environment has not yet initialized a random number generator. If the environment already has a random number generator and :meth:<code>reset</code> is called with <code>seed=None</code>, the RNG should not be reset. Moreover, :meth:<code>reset</code> should (in the typical use case) be called with an integer seed right after initialization and then never again.  Args:     seed (optional int): The seed that is used to initialize the environment's PRNG.         If the environment does not already have a PRNG and <code>seed=None</code> (the default option) is passed,         a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom).         However, if the environment already has a PRNG and <code>seed=None</code> is passed, the PRNG will not be reset.         If you pass an integer, the PRNG will be reset even if it already exists.         Usually, you want to pass an integer right after the environment has been initialized and then never again.         Please refer to the minimal example above to see this paradigm in action.     options (optional dict): Additional information to specify how the environment is reset (optional,         depending on the specific environment)  Returns:     observation (object): Observation of the initial state. This will be an element of :attr:<code>observation_space</code>         (typically a numpy array) and is analogous to the observation returned by :meth:<code>step</code>.     info (dictionary):  This dictionary contains auxiliary information complementing <code>observation</code>. It should be analogous to         the <code>info</code> returned by :meth:<code>step</code>.</p> <p>Parameters</p> <ul> <li>seed     (Optional[int])     \u2013 defaults to <code>None</code> </li> <li>options     (Optional[dict])     \u2013 defaults to <code>None</code> </li> </ul>   step <p>Run one timestep of the environment's dynamics.</p> <p>When end of episode is reached, you are responsible for calling :meth:<code>reset</code> to reset this environment's state. Accepts an action and returns either a tuple <code>(observation, reward, terminated, truncated, info)</code>.  Args:     action (ActType): an action provided by the agent  Returns:     observation (object): this will be an element of the environment's :attr:<code>observation_space</code>.         This may, for instance, be a numpy array containing the positions and velocities of certain objects.     reward (float): The amount of reward returned as a result of taking the action.     terminated (bool): whether a <code>terminal state</code> (as defined under the MDP of the task) is reached.         In this case further step() calls could return undefined results.     truncated (bool): whether a truncation condition outside the scope of the MDP is satisfied.         Typically a timelimit, but could also be used to indicate agent physically going out of bounds.         Can be used to end the episode prematurely before a <code>terminal state</code> is reached.     info (dictionary): <code>info</code> contains auxiliary diagnostic information (helpful for debugging, learning, and logging).         This might, for instance, contain: metrics that describe the agent's performance state, variables that are         hidden from observations, or individual reward terms that are combined to produce the total reward.         It also can contain information that distinguishes truncation and termination, however this is deprecated in favour         of returning two booleans, and will be removed in a future version.      (deprecated)     done (bool): A boolean value for if the episode has ended, in which case further :meth:<code>step</code> calls will return undefined results.         A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully,         a certain timelimit was exceeded, or the physics simulation has entered an invalid state.</p> <p>Parameters</p> <ul> <li>action     (~ActType)    </li> </ul>"},{"location":"api/bandit/envs/CandyCaneContest/#references","title":"References","text":"<ol> <li> <p>Santa 2020 - The Candy Cane Contest \u21a9</p> </li> </ol>"},{"location":"api/bandit/envs/KArmedTestbed/","title":"KArmedTestbed","text":"<p>k-armed testbed.</p> <p>This is a simple environment that can be used to test bandit algorithms. It is based on the 10 armed testbed described in the book \"Reinforcement Learning: An Introduction\" by Sutton and Barto.</p>"},{"location":"api/bandit/envs/KArmedTestbed/#parameters","title":"Parameters","text":"<ul> <li> <p>k (int) \u2013 defaults to <code>10</code></p> <p>Number of arms.</p> </li> </ul>"},{"location":"api/bandit/envs/KArmedTestbed/#attributes","title":"Attributes","text":"<ul> <li> <p>np_random</p> <p>Returns the environment's internal :attr:<code>_np_random</code> that if not set will initialise with a random seed.</p> </li> <li> <p>render_mode</p> </li> <li> <p>spec</p> </li> <li> <p>unwrapped</p> <p>Returns the base non-wrapped environment.  Returns:     Env: The base non-wrapped gym.Env instance</p> </li> </ul>"},{"location":"api/bandit/envs/KArmedTestbed/#methods","title":"Methods","text":"close <p>Override close in your subclass to perform any necessary cleanup.</p> <p>Environments will automatically :meth:<code>close()</code> themselves when garbage collected or when the program exits.</p>   render <p>Compute the render frames as specified by render_mode attribute during initialization of the environment.</p> <p>The set of supported modes varies per environment. (And some third-party environments may not support rendering at all.) By convention, if render_mode is:  - None (default): no render is computed. - human: render return None.   The environment is continuously rendered in the current display or terminal. Usually for human consumption. - rgb_array: return a single frame representing the current state of the environment.   A frame is a numpy.ndarray with shape (x, y, 3) representing RGB values for an x-by-y pixel image. - rgb_array_list: return a list of frames representing the states of the environment since the last reset.   Each frame is a numpy.ndarray with shape (x, y, 3), as with <code>rgb_array</code>. - ansi: Return a strings (str) or StringIO.StringIO containing a   terminal-style text representation for each time step.   The text can include newlines and ANSI escape sequences (e.g. for colors).  Note:     Make sure that your class's metadata 'render_modes' key includes     the list of supported modes. It's recommended to call super()     in implementations to use the functionality of this method.</p>   reset <p>Resets the environment to an initial state and returns the initial observation.</p> <p>This method can reset the environment's random number generator(s) if <code>seed</code> is an integer or if the environment has not yet initialized a random number generator. If the environment already has a random number generator and :meth:<code>reset</code> is called with <code>seed=None</code>, the RNG should not be reset. Moreover, :meth:<code>reset</code> should (in the typical use case) be called with an integer seed right after initialization and then never again.  Args:     seed (optional int): The seed that is used to initialize the environment's PRNG.         If the environment does not already have a PRNG and <code>seed=None</code> (the default option) is passed,         a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom).         However, if the environment already has a PRNG and <code>seed=None</code> is passed, the PRNG will not be reset.         If you pass an integer, the PRNG will be reset even if it already exists.         Usually, you want to pass an integer right after the environment has been initialized and then never again.         Please refer to the minimal example above to see this paradigm in action.     options (optional dict): Additional information to specify how the environment is reset (optional,         depending on the specific environment)  Returns:     observation (object): Observation of the initial state. This will be an element of :attr:<code>observation_space</code>         (typically a numpy array) and is analogous to the observation returned by :meth:<code>step</code>.     info (dictionary):  This dictionary contains auxiliary information complementing <code>observation</code>. It should be analogous to         the <code>info</code> returned by :meth:<code>step</code>.</p> <p>Parameters</p> <ul> <li>seed     (Optional[int])     \u2013 defaults to <code>None</code> </li> <li>options     (Optional[dict])     \u2013 defaults to <code>None</code> </li> </ul>   step <p>Run one timestep of the environment's dynamics.</p> <p>When end of episode is reached, you are responsible for calling :meth:<code>reset</code> to reset this environment's state. Accepts an action and returns either a tuple <code>(observation, reward, terminated, truncated, info)</code>.  Args:     action (ActType): an action provided by the agent  Returns:     observation (object): this will be an element of the environment's :attr:<code>observation_space</code>.         This may, for instance, be a numpy array containing the positions and velocities of certain objects.     reward (float): The amount of reward returned as a result of taking the action.     terminated (bool): whether a <code>terminal state</code> (as defined under the MDP of the task) is reached.         In this case further step() calls could return undefined results.     truncated (bool): whether a truncation condition outside the scope of the MDP is satisfied.         Typically a timelimit, but could also be used to indicate agent physically going out of bounds.         Can be used to end the episode prematurely before a <code>terminal state</code> is reached.     info (dictionary): <code>info</code> contains auxiliary diagnostic information (helpful for debugging, learning, and logging).         This might, for instance, contain: metrics that describe the agent's performance state, variables that are         hidden from observations, or individual reward terms that are combined to produce the total reward.         It also can contain information that distinguishes truncation and termination, however this is deprecated in favour         of returning two booleans, and will be removed in a future version.      (deprecated)     done (bool): A boolean value for if the episode has ended, in which case further :meth:<code>step</code> calls will return undefined results.         A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully,         a certain timelimit was exceeded, or the physics simulation has entered an invalid state.</p> <p>Parameters</p> <ul> <li>action     (~ActType)    </li> </ul>"},{"location":"api/base/Base/","title":"Base","text":"<p>Base class that is inherited by the majority of classes in River.</p> <p>This base class allows us to handle the following tasks in a uniform manner: </p> <ul> <li>Getting and setting parameters. - Displaying information. - Cloning.</li> </ul>"},{"location":"api/base/Base/#methods","title":"Methods","text":""},{"location":"api/base/Classifier/","title":"Classifier","text":"<p>A classifier.</p>"},{"location":"api/base/Classifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/base/Clusterer/","title":"Clusterer","text":"<p>A clustering model.</p>"},{"location":"api/base/Clusterer/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Clusterer:     self</p>   predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p>"},{"location":"api/base/DriftAndWarningDetector/","title":"DriftAndWarningDetector","text":"<p>A drift detector that is also capable of issuing warnings.</p>"},{"location":"api/base/DriftAndWarningDetector/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/base/DriftAndWarningDetector/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/base/DriftDetector/","title":"DriftDetector","text":"<p>A drift detector.</p>"},{"location":"api/base/DriftDetector/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/base/DriftDetector/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/base/Ensemble/","title":"Ensemble","text":"<p>An ensemble is a model which is composed of a list of models.</p>"},{"location":"api/base/Ensemble/#parameters","title":"Parameters","text":"<ul> <li>models (Iterator[base.Estimator])</li> </ul>"},{"location":"api/base/Ensemble/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/base/Ensemble/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/base/Estimator/","title":"Estimator","text":"<p>An estimator.</p>"},{"location":"api/base/Estimator/#methods","title":"Methods","text":""},{"location":"api/base/MiniBatchClassifier/","title":"MiniBatchClassifier","text":"<p>A classifier that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchClassifier/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and boolean targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> <li>y     ('pd.Series')    </li> </ul> <p>Returns</p> <p>MiniBatchClassifier:     self</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_many <p>Predict the outcome probabilities for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A dataframe with probabilities of <code>True</code> and <code>False</code> for each sample.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/base/MiniBatchRegressor/","title":"MiniBatchRegressor","text":"<p>A regressor that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchRegressor/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and real-valued targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> <li>y     ('pd.Series')    </li> </ul> <p>Returns</p> <p>MiniBatchRegressor:     self</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted outcomes.</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/base/MiniBatchSupervisedTransformer/","title":"MiniBatchSupervisedTransformer","text":"<p>A supervised transformer that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchSupervisedTransformer/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> <li>y     ('pd.Series')    </li> </ul> <p>Returns</p> <p>MiniBatchSupervisedTransformer:     self</p>   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/base/MiniBatchTransformer/","title":"MiniBatchTransformer","text":"<p>A transform that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchTransformer/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/base/MultiOutputMixin/","title":"MultiOutputMixin","text":"<p>A multi-output estimator.</p>"},{"location":"api/base/Regressor/","title":"Regressor","text":"<p>A regressor.</p>"},{"location":"api/base/Regressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/base/SupervisedTransformer/","title":"SupervisedTransformer","text":"<p>A supervised transformer.</p>"},{"location":"api/base/SupervisedTransformer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code> and a target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int, numbers.Number])    </li> </ul> <p>Returns</p> <p>SupervisedTransformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/base/Transformer/","title":"Transformer","text":"<p>A transformer.</p>"},{"location":"api/base/Transformer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/base/Wrapper/","title":"Wrapper","text":"<p>A wrapper model.</p>"},{"location":"api/base/WrapperEnsemble/","title":"WrapperEnsemble","text":"<p>A wrapper ensemble is an ensemble composed of multiple copies of the same model.</p>"},{"location":"api/base/WrapperEnsemble/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>The model to copy.</p> </li> <li> <p>n_models</p> <p>The number of copies to make.</p> </li> <li> <p>seed</p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/base/WrapperEnsemble/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/base/WrapperEnsemble/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/cluster/CluStream/","title":"CluStream","text":"<p>CluStream</p> <p>The CluStream algorithm 1 maintains statistical information about the data using micro-clusters. These micro-clusters are temporal extensions of cluster feature vectors. The micro-clusters are stored at snapshots in time following a pyramidal pattern. This pattern allows to recall summary statistics from different time horizons. </p> <p>Training with a new point <code>p</code> is performed in two main tasks: </p> <ul> <li> <p>Determinate the closest micro-cluster to <code>p</code>. </p> </li> <li> <p>Check whether <code>p</code> fits (memory) into the closest micro-cluster: </p> <ul> <li> <p>if <code>p</code> fits, put into micro-cluster </p> </li> <li> <p>if <code>p</code> does not fit, free some space to insert a new micro-cluster.       This is done in two ways, delete an old micro-cluster or merge the       two micro-clusters closest to each other. </p> </li> </ul> </li> </ul> <p>This implementation is an improved version from the original algorithm. Instead of calculating the traditional cluster feature vector of the number of observations, linear sum and sum of squares of data points and time stamps, this implementation adopts the use of Welford's algorithm 2 to calculate the incremental variance, facilitated through <code>stats.Var()</code> available within <code>River</code>. </p> <p>Since River does not support an actual \"off-line\" phase of the clustering algorithm (as data points are assumed to arrive continuously, one at a time), a <code>time_gap</code> parameter is introduced. After each <code>time_gap</code>, an incremental K-Means clustering algorithm will be initialized and applied on currently available micro-clusters to form the final solution, i.e. macro-clusters.</p>"},{"location":"api/cluster/CluStream/#parameters","title":"Parameters","text":"<ul> <li> <p>n_macro_clusters (int) \u2013 defaults to <code>5</code></p> <p>The number of clusters (k) for the k-means algorithm.</p> </li> <li> <p>max_micro_clusters (int) \u2013 defaults to <code>100</code></p> <p>The maximum number of micro-clusters to use.</p> </li> <li> <p>micro_cluster_r_factor (int) \u2013 defaults to <code>2</code></p> <p>Multiplier for the micro-cluster radius. When deciding to add a new data point to a micro-cluster, the maximum boundary is defined as a factor of the <code>micro_cluster_r_factor</code> of the RMS deviation of the data points in the micro-cluster from the centroid.</p> </li> <li> <p>time_window (int) \u2013 defaults to <code>1000</code></p> <p>If the current time is <code>T</code> and the time window is <code>h</code>, we only consider the data that arrived within the period <code>(T-h,T)</code>.</p> </li> <li> <p>time_gap (int) \u2013 defaults to <code>100</code></p> <p>An incremental k-means is applied on the current set of micro-clusters after each <code>time_gap</code> to form the final macro-cluster solution.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed used for generating initial centroid positions.</p> </li> <li> <p>kwargs</p> <p>Other parameters passed to the incremental kmeans at <code>cluster.KMeans</code>.</p> </li> </ul>"},{"location":"api/cluster/CluStream/#attributes","title":"Attributes","text":"<ul> <li> <p>centers (dict)</p> <p>Central positions of each cluster.</p> </li> </ul>"},{"location":"api/cluster/CluStream/#examples","title":"Examples","text":"<p>In the following example, <code>max_micro_clusters</code> is set relatively low due to the limited number of training points. Moreover, all points are learnt before any predictions are made. The <code>halflife</code> is set at 0.4, to show that you can pass <code>cluster.KMeans</code> parameters via keyword arguments.</p> <pre><code>&gt;&gt;&gt; from river import cluster\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; X = [\n...     [1, 2],\n...     [1, 4],\n...     [1, 0],\n...     [-4, 2],\n...     [-4, 4],\n...     [-4, 0],\n...     [5, 0],\n...     [5, 2],\n...     [5, 4]\n... ]\n\n&gt;&gt;&gt; clustream = cluster.CluStream(\n...     n_macro_clusters=3,\n...     max_micro_clusters=5,\n...     time_gap=3,\n...     seed=0,\n...     halflife=0.4\n... )\n\n&gt;&gt;&gt; for x, _ in stream.iter_array(X):\n...     clustream = clustream.learn_one(x)\n\n&gt;&gt;&gt; clustream.predict_one({0: 1, 1: 1})\n1\n\n&gt;&gt;&gt; clustream.predict_one({0: -4, 1: 3})\n2\n\n&gt;&gt;&gt; clustream.predict_one({0: 4, 1: 3.5})\n0\n</code></pre>"},{"location":"api/cluster/CluStream/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Clusterer:     self</p>   predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p>"},{"location":"api/cluster/CluStream/#references","title":"References","text":"<ol> <li> <p>Aggarwal, C.C., Philip, S.Y., Han, J. and Wang, J., 2003, A framework for clustering evolving data streams. In Proceedings 2003 VLDB conference (pp. 81-92). Morgan Kaufmann.\u00a0\u21a9</p> </li> <li> <p>Chan, T.F., Golub, G.H. and LeVeque, R.J., 1982. Updating formulae and a pairwise algorithm for computing sample variances. In COMPSTAT 1982 5th Symposium held at Toulouse 1982 (pp. 30-41). Physica, Heidelberg. https://doi.org/10.1007/978-3-642-51461-6_3.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/DBSTREAM/","title":"DBSTREAM","text":"<p>DBSTREAM</p> <p>DBSTREAM 1 is a clustering algorithm for evolving data streams. It is the first micro-cluster-based online clustering component that explicitely captures the density between micro-clusters via a shared density graph. The density information in the graph is then exploited for reclustering based on actual density between adjacent micro clusters. </p> <p>The algorithm is divided into two parts: </p> <p>Online micro-cluster maintenance (learning) </p> <p>For a new point <code>p</code>: </p> <ul> <li> <p>Find all micro clusters for which <code>p</code> falls within the fixed radius (clustering threshold). If no neighbor is found, a new micro cluster with a weight of 1 is created for <code>p</code>. </p> </li> <li> <p>If no neighbor is found, a new micro cluster with a weight of 1 is created for <code>p</code>. If one or more neighbors of <code>p</code> are found, we update the micro clusters by applying the appropriate fading, increasing their weight and then we try to move them closer to <code>p</code> using the Gaussian neighborhood function. </p> </li> <li> <p>Next, the shared density graph is updated. To prevent collapsing micro clusters, we will restrict the movement for micro clusters in case they come closer than \\(r\\) (clustering threshold) to each other. Finishing this process, the time stamp is also increased by 1. </p> </li> <li> <p>Finally, the cleanup will be processed. It is executed every <code>t_gap</code> time steps, removing weak micro clusters and weak entries in the shared density graph to recover memory and improve the clustering algorithm's processing speed. </p> </li> </ul> <p>Offline generation of macro clusters (clustering) </p> <p>The offline generation of macro clusters is generated through the two following steps: </p> <ul> <li> <p>The connectivity graph <code>C</code> is constructed using shared density entries between strong micro clusters. The edges in this connectivity graph with a connectivity value greater than the intersection threshold (\\(\\alpha\\)) are used to find connected components representing the final cluster. </p> </li> <li> <p>After the connectivity graph is generated, a variant of the DBSCAN algorithm proposed by Ester et al. is applied to form all macro clusters from \\(\\alpha\\)-connected micro clusters.</p> </li> </ul>"},{"location":"api/cluster/DBSTREAM/#parameters","title":"Parameters","text":"<ul> <li> <p>clustering_threshold (float) \u2013 defaults to <code>1.0</code></p> <p>DBStream represents each micro cluster by a leader (a data point defining the micro cluster's center) and the density in an area of a user-specified radius \\(r\\) (<code>clustering_threshold</code>) around the center.</p> </li> <li> <p>fading_factor (float) \u2013 defaults to <code>0.01</code></p> <p>Parameter that controls the importance of historical data to current cluster. Note that <code>fading_factor</code> has to be different from <code>0</code>.</p> </li> <li> <p>cleanup_interval (float) \u2013 defaults to <code>2</code></p> <p>The time interval between two consecutive time points when the cleanup process is  conducted.</p> </li> <li> <p>intersection_factor (float) \u2013 defaults to <code>0.3</code></p> <p>The intersection factor related to the area of the overlap of the micro clusters relative to the area cover by micro clusters. This parameter is used to determine whether a micro cluster or a shared density is weak.</p> </li> <li> <p>minimum_weight (float) \u2013 defaults to <code>1.0</code></p> <p>The minimum weight for a cluster to be not \"noisy\".</p> </li> </ul>"},{"location":"api/cluster/DBSTREAM/#attributes","title":"Attributes","text":"<ul> <li> <p>n_clusters</p> <p>Number of clusters generated by the algorithm.</p> </li> <li> <p>clusters</p> <p>A set of final clusters of type <code>DBStreamMicroCluster</code>. However, these are either micro clusters, or macro clusters that are generated by merging all \\(\\alpha\\)-connected micro clusters. This set is generated through the offline phase of the algorithm.</p> </li> <li> <p>centers</p> <p>Final clusters' centers.</p> </li> <li> <p>micro_clusters</p> <p>Micro clusters generated by the algorithm. Instead of updating directly the new instance points into a nearest micro cluster, through each iteration, the weight and center will be modified so that the clusters are closer to the new points, using the Gaussian neighborhood function.</p> </li> </ul>"},{"location":"api/cluster/DBSTREAM/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import cluster\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; X = [\n...     [1, 0.5], [1, 0.625], [1, 0.75], [1, 1.125], [1, 1.5], [1, 1.75],\n...     [4, 1.5], [4, 2.25], [4, 2.5], [4, 3], [4, 3.25], [4, 3.5]\n... ]\n\n&gt;&gt;&gt; dbstream = cluster.DBSTREAM(clustering_threshold = 1.5,\n...                             fading_factor = 0.05,\n...                             cleanup_interval = 4,\n...                             intersection_factor = 0.5,\n...                             minimum_weight = 1)\n\n&gt;&gt;&gt; for x, _ in stream.iter_array(X):\n...     dbstream = dbstream.learn_one(x)\n\n&gt;&gt;&gt; dbstream.predict_one({0: 1, 1: 2})\n0\n\n&gt;&gt;&gt; dbstream.predict_one({0: 5, 1: 2})\n1\n\n&gt;&gt;&gt; dbstream.n_clusters\n2\n</code></pre>"},{"location":"api/cluster/DBSTREAM/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Clusterer:     self</p>   predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p>"},{"location":"api/cluster/DBSTREAM/#references","title":"References","text":"<ol> <li> <p>Michael Hahsler and Matthew Bolanos (2016, pp 1449-1461). Clsutering Data Streams Based on   Shared Density between Micro-Clusters, IEEE Transactions on Knowledge and Data Engineering 28(6) .   In Proceedings of the Sixth SIAM International Conference on Data Mining,   April 20\u201322, 2006, Bethesda, MD, USA.\u00a0\u21a9</p> </li> <li> <p>Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases   with Noise. In KDD-96 Proceedings, AAAI.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/DenStream/","title":"DenStream","text":"<p>DenStream</p> <p>DenStream 1 is a clustering algorithm for evolving data streams. DenStream can discover clusters with arbitrary shape and is robust against noise (outliers). </p> <p>\"Dense\" micro-clusters (named core-micro-clusters) summarise the clusters of arbitrary shape. A pruning strategy based on the concepts of potential and outlier micro-clusters guarantees the precision of the weights of the micro-clusters with limited memory. </p> <p>The algorithm is divided into two parts: </p> <p>Online micro-cluster maintenance (learning) </p> <p>For a new point <code>p</code>: </p> <ul> <li> <p>Try to merge <code>p</code> into either the nearest <code>p-micro-cluster</code> (potential), <code>o-micro-cluster</code> (outlier), or create a new <code>o-micro-cluster</code> and insert it into the outlier buffer. </p> </li> <li> <p>For each <code>T_p</code> iterations, consider the weights of all potential and outlier micro-clusters. If their weights are smaller than a certain threshold (different for each type of micro-clusters), the micro-cluster is deleted. </p> </li> </ul> <p>Offline generation of clusters on-demand (clustering) </p> <p>A variant of the DBSCAN algorithm 2 is used, such that all density-connected p-micro-clusters determine the final clusters. Moreover, in order for the algorithm to always be able to generate clusters, a certain number of points must be passed through the algorithm with a suitable streaming speed (number of points passed through within a unit time), indicated by <code>n_samples_init</code> and <code>stream_speed</code>.</p>"},{"location":"api/cluster/DenStream/#parameters","title":"Parameters","text":"<ul> <li> <p>decaying_factor (float) \u2013 defaults to <code>0.25</code></p> <p>Parameter that controls the importance of historical data to current cluster. Note that <code>decaying_factor</code> has to be different from <code>0</code>.</p> </li> <li> <p>beta (float) \u2013 defaults to <code>0.75</code></p> <p>Parameter to determine the threshold of outlier relative to core micro-clusters. The value of <code>beta</code> must be within the range <code>(0,1]</code>.</p> </li> <li> <p>mu (float) \u2013 defaults to <code>2</code></p> <p>Parameter to determine the threshold of outliers relative to core micro-cluster. As <code>beta * mu</code> must be greater than 1, <code>mu</code> must be within the range <code>(1/beta, inf)</code>.</p> </li> <li> <p>epsilon (float) \u2013 defaults to <code>0.02</code></p> <p>Defines the epsilon neighborhood</p> </li> <li> <p>n_samples_init (int) \u2013 defaults to <code>1000</code></p> <p>Number of points to to initiqalize the online process</p> </li> <li> <p>stream_speed (int) \u2013 defaults to <code>100</code></p> <p>Number of points arrived in unit time</p> </li> </ul>"},{"location":"api/cluster/DenStream/#attributes","title":"Attributes","text":"<ul> <li> <p>n_clusters</p> <p>Number of clusters generated by the algorithm.</p> </li> <li> <p>clusters</p> <p>A set of final clusters of type <code>MicroCluster</code>, which means that these cluster include all the required information, including number of points, creation time, weight, (weighted) linear sum, (weighted) square sum, center and radius.</p> </li> <li> <p>p_micro_clusters</p> <p>The potential core-icro-clusters that are generated by the algorithm. When a generate cluster request arrives, these p-micro-clusters will go through a variant of the DBSCAN algorithm to determine the final clusters.</p> </li> <li> <p>o_micro_clusters</p> <p>The outlier micro-clusters.</p> </li> </ul>"},{"location":"api/cluster/DenStream/#examples","title":"Examples","text":"<p>The following example uses the default parameters of the algorithm to test its functionality. The set of evolving points <code>X</code> are designed so that clusters are easily identifiable.</p> <pre><code>&gt;&gt;&gt; from river import cluster\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; X = [\n...     [-1, -0.5], [-1, -0.625], [-1, -0.75], [-1, -1], [-1, -1.125],\n...     [-1, -1.25], [-1.5, -0.5], [-1.5, -0.625], [-1.5, -0.75], [-1.5, -1],\n...     [-1.5, -1.125], [-1.5, -1.25], [1, 1.5], [1, 1.75], [1, 2],\n...     [4, 1.25], [4, 1.5], [4, 2.25], [4, 2.5], [4, 3],\n...     [4, 3.25], [4, 3.5], [4, 3.75], [4, 4],\n... ]\n\n&gt;&gt;&gt; denstream = cluster.DenStream(decaying_factor=0.01,\n...                               beta=0.5,\n...                               mu=2.5,\n...                               epsilon=0.5,\n...                               n_samples_init=10)\n\n&gt;&gt;&gt; for x, _ in stream.iter_array(X):\n...     denstream = denstream.learn_one(x)\n\n&gt;&gt;&gt; denstream.predict_one({0: -1, 1: -2})\n1\n\n&gt;&gt;&gt; denstream.predict_one({0:5, 1:4})\n2\n\n&gt;&gt;&gt; denstream.predict_one({0:1, 1:1})\n0\n\n&gt;&gt;&gt; denstream.n_clusters\n3\n</code></pre>"},{"location":"api/cluster/DenStream/#methods","title":"Methods","text":"BufferItem   learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Clusterer:     self</p>   predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p>"},{"location":"api/cluster/DenStream/#references","title":"References","text":"<ol> <li> <p>Feng et al (2006, pp 328-339). Density-Based Clustering over an Evolving Data Stream with   Noise. In Proceedings of the Sixth SIAM International Conference on Data Mining,   April 20\u201322, 2006, Bethesda, MD, USA.\u00a0\u21a9</p> </li> <li> <p>Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial   Databases with Noise. In KDD-96 Proceedings, AAAI.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/KMeans/","title":"KMeans","text":"<p>Incremental k-means.</p> <p>The most common way to implement batch k-means is to use Lloyd's algorithm, which consists in assigning all the data points to a set of cluster centers and then moving the centers accordingly. This requires multiple passes over the data and thus isn't applicable in a streaming setting. </p> <p>In this implementation we start by finding the cluster that is closest to the current observation. We then move the cluster's central position towards the new observation. The <code>halflife</code> parameter determines by how much to move the cluster toward the new observation. You will get better results if you scale your data appropriately.</p>"},{"location":"api/cluster/KMeans/#parameters","title":"Parameters","text":"<ul> <li> <p>n_clusters \u2013 defaults to <code>5</code></p> <p>Maximum number of clusters to assign.</p> </li> <li> <p>halflife \u2013 defaults to <code>0.5</code></p> <p>Amount by which to move the cluster centers, a reasonable value if between 0 and 1.</p> </li> <li> <p>mu \u2013 defaults to <code>0</code></p> <p>Mean of the normal distribution used to instantiate cluster positions.</p> </li> <li> <p>sigma \u2013 defaults to <code>1</code></p> <p>Standard deviation of the normal distribution used to instantiate cluster positions.</p> </li> <li> <p>p \u2013 defaults to <code>2</code></p> <p>Power parameter for the Minkowski metric. When <code>p=1</code>, this corresponds to the Manhattan distance, while <code>p=2</code> corresponds to the Euclidean distance.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed used for generating initial centroid positions.</p> </li> </ul>"},{"location":"api/cluster/KMeans/#attributes","title":"Attributes","text":"<ul> <li> <p>centers (dict)</p> <p>Central positions of each cluster.</p> </li> </ul>"},{"location":"api/cluster/KMeans/#examples","title":"Examples","text":"<p>In the following example the cluster assignments are exactly the same as when using <code>sklearn</code>'s batch implementation. However changing the <code>halflife</code> parameter will produce different outputs.</p> <pre><code>&gt;&gt;&gt; from river import cluster\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; X = [\n...     [1, 2],\n...     [1, 4],\n...     [1, 0],\n...     [-4, 2],\n...     [-4, 4],\n...     [-4, 0]\n... ]\n\n&gt;&gt;&gt; k_means = cluster.KMeans(n_clusters=2, halflife=0.1, sigma=3, seed=42)\n\n&gt;&gt;&gt; for i, (x, _) in enumerate(stream.iter_array(X)):\n...     k_means = k_means.learn_one(x)\n...     print(f'{X[i]} is assigned to cluster {k_means.predict_one(x)}')\n[1, 2] is assigned to cluster 1\n[1, 4] is assigned to cluster 1\n[1, 0] is assigned to cluster 0\n[-4, 2] is assigned to cluster 1\n[-4, 4] is assigned to cluster 1\n[-4, 0] is assigned to cluster 0\n\n&gt;&gt;&gt; k_means.predict_one({0: 0, 1: 0})\n0\n\n&gt;&gt;&gt; k_means.predict_one({0: 4, 1: 4})\n1\n</code></pre>"},{"location":"api/cluster/KMeans/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Clusterer:     self</p>   learn_predict_one <p>Equivalent to <code>k_means.learn_one(x).predict_one(x)</code>, but faster.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p>"},{"location":"api/cluster/KMeans/#references","title":"References","text":"<ol> <li> <p>Sequential k-Means Clustering \u21a9</p> </li> <li> <p>Sculley, D., 2010, April. Web-scale k-means clustering. In Proceedings of the 19th international conference on World wide web (pp. 1177-1178 \u21a9</p> </li> </ol>"},{"location":"api/cluster/STREAMKMeans/","title":"STREAMKMeans","text":"<p>STREAMKMeans</p> <p>STREAMKMeans is an alternative version of the original algorithm STREAMLSEARCH proposed by O'Callaghan et al. 1, by replacing the k-medians using <code>LSEARCH</code> by the k-means algorithm. </p> <p>However, instead of using the traditional k-means, which requires a total reclustering each time the temporary chunk of data points is full, the implementation of this algorithm uses an increamental k-means. </p> <p>At first, the cluster centers are initialized with a <code>KMeans</code> instance. For a new point <code>p</code>: </p> <ul> <li> <p>If the size of chunk is less than the maximum size allowed, add the new point to the temporary chunk. </p> </li> <li> <p>When the size of chunk reaches the maximum value size allowed </p> <ul> <li> <p>A new incremental <code>KMeans</code> instance is created. The latter will process all points in the     temporary chunk. The centers of this new instance then become the new centers. </p> </li> <li> <p>All points are deleted from the temporary chunk so that new points can be added. </p> </li> </ul> </li> <li> <p>When a prediction request arrives, the centers of the algorithm will be exactly the same as the centers of the original <code>KMeans</code> at the time of retrieval.</p> </li> </ul>"},{"location":"api/cluster/STREAMKMeans/#parameters","title":"Parameters","text":"<ul> <li> <p>chunk_size \u2013 defaults to <code>10</code></p> <p>Maximum size allowed for the temporary data chunk.</p> </li> <li> <p>n_clusters \u2013 defaults to <code>2</code></p> <p>Number of clusters generated by the algorithm.</p> </li> <li> <p>kwargs</p> <p>Other parameters passed to the incremental kmeans at <code>cluster.KMeans</code>.</p> </li> </ul>"},{"location":"api/cluster/STREAMKMeans/#attributes","title":"Attributes","text":"<ul> <li> <p>centers</p> <p>Cluster centers generated from running the incremental <code>KMeans</code> algorithm through centers of each chunk.</p> </li> </ul>"},{"location":"api/cluster/STREAMKMeans/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import cluster\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; X = [\n...     [1, 0.5], [1, 0.625], [1, 0.75], [1, 1.125], [1, 1.5], [1, 1.75],\n...     [4, 1.5], [4, 2.25], [4, 2.5], [4, 3], [4, 3.25], [4, 3.5]\n... ]\n\n&gt;&gt;&gt; streamkmeans = cluster.STREAMKMeans(chunk_size=3, n_clusters=2, halflife=0.5, sigma=1.5, seed=0)\n\n&gt;&gt;&gt; for x, _ in stream.iter_array(X):\n...     streamkmeans = streamkmeans.learn_one(x)\n\n&gt;&gt;&gt; streamkmeans.predict_one({0: 1, 1: 0})\n0\n\n&gt;&gt;&gt; streamkmeans.predict_one({0: 5, 1: 2})\n1\n</code></pre>"},{"location":"api/cluster/STREAMKMeans/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Clusterer:     self</p>   predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p>"},{"location":"api/cluster/STREAMKMeans/#references","title":"References","text":"<ol> <li> <p>O'Callaghan et al. (2002). Streaming-data algorithms for high-quality clustering.   In Proceedings 18th International Conference on Data Engineering, Feb 26 - March 1,   San Jose, CA, USA. DOI: 10.1109/ICDE.2002.994785.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/TextClust/","title":"TextClust","text":"<p>textClust, a clustering algorithm for text data.</p> <p>textClust 12 is a stream clustering algorithm for textual data that can identify and track topics over time in a stream of texts. The algorithm uses a widely popular two-phase clustering approach where the stream is first summarised in real-time. </p> <p>The result is many small preliminary clusters in the stream called <code>micro-clusters</code>. Micro-clusters maintain enough information to update and efficiently calculate the cosine similarity between them over time, based on the TF-IDF vector of their texts. Upon request, the miro-clusters can be reclustered to generate the final result using any distance-based clustering algorithm, such as hierarchical clustering. To keep the micro-clusters up-to-date, our algorithm applies a fading strategy where micro-clusters that are not updated regularly lose relevance and are eventually removed.</p>"},{"location":"api/cluster/TextClust/#parameters","title":"Parameters","text":"<ul> <li> <p>radius \u2013 defaults to <code>0.3</code></p> <p>Distance threshold to merge two micro-clusters. Must be within the range <code>(0, 1]</code></p> </li> <li> <p>fading_factor \u2013 defaults to <code>0.0005</code></p> <p>Fading factor of micro-clusters</p> </li> <li> <p>tgap \u2013 defaults to <code>100</code></p> <p>Time between outlier removal</p> </li> <li> <p>term_fading \u2013 defaults to <code>True</code></p> <p>Determines whether individual terms should also be faded</p> </li> <li> <p>real_time_fading \u2013 defaults to <code>True</code></p> <p>Parameter that specifies whether natural time or the number of observations should be used for fading</p> </li> <li> <p>micro_distance \u2013 defaults to <code>tfidf_cosine_distance</code></p> <p>Distance metric used for clustering macro-clusters</p> </li> <li> <p>macro_distance \u2013 defaults to <code>tfidf_cosine_distance</code></p> <p>Distance metric used for clustering macro-clusters</p> </li> <li> <p>num_macro \u2013 defaults to <code>3</code></p> <p>Number of macro clusters that should be identified during the reclustering phase</p> </li> <li> <p>min_weight \u2013 defaults to <code>0</code></p> <p>Minimum weight of micro clusters to be used for reclustering</p> </li> <li> <p>auto_r \u2013 defaults to <code>False</code></p> <p>Parameter that specifies if  <code>radius</code> should be automatically updated</p> </li> <li> <p>auto_merge \u2013 defaults to <code>True</code></p> <p>Determines, if close observations shall be merged together</p> </li> <li> <p>sigma \u2013 defaults to <code>1</code></p> <p>Parameter that influences the automated trheshold adaption technique</p> </li> </ul>"},{"location":"api/cluster/TextClust/#attributes","title":"Attributes","text":"<ul> <li> <p>micro_clusters</p> <p>Micro-clusters generated by the algorithm. Micro-clusters are of type <code>textclust.microcluster</code></p> </li> </ul>"},{"location":"api/cluster/TextClust/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import feature_extraction\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import cluster\n\n&gt;&gt;&gt; corpus = [\n...    {\"text\":'This is the first document.',\"idd\":1, \"cluster\": 1, \"cluster\":1},\n...    {\"text\":'This document is the second document.',\"idd\":2,\"cluster\": 1},\n...    {\"text\":'And this is super unrelated.',\"idd\":3,\"cluster\": 2},\n...    {\"text\":'Is this the first document?',\"idd\":4,\"cluster\": 1},\n...    {\"text\":'This is super unrelated as well',\"idd\":5,\"cluster\": 2},\n...    {\"text\":'Test text',\"idd\":6,\"cluster\": 5}\n... ]\n\n&gt;&gt;&gt; stopwords = [ 'stop', 'the', 'to', 'and', 'a', 'in', 'it', 'is', 'I']\n\n&gt;&gt;&gt; metric = metrics.AdjustedRand()\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     feature_extraction.BagOfWords(lowercase=True, ngram_range=(1, 2), stop_words=stopwords),\n...     cluster.TextClust(real_time_fading=False, fading_factor=0.001, tgap=100, auto_r=True,\n...     radius=0.9)\n... )\n\n&gt;&gt;&gt; for x in corpus:\n...     y_pred = model.predict_one(x[\"text\"])\n...     y = x[\"cluster\"]\n...     metric = metric.update(y,y_pred)\n...     model = model.learn_one(x[\"text\"])\n\n&gt;&gt;&gt; print(metric)\nAdjustedRand: -0.17647058823529413\n</code></pre>"},{"location":"api/cluster/TextClust/#methods","title":"Methods","text":"distances   get_assignment   get_macroclusters   learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>t     \u2013 defaults to <code>None</code> </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Clusterer:     self</p>   microcluster   predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> <li>type     \u2013 defaults to <code>micro</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p>   showclusters   tfcontainer   updateMacroClusters"},{"location":"api/cluster/TextClust/#references","title":"References","text":"<ol> <li> <p>Assenmacher, D. und Trautmann, H. (2022). Textual One-Pass Stream Clustering with Automated Distance Threshold Adaption. In: Asian Conference on Intelligent Information and Database Systems (Accepted)\u00a0\u21a9</p> </li> <li> <p>Carnein, M., Assenmacher, D., Trautmann, H. (2017). Stream Clustering of Chat Messages with Applications to Twitch Streams. In: Advances in Conceptual Modeling. ER 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/compat/River2SKLClassifier/","title":"River2SKLClassifier","text":"<p>Compatibility layer from River to scikit-learn for classification.</p>"},{"location":"api/compat/River2SKLClassifier/#parameters","title":"Parameters","text":"<ul> <li>river_estimator (base.Classifier)</li> </ul>"},{"location":"api/compat/River2SKLClassifier/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2013 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p>   partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> <li>classes     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p>   predict <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Predicted target values for each row of <code>X</code>.</p>   predict_proba <p>Predicts the target probability of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Predicted target values for each row of <code>X</code>.</p>   score <p>Return the mean accuracy on the given test data and labels.</p> <p>In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>float</p>   set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p>"},{"location":"api/compat/River2SKLClusterer/","title":"River2SKLClusterer","text":"<p>Compatibility layer from River to scikit-learn for clustering.</p>"},{"location":"api/compat/River2SKLClusterer/#parameters","title":"Parameters","text":"<ul> <li>river_estimator (base.Clusterer)</li> </ul>"},{"location":"api/compat/River2SKLClusterer/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p>   fit_predict <p>Perform clustering on <code>X</code> and returns cluster labels.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>ndarray of shape (n_samples,), dtype=np.int64</p>   get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2013 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p>   partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Transformed output.</p>   set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p>"},{"location":"api/compat/River2SKLRegressor/","title":"River2SKLRegressor","text":"<p>Compatibility layer from River to scikit-learn for regression.</p>"},{"location":"api/compat/River2SKLRegressor/#parameters","title":"Parameters","text":"<ul> <li>river_estimator (base.Regressor)</li> </ul>"},{"location":"api/compat/River2SKLRegressor/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2013 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p>   partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>ndarray:     Predicted target values for each row of <code>X</code>.</p>   score <p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination :math:<code>R^2</code> is defined as :math:<code>(1 - \\frac{u}{v})</code>, where :math:<code>u</code> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and :math:<code>v</code> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a :math:<code>R^2</code> score of 0.0.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>float</p>   set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p>"},{"location":"api/compat/River2SKLTransformer/","title":"River2SKLTransformer","text":"<p>Compatibility layer from River to scikit-learn for transformation.</p>"},{"location":"api/compat/River2SKLTransformer/#parameters","title":"Parameters","text":"<ul> <li>river_estimator (base.Transformer)</li> </ul>"},{"location":"api/compat/River2SKLTransformer/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p>   fit_transform <p>Fit to data, then transform it.</p> <p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code> and returns a transformed version of <code>X</code>.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2013 defaults to <code>None</code> </li> <li>fit_params </li> </ul> <p>Returns</p> <p>ndarray array of shape (n_samples, n_features_new)</p>   get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2013 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p>   partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p>   set_output <p>Set output container.</p> <p>See :ref:<code>sphx_glr_auto_examples_miscellaneous_plot_set_output.py</code> for an example on how to use the API.</p> <p>Parameters</p> <ul> <li>transform     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>estimator instance</p>   set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p>   transform <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Transformed output.</p>"},{"location":"api/compat/SKL2RiverClassifier/","title":"SKL2RiverClassifier","text":"<p>Compatibility layer from scikit-learn to River for classification.</p>"},{"location":"api/compat/SKL2RiverClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>estimator ('sklearn_base.ClassifierMixin')</p> <p>A scikit-learn regressor which has a <code>partial_fit</code> method.</p> </li> <li> <p>classes ('list')</p> </li> </ul>"},{"location":"api/compat/SKL2RiverClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compat\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; from sklearn import linear_model\n&gt;&gt;&gt; from sklearn import datasets\n\n&gt;&gt;&gt; dataset = stream.iter_sklearn_dataset(\n...     dataset=datasets.load_breast_cancer(),\n...     shuffle=True,\n...     seed=42\n... )\n\n&gt;&gt;&gt; model = preprocessing.StandardScaler()\n&gt;&gt;&gt; model |= compat.convert_sklearn_to_river(\n...     estimator=linear_model.SGDClassifier(\n...         loss='log_loss',\n...         eta0=0.01,\n...         learning_rate='constant'\n...     ),\n...     classes=[False, True]\n... )\n\n&gt;&gt;&gt; metric = metrics.LogLoss()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nLogLoss: 0.199554\n</code></pre>"},{"location":"api/compat/SKL2RiverClassifier/#methods","title":"Methods","text":"learn_many   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_many   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_many   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/compat/SKL2RiverRegressor/","title":"SKL2RiverRegressor","text":"<p>Compatibility layer from scikit-learn to River for regression.</p>"},{"location":"api/compat/SKL2RiverRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>estimator ('sklearn_base.BaseEstimator')</p> <p>A scikit-learn transformer which has a <code>partial_fit</code> method.</p> </li> </ul>"},{"location":"api/compat/SKL2RiverRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compat\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; from sklearn import linear_model\n&gt;&gt;&gt; from sklearn import datasets\n\n&gt;&gt;&gt; dataset = stream.iter_sklearn_dataset(\n...     dataset=datasets.load_diabetes(),\n...     shuffle=True,\n...     seed=42\n... )\n\n&gt;&gt;&gt; scaler = preprocessing.StandardScaler()\n&gt;&gt;&gt; sgd_reg = compat.convert_sklearn_to_river(linear_model.SGDRegressor())\n&gt;&gt;&gt; model = scaler | sgd_reg\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 84.519485\n</code></pre>"},{"location":"api/compat/SKL2RiverRegressor/#methods","title":"Methods","text":"learn_many   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_many   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/compat/convert-river-to-sklearn/","title":"convert_river_to_sklearn","text":"<p>Wraps a river estimator to make it compatible with scikit-learn.</p>"},{"location":"api/compat/convert-river-to-sklearn/#parameters","title":"Parameters","text":"<ul> <li>estimator (base.Estimator)</li> </ul>"},{"location":"api/compat/convert-sklearn-to-river/","title":"convert_sklearn_to_river","text":"<p>Wraps a scikit-learn estimator to make it compatible with river.</p>"},{"location":"api/compat/convert-sklearn-to-river/#parameters","title":"Parameters","text":"<ul> <li> <p>estimator ('sklearn_base.BaseEstimator')</p> </li> <li> <p>classes ('list') \u2013 defaults to <code>None</code></p> <p>Class names necessary for classifiers.</p> </li> </ul>"},{"location":"api/compose/Discard/","title":"Discard","text":"<p>Removes features.</p> <p>This can be used in a pipeline when you want to remove certain features. The <code>transform_one</code> method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input.</p>"},{"location":"api/compose/Discard/#parameters","title":"Parameters","text":"<ul> <li> <p>keys (Tuple[Hashable])</p> <p>Key(s) to discard.</p> </li> </ul>"},{"location":"api/compose/Discard/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; x = {'a': 42, 'b': 12, 'c': 13}\n&gt;&gt;&gt; compose.Discard('a', 'b').transform_one(x)\n{'c': 13}\n</code></pre> <p>You can chain a discarder with any estimator in order to apply said estimator to the desired features.</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction as fx\n\n&gt;&gt;&gt; x = {'sales': 10, 'shop': 'Ikea', 'country': 'Sweden'}\n\n&gt;&gt;&gt; pipeline = (\n...     compose.Discard('shop', 'country') |\n...     fx.PolynomialExtender()\n... )\n&gt;&gt;&gt; pipeline.transform_one(x)\n{'sales': 10, 'sales*sales': 100}\n</code></pre>"},{"location":"api/compose/Discard/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/FuncTransformer/","title":"FuncTransformer","text":"<p>Wraps a function to make it usable in a pipeline.</p> <p>There is often a need to apply an arbitrary transformation to a set of features. For instance, this could involve parsing a date and then extracting the hour from said date. If you're processing a stream of data, then you can do this yourself by calling the necessary code at your leisure. On the other hand, if you want to do this as part of a pipeline, then you need to follow a simple convention. </p> <p>To use a function as part of a pipeline, take as input a <code>dict</code> of features and output a <code>dict</code>. Once you have initialized this class with your function, then you can use it like you would use any other (unsupervised) transformer. </p> <p>It is up to you if you want your function to be pure or not. By pure we refer to a function that doesn't modify its input. However, we recommend writing pure functions because this reduces the chances of inserting bugs into your pipeline.</p>"},{"location":"api/compose/FuncTransformer/#parameters","title":"Parameters","text":"<ul> <li> <p>func (Callable[[dict], dict])</p> <p>A function that takes as input a <code>dict</code> and outputs a <code>dict</code>.</p> </li> </ul>"},{"location":"api/compose/FuncTransformer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; x = {'date': '2019-02-14'}\n\n&gt;&gt;&gt; def parse_date(x):\n...     date = dt.datetime.strptime(x['date'], '%Y-%m-%d')\n...     x['is_weekend'] = date.day in (5, 6)\n...     x['hour'] = date.hour\n...     return x\n\n&gt;&gt;&gt; t = compose.FuncTransformer(parse_date)\n&gt;&gt;&gt; pprint(t.transform_one(x))\n{'date': '2019-02-14', 'hour': 0, 'is_weekend': False}\n</code></pre> <p>The above example is not pure because it modifies the input. The following example is pure and produces the same output:</p> <pre><code>&gt;&gt;&gt; def parse_date(x):\n...     date = dt.datetime.strptime(x['date'], '%Y-%m-%d')\n...     return {'is_weekend': date.day in (5, 6), 'hour': date.hour}\n\n&gt;&gt;&gt; t = compose.FuncTransformer(parse_date)\n&gt;&gt;&gt; pprint(t.transform_one(x))\n{'hour': 0, 'is_weekend': False}\n</code></pre> <p>The previous example doesn't include the <code>date</code> feature because it returns a new <code>dict</code>. However, a common usecase is to add a feature to an existing set of features. You can do this in a pure way by unpacking the input <code>dict</code> into the output <code>dict</code>:</p> <pre><code>&gt;&gt;&gt; def parse_date(x):\n...     date = dt.datetime.strptime(x['date'], '%Y-%m-%d')\n...     return {'is_weekend': date.day in (5, 6), 'hour': date.hour, **x}\n\n&gt;&gt;&gt; t = compose.FuncTransformer(parse_date)\n&gt;&gt;&gt; pprint(t.transform_one(x))\n{'date': '2019-02-14', 'hour': 0, 'is_weekend': False}\n</code></pre> <p>You can add <code>FuncTransformer</code> to a pipeline just like you would with any other transformer.</p> <pre><code>&gt;&gt;&gt; from river import naive_bayes\n\n&gt;&gt;&gt; pipeline = compose.FuncTransformer(parse_date) | naive_bayes.MultinomialNB()\n&gt;&gt;&gt; pipeline\nPipeline (\n  FuncTransformer (\n    func=\"parse_date\"\n  ),\n  MultinomialNB (\n    alpha=1.\n  )\n)\n</code></pre> <p>If you provide a function without wrapping it, then the pipeline will do it for you:</p> <pre><code>&gt;&gt;&gt; pipeline = parse_date | naive_bayes.MultinomialNB()\n</code></pre>"},{"location":"api/compose/FuncTransformer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/Grouper/","title":"Grouper","text":"<p>Applies a transformer within different groups.</p> <p>This transformer allows you to split your data into groups and apply a transformer within each group. This happens in a streaming manner, which means that the groups are discovered online. A separate copy of the provided transformer is made whenever a new group appears. The groups are defined according to one or more keys.</p>"},{"location":"api/compose/Grouper/#parameters","title":"Parameters","text":"<ul> <li> <p>transformer (base.Transformer)</p> </li> <li> <p>by (Union[Hashable, List[Hashable]])</p> <p>The field on which to group the data. This can either by a single value, or a list of values.</p> </li> </ul>"},{"location":"api/compose/Grouper/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/Pipeline/","title":"Pipeline","text":"<p>A pipeline of estimators.</p> <p>Pipelines allow you to chain different steps into a sequence. Typically, when doing supervised learning, a pipeline contains one ore more transformation steps, whilst it's is a regressor or a classifier. It is highly recommended to use pipelines with <code>river</code>. Indeed, in an online learning setting, it is very practical to have a model defined as a single object. Take a look at the user guide for further information and practical examples. </p> <p>One special thing to take notice to is the way transformers are handled. It is usual to predict something for a sample and wait for the ground truth to arrive. In such a scenario, the features are seen before the ground truth arrives. Therefore, the unsupervised parts of the pipeline are updated when <code>predict_one</code> and <code>predict_proba_one</code> are called. Usually the unsupervised parts of the pipeline are all the steps that precede the final step, which is a supervised model. However, some transformers are supervised and are therefore also updated during calls to <code>learn_one</code>.</p>"},{"location":"api/compose/Pipeline/#parameters","title":"Parameters","text":"<ul> <li> <p>steps</p> <p>Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.</p> </li> </ul>"},{"location":"api/compose/Pipeline/#examples","title":"Examples","text":"<p>The recommended way to declare a pipeline is to use the <code>|</code> operator. The latter allows you to chain estimators in a very terse manner:</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; scaler = preprocessing.StandardScaler()\n&gt;&gt;&gt; log_reg = linear_model.LinearRegression()\n&gt;&gt;&gt; model = scaler | log_reg\n</code></pre> <p>This results in a pipeline that stores each step inside a dictionary.</p> <pre><code>&gt;&gt;&gt; model\nPipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</code></pre> <p>You can access parts of a pipeline in the same manner as a dictionary:</p> <pre><code>&gt;&gt;&gt; model['LinearRegression']\nLinearRegression (\n  optimizer=SGD (\n    lr=Constant (\n      learning_rate=0.01\n    )\n  )\n  loss=Squared ()\n  l2=0.\n  l1=0.\n  intercept_init=0.\n  intercept_lr=Constant (\n    learning_rate=0.01\n  )\n  clip_gradient=1e+12\n  initializer=Zeros ()\n)\n</code></pre> <p>Note that you can also declare a pipeline by using the <code>compose.Pipeline</code> constructor method, which is slightly more verbose:</p> <pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; model = compose.Pipeline(scaler, log_reg)\n</code></pre> <p>By using a <code>compose.TransformerUnion</code>, you can define complex pipelines that apply different steps to different parts of the data. For instance, we can extract word counts from text data, and extract polynomial features from numeric data.</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction as fx\n\n&gt;&gt;&gt; tfidf = fx.TFIDF('text')\n&gt;&gt;&gt; counts = fx.BagOfWords('text')\n&gt;&gt;&gt; text_part = compose.Select('text') | (tfidf + counts)\n\n&gt;&gt;&gt; num_part = compose.Select('a', 'b') | fx.PolynomialExtender()\n\n&gt;&gt;&gt; model = text_part + num_part\n&gt;&gt;&gt; model |= preprocessing.StandardScaler()\n&gt;&gt;&gt; model |= linear_model.LinearRegression()\n</code></pre> <p>The following shows an example of using <code>debug_one</code> to visualize how the information flows and changes throughout the pipeline.</p> <pre><code>&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import naive_bayes\n\n&gt;&gt;&gt; dataset = [\n...     ('A positive comment', True),\n...     ('A negative comment', False),\n...     ('A happy comment', True),\n...     ('A lovely comment', True),\n...     ('A harsh comment', False)\n... ]\n\n&gt;&gt;&gt; tfidf = fx.TFIDF() | compose.Prefixer('tfidf_')\n&gt;&gt;&gt; counts = fx.BagOfWords() | compose.Prefixer('count_')\n&gt;&gt;&gt; mnb = naive_bayes.MultinomialNB()\n&gt;&gt;&gt; model = (tfidf + counts) | mnb\n\n&gt;&gt;&gt; for x, y in dataset:\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; x = dataset[0][0]\n&gt;&gt;&gt; report = model.debug_one(dataset[0][0])\n&gt;&gt;&gt; print(report)\n0. Input\n--------\nA positive comment\n1. Transformer union\n--------------------\n    1.0 TFIDF | Prefixer\n    --------------------\n    tfidf_comment: 0.47606 (float)\n    tfidf_positive: 0.87942 (float)\n    1.1 BagOfWords | Prefixer\n    -------------------------\n    count_comment: 1 (int)\n    count_positive: 1 (int)\ncount_comment: 1 (int)\ncount_positive: 1 (int)\ntfidf_comment: 0.50854 (float)\ntfidf_positive: 0.86104 (float)\n2. MultinomialNB\n----------------\nFalse: 0.19313\nTrue: 0.80687\n</code></pre>"},{"location":"api/compose/Pipeline/#methods","title":"Methods","text":"debug_one <p>Displays the state of a set of features as it goes through the pipeline.</p> <p>Parameters</p> <ul> <li>x     ('dict')    </li> <li>show_types     \u2013 defaults to <code>True</code> </li> <li>n_decimals     \u2013 defaults to <code>5</code> </li> </ul>   forecast <p>Return a forecast.</p> <p>Only works if each estimator has a <code>transform_one</code> method and the final estimator has a <code>forecast</code> method. This is the case of time series models from the <code>time_series</code> module.</p> <p>Parameters</p> <ul> <li>horizon     ('int')    </li> <li>xs     ('list[dict]')     \u2013 defaults to <code>None</code> </li> </ul>   learn_many <p>Fit to a mini-batch.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> <li>y     ('pd.Series')     \u2013 defaults to <code>None</code> </li> <li>params </li> </ul>   learn_one <p>Fit to a single instance.</p> <p>Parameters</p> <ul> <li>x     ('dict')    </li> <li>y     \u2013 defaults to <code>None</code> </li> <li>params </li> </ul>   predict_many   predict_one <p>Call <code>transform_one</code> on the first steps and <code>predict_one</code> on the last step.</p> <p>Parameters</p> <ul> <li>x     ('dict')    </li> <li>params </li> </ul>   predict_proba_many   predict_proba_one <p>Call <code>transform_one</code> on the first steps and <code>predict_proba_one</code> on the last step.</p> <p>Parameters</p> <ul> <li>x     ('dict')    </li> <li>params </li> </ul>   score_one <p>Call <code>transform_one</code> on the first steps and <code>score_one</code> on the last step.</p> <p>Parameters</p> <ul> <li>x     ('dict')    </li> <li>params </li> </ul>   transform_many <p>Apply each transformer in the pipeline to some features.</p> <p>The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul>   transform_one <p>Apply each transformer in the pipeline to some features.</p> <p>The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers.</p> <p>Parameters</p> <ul> <li>x     ('dict')    </li> <li>params </li> </ul>"},{"location":"api/compose/Prefixer/","title":"Prefixer","text":"<p>Prepends a prefix on features names.</p>"},{"location":"api/compose/Prefixer/#parameters","title":"Parameters","text":"<ul> <li>prefix (str)</li> </ul>"},{"location":"api/compose/Prefixer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; x = {'a': 42, 'b': 12}\n&gt;&gt;&gt; compose.Prefixer('prefix_').transform_one(x)\n{'prefix_a': 42, 'prefix_b': 12}\n</code></pre>"},{"location":"api/compose/Prefixer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/Renamer/","title":"Renamer","text":"<p>Renames features following substitution rules.</p>"},{"location":"api/compose/Renamer/#parameters","title":"Parameters","text":"<ul> <li> <p>mapping (Dict[str, str])</p> <p>Dictionnary describing substitution rules. Keys in <code>mapping</code> that are not a feature's name are silently ignored.</p> </li> </ul>"},{"location":"api/compose/Renamer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; mapping = {'a': 'v', 'c': 'o'}\n&gt;&gt;&gt; x = {'a': 42, 'b': 12}\n&gt;&gt;&gt; compose.Renamer(mapping).transform_one(x)\n{'b': 12, 'v': 42}\n</code></pre>"},{"location":"api/compose/Renamer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/Select/","title":"Select","text":"<p>Selects features.</p> <p>This can be used in a pipeline when you want to select certain features. The <code>transform_one</code> method is pure, and therefore returns a fresh new dictionary instead of filtering the specified keys from the input.</p>"},{"location":"api/compose/Select/#parameters","title":"Parameters","text":"<ul> <li> <p>keys (Tuple[Hashable])</p> <p>Key(s) to keep.</p> </li> </ul>"},{"location":"api/compose/Select/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; x = {'a': 42, 'b': 12, 'c': 13}\n&gt;&gt;&gt; compose.Select('c').transform_one(x)\n{'c': 13}\n</code></pre> <p>You can chain a selector with any estimator in order to apply said estimator to the desired features.</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction as fx\n\n&gt;&gt;&gt; x = {'sales': 10, 'shop': 'Ikea', 'country': 'Sweden'}\n\n&gt;&gt;&gt; pipeline = (\n...     compose.Select('sales') |\n...     fx.PolynomialExtender()\n... )\n&gt;&gt;&gt; pipeline.transform_one(x)\n{'sales': 10, 'sales*sales': 100}\n</code></pre> <p>This transformer also supports mini-batch processing:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; X = [{\"x_1\": random.uniform(8, 12), \"x_2\": random.uniform(8, 12)} for _ in range(6)]\n&gt;&gt;&gt; for x in X:\n...     print(x)\n{'x_1': 10.557707193831535, 'x_2': 8.100043020890668}\n{'x_1': 9.100117273476478, 'x_2': 8.892842952595291}\n{'x_1': 10.94588485665605, 'x_2': 10.706797949691644}\n{'x_1': 11.568718270819382, 'x_2': 8.347755330517664}\n{'x_1': 9.687687278741082, 'x_2': 8.119188877752281}\n{'x_1': 8.874551899214413, 'x_2': 10.021421152413449}\n\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; X = pd.DataFrame.from_dict(X)\n</code></pre> <p>You can then call <code>transform_many</code> to transform a mini-batch of features:</p> <pre><code>&gt;&gt;&gt; compose.Select('x_2').transform_many(X)\n    x_2\n0   8.100043\n1   8.892843\n2  10.706798\n3   8.347755\n4   8.119189\n5  10.021421\n</code></pre>"},{"location":"api/compose/Select/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/SelectType/","title":"SelectType","text":"<p>Selects features based on their type.</p> <p>This is practical when you want to apply different preprocessing steps to different kinds of features. For instance, a common usecase is to apply a <code>preprocessing.StandardScaler</code> to numeric features and a <code>preprocessing.OneHotEncoder</code> to categorical features.</p>"},{"location":"api/compose/SelectType/#parameters","title":"Parameters","text":"<ul> <li> <p>types (Tuple[type])</p> <p>Python types which you want to select. Under the hood, the <code>isinstance</code> method will be used to check if a value is of a given type.</p> </li> </ul>"},{"location":"api/compose/SelectType/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import numbers\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; num = compose.SelectType(numbers.Number) | preprocessing.StandardScaler()\n&gt;&gt;&gt; cat = compose.SelectType(str) | preprocessing.OneHotEncoder()\n&gt;&gt;&gt; model = (num + cat) | linear_model.LogisticRegression()\n</code></pre>"},{"location":"api/compose/SelectType/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/Suffixer/","title":"Suffixer","text":"<p>Appends a suffix on features names.</p>"},{"location":"api/compose/Suffixer/#parameters","title":"Parameters","text":"<ul> <li>suffix (str)</li> </ul>"},{"location":"api/compose/Suffixer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; x = {'a': 42, 'b': 12}\n&gt;&gt;&gt; compose.Suffixer('_suffix').transform_one(x)\n{'a_suffix': 42, 'b_suffix': 12}\n</code></pre>"},{"location":"api/compose/Suffixer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/compose/TargetTransformRegressor/","title":"TargetTransformRegressor","text":"<p>Modifies the target before training.</p> <p>The user is expected to check that <code>func</code> and <code>inverse_func</code> are coherent with each other.</p>"},{"location":"api/compose/TargetTransformRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor (base.Regressor)</p> <p>Regression model to wrap.</p> </li> <li> <p>func (Callable)</p> <p>A function modifying the target before training.</p> </li> <li> <p>inverse_func (Callable)</p> <p>A function to return to the target's original space.</p> </li> </ul>"},{"location":"api/compose/TargetTransformRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     compose.TargetTransformRegressor(\n...         regressor=linear_model.LinearRegression(intercept_lr=0.15),\n...         func=math.log,\n...         inverse_func=math.exp\n...     )\n... )\n&gt;&gt;&gt; metric = metrics.MSE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMSE: 8.759624\n</code></pre>"},{"location":"api/compose/TargetTransformRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/compose/TransformerProduct/","title":"TransformerProduct","text":"<p>Computes interactions between the outputs of a set transformers.</p> <p>This is for when you want to add interaction terms between groups of features. It may also be used an alternative to <code>feature_extraction.PolynomialExtender</code> when the latter is overkill.</p>"},{"location":"api/compose/TransformerProduct/#parameters","title":"Parameters","text":"<ul> <li> <p>transformers</p> <p>Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.</p> </li> </ul>"},{"location":"api/compose/TransformerProduct/#examples","title":"Examples","text":"<p>Let's say we have a certain set of features with two groups. In practice these may be different namespaces, such one for items and the other for users.</p> <pre><code>&gt;&gt;&gt; x = dict(\n...     a=0, b=1,  # group 1\n...     x=2, y=3   # group 2\n... )\n</code></pre> <p>We might want to add interaction terms between groups <code>('a', 'b')</code> and <code>('x', 'y')</code>, as so:</p> <pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; from river.compose import Select, TransformerProduct\n\n&gt;&gt;&gt; product = TransformerProduct(\n...     Select('a', 'b'),\n...     Select('x', 'y')\n... )\n&gt;&gt;&gt; pprint(product.transform_one(x))\n{'a*x': 0, 'a*y': 0, 'b*x': 2, 'b*y': 3}\n</code></pre> <p>This can also be done with the following shorthand:</p> <pre><code>&gt;&gt;&gt; product = Select('a', 'b') * Select('x', 'y')\n&gt;&gt;&gt; pprint(product.transform_one(x))\n{'a*x': 0, 'a*y': 0, 'b*x': 2, 'b*y': 3}\n</code></pre> <p>If you want to include the original terms, you can do something like this:</p> <pre><code>&gt;&gt;&gt; group_1 = Select('a', 'b')\n&gt;&gt;&gt; group_2 = Select('x', 'y')\n&gt;&gt;&gt; product = group_1 + group_2 + group_1 * group_2\n&gt;&gt;&gt; pprint(product.transform_one(x))\n{'a': 0, 'a*x': 0, 'a*y': 0, 'b': 1, 'b*x': 2, 'b*y': 3, 'x': 2, 'y': 3}\n</code></pre>"},{"location":"api/compose/TransformerProduct/#methods","title":"Methods","text":"learn_many <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)     \u2013 defaults to <code>None</code> </li> </ul>   learn_one <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul>   transform_many <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul>   transform_one <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>"},{"location":"api/compose/TransformerUnion/","title":"TransformerUnion","text":"<p>Packs multiple transformers into a single one.</p> <p>Pipelines allow you to apply steps sequentially. Therefore, the output of a step becomes the input of the next one. In many cases, you may want to pass the output of a step to multiple steps. This simple transformer allows you to do so. In other words, it enables you to apply particular steps to different parts of an input. A typical example is when you want to scale numeric features and one-hot encode categorical features. </p> <p>This transformer is essentially a list of transformers. Whenever it is updated, it loops through each transformer and updates them. Meanwhile, calling <code>transform_one</code> collects the output of each transformer and merges them into a single dictionary.</p>"},{"location":"api/compose/TransformerUnion/#parameters","title":"Parameters","text":"<ul> <li> <p>transformers</p> <p>Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.</p> </li> </ul>"},{"location":"api/compose/TransformerUnion/#examples","title":"Examples","text":"<p>Take the following dataset:</p> <pre><code>&gt;&gt;&gt; X = [\n...     {'place': 'Taco Bell', 'revenue': 42},\n...     {'place': 'Burger King', 'revenue': 16},\n...     {'place': 'Burger King', 'revenue': 24},\n...     {'place': 'Taco Bell', 'revenue': 58},\n...     {'place': 'Burger King', 'revenue': 20},\n...     {'place': 'Taco Bell', 'revenue': 50}\n... ]\n</code></pre> <p>As an example, let's assume we want to compute two aggregates of a dataset. We therefore define two <code>feature_extraction.Agg</code>s and initialize a <code>TransformerUnion</code> with them:</p> <pre><code>&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import feature_extraction\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; mean = feature_extraction.Agg(\n...     on='revenue', by='place',\n...     how=stats.Mean()\n... )\n&gt;&gt;&gt; count = feature_extraction.Agg(\n...     on='revenue', by='place',\n...     how=stats.Count()\n... )\n&gt;&gt;&gt; agg = compose.TransformerUnion(mean, count)\n</code></pre> <p>We can now update each transformer and obtain their output with a single function call:</p> <pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; for x in X:\n...     agg = agg.learn_one(x)\n...     pprint(agg.transform_one(x))\n{'revenue_count_by_place': 1, 'revenue_mean_by_place': 42.0}\n{'revenue_count_by_place': 1, 'revenue_mean_by_place': 16.0}\n{'revenue_count_by_place': 2, 'revenue_mean_by_place': 20.0}\n{'revenue_count_by_place': 2, 'revenue_mean_by_place': 50.0}\n{'revenue_count_by_place': 3, 'revenue_mean_by_place': 20.0}\n{'revenue_count_by_place': 3, 'revenue_mean_by_place': 50.0}\n</code></pre> <p>Note that you can use the <code>+</code> operator as a shorthand notation:</p> <p>agg = mean + count</p> <p>This allows you to build complex pipelines in a very terse manner. For instance, we can create a pipeline that scales each feature and fits a logistic regression as so:</p> <pre><code>&gt;&gt;&gt; from river import linear_model as lm\n&gt;&gt;&gt; from river import preprocessing as pp\n\n&gt;&gt;&gt; model = (\n...     (mean + count) |\n...     pp.StandardScaler() |\n...     lm.LogisticRegression()\n... )\n</code></pre> <p>Whice is equivalent to the following code:</p> <pre><code>&gt;&gt;&gt; model = compose.Pipeline(\n...     compose.TransformerUnion(mean, count),\n...     pp.StandardScaler(),\n...     lm.LogisticRegression()\n... )\n</code></pre> <p>Note that you access any part of a <code>TransformerUnion</code> by name:</p> <pre><code>&gt;&gt;&gt; model['TransformerUnion']['Agg']\nAgg (\n    on=\"revenue\"\n    by=['place']\n    how=Mean ()\n)\n\n&gt;&gt;&gt; model['TransformerUnion']['Agg1']\nAgg (\n    on=\"revenue\"\n    by=['place']\n    how=Count ()\n)\n</code></pre> <p>You can also manually provide a name for each step:</p> <pre><code>&gt;&gt;&gt; agg = compose.TransformerUnion(\n...     ('Mean revenue by place', mean),\n...     ('# by place', count)\n... )\n</code></pre> <p>Mini-batch example:</p> <pre><code>&gt;&gt;&gt; X = pd.DataFrame([\n...     {\"place\": 2, \"revenue\": 42},\n...     {\"place\": 3, \"revenue\": 16},\n...     {\"place\": 3, \"revenue\": 24},\n...     {\"place\": 2, \"revenue\": 58},\n...     {\"place\": 3, \"revenue\": 20},\n...     {\"place\": 2, \"revenue\": 50},\n... ])\n</code></pre> <p>Since we need a transformer with mini-batch support to demonstrate, we shall use a <code>StandardScaler</code>.</p> <pre><code>&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; agg = (\n...     compose.Select(\"place\") +\n...     (compose.Select(\"revenue\") | preprocessing.StandardScaler())\n... )\n\n&gt;&gt;&gt; _ = agg.learn_many(X)\n&gt;&gt;&gt; agg.transform_many(X)\n   place   revenue\n0      2  0.441250\n1      3 -1.197680\n2      3 -0.693394\n3      2  1.449823\n4      3 -0.945537\n5      2  0.945537\n</code></pre>"},{"location":"api/compose/TransformerUnion/#methods","title":"Methods","text":"learn_many <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)     \u2013 defaults to <code>None</code> </li> </ul>   learn_one <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul>   transform_many <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul>   transform_one <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>"},{"location":"api/compose/pure-inference-mode/","title":"pure_inference_mode","text":"<p>A context manager for making inferences with no side-effects.</p> <p>Calling <code>predict_one</code> with a pipeline will update the unsupervised steps of the pipeline. This is the expected behavior for online machine learning. However, in some cases you might just want to produce predictions without necessarily updating anything. </p> <p>This context manager allows you to override that behavior and make it so that unsupervised estimators are not updated when <code>predict_one</code> is called.</p>"},{"location":"api/compose/pure-inference-mode/#examples","title":"Examples","text":"<p>Let's first see what methods are called if we just call <code>predict_one</code>.</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; import logging\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     preprocessing.StandardScaler(),\n...     linear_model.LinearRegression()\n... )\n\n&gt;&gt;&gt; class_condition = lambda x: x.__class__.__name__ in ('StandardScaler', 'LinearRegression')\n\n&gt;&gt;&gt; logger = logging.getLogger()\n&gt;&gt;&gt; logger.setLevel(logging.DEBUG)\n\n&gt;&gt;&gt; logs = io.StringIO()\n&gt;&gt;&gt; sh = logging.StreamHandler(logs)\n&gt;&gt;&gt; sh.setLevel(logging.DEBUG)\n&gt;&gt;&gt; logger.addHandler(sh)\n\n&gt;&gt;&gt; with utils.log_method_calls(class_condition):\n...     for x, y in datasets.TrumpApproval().take(1):\n...         _ = model.predict_one(x)\n\n&gt;&gt;&gt; print(logs.getvalue())\nStandardScaler.learn_one\nStandardScaler.transform_one\nLinearRegression.predict_one\n</code></pre> <p>Now let's use the context manager and see what methods get called.</p> <pre><code>&gt;&gt;&gt; logs = io.StringIO()\n&gt;&gt;&gt; sh = logging.StreamHandler(logs)\n&gt;&gt;&gt; sh.setLevel(logging.DEBUG)\n&gt;&gt;&gt; logger.addHandler(sh)\n\n&gt;&gt;&gt; with utils.log_method_calls(class_condition), compose.pure_inference_mode():\n...     for x, y in datasets.TrumpApproval().take(1):\n...         _ = model.predict_one(x)\n\n&gt;&gt;&gt; print(logs.getvalue())\nStandardScaler.transform_one\nLinearRegression.predict_one\n</code></pre> <p>We can see that the scaler did not get updated before transforming the data.</p>"},{"location":"api/compose/warm-up-mode/","title":"warm_up_mode","text":"<p>A context manager for training pipelines during a warm-up phase.</p> <p>You don't have to worry about anything when you call <code>predict_one</code> and <code>learn_one</code> with a pipeline during in a training loop. The methods at each step of the pipeline will be called in the correct order. </p> <p>However, during a warm-up phase, you might just be calling <code>learn_one</code> because you don't need the out-of-sample predictions. In this case the unsupervised estimators in the pipeline won't be updated, because they are usually updated when <code>predict_one</code> is called. </p> <p>This context manager allows you to override that behavior and make it so that unsupervised estimators are updated when <code>learn_one</code> is called.</p>"},{"location":"api/compose/warm-up-mode/#examples","title":"Examples","text":"<p>Let's first see what methods are called if we just call <code>learn_one</code>.</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; import logging\n&gt;&gt;&gt; from river import anomaly\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     preprocessing.MinMaxScaler(),\n...     anomaly.HalfSpaceTrees()\n... )\n\n&gt;&gt;&gt; class_condition = lambda x: x.__class__.__name__ in ('MinMaxScaler', 'HalfSpaceTrees')\n\n&gt;&gt;&gt; logger = logging.getLogger()\n&gt;&gt;&gt; logger.setLevel(logging.DEBUG)\n\n&gt;&gt;&gt; logs = io.StringIO()\n&gt;&gt;&gt; sh = logging.StreamHandler(logs)\n&gt;&gt;&gt; sh.setLevel(logging.DEBUG)\n&gt;&gt;&gt; logger.addHandler(sh)\n\n&gt;&gt;&gt; with utils.log_method_calls(class_condition):\n...     for x, y in datasets.CreditCard().take(1):\n...         model = model.learn_one(x)\n\n&gt;&gt;&gt; print(logs.getvalue())\nMinMaxScaler.transform_one\nHalfSpaceTrees.learn_one\n</code></pre> <p>Now let's use the context manager and see what methods get called.</p> <pre><code>&gt;&gt;&gt; logs = io.StringIO()\n&gt;&gt;&gt; sh = logging.StreamHandler(logs)\n&gt;&gt;&gt; sh.setLevel(logging.DEBUG)\n&gt;&gt;&gt; logger.addHandler(sh)\n\n&gt;&gt;&gt; with utils.log_method_calls(class_condition), compose.warm_up_mode():\n...     for x, y in datasets.CreditCard().take(1):\n...         model = model.learn_one(x)\n\n&gt;&gt;&gt; print(logs.getvalue())\nMinMaxScaler.learn_one\nMinMaxScaler.transform_one\nHalfSpaceTrees.learn_one\n</code></pre> <p>We can see that the scaler got updated before transforming the data.</p>"},{"location":"api/conf/Interval/","title":"Interval","text":"<p>An object to represent a (prediction) interval.</p> <p>Users are not expected to use this class as-is. Instead, they should use the <code>with_interval</code> parameter of the <code>predict_one</code> method of any regressor or classifier wrapped with a conformal prediction method.</p>"},{"location":"api/conf/Interval/#parameters","title":"Parameters","text":"<ul> <li> <p>lower (float)</p> <p>The lower bound of the interval.</p> </li> <li> <p>upper (float)</p> <p>The upper bound of the interval.</p> </li> </ul>"},{"location":"api/conf/Interval/#attributes","title":"Attributes","text":"<ul> <li> <p>center</p> <p>The center of the interval.</p> </li> <li> <p>width</p> <p>The width of the interval.</p> </li> </ul>"},{"location":"api/conf/RegressionJackknife/","title":"RegressionJackknife","text":"<p>Jackknife method for regression.</p> <p>This is a conformal prediction method for regression. It is based on the jackknife method. The idea is to compute the quantiles of the residuals of the regressor. The prediction interval is then computed as the prediction of the regressor plus the quantiles of the residuals. </p> <p>This works naturally online, as the quantiles of the residuals are updated at each iteration. Each residual is produced before the regressor is updated, which ensures the predicted intervals are not optimistic. </p> <p>Note that the produced intervals are marginal and not conditional. This means that the intervals are not adjusted for the features <code>x</code>. This is a limitation of the jackknife method. However, the jackknife method is very simple and efficient. It is also very robust to outliers.</p>"},{"location":"api/conf/RegressionJackknife/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor (base.Regressor)</p> <p>The regressor to be wrapped.</p> </li> <li> <p>confidence_level (float) \u2013 defaults to <code>0.95</code></p> <p>The confidence level of the prediction intervals.</p> </li> <li> <p>window_size (int) \u2013 defaults to <code>None</code></p> <p>The size of the window used to compute the quantiles of the residuals. If <code>None</code>, the quantiles are computed over the whole history. It is advised to set this if you expect the model's performance to change over time.</p> </li> </ul>"},{"location":"api/conf/RegressionJackknife/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import conf\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = conf.RegressionJackknife(\n...     (\n...         preprocessing.StandardScaler() |\n...         linear_model.LinearRegression(intercept_lr=.1)\n...     ),\n...     confidence_level=0.9\n... )\n\n&gt;&gt;&gt; validity = stats.Mean()\n&gt;&gt;&gt; efficiency = stats.Mean()\n\n&gt;&gt;&gt; for x, y in dataset:\n...     interval = model.predict_one(x, with_interval=True)\n...     validity = validity.update(y in interval)\n...     efficiency = efficiency.update(interval.width)\n...     model = model.learn_one(x, y)\n</code></pre> <p>The interval's validity is the proportion of times the true value is within the interval. We specified a confidence level of 90%, so we expect the validity to be around 90%.</p> <pre><code>&gt;&gt;&gt; validity\nMean: 0.903097\n</code></pre> <p>The interval's efficiency is the average width of the intervals.</p> <pre><code>&gt;&gt;&gt; efficiency\nMean: 3.430883\n</code></pre> <p>Lowering the confidence lowering will mechanically improve the efficiency.</p>"},{"location":"api/conf/RegressionJackknife/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>with_interval     \u2013 defaults to <code>False</code> </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/conf/RegressionJackknife/#references","title":"References","text":"<ol> <li> <p>Barber, Rina Foygel, Emmanuel J. Candes, Aaditya Ramdas, and Ryan J. Tibshirani. \"Predictive inference with the jackknife+.\" The Annals of Statistics 49, no. 1 (2021): 486-507. \u21a9</p> </li> </ol>"},{"location":"api/covariance/EmpiricalCovariance/","title":"EmpiricalCovariance","text":"<p>Empirical covariance matrix.</p>"},{"location":"api/covariance/EmpiricalCovariance/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof \u2013 defaults to <code>1</code></p> <p>Delta Degrees of Freedom.</p> </li> </ul>"},{"location":"api/covariance/EmpiricalCovariance/#attributes","title":"Attributes","text":"<ul> <li>matrix</li> </ul>"},{"location":"api/covariance/EmpiricalCovariance/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from river import covariance\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; X = pd.DataFrame(np.random.random((8, 3)), columns=[\"red\", \"green\", \"blue\"])\n&gt;&gt;&gt; X\n        red     green      blue\n0  0.374540  0.950714  0.731994\n1  0.598658  0.156019  0.155995\n2  0.058084  0.866176  0.601115\n3  0.708073  0.020584  0.969910\n4  0.832443  0.212339  0.181825\n5  0.183405  0.304242  0.524756\n6  0.431945  0.291229  0.611853\n7  0.139494  0.292145  0.366362\n\n&gt;&gt;&gt; cov = covariance.EmpiricalCovariance()\n&gt;&gt;&gt; for x in X.to_dict(orient=\"records\"):\n...     cov = cov.update(x)\n&gt;&gt;&gt; cov\n        blue     green    red\n blue    0.076    0.020   -0.010\ngreen    0.020    0.113   -0.053\n  red   -0.010   -0.053    0.079\n</code></pre> <p>There is also an <code>update_many</code> method to process mini-batches. The results are identical.</p> <pre><code>&gt;&gt;&gt; cov = covariance.EmpiricalCovariance()\n&gt;&gt;&gt; cov = cov.update_many(X)\n&gt;&gt;&gt; cov\n        blue     green    red\n blue    0.076    0.020   -0.010\ngreen    0.020    0.113   -0.053\n  red   -0.010   -0.053    0.079\n</code></pre> <p>The covariances are stored in a dictionary, meaning any one of them can be accessed as such:</p> <pre><code>&gt;&gt;&gt; cov[\"blue\", \"green\"]\nCov: 0.020292\n</code></pre> <p>Diagonal entries are variances:</p> <pre><code>&gt;&gt;&gt; cov[\"blue\", \"blue\"]\nVar: 0.076119\n</code></pre>"},{"location":"api/covariance/EmpiricalCovariance/#methods","title":"Methods","text":"revert <p>Downdate with a single sample.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>   update <p>Update with a single sample.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>   update_many <p>Update with a dataframe of samples.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul>"},{"location":"api/covariance/EmpiricalPrecision/","title":"EmpiricalPrecision","text":"<p>Empirical precision matrix.</p> <p>The precision matrix is the inverse of the covariance matrix. </p> <p>This implementation leverages the Sherman-Morrison formula. The resulting inverse covariance matrix is not guaranteed to be identical to a batch computation. However, the difference shrinks with the number of observations.</p>"},{"location":"api/covariance/EmpiricalPrecision/#attributes","title":"Attributes","text":"<ul> <li>matrix</li> </ul>"},{"location":"api/covariance/EmpiricalPrecision/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from river import covariance\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; X = pd.DataFrame(np.random.random((1000, 3)))\n&gt;&gt;&gt; X.head()\n          0         1         2\n0  0.374540  0.950714  0.731994\n1  0.598658  0.156019  0.155995\n2  0.058084  0.866176  0.601115\n3  0.708073  0.020584  0.969910\n4  0.832443  0.212339  0.181825\n\n&gt;&gt;&gt; prec = covariance.EmpiricalPrecision()\n&gt;&gt;&gt; for x in X.to_dict(orient=\"records\"):\n...     prec = prec.update(x)\n\n&gt;&gt;&gt; prec\n    0        1        2\n0   12.026   -0.122   -0.214\n1   -0.122   11.276   -0.026\n2   -0.214   -0.026   11.632\n\n&gt;&gt;&gt; pd.DataFrame(np.linalg.inv(np.cov(X.T, ddof=1)))\n           0          1          2\n0  12.159791  -0.124966  -0.218671\n1  -0.124966  11.393394  -0.026662\n2  -0.218671  -0.026662  11.756907\n</code></pre>"},{"location":"api/covariance/EmpiricalPrecision/#methods","title":"Methods","text":"update <p>Update with a single sample.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   update_many <p>Update with a dataframe of samples.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul>"},{"location":"api/covariance/EmpiricalPrecision/#references","title":"References","text":"<ol> <li> <p>Online Estimation of the Inverse Covariance Matrix - Markus Thill \u21a9</p> </li> <li> <p>Fast rank-one updates to matrix inverse? - Tim Vieira \u21a9</p> </li> <li> <p>Woodbury matrix identity \u21a9</p> </li> </ol>"},{"location":"api/datasets/AirlinePassengers/","title":"AirlinePassengers","text":"<p>Monthly number of international airline passengers.</p> <p>The stream contains 144 items and only one single feature, which is the month. The goal is to predict the number of passengers each month by capturing the trend and the seasonality of the data.</p>"},{"location":"api/datasets/AirlinePassengers/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/AirlinePassengers/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/AirlinePassengers/#references","title":"References","text":"<ol> <li> <p>International airline passengers: monthly totals in thousands. Jan 49 \u2013 Dec 60 \u21a9</p> </li> </ol>"},{"location":"api/datasets/Bananas/","title":"Bananas","text":"<p>Bananas dataset.</p> <p>An artificial dataset where instances belongs to several clusters with a banana shape. There are two attributes that correspond to the x and y axis, respectively.</p>"},{"location":"api/datasets/Bananas/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Bananas/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Bananas/#references","title":"References","text":"<ol> <li> <p>OpenML page \u21a9</p> </li> </ol>"},{"location":"api/datasets/Bikes/","title":"Bikes","text":"<p>Bike sharing station information from the city of Toulouse.</p> <p>The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse.</p>"},{"location":"api/datasets/Bikes/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Bikes/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Bikes/#references","title":"References","text":"<ol> <li> <p>A short introduction and conclusion to the OpenBikes 2016 Challenge \u21a9</p> </li> </ol>"},{"location":"api/datasets/ChickWeights/","title":"ChickWeights","text":"<p>Chick weights along time.</p> <p>The stream contains 578 items and 3 features. The goal is to predict the weight of each chick along time, according to the diet the chick is on. The data is ordered by time and then by chick.</p>"},{"location":"api/datasets/ChickWeights/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/ChickWeights/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/ChickWeights/#references","title":"References","text":"<ol> <li> <p>Chick weight dataset overview \u21a9</p> </li> </ol>"},{"location":"api/datasets/CreditCard/","title":"CreditCard","text":"<p>Credit card frauds.</p> <p>The datasets contains transactions made by credit cards in September 2013 by european cardholders. This dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions. </p> <p>It contains only numerical input variables which are the result of a PCA transformation. Unfortunately, due to confidentiality issues, we cannot provide the original features and more background information about the data. Features V1, V2, ... V28 are the principal components obtained with PCA, the only features which have not been transformed with PCA are 'Time' and 'Amount'. Feature 'Time' contains the seconds elapsed between each transaction and the first transaction in the dataset. The feature 'Amount' is the transaction Amount, this feature can be used for example-dependant cost-senstive learning. Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise.</p>"},{"location":"api/datasets/CreditCard/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/CreditCard/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/CreditCard/#references","title":"References","text":"<ol> <li> <p>Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015\u00a0\u21a9</p> </li> <li> <p>Dal Pozzolo, Andrea; Caelen, Olivier; Le Borgne, Yann-Ael; Waterschoot, Serge; Bontempi, Gianluca. Learned lessons in credit card fraud detection from a practitioner perspective, Expert systems with applications,41,10,4915-4928,2014, Pergamon\u00a0\u21a9</p> </li> <li> <p>Dal Pozzolo, Andrea; Boracchi, Giacomo; Caelen, Olivier; Alippi, Cesare; Bontempi, Gianluca. Credit card fraud detection: a realistic modeling and a novel learning strategy, IEEE transactions on neural networks and learning systems,29,8,3784-3797,2018,IEEE\u00a0\u21a9</p> </li> <li> <p>Dal Pozzolo, Andrea Adaptive Machine learning for credit card fraud detection ULB MLG PhD thesis (supervised by G. Bontempi)\u00a0\u21a9</p> </li> <li> <p>Carcillo, Fabrizio; Dal Pozzolo, Andrea; Le Borgne, Yann-Ael; Caelen, Olivier; Mazzer, Yannis; Bontempi, Gianluca. Scarff: a scalable framework for streaming credit card fraud detection with Spark, Information fusion,41, 182-194,2018,Elsevier\u00a0\u21a9</p> </li> <li> <p>Carcillo, Fabrizio; Le Borgne, Yann-Ael; Caelen, Olivier; Bontempi, Gianluca. Streaming active learning strategies for real-life credit card fraud detection: assessment and visualization, International Journal of Data Science and Analytics, 5,4,285-300,2018,Springer International Publishing\u00a0\u21a9</p> </li> <li> <p>Bertrand Lebichot, Yann-Ael Le Borgne, Liyun He, Frederic Oble, Gianluca Bontempi Deep-Learning Domain Adaptation Techniques for Credit Cards Fraud Detection, INNSBDDL 2019: Recent Advances in Big Data and Deep Learning, pp 78-88, 2019\u00a0\u21a9</p> </li> <li> <p>Fabrizio Carcillo, Yann-Ael Le Borgne, Olivier Caelen, Frederic Oble, Gianluca Bontempi Combining Unsupervised and Supervised Learning in Credit Card Fraud Detection Information Sciences, 2019\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/Elec2/","title":"Elec2","text":"<p>Electricity prices in New South Wales.</p> <p>This is a binary classification task, where the goal is to predict if the price of electricity will go up or down. </p> <p>This data was collected from the Australian New South Wales Electricity Market. In this market, prices are not fixed and are affected by demand and supply of the market. They are set every five minutes. Electricity transfers to/from the neighboring state of Victoria were done to alleviate fluctuations.</p>"},{"location":"api/datasets/Elec2/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Elec2/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Elec2/#references","title":"References","text":"<ol> <li> <p>SPLICE-2 Comparative Evaluation: Electricity Pricing \u21a9</p> </li> <li> <p>DataHub description \u21a9</p> </li> </ol>"},{"location":"api/datasets/HTTP/","title":"HTTP","text":"<p>HTTP dataset of the KDD 1999 cup.</p> <p>The goal is to predict whether or not an HTTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.</p>"},{"location":"api/datasets/HTTP/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/HTTP/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/HTTP/#references","title":"References","text":"<ol> <li> <p>HTTP (KDDCUP99) dataset \u21a9</p> </li> </ol>"},{"location":"api/datasets/Higgs/","title":"Higgs","text":"<p>Higgs dataset.</p> <p>The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes.</p>"},{"location":"api/datasets/Higgs/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Higgs/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Higgs/#references","title":"References","text":"<ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/ImageSegments/","title":"ImageSegments","text":"<p>Image segments classification.</p> <p>This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass.</p>"},{"location":"api/datasets/ImageSegments/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/ImageSegments/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/ImageSegments/#references","title":"References","text":"<ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/Insects/","title":"Insects","text":"<p>Insects dataset.</p> <p>This dataset has different variants, which are: </p> <ul> <li>abrupt_balanced - abrupt_imbalanced - gradual_balanced - gradual_imbalanced - incremental-abrupt_balanced - incremental-abrupt_imbalanced - incremental-reoccurring_balanced - incremental-reoccurring_imbalanced - incremental_balanced - incremental_imbalanced - out-of-control </li> </ul> <p>The number of samples and the difficulty change from one variant to another. The number of classes is always the same (6), except for the last variant (24).</p>"},{"location":"api/datasets/Insects/#parameters","title":"Parameters","text":"<ul> <li> <p>variant \u2013 defaults to <code>abrupt_balanced</code></p> <p>Indicates which variant of the dataset to load.</p> </li> </ul>"},{"location":"api/datasets/Insects/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Insects/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Insects/#references","title":"References","text":"<ol> <li> <p>USP DS repository \u21a9</p> </li> <li> <p>Souza, V., Reis, D.M.D., Maletzke, A.G. and Batista, G.E., 2020. Challenges in Benchmarking Stream Learning Algorithms with Real-world Data. arXiv preprint arXiv:2005.00113. \u21a9</p> </li> </ol>"},{"location":"api/datasets/Keystroke/","title":"Keystroke","text":"<p>CMU keystroke dataset.</p> <p>Users are tasked to type in a password. The task is to determine which user is typing in the password. </p> <p>The only difference with the original dataset is that the \"sessionIndex\" and \"rep\" attributes have been dropped.</p>"},{"location":"api/datasets/Keystroke/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Keystroke/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Keystroke/#references","title":"References","text":"<ol> <li> <p>Keystroke Dynamics - Benchmark Data Set \u21a9</p> </li> </ol>"},{"location":"api/datasets/MaliciousURL/","title":"MaliciousURL","text":"<p>Malicious URLs dataset.</p> <p>This dataset contains features about URLs that are classified as malicious or not.</p>"},{"location":"api/datasets/MaliciousURL/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/MaliciousURL/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/MaliciousURL/#references","title":"References","text":"<ol> <li> <p>Detecting Malicious URLs \u21a9</p> </li> <li> <p>Identifying Suspicious URLs: An Application of Large-Scale Online Learning \u21a9</p> </li> </ol>"},{"location":"api/datasets/MovieLens100K/","title":"MovieLens100K","text":"<p>MovieLens 100K dataset.</p> <p>MovieLens datasets were collected by the GroupLens Research Project at the University of Minnesota. This dataset consists of 100,000 ratings (1-5) from 943 users on 1682 movies. Each user has rated at least 20 movies. User and movie information are provided. The data was collected through the MovieLens web site (movielens.umn.edu) during the seven-month period from September 19th, 1997 through April 22nd, 1998.</p>"},{"location":"api/datasets/MovieLens100K/#parameters","title":"Parameters","text":"<ul> <li> <p>unpack_user_and_item \u2013 defaults to <code>False</code></p> <p>Whether or not the user and item should be extracted from the context and included as extra keyword arguments.</p> </li> </ul>"},{"location":"api/datasets/MovieLens100K/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/MovieLens100K/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/MovieLens100K/#references","title":"References","text":"<ol> <li> <p>The MovieLens Datasets: History and Context \u21a9</p> </li> </ol>"},{"location":"api/datasets/Music/","title":"Music","text":"<p>Multi-label music mood prediction.</p> <p>The goal is to predict to which kinds of moods a song pertains to.</p>"},{"location":"api/datasets/Music/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Music/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Music/#references","title":"References","text":"<ol> <li> <p>Read, J., Reutemann, P., Pfahringer, B. and Holmes, G., 2016. MEKA: a multi-label/multi-target extension to WEKA. The Journal of Machine Learning Research, 17(1), pp.667-671. \u21a9</p> </li> </ol>"},{"location":"api/datasets/Phishing/","title":"Phishing","text":"<p>Phishing websites.</p> <p>This dataset contains features from web pages that are classified as phishing or not.</p>"},{"location":"api/datasets/Phishing/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Phishing/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Phishing/#references","title":"References","text":"<ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/Restaurants/","title":"Restaurants","text":"<p>Data from the Kaggle Recruit Restaurants challenge.</p> <p>The goal is to predict the number of visitors in each of 829 Japanese restaurants over a priod of roughly 16 weeks. The data is ordered by date and then by restaurant ID.</p>"},{"location":"api/datasets/Restaurants/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Restaurants/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Restaurants/#references","title":"References","text":"<ol> <li> <p>Recruit Restaurant Visitor Forecasting \u21a9</p> </li> </ol>"},{"location":"api/datasets/SMSSpam/","title":"SMSSpam","text":"<p>SMS Spam Collection dataset.</p> <p>The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not.</p>"},{"location":"api/datasets/SMSSpam/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/SMSSpam/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/SMSSpam/#references","title":"References","text":"<ol> <li> <p>Almeida, T.A., Hidalgo, J.M.G. and Yamakami, A., 2011, September. Contributions to the study of SMS spam filtering: new collection and results. In Proceedings of the 11th ACM symposium on Document engineering (pp. 259-262). \u21a9</p> </li> </ol>"},{"location":"api/datasets/SMTP/","title":"SMTP","text":"<p>SMTP dataset from the KDD 1999 cup.</p> <p>The goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.</p>"},{"location":"api/datasets/SMTP/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/SMTP/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/SMTP/#references","title":"References","text":"<ol> <li> <p>SMTP (KDDCUP99) dataset \u21a9</p> </li> </ol>"},{"location":"api/datasets/SolarFlare/","title":"SolarFlare","text":"<p>Solar flare multi-output regression.</p>"},{"location":"api/datasets/SolarFlare/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/SolarFlare/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/SolarFlare/#references","title":"References","text":"<ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/TREC07/","title":"TREC07","text":"<p>TREC's 2007 Spam Track dataset.</p> <p>The data contains 75,419 chronologically ordered items, i.e. 3 months of emails delivered to a particular server in 2007. Spam messages represent 66.6% of the dataset. The goal is to predict whether an email is a spam or not. </p> <p>The available raw features are: sender, recipients, date, subject, body.</p>"},{"location":"api/datasets/TREC07/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/TREC07/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/TREC07/#references","title":"References","text":"<ol> <li> <p>TREC 2007 Spam Track Overview \u21a9</p> </li> <li> <p>Code ran to parse the dataset \u21a9</p> </li> </ol>"},{"location":"api/datasets/Taxis/","title":"Taxis","text":"<p>Taxi ride durations in New York City.</p> <p>The goal is to predict the duration of taxi rides in New York City.</p>"},{"location":"api/datasets/Taxis/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Taxis/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/Taxis/#references","title":"References","text":"<ol> <li> <p>New York City Taxi Trip Duration competition on Kaggle \u21a9</p> </li> </ol>"},{"location":"api/datasets/TrumpApproval/","title":"TrumpApproval","text":"<p>Donald Trump approval ratings.</p> <p>This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model.</p>"},{"location":"api/datasets/TrumpApproval/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/TrumpApproval/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/TrumpApproval/#references","title":"References","text":"<ol> <li> <p>Trump Approval Ratings \u21a9</p> </li> </ol>"},{"location":"api/datasets/WaterFlow/","title":"WaterFlow","text":"<p>Water flow through a pipeline branch.</p> <p>The series includes hourly values for about 2 months, March 2022 to May 2022. The values are expressed in liters per second. There are four anomalous segments in the series: </p> <ul> <li>3 \"low value moments\": this is due to water losses or human intervention for maintenance * A small peak in the water inflow after the first 2 segments: this is due to a pumping     operation into the main pipeline, when more water pressure is needed </li> </ul> <p>This dataset is well suited for time series forecasting models, as well as anomaly detection methods. Ideally, the goal is to build a time series forecasting model that is robust to the anomalous segments. </p> <p>This data has been kindly donated by the Tecnojest s.r.l. company (www.invidea.it) from Italy.</p>"},{"location":"api/datasets/WaterFlow/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/WaterFlow/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/base/Dataset/","title":"Dataset","text":"<p>Base class for all datasets.</p> <p>All datasets inherit from this class, be they stored in a file or generated on the fly.</p>"},{"location":"api/datasets/base/Dataset/#parameters","title":"Parameters","text":"<ul> <li> <p>task</p> <p>Type of task the dataset is meant for. Should be one of: - \"Regression\" - \"Binary classification\" - \"Multi-class classification\" - \"Multi-output binary classification\" - \"Multi-output regression\"</p> </li> <li> <p>n_features</p> <p>Number of features in the dataset.</p> </li> <li> <p>n_samples \u2013 defaults to <code>None</code></p> <p>Number of samples in the dataset.</p> </li> <li> <p>n_classes \u2013 defaults to <code>None</code></p> <p>Number of classes in the dataset, only applies to classification datasets.</p> </li> <li> <p>n_outputs \u2013 defaults to <code>None</code></p> <p>Number of outputs the target is made of, only applies to multi-output datasets.</p> </li> <li> <p>sparse \u2013 defaults to <code>False</code></p> <p>Whether the dataset is sparse or not.</p> </li> </ul>"},{"location":"api/datasets/base/Dataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/base/Dataset/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/base/FileDataset/","title":"FileDataset","text":"<p>Base class for datasets that are stored in a local file.</p> <p>Small datasets that are part of the river package inherit from this class.</p>"},{"location":"api/datasets/base/FileDataset/#parameters","title":"Parameters","text":"<ul> <li> <p>filename</p> <p>The file's name.</p> </li> <li> <p>directory \u2013 defaults to <code>None</code></p> <p>The directory where the file is contained. Defaults to the location of the <code>datasets</code> module.</p> </li> <li> <p>desc</p> <p>Extra dataset parameters to pass as keyword arguments.</p> </li> </ul>"},{"location":"api/datasets/base/FileDataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/base/FileDataset/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/base/RemoteDataset/","title":"RemoteDataset","text":"<p>Base class for datasets that are stored in a remote file.</p> <p>Medium and large datasets that are not part of the river package inherit from this class. </p> <p>The filename doesn't have to be provided if unpack is False. Indeed in the latter case the filename will be inferred from the URL.</p>"},{"location":"api/datasets/base/RemoteDataset/#parameters","title":"Parameters","text":"<ul> <li> <p>url</p> <p>The URL the dataset is located at.</p> </li> <li> <p>size</p> <p>The expected download size.</p> </li> <li> <p>unpack \u2013 defaults to <code>True</code></p> <p>Whether to unpack the download or not.</p> </li> <li> <p>filename \u2013 defaults to <code>None</code></p> <p>An optional name to given to the file if the file is unpacked.</p> </li> <li> <p>desc</p> <p>Extra dataset parameters to pass as keyword arguments.</p> </li> </ul>"},{"location":"api/datasets/base/RemoteDataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/base/RemoteDataset/#methods","title":"Methods","text":"download   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/base/SyntheticDataset/","title":"SyntheticDataset","text":"<p>A synthetic dataset.</p>"},{"location":"api/datasets/base/SyntheticDataset/#parameters","title":"Parameters","text":"<ul> <li> <p>task</p> <p>Type of task the dataset is meant for. Should be one of: - \"Regression\" - \"Binary classification\" - \"Multi-class classification\" - \"Multi-output binary classification\" - \"Multi-output regression\"</p> </li> <li> <p>n_features</p> <p>Number of features in the dataset.</p> </li> <li> <p>n_samples \u2013 defaults to <code>None</code></p> <p>Number of samples in the dataset.</p> </li> <li> <p>n_classes \u2013 defaults to <code>None</code></p> <p>Number of classes in the dataset, only applies to classification datasets.</p> </li> <li> <p>n_outputs \u2013 defaults to <code>None</code></p> <p>Number of outputs the target is made of, only applies to multi-output datasets.</p> </li> <li> <p>sparse \u2013 defaults to <code>False</code></p> <p>Whether the dataset is sparse or not.</p> </li> </ul>"},{"location":"api/datasets/base/SyntheticDataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/base/SyntheticDataset/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Agrawal/","title":"Agrawal","text":"<p>Agrawal stream generator.</p> <p>The generator was introduced by Agrawal et al. 1, and was a common source of data for early work on scaling up decision tree learners. The generator produces a stream containing nine features, six numeric and three categorical. There are 10 functions defined for generating binary class labels from the features. Presumably these determine whether the loan should be approved. Classification functions are listed in the original paper 1. </p> <p>Feature | Description | Values </p> <ul> <li> <p><code>salary</code> | salary | uniformly distributed from 20k to 150k </p> </li> <li> <p><code>commission</code> | commission | 0 if <code>salary</code> &lt; 75k else uniformly distributed from 10k to 75k </p> </li> <li> <p><code>age</code> | age | uniformly distributed from 20 to 80 </p> </li> <li> <p><code>elevel</code> | education level | uniformly chosen from 0 to 4 </p> </li> <li> <p><code>car</code> | car maker | uniformly chosen from 1 to 20 </p> </li> <li> <p><code>zipcode</code> | zip code of the town | uniformly chosen from 0 to 8 </p> </li> <li> <p><code>hvalue</code> | house value | uniformly distributed from 50k x zipcode to 100k x zipcode </p> </li> <li> <p><code>hyears</code> | years house owned | uniformly distributed from 1 to 30 </p> </li> <li> <p><code>loan</code> | total loan amount | uniformly distributed from 0 to 500k</p> </li> </ul>"},{"location":"api/datasets/synth/Agrawal/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function ('int') \u2013 defaults to <code>0</code></p> <p>The classification function to use for the generation. Valid values are from 0 to 9.</p> </li> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes ('bool') \u2013 defaults to <code>False</code></p> <p>If True, the class distribution will converge to a uniform distribution.</p> </li> <li> <p>perturbation ('float') \u2013 defaults to <code>0.0</code></p> <p>The probability that noise will happen in the generation. Each new sample will be perturbed by the magnitude of <code>perturbation</code>. Valid values are in the range [0.0 to 1.0].</p> </li> </ul>"},{"location":"api/datasets/synth/Agrawal/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Agrawal/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Agrawal(\n...     classification_function=0,\n...     seed=42\n... )\n\n&gt;&gt;&gt; dataset\nSynthetic data generator\n&lt;BLANKLINE&gt;\n    Name  Agrawal\n    Task  Binary classification\n Samples  \u221e\nFeatures  9\n Outputs  1\n Classes  2\n  Sparse  False\n&lt;BLANKLINE&gt;\nConfiguration\n-------------\nclassification_function  0\n                   seed  42\n        balance_classes  False\n           perturbation  0.0\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[103125.4837, 0, 21, 2, 8, 3, 319768.9642, 4, 338349.7437] 1\n[135983.3438, 0, 25, 4, 14, 0, 423837.7755, 7, 116330.4466] 1\n[98262.4347, 0, 55, 1, 18, 6, 144088.1244, 19, 139095.3541] 0\n[133009.0417, 0, 68, 1, 14, 5, 233361.4025, 7, 478606.5361] 1\n[63757.2908, 16955.9382, 26, 2, 12, 4, 522851.3093, 24, 229712.4398] 1\n</code></pre>"},{"location":"api/datasets/synth/Agrawal/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function randomly.</p>   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Agrawal/#notes","title":"Notes","text":"<p>The sample generation works as follows: The 9 features are generated with the random generator, initialized with the seed passed by the user. Then, the classification function decides, as a function of all the attributes, whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. Finally, add noise if <code>perturbation</code> &gt; 0.0.</p>"},{"location":"api/datasets/synth/Agrawal/#references","title":"References","text":"<ol> <li> <p>Rakesh Agrawal, Tomasz Imielinksi, and Arun Swami. \"Database Mining:   A Performance Perspective\", IEEE Transactions on Knowledge and   Data Engineering, 5(6), December 1993.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/AnomalySine/","title":"AnomalySine","text":"<p>Simulate a stream with anomalies in sine waves.</p> <p>The amount of data generated by this generator is finite. </p> <p>The data generated corresponds to sine and cosine functions. Anomalies are induced by replacing the cosine values with values from a different a sine function. The <code>contextual</code> flag can be used to introduce contextual anomalies which are values in the normal global range, but abnormal compared to the seasonal pattern. Contextual attributes are introduced by replacing cosine entries with sine values. </p> <p>The target indicates whether or not the instances are anomalous.</p>"},{"location":"api/datasets/synth/AnomalySine/#parameters","title":"Parameters","text":"<ul> <li> <p>n_samples ('int') \u2013 defaults to <code>10000</code></p> <p>The number of samples to generate. This generator creates a batch of data affected by contextual anomalies and noise.</p> </li> <li> <p>n_anomalies ('int') \u2013 defaults to <code>2500</code></p> <p>Number of anomalies. Can't be larger than <code>n_samples</code>.</p> </li> <li> <p>contextual ('bool') \u2013 defaults to <code>False</code></p> <p>If True, will add contextual anomalies.</p> </li> <li> <p>n_contextual ('int') \u2013 defaults to <code>2500</code></p> <p>Number of contextual anomalies. Can't be larger than <code>n_samples</code>.</p> </li> <li> <p>shift ('int') \u2013 defaults to <code>4</code></p> <p>Shift in number of samples applied when retrieving contextual anomalies.</p> </li> <li> <p>noise ('float') \u2013 defaults to <code>0.5</code></p> <p>Amount of noise.</p> </li> <li> <p>replace ('bool') \u2013 defaults to <code>True</code></p> <p>If True, anomalies are randomly sampled with replacement.</p> </li> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/AnomalySine/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/AnomalySine/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.AnomalySine(\n...     seed=12345,\n...     n_samples=100,\n...     n_anomalies=25,\n...     contextual=True,\n...     n_contextual=10\n... )\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{'sine': -0.7119, 'cosine': 0.8777} False\n{'sine': 0.8792, 'cosine': -0.0290} False\n{'sine': 0.0440, 'cosine': 3.0852} True\n{'sine': 0.5520, 'cosine': 3.4515} True\n{'sine': 0.8037, 'cosine': 0.4027} False\n</code></pre>"},{"location":"api/datasets/synth/AnomalySine/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/ConceptDriftStream/","title":"ConceptDriftStream","text":"<p>Generates a stream with concept drift.</p> <p>A stream generator that adds concept drift or change by joining two streams. This is done by building a weighted combination of two pure distributions that characterizes the target concepts before and after the change. </p> <p>The sigmoid function is an elegant and practical solution to define the probability that each new instance of the stream belongs to the new concept after the drift. The sigmoid function introduces a gradual, smooth transition whose duration is controlled with two parameters: </p> <ul> <li> <p>\\(p\\), the position of the change. </p> </li> <li> <p>\\(w\\), the width of the transition. </p> </li> </ul> <p>The sigmoid function at sample \\(t\\) is </p> \\[f(t) = 1/(1+e^{-4(t-p)/w})\\]"},{"location":"api/datasets/synth/ConceptDriftStream/#parameters","title":"Parameters","text":"<ul> <li> <p>stream (river.datasets.base.SyntheticDataset) \u2013 defaults to <code>None</code></p> <p>Original stream</p> </li> <li> <p>drift_stream (river.datasets.base.SyntheticDataset) \u2013 defaults to <code>None</code></p> <p>Drift stream</p> </li> <li> <p>position (int) \u2013 defaults to <code>5000</code></p> <p>Central position of the concept drift change.</p> </li> <li> <p>width (int) \u2013 defaults to <code>1000</code></p> <p>Width of concept drift change.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>alpha (float) \u2013 defaults to <code>None</code></p> <p>Angle of change used to estimate the width of concept drift change. If set, it will override the width parameter. Valid values are in the range (0.0, 90.0].</p> </li> </ul>"},{"location":"api/datasets/synth/ConceptDriftStream/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/ConceptDriftStream/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.ConceptDriftStream(\n...     stream=synth.SEA(seed=42, variant=0),\n...     drift_stream=synth.SEA(seed=42, variant=1),\n...     seed=1, position=5, width=2\n... )\n\n&gt;&gt;&gt; for x, y in dataset.take(10):\n...     print(x, y)\n{0: 6.3942, 1: 0.2501, 2: 2.7502} False\n{0: 2.2321, 1: 7.3647, 2: 6.7669} True\n{0: 8.9217, 1: 0.8693, 2: 4.2192} True\n{0: 0.2979, 1: 2.1863, 2: 5.0535} False\n{0: 6.3942, 1: 0.2501, 2: 2.7502} False\n{0: 2.2321, 1: 7.3647, 2: 6.7669} True\n{0: 8.9217, 1: 0.8693, 2: 4.2192} True\n{0: 0.2979, 1: 2.1863, 2: 5.0535} False\n{0: 0.2653, 1: 1.9883, 2: 6.4988} False\n{0: 5.4494, 1: 2.2044, 2: 5.8926} False\n</code></pre>"},{"location":"api/datasets/synth/ConceptDriftStream/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/ConceptDriftStream/#notes","title":"Notes","text":"<p>An optional way to estimate the width of the transition \\(w\\) is based on the angle \\(\\alpha\\), \\(w = 1/ tan(\\alpha)\\). Since width corresponds to the number of samples for the transition, the width is rounded to the nearest smaller integer. Notice that larger values of \\(\\alpha\\) result in smaller widths. For \\(\\alpha &gt; 45.0\\), the width is smaller than 1 so values are rounded to 1 to avoid division by zero errors.</p>"},{"location":"api/datasets/synth/Friedman/","title":"Friedman","text":"<p>Friedman synthetic dataset.</p> <p>Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. The target is defined by the following function: </p> \\[y = 10 sin(\\pi x_0 x_1) + 20 (x_2 - 0.5)^2 + 10 x_3 + 5 x_4 + \\epsilon\\] <p>In the last expression, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\), is the noise. Therefore, only the first 5 features are relevant.</p>"},{"location":"api/datasets/synth/Friedman/#parameters","title":"Parameters","text":"<ul> <li> <p>seed ('int') \u2013 defaults to <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Friedman/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Friedman/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Friedman(seed=42)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 7.04\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 18.16\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] 8.90\n</code></pre>"},{"location":"api/datasets/synth/Friedman/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Friedman/#references","title":"References","text":"<ol> <li> <p>Friedman, J.H., 1991. Multivariate adaptive regression splines. The annals of statistics, pp.1-67. \u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/FriedmanDrift/","title":"FriedmanDrift","text":"<p>Friedman synthetic dataset with concept drifts.</p> <p>Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. Only the first 5 features are relevant. The target is defined by different functions depending on the type of the drift. </p> <p>The three available modes of operation of the data generator are described in 1.</p>"},{"location":"api/datasets/synth/FriedmanDrift/#parameters","title":"Parameters","text":"<ul> <li> <p>drift_type ('str') \u2013 defaults to <code>lea</code></p> <p>The variant of concept drift. - <code>'lea'</code>: Local Expanding Abrupt drift. The concept drift appears in two distinct regions of the instance space, while the remaining regions are left unaltered. There are three points of abrupt change in the training dataset. At every consecutive change the regions of drift are expanded. - <code>'gra'</code>: Global Recurring Abrupt drift. The concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs. - <code>'gsg'</code>: Global and Slow Gradual drift. The concept drift affects all the instance space. However, the change is gradual and not abrupt. After each one of the two change points covered by this variant, and during a window of length <code>transition_window</code>, examples from both old and the new concepts are generated with equal probability. After the transition period, only the examples from the new concept are generated.</p> </li> <li> <p>position ('tuple[int, ...]') \u2013 defaults to <code>(50000, 100000, 150000)</code></p> <p>The amount of monitored instances after which each concept drift occurs. A tuple with at least two element must be passed, where each number is greater than the preceding one. If <code>drift_type='lea'</code>, then the tuple must have three elements.</p> </li> <li> <p>transition_window ('int') \u2013 defaults to <code>10000</code></p> <p>The length of the transition window between two concepts. Only applicable when  <code>drift_type='gsg'</code>. If set to zero, the drifts will be abrupt. Anytime  <code>transition_window &gt; 0</code>, it defines a window in which instances of the new  concept are gradually introduced among the examples from the old concept.  During this transition phase, both old and new concepts appear with equal probability.</p> </li> <li> <p>seed ('int') \u2013 defaults to <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/FriedmanDrift/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/FriedmanDrift/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.FriedmanDrift(\n...     drift_type='lea',\n...     position=(1, 2, 3),\n...     seed=42\n... )\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 7.04\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 18.16\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] -2.65\n\n&gt;&gt;&gt; dataset = synth.FriedmanDrift(\n...     drift_type='gra',\n...     position=(2, 3),\n...     seed=42\n... )\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 8.96\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 18.16\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] 8.90\n\n&gt;&gt;&gt; dataset = synth.FriedmanDrift(\n...     drift_type='gsg',\n...     position=(1, 4),\n...     transition_window=2,\n...     seed=42\n... )\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 8.92\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 17.32\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] 6.05\n</code></pre>"},{"location":"api/datasets/synth/FriedmanDrift/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/FriedmanDrift/#references","title":"References","text":"<ol> <li> <p>Ikonomovska, E., Gama, J. and D\u017eeroski, S., 2011. Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), pp.128-168.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Hyperplane/","title":"Hyperplane","text":"<p>Hyperplane stream generator.</p> <p>Generates a problem of prediction class of a rotation hyperplane. It was used as testbed for CVFDT and VFDT in 1. </p> <p>A hyperplane in d-dimensional space is the set of points \\(x\\) that satisfy </p> \\[\\sum^{d}_{i=1} w_i x_i = w_0 = \\sum^{d}_{i=1} w_i\\] <p>where \\(x_i\\) is the i-th coordinate of \\(x\\). </p> <ul> <li> <p>Examples for which \\(\\sum^{d}_{i=1} w_i x_i &gt; w_0\\), are labeled positive. </p> </li> <li> <p>Examples for which \\(\\sum^{d}_{i=1} w_i x_i \\leq w_0\\), are labeled negative. </p> </li> </ul> <p>Hyperplanes are useful for simulating time-changing concepts because we can change the orientation and position of the hyperplane in a smooth manner by changing the relative size of the weights. We introduce change to this dataset by adding drift to each weighted feature \\(w_i = w_i + d \\sigma\\), where \\(\\sigma\\) is the probability that the direction of change is reversed and \\(d\\) is the change applied to each example.</p>"},{"location":"api/datasets/synth/Hyperplane/#parameters","title":"Parameters","text":"<ul> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>n_features ('int') \u2013 defaults to <code>10</code></p> <p>The number of attributes to generate. Higher than 2.</p> </li> <li> <p>n_drift_features ('int') \u2013 defaults to <code>2</code></p> <p>The number of attributes with drift. Higher than 2.</p> </li> <li> <p>mag_change ('float') \u2013 defaults to <code>0.0</code></p> <p>Magnitude of the change for every example. From 0.0 to 1.0.</p> </li> <li> <p>noise_percentage ('float') \u2013 defaults to <code>0.05</code></p> <p>Percentage of noise to add to the data. From 0.0 to 1.0.</p> </li> <li> <p>sigma ('float') \u2013 defaults to <code>0.1</code></p> <p>Probability that the direction of change is reversed. From 0.0 to 1.0.</p> </li> </ul>"},{"location":"api/datasets/synth/Hyperplane/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Hyperplane/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Hyperplane(seed=42, n_features=2)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{0: 0.2750, 1: 0.2232} 0\n{0: 0.0869, 1: 0.4219} 1\n{0: 0.0265, 1: 0.1988} 0\n{0: 0.5892, 1: 0.8094} 0\n{0: 0.3402, 1: 0.1554} 0\n</code></pre>"},{"location":"api/datasets/synth/Hyperplane/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Hyperplane/#notes","title":"Notes","text":"<p>The sample generation works as follows: The features are generated with the random number generator, initialized with the seed passed by the user. Then the classification function decides, as a function of the sum of the weighted features and the sum of the weights, whether the instance belongs to class 0 or class 1. The last step is to add noise and generate drift.</p>"},{"location":"api/datasets/synth/Hyperplane/#references","title":"References","text":"<ol> <li> <p>G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams.   In KDD'01, pages 97-106, San Francisco, CA, 2001. ACM Press.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/LED/","title":"LED","text":"<p>LED stream generator.</p> <p>This data source originates from the CART book 1. An implementation in C was donated to the UCI 2 machine learning repository by David Aha. The goal is to predict the digit displayed on a seven-segment LED display, where each attribute has a 10% chance of being inverted. It has an optimal Bayes classification rate of 74%. The particular configuration of the generator used for experiments (LED) produces 24 binary attributes, 17 of which are irrelevant.</p>"},{"location":"api/datasets/synth/LED/#parameters","title":"Parameters","text":"<ul> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>noise_percentage ('float') \u2013 defaults to <code>0.0</code></p> <p>The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value  will be switched</p> </li> <li> <p>irrelevant_features ('bool') \u2013 defaults to <code>False</code></p> <p>Adds 17 non-relevant attributes to the stream.</p> </li> </ul>"},{"location":"api/datasets/synth/LED/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/LED/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.LED(seed = 112, noise_percentage = 0.28, irrelevant_features= False)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{0: 1, 1: 0, 2: 1, 3: 0, 4: 0, 5: 1, 6: 0} 7\n{0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 0} 8\n{0: 1, 1: 1, 2: 1, 3: 1, 4: 0, 5: 1, 6: 0} 9\n{0: 0, 1: 0, 2: 1, 3: 0, 4: 0, 5: 1, 6: 0} 1\n{0: 0, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0} 1\n</code></pre>"},{"location":"api/datasets/synth/LED/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/LED/#notes","title":"Notes","text":"<p>An instance is generated based on the parameters passed. If <code>has_noise</code> is set then the total number of attributes will be 24, otherwise there will be 7 attributes.</p>"},{"location":"api/datasets/synth/LED/#references","title":"References","text":"<ol> <li> <p>Leo Breiman, Jerome Friedman, R. Olshen, and Charles J. Stone.   Classification and Regression Trees. Wadsworth and Brooks,   Monterey, CA,1984.\u00a0\u21a9</p> </li> <li> <p>A. Asuncion and D. J. Newman. UCI Machine Learning Repository   [http://www.ics.uci.edu/~mlearn/mlrepository.html].   University of California, Irvine, School of Information and   Computer Sciences,2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/LEDDrift/","title":"LEDDrift","text":"<p>LED stream generator with concept drift.</p> <p>This class is an extension of the <code>LED</code> generator whose purpose is to add concept drift to the stream.</p>"},{"location":"api/datasets/synth/LEDDrift/#parameters","title":"Parameters","text":"<ul> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>noise_percentage ('float') \u2013 defaults to <code>0.0</code></p> <p>The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value  will be switched</p> </li> <li> <p>irrelevant_features ('bool') \u2013 defaults to <code>False</code></p> <p>Adds 17 non-relevant attributes to the stream.</p> </li> <li> <p>n_drift_features ('int') \u2013 defaults to <code>0</code></p> <p>The number of attributes that have drift.</p> </li> </ul>"},{"location":"api/datasets/synth/LEDDrift/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/LEDDrift/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.LEDDrift(seed = 112, noise_percentage = 0.28,\n...                          irrelevant_features= True, n_drift_features=4)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1] 7\n[1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0] 6\n[0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1] 1\n[1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1] 6\n[1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0] 7\n</code></pre>"},{"location":"api/datasets/synth/LEDDrift/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/LEDDrift/#notes","title":"Notes","text":"<p>An instance is generated based on the parameters passed. If <code>has_noise</code> is set then the total number of attributes will be 24, otherwise there will be 7 attributes.</p>"},{"location":"api/datasets/synth/Logical/","title":"Logical","text":"<p>Logical functions stream generator.</p> <p>Make a toy dataset with three labels that represent the logical functions: <code>OR</code>, <code>XOR</code>, <code>AND</code> (functions of the 2D input). </p> <p>Data is generated in 'tiles' which contain the complete set of logical operations results. The tiles are repeated <code>n_tiles</code> times. Optionally, the generated data can be shuffled.</p>"},{"location":"api/datasets/synth/Logical/#parameters","title":"Parameters","text":"<ul> <li> <p>n_tiles ('int') \u2013 defaults to <code>1</code></p> <p>Number of tiles to generate.</p> </li> <li> <p>shuffle ('bool') \u2013 defaults to <code>True</code></p> <p>If set, generated data will be shuffled.</p> </li> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Logical/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Logical/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Logical(n_tiles=2, shuffle=True, seed=42)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{'A': 1, 'B': 1} {'OR': 1, 'XOR': 0, 'AND': 1}\n{'A': 0, 'B': 0} {'OR': 0, 'XOR': 0, 'AND': 0}\n{'A': 1, 'B': 0} {'OR': 1, 'XOR': 1, 'AND': 0}\n{'A': 1, 'B': 1} {'OR': 1, 'XOR': 0, 'AND': 1}\n{'A': 1, 'B': 0} {'OR': 1, 'XOR': 1, 'AND': 0}\n</code></pre>"},{"location":"api/datasets/synth/Logical/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Mixed/","title":"Mixed","text":"<p>Mixed data stream generator.</p> <p>This generator is an implementation of a data stream with abrupt concept drift and boolean noise-free examples as described in 1. </p> <p>It has four relevant attributes, two boolean attributes \\(v, w\\) and two numeric attributes \\(x, y\\) uniformly distributed from 0 to 1. The examples are labeled depending on the classification function chosen from below. </p> <ul> <li> <p><code>function 0</code>:   if \\(v\\) and \\(w\\) are true or \\(v\\) and \\(z\\) are true or \\(w\\) and \\(z\\) are true   then 0 else 1, where \\(z\\) is \\(y &lt; 0.5 + 0.3 sin(3 \\pi  x)\\) </p> </li> <li> <p><code>function 1</code>:    The opposite of <code>function 0</code>. </p> </li> </ul> <p>Concept drift can be introduced by changing the classification function. This can be done manually or using <code>ConceptDriftStream</code>.</p>"},{"location":"api/datasets/synth/Mixed/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function ('int') \u2013 defaults to <code>0</code></p> <p>Which of the two classification functions to use for the generation. Valid options are 0 or 1.</p> </li> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes ('bool') \u2013 defaults to <code>False</code></p> <p>Whether to balance classes or not. If balanced, the class distribution will converge to a uniform distribution.</p> </li> </ul>"},{"location":"api/datasets/synth/Mixed/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Mixed/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt;\n&gt;&gt;&gt; dataset = synth.Mixed(seed = 42, classification_function=1, balance_classes = True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{0: True, 1: False, 2: 0.2750, 3: 0.2232} 1\n{0: False, 1: False, 2: 0.2186, 3: 0.5053} 0\n{0: False, 1: True, 2: 0.8094, 3: 0.0064} 1\n{0: False, 1: False, 2: 0.1010, 3: 0.2779} 0\n{0: True, 1: False, 2: 0.37018, 3: 0.2095} 1\n</code></pre>"},{"location":"api/datasets/synth/Mixed/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function.</p>   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Mixed/#notes","title":"Notes","text":"<p>The sample generation works as follows: The two numeric attributes are generated with the random  generator initialized with the seed passed by the user (optional). The boolean attributes are either 0 or 1 based on the comparison of the random number generator and 0.5, the classification function decides whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes.</p> <p>The generated sample will have 4 relevant features and 1 label (it is a binary-classification task).</p>"},{"location":"api/datasets/synth/Mixed/#references","title":"References","text":"<ol> <li> <p>Gama, Joao, et al. \"Learning with drift detection.\" Advances in   artificial intelligence-SBIA 2004. Springer Berlin Heidelberg,   2004. 286-295\"\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Mv/","title":"Mv","text":"<p>Mv artificial dataset.</p> <p>Artificial dataset composed of both nominal and numeric features, whose features present co-dependencies. Originally described in 1. </p> <p>The features are generated using the following expressions: </p> <ul> <li> <p>\\(x_1\\): uniformly distributed over <code>[-5, 5]</code>. </p> </li> <li> <p>\\(x_2\\): uniformly distributed over <code>[-15, -10]</code>. </p> </li> <li> <p>\\(x_3\\): </p> <ul> <li> <p>if \\(x_1 &gt; 0\\), \\(x_3 \\leftarrow\\) <code>'green'</code> </p> </li> <li> <p>else \\(x_3 \\leftarrow\\) <code>'red'</code> with probability \\(0.4\\) and \\(x_3 \\leftarrow\\) <code>'brown'</code>     with probability \\(0.6\\). </p> </li> </ul> </li> <li> <p>\\(x_4\\): </p> <ul> <li> <p>if \\(x_3 =\\) <code>'green'</code>, \\(x_4 \\leftarrow x_1 + 2 x_2\\) </p> </li> <li> <p>else \\(x_4 = \\frac{x_1}{2}\\) with probability \\(0.3\\) and \\(x_4 = \\frac{x_2}{2}\\)     with probability \\(0.7\\). </p> </li> </ul> </li> <li> <p>\\(x_5\\): uniformly distributed over <code>[-1, 1]</code>. </p> </li> <li> <p>\\(x_6 \\leftarrow x_4 \\times \\epsilon\\), where \\(\\epsilon\\) is uniformly distributed over <code>[0, 5]</code>. </p> </li> <li> <p>\\(x_7\\): <code>'yes'</code> with probability \\(0.3\\), and <code>'no'</code> with probability \\(0.7\\). </p> </li> <li> <p>\\(x_8\\): <code>'normal'</code> if \\(x_5 &lt; 0.5\\) else <code>'large'</code>. </p> </li> <li> <p>\\(x_9\\): uniformly distributed over <code>[100, 500]</code>. </p> </li> <li> <p>\\(x_{10}\\): uniformly distributed integer over the interval <code>[1000, 1200]</code>. </p> </li> </ul> <p>The target value is generated using the following rules: </p> <ul> <li> <p>if \\(x_2 &gt; 2\\), \\(y \\leftarrow 35 - 0.5 x_4\\) </p> </li> <li> <p>else if \\(-2 \\le x_4 \\le 2\\), \\(y \\leftarrow 10 - 2 x_1\\) </p> </li> <li> <p>else if \\(x_7 =\\) <code>'yes'</code>, \\(y \\leftarrow 3 - \\frac{x_1}{x_4}\\) </p> </li> <li> <p>else if \\(x_8 =\\) <code>'normal'</code>, \\(y \\leftarrow x_6 + x_1\\) </p> </li> <li> <p>else \\(y \\leftarrow \\frac{x_1}{2}\\).</p> </li> </ul>"},{"location":"api/datasets/synth/Mv/#parameters","title":"Parameters","text":"<ul> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Mv/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Mv/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Mv(seed=42)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[1.39, -14.87, 'green', -28.35, -0.44, -31.64, 'no', 'normal', 370.67, 1178.43] -30.25\n[-4.13, -12.89, 'red', -2.06, 0.01, -0.27, 'yes', 'normal', 359.95, 1108.98] 1.00\n[-2.79, -12.05, 'brown', -1.39, 0.61, -4.87, 'no', 'large', 162.19, 1191.44] 15.59\n[-1.63, -14.53, 'red', -7.26, 0.20, -29.33, 'no', 'normal', 314.49, 1194.62] -30.96\n[-1.21, -12.23, 'brown', -6.11, 0.72, -17.66, 'no', 'large', 118.32, 1045.57] -0.60\n</code></pre>"},{"location":"api/datasets/synth/Mv/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Mv/#references","title":"References","text":"<ol> <li> <p>Mv in Lu\u00eds Torgo regression datasets \u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Planes2D/","title":"Planes2D","text":"<p>2D Planes synthetic dataset.</p> <p>This dataset is described in 1 and was adapted from 2. The features are generated using the following probabilities: </p> \\[P(x_1 = -1) = P(x_1 = 1) = \\frac{1}{2}\\] \\[P(x_m = -1) = P(x_m = 0) = P(x_m = 1) = \\frac{1}{3}, m=2,\\ldots, 10\\] <p>The target value is defined by the following rule: </p> \\[\\text{if}~x_1 = 1, y \\leftarrow 3 + 3x_2 + 2x_3 + x_4 + \\epsilon\\] \\[\\text{if}~x_1 = -1, y \\leftarrow -3 + 3x_5 + 2x_6 + x_7 + \\epsilon\\] <p>In the expressions, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\), is the noise.</p>"},{"location":"api/datasets/synth/Planes2D/#parameters","title":"Parameters","text":"<ul> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Planes2D/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Planes2D/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Planes2D(seed=42)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(list(x.values()), y)\n[-1, -1, 1, 0, -1, -1, -1, 1, -1, 1] -9.07\n[1, -1, -1, -1, -1, -1, 1, 1, -1, 1] -4.25\n[-1, 1, 1, 1, 1, 0, -1, 0, 1, 0] -0.95\n[-1, 1, 0, 0, 0, -1, -1, 0, -1, -1] -6.10\n[1, -1, 0, 0, 1, 0, -1, 1, 0, 1] 1.60\n</code></pre>"},{"location":"api/datasets/synth/Planes2D/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Planes2D/#references","title":"References","text":"<ol> <li> <p>2DPlanes in Lu\u00eds Torgo regression datasets \u21a9</p> </li> <li> <p>Breiman, L., Friedman, J., Stone, C.J. and Olshen, R.A., 1984. Classification and regression trees. CRC press.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/RandomRBF/","title":"RandomRBF","text":"<p>Random Radial Basis Function generator.</p> <p>Produces a radial basis function stream. A number of centroids, having a random central position, a standard deviation, a class label and weight are generated. A new sample is created by choosing one of the centroids at random, taking into account their weights, and offsetting the attributes in a random direction from the centroid's center. The offset length is drawn from a Gaussian distribution. </p> <p>This process will create a normally distributed hypersphere of samples on the surrounds of each centroid.</p>"},{"location":"api/datasets/synth/RandomRBF/#parameters","title":"Parameters","text":"<ul> <li> <p>seed_model ('int | None') \u2013 defaults to <code>None</code></p> <p>Model's random seed to generate centroids.</p> </li> <li> <p>seed_sample ('int | None') \u2013 defaults to <code>None</code></p> <p>Sample's random seed.</p> </li> <li> <p>n_classes ('int') \u2013 defaults to <code>2</code></p> <p>The number of class labels to generate.</p> </li> <li> <p>n_features ('int') \u2013 defaults to <code>10</code></p> <p>The number of numerical features to generate.</p> </li> <li> <p>n_centroids ('int') \u2013 defaults to <code>50</code></p> <p>The number of centroids to generate.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBF/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBF/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt;\n&gt;&gt;&gt; dataset = synth.RandomRBF(seed_model=42, seed_sample=42,\n...                           n_classes=4, n_features=4, n_centroids=20)\n&gt;&gt;&gt;\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{0: 1.0989, 1: 0.3840, 2: 0.7759, 3: 0.6592} 2\n{0: 0.2366, 1: 1.3233, 2: 0.5691, 3: 0.2083} 0\n{0: 1.3540, 1: -0.3306, 2: 0.1683, 3: 0.8865} 0\n{0: 0.2585, 1: -0.2217, 2: 0.4739, 3: 0.6522} 0\n{0: 0.1295, 1: 0.5953, 2: 0.1774, 3: 0.6673} 1\n</code></pre>"},{"location":"api/datasets/synth/RandomRBF/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/RandomRBFDrift/","title":"RandomRBFDrift","text":"<p>Random Radial Basis Function generator with concept drift.</p> <p>This class is an extension from the <code>RandomRBF</code> generator. Concept drift can be introduced in instances of this class. </p> <p>The drift is created by adding a \"speed\" to certain centroids. As the samples are generated each of the moving centroids' centers is changed by an amount determined by its speed.</p>"},{"location":"api/datasets/synth/RandomRBFDrift/#parameters","title":"Parameters","text":"<ul> <li> <p>seed_model ('int | None') \u2013 defaults to <code>None</code></p> <p>Model's random seed to generate centroids.</p> </li> <li> <p>seed_sample ('int | None') \u2013 defaults to <code>None</code></p> <p>Sample's random seed.</p> </li> <li> <p>n_classes ('int') \u2013 defaults to <code>2</code></p> <p>The number of class labels to generate.</p> </li> <li> <p>n_features ('int') \u2013 defaults to <code>10</code></p> <p>The number of numerical features to generate.</p> </li> <li> <p>n_centroids ('int') \u2013 defaults to <code>50</code></p> <p>The number of centroids to generate.</p> </li> <li> <p>change_speed ('float') \u2013 defaults to <code>0.0</code></p> <p>The concept drift speed.</p> </li> <li> <p>n_drift_centroids ('int') \u2013 defaults to <code>50</code></p> <p>The number of centroids that will drift.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBFDrift/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBFDrift/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt;\n&gt;&gt;&gt; dataset = synth.RandomRBFDrift(seed_model=42, seed_sample=42,\n...                                n_classes=4, n_features=4, n_centroids=20,\n...                                change_speed=0.87, n_drift_centroids=10)\n&gt;&gt;&gt;\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{0: 1.0989, 1: 0.3840, 2: 0.7759, 3: 0.6592} 2\n{0: 1.1496, 1: 1.9014, 2: 1.5393, 3: 0.3210} 0\n{0: 0.7146, 1: -0.2414, 2: 0.8933, 3: 1.6633} 0\n{0: 0.3797, 1: -0.1027, 2: 0.8717, 3: 1.1635} 0\n{0: 0.1295, 1: 0.5953, 2: 0.1774, 3: 0.6673} 1\n</code></pre>"},{"location":"api/datasets/synth/RandomRBFDrift/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/RandomTree/","title":"RandomTree","text":"<p>Random Tree generator.</p> <p>This generator is based on 1. The generator creates a random tree by splitting features at random and setting labels at its leaves. </p> <p>The tree structure is composed of node objects, which can be either inner nodes or leaf nodes. The choice comes as a function of the parameters passed to its initializer. </p> <p>Since the concepts are generated and classified according to a tree structure, in theory, it should favor decision tree learners.</p>"},{"location":"api/datasets/synth/RandomTree/#parameters","title":"Parameters","text":"<ul> <li> <p>seed_tree ('int | None') \u2013 defaults to <code>None</code></p> <p>Seed for random generation of tree.</p> </li> <li> <p>seed_sample ('int | None') \u2013 defaults to <code>None</code></p> <p>Seed for random generation of instances.</p> </li> <li> <p>n_classes ('int') \u2013 defaults to <code>2</code></p> <p>The number of classes to generate.</p> </li> <li> <p>n_num_features ('int') \u2013 defaults to <code>5</code></p> <p>The number of numerical features to generate.</p> </li> <li> <p>n_cat_features ('int') \u2013 defaults to <code>5</code></p> <p>The number of categorical features to generate.</p> </li> <li> <p>n_categories_per_feature ('int') \u2013 defaults to <code>5</code></p> <p>The number of values to generate per categorical feature.</p> </li> <li> <p>max_tree_depth ('int') \u2013 defaults to <code>5</code></p> <p>The maximum depth of the tree concept.</p> </li> <li> <p>first_leaf_level ('int') \u2013 defaults to <code>3</code></p> <p>The first level of the tree above <code>max_tree_depth</code> that can have leaves.</p> </li> <li> <p>fraction_leaves_per_level ('float') \u2013 defaults to <code>0.15</code></p> <p>The fraction of leaves per level from <code>first_leaf_level</code> onwards.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomTree/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomTree/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.RandomTree(seed_tree=42, seed_sample=42, n_classes=2,\n...                            n_num_features=2, n_cat_features=2,\n...                            n_categories_per_feature=2, max_tree_depth=6,\n...                            first_leaf_level=3, fraction_leaves_per_level=0.15)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{'x_num_0': 0.6394, 'x_num_1': 0.0250, 'x_cat_0': 1, 'x_cat_1': 0} 0\n{'x_num_0': 0.2232, 'x_num_1': 0.7364, 'x_cat_0': 0, 'x_cat_1': 1} 1\n{'x_num_0': 0.0317, 'x_num_1': 0.0936, 'x_cat_0': 0, 'x_cat_1': 0} 0\n{'x_num_0': 0.5612, 'x_num_1': 0.7160, 'x_cat_0': 1, 'x_cat_1': 0} 0\n{'x_num_0': 0.4492, 'x_num_1': 0.2781, 'x_cat_0': 0, 'x_cat_1': 0} 0\n</code></pre>"},{"location":"api/datasets/synth/RandomTree/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/RandomTree/#references","title":"References","text":"<ol> <li> <p>Domingos, Pedro, and Geoff Hulten. \"Mining high-speed data streams.\"   In Proceedings of the sixth ACM SIGKDD international conference on   Knowledge discovery and data mining, pp. 71-80. 2000.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/SEA/","title":"SEA","text":"<p>SEA synthetic dataset.</p> <p>Implementation of the data stream with abrupt drift described in 1. Each observation is composed of 3 features. Only the first two features are relevant. The target is binary, and is positive if the sum of the features exceeds a certain threshold. There are 4 thresholds to choose from. Concept drift can be introduced by switching the threshold anytime during the stream. </p> <ul> <li> <p>Variant 0: <code>True</code> if \\(att1 + att2 &gt; 8\\) </p> </li> <li> <p>Variant 1: <code>True</code> if \\(att1 + att2 &gt; 9\\) </p> </li> <li> <p>Variant 2: <code>True</code> if \\(att1 + att2 &gt; 7\\) </p> </li> <li> <p>Variant 3: <code>True</code> if \\(att1 + att2 &gt; 9.5\\)</p> </li> </ul>"},{"location":"api/datasets/synth/SEA/#parameters","title":"Parameters","text":"<ul> <li> <p>variant \u2013 defaults to <code>0</code></p> <p>Determines the classification function to use. Possible choices are 0, 1, 2, 3.</p> </li> <li> <p>noise \u2013 defaults to <code>0.0</code></p> <p>Determines the amount of observations for which the target sign will be flipped.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/SEA/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/SEA/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.SEA(variant=0, seed=42)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{0: 6.39426, 1: 0.25010, 2: 2.75029} False\n{0: 2.23210, 1: 7.36471, 2: 6.76699} True\n{0: 8.92179, 1: 0.86938, 2: 4.21921} True\n{0: 0.29797, 1: 2.18637, 2: 5.05355} False\n{0: 0.26535, 1: 1.98837, 2: 6.49884} False\n</code></pre>"},{"location":"api/datasets/synth/SEA/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/SEA/#references","title":"References","text":"<ol> <li> <p>A Streaming Ensemble Algorithm (SEA) for Large-Scale Classification \u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/STAGGER/","title":"STAGGER","text":"<p>STAGGER concepts stream generator.</p> <p>This generator is an implementation of the dara stream with abrupt concept drift, as described in 1. </p> <p>The STAGGER concepts are boolean functions <code>f</code> with three features describing objects: size (small, medium and large), shape (circle, square and triangle) and colour (red, blue and green). </p> <p><code>f</code> options: </p> <ol> <li> <p><code>True</code> if the size is small and the color is red. </p> </li> <li> <p><code>True</code> if the color is green or the shape is a circle. </p> </li> <li> <p><code>True</code> if the size is medium or large </p> </li> </ol> <p>Concept drift can be introduced by changing the classification function. This can be done manually or using <code>datasets.synth.ConceptDriftStream</code>. </p> <p>One important feature is the possibility to balance classes, which means the class distribution will tend to a uniform one.</p>"},{"location":"api/datasets/synth/STAGGER/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function ('int') \u2013 defaults to <code>0</code></p> <p>Classification functions to use. From 0 to 2.</p> </li> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes ('bool') \u2013 defaults to <code>False</code></p> <p>Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution.</p> </li> </ul>"},{"location":"api/datasets/synth/STAGGER/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/STAGGER/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.STAGGER(classification_function = 2, seed = 112,\n...                      balance_classes = False)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{'size': 1, 'color': 2, 'shape': 2} 1\n{'size': 2, 'color': 1, 'shape': 2} 1\n{'size': 1, 'color': 1, 'shape': 2} 1\n{'size': 0, 'color': 1, 'shape': 0} 0\n{'size': 2, 'color': 1, 'shape': 0} 1\n</code></pre>"},{"location":"api/datasets/synth/STAGGER/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function at random.</p>   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/STAGGER/#notes","title":"Notes","text":"<p>The sample generation works as follows: The 3 attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced, if this option is set by the user.</p>"},{"location":"api/datasets/synth/STAGGER/#references","title":"References","text":"<ol> <li> <p>Schlimmer, J. C., &amp; Granger, R. H. (1986). Incremental learning   from noisy data. Machine learning, 1(3), 317-354.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Sine/","title":"Sine","text":"<p>Sine generator.</p> <p>This generator is an implementation of the dara stream with abrupt concept drift, as described in Gama, Joao, et al. 1. </p> <p>It generates up to 4 relevant numerical features, that vary from 0 to 1, where only 2 of them are relevant to the classification task and the other 2 are optionally added by as noise. A classification function is chosen among four options: </p> <ol> <li> <p><code>SINE1</code>. Abrupt concept drift, noise-free examples. It has two relevant    attributes. Each attributes has values uniformly distributed in [0, 1].    In the first context all points below the curve \\(y = sin(x)\\) are    classified as positive. </p> </li> <li> <p><code>Reversed SINE1</code>. The reversed classification of <code>SINE1</code>. </p> </li> <li> <p><code>SINE2</code>. The same two relevant attributes. The classification function    is \\(y &lt; 0.5 + 0.3 sin(3 \\pi  x)\\). </p> </li> <li> <p><code>Reversed SINE2</code>. The reversed classification of <code>SINE2</code>. </p> </li> </ol> <p>Concept drift can be introduced by changing the classification function. This can be done manually or using <code>ConceptDriftStream</code>. </p> <p>Two important features are the possibility to balance classes, which means the class distribution will tend to a uniform one, and the possibility to add noise, which will, add two non relevant attributes.</p>"},{"location":"api/datasets/synth/Sine/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function ('int') \u2013 defaults to <code>0</code></p> <p>Classification functions to use. From 0 to 3.</p> </li> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes ('bool') \u2013 defaults to <code>False</code></p> <p>Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution.</p> </li> <li> <p>has_noise ('bool') \u2013 defaults to <code>False</code></p> <p>Adds 2 non relevant features to the stream.</p> </li> </ul>"},{"location":"api/datasets/synth/Sine/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Sine/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Sine(classification_function = 2, seed = 112,\n...                      balance_classes = False, has_noise = True)\n\n&gt;&gt;&gt; for x, y in dataset.take(5):\n...     print(x, y)\n{0: 0.4812, 1: 0.6660, 2: 0.6198, 3: 0.6994} 1\n{0: 0.9022, 1: 0.7518, 2: 0.1625, 3: 0.2209} 0\n{0: 0.4547, 1: 0.3901, 2: 0.9629, 3: 0.7287} 0\n{0: 0.4683, 1: 0.3515, 2: 0.2273, 3: 0.6027} 0\n{0: 0.9238, 1: 0.1673, 2: 0.4522, 3: 0.3447} 0\n</code></pre>"},{"location":"api/datasets/synth/Sine/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function at random.</p>   take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Sine/#notes","title":"Notes","text":"<p>The sample generation works as follows: The two attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced and noise is added, if these options are set by the user.</p> <p>The generated sample will have 2 relevant features, and an additional two noise features if <code>has_noise</code> is set.</p>"},{"location":"api/datasets/synth/Sine/#references","title":"References","text":"<ol> <li> <p>Gama, Joao, et al.'s 'Learning with drift detection.'   Advances in artificial intelligence-SBIA 2004.   Springer Berlin Heidelberg, 2004. 286-295.\"\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Waveform/","title":"Waveform","text":"<p>Waveform stream generator.</p> <p>Generates samples with 21 numeric features and 3 classes, based on a random differentiation of some base waveforms. Supports noise addition, in this case the samples will have 40 features.</p>"},{"location":"api/datasets/synth/Waveform/#parameters","title":"Parameters","text":"<ul> <li> <p>seed ('int | None') \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>has_noise ('bool') \u2013 defaults to <code>False</code></p> <p>Adds 19 unrelated features to the stream.</p> </li> </ul>"},{"location":"api/datasets/synth/Waveform/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Waveform/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Waveform(seed=42, has_noise=True)\n\n&gt;&gt;&gt; for x, y in dataset:\n...     break\n\n&gt;&gt;&gt; x\n{0: -0.0397, 1: -0.7484, 2: 0.2974, 3: 0.3574, 4: -0.0735, 5: -0.3647, 6: 1.5631,     7: 2.5291, 8: 4.1599, 9: 4.9587, 10: 4.52587, 11: 4.0097, 12: 3.6705, 13: 1.7033,     14: 1.4898, 15: 1.9743, 16: 0.0898, 17: 2.319, 18: 0.2552, 19: -0.4775, 20: -0.71339,     21: 0.3770, 22: 0.3671, 23: 1.6579, 24: 0.7828, 25: 0.5855, 26: -0.5807, 27: 0.7112,     28: -0.0271, 29: 0.2968, 30: -0.4997, 31: 0.1302, 32: 0.3578, 33: -0.1900, 34: -0.3771,     35: 1.3560, 36: 0.7124, 37: -0.6245, 38: 0.1346, 39: 0.3550}\n\n&gt;&gt;&gt; y\n2\n</code></pre>"},{"location":"api/datasets/synth/Waveform/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     (int)    </li> </ul>"},{"location":"api/datasets/synth/Waveform/#notes","title":"Notes","text":"<p>An instance is generated based on the parameters passed. The generator will randomly choose one of the hard coded waveforms, as well as random multipliers. For each feature, the actual value generated will be a a combination of the hard coded functions, with the multipliers and a random value.</p> <p>If noise is added then the features 21 to 40 will be replaced with a random normal value.</p>"},{"location":"api/drift/ADWIN/","title":"ADWIN","text":"<p>Adaptive Windowing method for concept drift detection.</p> <p>ADWIN (ADaptive WINdowing) is a popular drift detection method with mathematical guarantees. ADWIN efficiently keeps a variable-length window of recent items; such that it holds that there has no been change in the data distribution. This window is further divided into two sub-windows \\((W_0, W_1)\\) used to determine if a change has happened. ADWIN compares the average of \\(W_0\\) and \\(W_1\\) to confirm that they correspond to the same distribution. Concept drift is detected if the distribution equality no longer holds. Upon detecting a drift, \\(W_0\\) is replaced by \\(W_1\\) and a new \\(W_1\\) is initialized. ADWIN uses a significance value \\(\\delta=\\in(0,1)\\) to determine if the two sub-windows correspond to the same distribution.</p>"},{"location":"api/drift/ADWIN/#parameters","title":"Parameters","text":"<ul> <li> <p>delta \u2013 defaults to <code>0.002</code></p> <p>Significance value.</p> </li> <li> <p>clock \u2013 defaults to <code>32</code></p> <p>How often ADWIN should check for change. 1 means every new data point, default is 32. Higher values speed up processing, but may also lead to increased delay in change detection.</p> </li> <li> <p>max_buckets \u2013 defaults to <code>5</code></p> <p>The maximum number of buckets of each size that ADWIN should keep before merging buckets (default is 5).</p> </li> <li> <p>min_window_length \u2013 defaults to <code>5</code></p> <p>The minimum length of each subwindow (default is 5). Lower values may decrease delay in change detection but may also lead to more false positives.</p> </li> <li> <p>grace_period \u2013 defaults to <code>10</code></p> <p>ADWIN does not perform any change detection until at least this many data points have arrived (default is 10).</p> </li> </ul>"},{"location":"api/drift/ADWIN/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>estimation</p> <p>Estimate of mean value in the window.</p> </li> <li> <p>n_detections</p> </li> <li> <p>total</p> </li> <li> <p>variance</p> </li> <li> <p>width</p> <p>Window size</p> </li> </ul>"},{"location":"api/drift/ADWIN/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(12345)\n&gt;&gt;&gt; adwin = drift.ADWIN()\n\n&gt;&gt;&gt; # Simulate a data stream composed by two data distributions\n&gt;&gt;&gt; data_stream = rng.choices([0, 1], k=1000) + rng.choices(range(4, 8), k=1000)\n\n&gt;&gt;&gt; # Update drift detector and verify if change is detected\n&gt;&gt;&gt; for i, val in enumerate(data_stream):\n...     _ = adwin.update(val)\n...     if adwin.drift_detected:\n...         print(f\"Change detected at index {i}, input value: {val}\")\nChange detected at index 1023, input value: 4\n</code></pre>"},{"location":"api/drift/ADWIN/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Apart from adding the element value to the window, by inserting it in the correct bucket, it will also update the relevant statistics, in this case the total sum of all values, the window width and the total variance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/ADWIN/#references","title":"References","text":"<ol> <li> <p>Albert Bifet and Ricard Gavalda. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/DDM/","title":"DDM","text":"<p>Drift Detection Method.</p> <p>DDM (Drift Detection Method) is a concept change detection method based on the PAC learning model premise, that the learner's error rate will decrease as the number of analysed samples increase, as long as the data distribution is stationary. </p> <p>If the algorithm detects an increase in the error rate, that surpasses a calculated threshold, either change is detected or the algorithm will warn the user that change may occur in the near future, which is called the warning zone. </p> <p>The detection threshold is calculated in function of two statistics, obtained when \\((p_i + s_i)\\) is minimum: </p> <ul> <li> <p>\\(p_{min}\\): The minimum recorded error rate. </p> </li> <li> <p>\\(s_{min}\\): The minimum recorded standard deviation. </p> </li> </ul> <p>At instant \\(i\\), the detection algorithm uses: </p> <ul> <li> <p>\\(p_i\\): The error rate at instant \\(i\\). </p> </li> <li> <p>\\(s_i\\): The standard deviation at instant \\(i\\). </p> </li> </ul> <p>The conditions for entering the warning zone and detecting change are as follows [see implementation note below]: </p> <ul> <li> <p>if \\(p_i + s_i \\geq p_{min} + w_l * s_{min}\\) -&gt; Warning zone </p> </li> <li> <p>if \\(p_i + s_i \\geq p_{min} + d_l * s_{min}\\) -&gt; Change detected </p> </li> </ul> <p>In the above expressions, \\(w_l\\) and \\(d_l\\) represent, respectively, the warning and drift thresholds. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\) </p> </li> <li> <p>1: Error, \\(y \\neq y'\\)</p> </li> </ul>"},{"location":"api/drift/DDM/#parameters","title":"Parameters","text":"<ul> <li> <p>warm_start (int) \u2013 defaults to <code>30</code></p> <p>The minimum required number of analyzed samples so change can be detected. Warm start parameter for the drift detector.</p> </li> <li> <p>warning_threshold (float) \u2013 defaults to <code>2.0</code></p> <p>Threshold to decide if the detector is in a warning zone. The default value gives 95\\% of confidence level to the warning assessment.</p> </li> <li> <p>drift_threshold (float) \u2013 defaults to <code>3.0</code></p> <p>Threshold to decide if a drift was detected. The default value gives a 99\\% of confidence level to the drift assessment.</p> </li> </ul>"},{"location":"api/drift/DDM/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/DDM/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(42)\n&gt;&gt;&gt; ddm = drift.DDM()\n\n&gt;&gt;&gt; # Simulate a data stream where the first 1000 instances come from a uniform distribution\n&gt;&gt;&gt; # of 1's and 0's\n&gt;&gt;&gt; data_stream = rng.choices([0, 1], k=1000)\n&gt;&gt;&gt; # Increase the probability of 1's appearing in the next 1000 instances\n&gt;&gt;&gt; data_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\n&gt;&gt;&gt; print_warning = True\n&gt;&gt;&gt; # Update drift detector and verify if change is detected\n&gt;&gt;&gt; for i, x in enumerate(data_stream):\n...     _ = ddm.update(x)\n...     if ddm.warning_detected and print_warning:\n...         print(f\"Warning detected at index {i}\")\n...         print_warning = False\n...     if ddm.drift_detected:\n...         print(f\"Change detected at index {i}\")\n...         print_warning = True\nWarning detected at index 1084\nChange detected at index 1334\nWarning detected at index 1492\n</code></pre>"},{"location":"api/drift/DDM/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/DDM/#references","title":"References","text":"<ol> <li> <p>Jo\u00e3o Gama, Pedro Medas, Gladys Castillo, Pedro Pereira Rodrigues: Learning with Drift Detection. SBIA 2004: 286-295\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/DriftRetrainingClassifier/","title":"DriftRetrainingClassifier","text":"<p>Drift retraining classifier.</p> <p>This classifier is a wrapper for any classifier. It monitors the incoming data for concept drifts and warnings in the model's accurary. In case a warning is detected, a background model starts to train. If a drift is detected, the model will be replaced by the background model, and the background model will be reset.</p>"},{"location":"api/drift/DriftRetrainingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> <p>The classifier and background classifier class.</p> </li> <li> <p>drift_detector (base.DriftAndWarningDetector) \u2013 defaults to <code>None</code></p> <p>Algorithm to track warnings and concept drifts. Attention! The drift_detector must have a warning tracker.</p> </li> </ul>"},{"location":"api/drift/DriftRetrainingClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import drift\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = datasets.Elec2().take(3000)\n\n&gt;&gt;&gt; model = drift.DriftRetrainingClassifier(\n...     model=tree.HoeffdingTreeClassifier(),\n...     drift_detector= drift.DDM()\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 86.40%\n</code></pre>"},{"location":"api/drift/DriftRetrainingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/drift/EDDM/","title":"EDDM","text":"<p>Early Drift Detection Method.</p> <p>EDDM (Early Drift Detection Method) aims to improve the detection rate of gradual concept drift in DDM, while keeping a good performance against abrupt concept drift. </p> <p>This method works by keeping track of the average distance between two errors instead of only the error rate. For this, it is necessary to keep track of the running average distance and the running standard deviation, as well as the maximum distance and the maximum standard deviation. </p> <p>The algorithm works similarly to the DDM algorithm, by keeping track of statistics only. It works with the running average distance (\\(p_i'\\)) and the running standard deviation (\\(s_i'\\)), as well as \\(p'_{max}\\) and \\(s'_{max}\\), which are the values of \\(p_i'\\) and \\(s_i'\\) when \\((p_i' + 2 * s_i')\\) reaches its maximum. </p> <p>Like DDM, there are two threshold values that define the borderline between no change, warning zone, and drift detected. These are as follows: </p> <ul> <li> <p>if \\((p_i' + 2 * s_i') / (p'_{max} + 2 * s'_{max}) &lt; \\alpha\\) -&gt; Warning zone </p> </li> <li> <p>if \\((p_i' + 2 * s_i') / (p'_{max} + 2 * s'_{max}) &lt; \\beta\\) -&gt; Change detected </p> </li> </ul> <p>\\(\\alpha\\) and \\(\\beta\\) are set to 0.95 and 0.9, respectively. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\) </p> </li> <li> <p>1: Error, \\(y \\\\neq y'\\)</p> </li> </ul>"},{"location":"api/drift/EDDM/#parameters","title":"Parameters","text":"<ul> <li> <p>warm_start (int) \u2013 defaults to <code>30</code></p> <p>The minimum required number of monitored errors/failures so change can be detected. Warm start parameter for the drift detector.</p> </li> <li> <p>alpha (float) \u2013 defaults to <code>0.95</code></p> <p>Threshold for triggering a warning. Must be between 0 and 1. The smaller the value, the more conservative the detector becomes.</p> </li> <li> <p>beta (float) \u2013 defaults to <code>0.9</code></p> <p>Threshold for triggering a drift. Must be between 0 and 1. The smaller the value, the more conservative the detector becomes.</p> </li> </ul>"},{"location":"api/drift/EDDM/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/EDDM/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(42)\n&gt;&gt;&gt; # Change the default hyperparameters to avoid too many false positives\n&gt;&gt;&gt; # in this example\n&gt;&gt;&gt; eddm = drift.EDDM(alpha=0.8, beta=0.75)\n\n&gt;&gt;&gt; # Simulate a data stream where the first 1000 instances come from a uniform distribution\n&gt;&gt;&gt; # of 1's and 0's\n&gt;&gt;&gt; data_stream = rng.choices([0, 1], k=1000)\n&gt;&gt;&gt; # Increase the probability of 1's appearing in the next 1000 instances\n&gt;&gt;&gt; data_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\n&gt;&gt;&gt; print_warning = True\n&gt;&gt;&gt; # Update drift detector and verify if change is detected\n&gt;&gt;&gt; for i, x in enumerate(data_stream):\n...     _ = eddm.update(x)\n...     if eddm.warning_detected and print_warning:\n...         print(f\"Warning detected at index {i}\")\n...         print_warning = False\n...     if eddm.drift_detected:\n...         print(f\"Change detected at index {i}\")\n...         print_warning = True\nWarning detected at index 1059\nChange detected at index 1278\n</code></pre>"},{"location":"api/drift/EDDM/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/EDDM/#references","title":"References","text":"<ol> <li> <p>Early Drift Detection Method. Manuel Baena-Garcia, Jose Del Campo-Avila, Ra\u00fal Fidalgo, Albert Bifet, Ricard Gavalda, Rafael Morales-Bueno. In Fourth International Workshop on Knowledge Discovery from Data Streams, 2006.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/HDDM-A/","title":"HDDM_A","text":"<p>Drift Detection Method based on Hoeffding's bounds with moving average-test.</p> <p>HDDM_A is a drift detection method based on the Hoeffding's inequality which uses the input average as estimator. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\) </p> </li> <li> <p>1: Error, \\(y \\neq y'\\) </p> </li> </ul> <p>Implementation based on MOA.</p>"},{"location":"api/drift/HDDM-A/#parameters","title":"Parameters","text":"<ul> <li> <p>drift_confidence \u2013 defaults to <code>0.001</code></p> <p>Confidence to the drift</p> </li> <li> <p>warning_confidence \u2013 defaults to <code>0.005</code></p> <p>Confidence to the warning</p> </li> <li> <p>two_sided_test \u2013 defaults to <code>False</code></p> <p>If <code>True</code>, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).</p> </li> </ul>"},{"location":"api/drift/HDDM-A/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/HDDM-A/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(42)\n&gt;&gt;&gt; hddm_a = drift.HDDM_A()\n\n&gt;&gt;&gt; # Simulate a data stream where the first 1000 instances come from a uniform distribution\n&gt;&gt;&gt; # of 1's and 0's\n&gt;&gt;&gt; data_stream = rng.choices([0, 1], k=1000)\n&gt;&gt;&gt; # Increase the probability of 1's appearing in the next 1000 instances\n&gt;&gt;&gt; data_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\n&gt;&gt;&gt; print_warning = True\n&gt;&gt;&gt; # Update drift detector and verify if change is detected\n&gt;&gt;&gt; for i, x in enumerate(data_stream):\n...     _ = hddm_a.update(x)\n...     if hddm_a.warning_detected and print_warning:\n...         print(f\"Warning detected at index {i}\")\n...         print_warning = False\n...     if hddm_a.drift_detected:\n...         print(f\"Change detected at index {i}\")\n...         print_warning = True\nWarning detected at index 451\nChange detected at index 1206\n</code></pre>"},{"location":"api/drift/HDDM-A/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/HDDM-A/#references","title":"References","text":"<ol> <li> <p>Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding's bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823.\u00a0\u21a9</p> </li> <li> <p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/HDDM-W/","title":"HDDM_W","text":"<p>Drift Detection Method based on Hoeffding's bounds with moving weighted average-test.</p> <p>HDDM_W is an online drift detection method based on McDiarmid's bounds. HDDM_W uses the Exponentially Weighted Moving Average (EWMA) statistic as estimator. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\) </p> </li> <li> <p>1: Error, \\(y \\neq y'\\) </p> </li> </ul> <p>Implementation based on MOA.</p>"},{"location":"api/drift/HDDM-W/#parameters","title":"Parameters","text":"<ul> <li> <p>drift_confidence \u2013 defaults to <code>0.001</code></p> <p>Confidence to the drift</p> </li> <li> <p>warning_confidence \u2013 defaults to <code>0.005</code></p> <p>Confidence to the warning</p> </li> <li> <p>lambda_val \u2013 defaults to <code>0.05</code></p> <p>The weight given to recent data. Smaller values mean less weight given to recent data.</p> </li> <li> <p>two_sided_test \u2013 defaults to <code>False</code></p> <p>If True, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).</p> </li> </ul>"},{"location":"api/drift/HDDM-W/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/HDDM-W/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(42)\n&gt;&gt;&gt; hddm_w = drift.HDDM_W()\n\n&gt;&gt;&gt; # Simulate a data stream where the first 1000 instances come from a uniform distribution\n&gt;&gt;&gt; # of 1's and 0's\n&gt;&gt;&gt; data_stream = rng.choices([0, 1], k=1000)\n&gt;&gt;&gt; # Increase the probability of 1's appearing in the next 1000 instances\n&gt;&gt;&gt; data_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\n&gt;&gt;&gt; print_warning = True\n&gt;&gt;&gt; # Update drift detector and verify if change is detected\n&gt;&gt;&gt; for i, x in enumerate(data_stream):\n...     _ = hddm_w.update(x)\n...     if hddm_w.warning_detected and print_warning:\n...         print(f\"Warning detected at index {i}\")\n...         print_warning = False\n...     if hddm_w.drift_detected:\n...         print(f\"Change detected at index {i}\")\n...         print_warning = True\nWarning detected at index 451\nChange detected at index 1077\n</code></pre>"},{"location":"api/drift/HDDM-W/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/HDDM-W/#references","title":"References","text":"<ol> <li> <p>Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift  detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data  Engineering, 2014, 27(3): 810-823.\u00a0\u21a9</p> </li> <li> <p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis;  Journal of Machine Learning Research 11: 1601-1604, 2010.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/KSWIN/","title":"KSWIN","text":"<p>Kolmogorov-Smirnov Windowing method for concept drift detection.</p>"},{"location":"api/drift/KSWIN/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha (float) \u2013 defaults to <code>0.005</code></p> <p>Probability for the test statistic of the Kolmogorov-Smirnov-Test. The alpha parameter is very sensitive, therefore should be set below 0.01.</p> </li> <li> <p>window_size (int) \u2013 defaults to <code>100</code></p> <p>Size of the sliding window.</p> </li> <li> <p>stat_size (int) \u2013 defaults to <code>30</code></p> <p>Size of the statistic window.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>window (Iterable) \u2013 defaults to <code>None</code></p> <p>Already collected data to avoid cold start.</p> </li> </ul>"},{"location":"api/drift/KSWIN/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/KSWIN/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(12345)\n&gt;&gt;&gt; kswin = drift.KSWIN(alpha=0.0001, seed=42)\n\n&gt;&gt;&gt; # Simulate a data stream composed by two data distributions\n&gt;&gt;&gt; data_stream = rng.choices([0, 1], k=1000) + rng.choices(range(4, 8), k=1000)\n\n&gt;&gt;&gt; # Update drift detector and verify if change is detected\n&gt;&gt;&gt; for i, val in enumerate(data_stream):\n...     _ = kswin.update(val)\n...     if kswin.drift_detected:\n...         print(f\"Change detected at index {i}, input value: {val}\")\nChange detected at index 1016, input value: 6\n</code></pre>"},{"location":"api/drift/KSWIN/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Adds an element on top of the sliding window and removes the oldest one from the window. Afterwards, the KS-test is performed.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/KSWIN/#notes","title":"Notes","text":"<p>KSWIN (Kolmogorov-Smirnov Windowing) is a concept change detection method based on the Kolmogorov-Smirnov (KS) statistical test. KS-test is a statistical test with no assumption of underlying data distribution. KSWIN can monitor data or performance distributions. Note that the detector accepts one dimensional input as array.</p> <p>KSWIN maintains a sliding window \\(\\Psi\\) of fixed size \\(n\\) (window_size). The last \\(r\\) (stat_size) samples of \\(\\Psi\\) are assumed to represent the last concept considered as \\(R\\). From the first \\(n-r\\) samples of \\(\\Psi\\), \\(r\\) samples are uniformly drawn, representing an approximated last concept \\(W\\).</p> <p>The KS-test is performed on the windows \\(R\\) and \\(W\\) of the same size. KS -test compares the distance of the empirical cumulative data distribution \\(dist(R,W)\\).</p> <p>A concept drift is detected by KSWIN if:</p> \\[ dist(R,W) &gt; \\sqrt{-\\frac{ln\\alpha}{r}} \\] <p>The difference in empirical data distributions between the windows \\(R\\) and \\(W\\) is too large since \\(R\\) and \\(W\\) come from the same distribution.</p>"},{"location":"api/drift/KSWIN/#references","title":"References","text":"<ol> <li> <p>Christoph Raab, Moritz Heusinger, Frank-Michael Schleif, Reactive Soft Prototype Computing for Concept Drift Streams, Neurocomputing, 2020,\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/PageHinkley/","title":"PageHinkley","text":"<p>Page-Hinkley method for concept drift detection.</p> <p>This change detection method works by computing the observed values and their mean up to the current moment. Page-Hinkley does not signal warning zones, only change detections. </p> <p>This detector implements the CUSUM control chart for detecting changes. This implementation also supports the two-sided Page-Hinkley test to detect increasing and decreasing changes in the mean of the input values.</p>"},{"location":"api/drift/PageHinkley/#parameters","title":"Parameters","text":"<ul> <li> <p>min_instances (int) \u2013 defaults to <code>30</code></p> <p>The minimum number of instances before detecting change.</p> </li> <li> <p>delta (float) \u2013 defaults to <code>0.005</code></p> <p>The delta factor for the Page-Hinkley test.</p> </li> <li> <p>threshold (float) \u2013 defaults to <code>50.0</code></p> <p>The change detection threshold (lambda).</p> </li> <li> <p>alpha (float) \u2013 defaults to <code>0.9999</code></p> <p>The forgetting factor, used to weight the observed value and the mean.</p> </li> <li> <p>mode (str) \u2013 defaults to <code>both</code></p> <p>Whether to consider increases (\"up\"), decreases (\"down\") or both (\"both\") when monitoring the fading mean.</p> </li> </ul>"},{"location":"api/drift/PageHinkley/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/PageHinkley/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(12345)\n&gt;&gt;&gt; ph = drift.PageHinkley()\n\n&gt;&gt;&gt; # Simulate a data stream composed by two data distributions\n&gt;&gt;&gt; data_stream = rng.choices([0, 1], k=1000) + rng.choices(range(4, 8), k=1000)\n\n&gt;&gt;&gt; # Update drift detector and verify if change is detected\n&gt;&gt;&gt; for i, val in enumerate(data_stream):\n...     _ = ph.update(val)\n...     if ph.drift_detected:\n...         print(f\"Change detected at index {i}, input value: {val}\")\nChange detected at index 1006, input value: 5\n</code></pre>"},{"location":"api/drift/PageHinkley/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/PageHinkley/#references","title":"References","text":"<ol> <li> <p>E. S. Page. 1954. Continuous Inspection Schemes. Biometrika 41, 1/2 (1954), 100-115.\u00a0\u21a9</p> </li> <li> <p>Sebasti\u00e3o, R., &amp; Fernandes, J. M. (2017, June). Supporting the Page-Hinkley test with empirical mode decomposition for change detection. In International Symposium on Methodologies for Intelligent Systems (pp. 492-498). Springer, Cham.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/PeriodicTrigger/","title":"PeriodicTrigger","text":"<p>Generate pseudo drift detection signals.</p> <p>There are two approaches1: </p> <ul> <li><code>fixed</code> where the drift signal is generated every <code>t_0</code> samples. - <code>random</code> corresponds to a pseudo-random drift detection strategy.</li> </ul>"},{"location":"api/drift/PeriodicTrigger/#parameters","title":"Parameters","text":"<ul> <li> <p>trigger_method (str) \u2013 defaults to <code>fixed</code></p> <p>The trigger method to use. * <code>fixed</code> * <code>random</code></p> </li> <li> <p>t_0 (int) \u2013 defaults to <code>300</code></p> <p>Reference point to define triggers.</p> </li> <li> <p>w (int) \u2013 defaults to <code>0</code></p> <p>Auxiliary parameter whose purpose is twofold: - if <code>trigger_method=\"fixed\"</code>, the periodic drift signals will only start after an initial warm-up period randomly defined between <code>[0, w]</code>. Useful to avoid that all ensemble members are reset at the same time when periodic triggers are used as the adaptation strategy. - if <code>trigger_method=\"random\"</code>, <code>w</code> defines the probability bounds of triggering a drift. The chance of triggering a drift is \\(0.5\\) after observing <code>t_0</code> instances and becomes \\(1\\) after monitoring <code>t_0 + w / 2</code> instances. A sigmoid function is used to produce values between <code>[0, 1]</code> that are used as the reset probabilities.</p> </li> <li> <p>dynamic_cloning (bool) \u2013 defaults to <code>False</code></p> <p>Whether to change the <code>seed</code> and <code>w</code> values each time <code>clone()</code> is called.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/drift/PeriodicTrigger/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/PeriodicTrigger/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import drift\n\n&gt;&gt;&gt; rng = random.Random(42)\n</code></pre> <p>The observed values will not affect the periodic triggers.</p> <pre><code>&gt;&gt;&gt; data = [rng.gauss(0, 1) for _ in range(1000)]\n</code></pre> <p>Let's start with the fixed drift signals:</p> <pre><code>&gt;&gt;&gt; ptrigger = PeriodicTrigger(t_0=500, seed=42)\n&gt;&gt;&gt; for i, v in enumerate(data):\n...     _ = ptrigger.update(v)\n...     if ptrigger.drift_detected:\n...         print(f\"Drift detected at instance {i}.\")\nDrift detected at instance 499.\nDrift detected at instance 999.\n</code></pre> <p>Now, the random drift signals:</p> <pre><code>&gt;&gt;&gt; rtrigger = PeriodicTrigger(\n...     trigger_method=\"random\",\n...     t_0=500,\n...     w=100,\n...     dynamic_cloning=True,\n...     seed=42\n... )\n&gt;&gt;&gt; for i, v in enumerate(data):\n...     _ = rtrigger.update(v)\n...     if rtrigger.drift_detected:\n...         print(f\"Drift detected at instance {i}.\")\nDrift detected at instance 368.\nDrift detected at instance 817.\n</code></pre> <p>Remember to set a w &gt; 0 value if random triggers are used:</p> <pre><code>&gt;&gt;&gt; try:\n...     PeriodicTrigger(trigger_method=\"random\")\n... except ValueError as ve:\n...     print(ve)\nThe 'w' value must be greater than zero when 'trigger_method' is 'random'.\n</code></pre> <p>Since we set <code>dynamic_cloning</code> to <code>True</code>, a clone of the periodic trigger will have its internal paramenters changed:</p> <pre><code>&gt;&gt;&gt; rtrigger = rtrigger.clone()\n&gt;&gt;&gt; for i, v in enumerate(data):\n...     _ = rtrigger.update(v)\n...     if rtrigger.drift_detected:\n...         print(f\"Drift detected at instance {i}.\")\nDrift detected at instance 429.\nDrift detected at instance 728.\n</code></pre>"},{"location":"api/drift/PeriodicTrigger/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul> <p>Returns</p> <p>DriftDetector:     self</p>"},{"location":"api/drift/PeriodicTrigger/#notes","title":"Notes","text":"<p>When used in ensembles, a naive implementation of periodic drift signals would make all ensemble members reset at the same time. To avoid that, the <code>dynamic_cloning</code> parameter can be set to <code>True</code>. In this case, every time the <code>clone</code> method of this detector is called in an ensemble a new <code>seed</code> is defined. If <code>dynamic_cloning=True</code> and <code>trigger_method=\"fixed\"</code>, a new <code>w</code> between <code>[0, t_0]</code> will also be created for the new cloned instance.</p>"},{"location":"api/drift/PeriodicTrigger/#references","title":"References","text":"<ol> <li> <p>Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini, Bernhard Pfahringer, and Albert Bifet. On Ensemble Techniques for Data Stream Regression. IJCNN'20. International Joint Conference on Neural Networks. 2020.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/dummy/NoChangeClassifier/","title":"NoChangeClassifier","text":"<p>Dummy classifier which returns the last class seen.</p> <p>The predict_one method will output the last class seen whilst predict_proba_one will return 1 for the last class seen and 0 for the others.</p>"},{"location":"api/dummy/NoChangeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>last_class</p> <p>The last class seen.</p> </li> <li> <p>classes</p> <p>The set of classes seen.</p> </li> </ul>"},{"location":"api/dummy/NoChangeClassifier/#examples","title":"Examples","text":"<p>Taken from example 2.1 from this page.</p> <pre><code>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; from river import dummy\n\n&gt;&gt;&gt; sentences = [\n...     ('glad happy glad', '+'),\n...     ('glad glad joyful', '+'),\n...     ('glad pleasant', '+'),\n...     ('miserable sad glad', '\u2212')\n... ]\n\n&gt;&gt;&gt; model = dummy.NoChangeClassifier()\n\n&gt;&gt;&gt; for sentence, label in sentences:\n...     model = model.learn_one(sentence, label)\n\n&gt;&gt;&gt; new_sentence = 'glad sad miserable pleasant glad'\n&gt;&gt;&gt; model.predict_one(new_sentence)\n'\u2212'\n\n&gt;&gt;&gt; pprint.pprint(model.predict_proba_one(new_sentence))\n{'+': 0, '\u2212': 1}\n</code></pre>"},{"location":"api/dummy/NoChangeClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/dummy/PriorClassifier/","title":"PriorClassifier","text":"<p>Dummy classifier which uses the prior distribution.</p> <p>The <code>predict_one</code> method will output the most common class whilst <code>predict_proba_one</code> will return the normalized class counts.</p>"},{"location":"api/dummy/PriorClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>counts (collections.Counter)</p> <p>Class counts.</p> </li> <li> <p>n (int)</p> <p>Total number of seen instances.</p> </li> </ul>"},{"location":"api/dummy/PriorClassifier/#examples","title":"Examples","text":"<p>Taken from example 2.1 from this page</p> <pre><code>&gt;&gt;&gt; from river import dummy\n\n&gt;&gt;&gt; sentences = [\n...     ('glad happy glad', '+'),\n...     ('glad glad joyful', '+'),\n...     ('glad pleasant', '+'),\n...     ('miserable sad glad', '\u2212')\n... ]\n\n&gt;&gt;&gt; model = dummy.PriorClassifier()\n\n&gt;&gt;&gt; for sentence, label in sentences:\n...     model = model.learn_one(sentence, label)\n\n&gt;&gt;&gt; new_sentence = 'glad sad miserable pleasant glad'\n&gt;&gt;&gt; model.predict_one(new_sentence)\n'+'\n&gt;&gt;&gt; model.predict_proba_one(new_sentence)\n{'+': 0.75, '\u2212': 0.25}\n</code></pre>"},{"location":"api/dummy/PriorClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/dummy/PriorClassifier/#references","title":"References","text":"<ol> <li> <p>Krichevsky\u2013Trofimov estimator \u21a9</p> </li> </ol>"},{"location":"api/dummy/StatisticRegressor/","title":"StatisticRegressor","text":"<p>Dummy regressor that uses a univariate statistic to make predictions.</p>"},{"location":"api/dummy/StatisticRegressor/#parameters","title":"Parameters","text":"<ul> <li>statistic (river.stats.base.Univariate)</li> </ul>"},{"location":"api/dummy/StatisticRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; from river import dummy\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; sentences = [\n...     ('glad happy glad', 3),\n...     ('glad glad joyful', 3),\n...     ('glad pleasant', 2),\n...     ('miserable sad glad', -3)\n... ]\n\n&gt;&gt;&gt; model = dummy.StatisticRegressor(stats.Mean())\n\n&gt;&gt;&gt; for sentence, score in sentences:\n...     model = model.learn_one(sentence, score)\n\n&gt;&gt;&gt; new_sentence = 'glad sad miserable pleasant glad'\n&gt;&gt;&gt; model.predict_one(new_sentence)\n1.25\n</code></pre>"},{"location":"api/dummy/StatisticRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/ensemble/ADWINBaggingClassifier/","title":"ADWINBaggingClassifier","text":"<p>ADWIN Bagging classifier.</p> <p>ADWIN Bagging 1 is the online bagging method of Oza and Russell 2 with the addition of the <code>ADWIN</code> algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.</p>"},{"location":"api/ensemble/ADWINBaggingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> <p>The classifier to bag.</p> </li> <li> <p>n_models \u2013 defaults to <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/ADWINBaggingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/ADWINBaggingClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = ensemble.ADWINBaggingClassifier(\n...     model=(\n...         preprocessing.StandardScaler() |\n...         linear_model.LogisticRegression()\n...     ),\n...     n_models=3,\n...     seed=42\n... )\n\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.83%\n</code></pre>"},{"location":"api/ensemble/ADWINBaggingClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Averages the predictions of each classifier.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/ADWINBaggingClassifier/#references","title":"References","text":"<ol> <li> <p>Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009.\u00a0\u21a9</p> </li> <li> <p>Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/ADWINBoostingClassifier/","title":"ADWINBoostingClassifier","text":"<p>ADWIN Boosting classifier.</p> <p>ADWIN Boosting 1 is the online boosting method of Oza and Russell 2 with the addition of the <code>ADWIN</code> algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.</p>"},{"location":"api/ensemble/ADWINBoostingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> <p>The classifier to boost.</p> </li> <li> <p>n_models \u2013 defaults to <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/ADWINBoostingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/ADWINBoostingClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; model = ensemble.ADWINBoostingClassifier(\n...     model=(\n...         preprocessing.StandardScaler() |\n...         linear_model.LogisticRegression()\n...     ),\n...     n_models=3,\n...     seed=42\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.41%\n</code></pre>"},{"location":"api/ensemble/ADWINBoostingClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/ADWINBoostingClassifier/#references","title":"References","text":"<ol> <li> <p>Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009.\u00a0\u21a9</p> </li> <li> <p>Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/AdaBoostClassifier/","title":"AdaBoostClassifier","text":"<p>Boosting for classification.</p> <p>For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter lambda. The lambda parameter is updated when the weaks learners fit successively the same observation.</p>"},{"location":"api/ensemble/AdaBoostClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> <p>The classifier to boost.</p> </li> <li> <p>n_models \u2013 defaults to <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/AdaBoostClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>wrong_weight (collections.defaultdict)</p> <p>Number of times a model has made a mistake when making predictions.</p> </li> <li> <p>correct_weight (collections.defaultdict)</p> <p>Number of times a model has predicted the right label when making predictions.</p> </li> </ul>"},{"location":"api/ensemble/AdaBoostClassifier/#examples","title":"Examples","text":"<p>In the following example three tree classifiers are boosted together. The performance is slightly better than when using a single tree.</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; metric = metrics.LogLoss()\n\n&gt;&gt;&gt; model = ensemble.AdaBoostClassifier(\n...     model=(\n...         tree.HoeffdingTreeClassifier(\n...             split_criterion='gini',\n...             delta=1e-5,\n...             grace_period=2000\n...         )\n...     ),\n...     n_models=5,\n...     seed=42\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nLogLoss: 0.370805\n\n&gt;&gt;&gt; print(model)\nAdaBoostClassifier(HoeffdingTreeClassifier)\n</code></pre>"},{"location":"api/ensemble/AdaBoostClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/AdaBoostClassifier/#references","title":"References","text":"<ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/","title":"AdaptiveRandomForestClassifier","text":"<p>Adaptive Random Forest classifier.</p> <p>The 3 most important aspects of Adaptive Random Forest 1 are: </p> <ol> <li> <p>inducing diversity through re-sampling </p> </li> <li> <p>inducing diversity through randomly selecting subsets of features for    node splits </p> </li> <li> <p>drift detectors per base tree, which cause selective resets in response    to drifts </p> </li> </ol> <p>It also allows training background trees, which start training if a warning is detected and replace the active tree if the warning escalates to a drift.</p>"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_models (int) \u2013 defaults to <code>10</code></p> <p>Number of trees in the ensemble.</p> </li> <li> <p>max_features (Union[bool, str, int]) \u2013 defaults to <code>sqrt</code></p> <p>Max number of attributes for each node split. - If <code>int</code>, then consider <code>max_features</code> at each split. - If <code>float</code>, then <code>max_features</code> is a percentage and   <code>int(max_features * n_features)</code> features are considered per split. - If \"sqrt\", then <code>max_features=sqrt(n_features)</code>. - If \"log2\", then <code>max_features=log2(n_features)</code>. - If None, then <code>max_features=n_features</code>.</p> </li> <li> <p>lambda_value (int) \u2013 defaults to <code>6</code></p> <p>The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging).</p> </li> <li> <p>metric (river.metrics.base.MultiClassMetric) \u2013 defaults to <code>Accuracy: 0.00%</code></p> <p>Metric used to track trees performance within the ensemble.</p> </li> <li> <p>disable_weighted_vote \u2013 defaults to <code>False</code></p> <p>If <code>True</code>, disables the weighted vote prediction.</p> </li> <li> <p>drift_detector (Optional[base.DriftDetector]) \u2013 defaults to <code>ADWIN</code></p> <p>Drift Detection method. Set to None to disable Drift detection.</p> </li> <li> <p>warning_detector (Optional[base.DriftDetector]) \u2013 defaults to <code>ADWIN</code></p> <p>Warning Detection method. Set to None to disable warning detection.</p> </li> <li> <p>grace_period (int) \u2013 defaults to <code>50</code></p> <p>[Tree parameter] Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>[Tree parameter] The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>split_criterion (str) \u2013 defaults to <code>info_gain</code></p> <p>[Tree parameter] Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Hellinger Distance</p> </li> <li> <p>delta (float) \u2013 defaults to <code>0.01</code></p> <p>[Tree parameter] Allowed error in split decision, a value closer to 0 takes longer to decide.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>[Tree parameter] Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>nba</code></p> <p>[Tree parameter] Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold (int) \u2013 defaults to <code>0</code></p> <p>[Tree parameter] Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>[Tree parameter] List of Nominal attributes. If empty, then assume that all attributes are numerical.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>[Tree parameter] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>[Tree parameter] If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>100.0</code></p> <p>[Tree parameter] Maximum memory (MB) consumed by the tree.</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>2000000</code></p> <p>[Tree parameter] Number of instances between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>[Tree parameter] If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>[Tree parameter] If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>[Tree parameter] If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.ConceptDriftStream(seed=42, position=500,\n...                                    width=40).take(1000)\n\n&gt;&gt;&gt; model = ensemble.AdaptiveRandomForestClassifier(seed=8, leaf_prediction=\"mc\")\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 71.07%\n</code></pre>"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#references","title":"References","text":"<ol> <li> <p>Heitor Murilo Gomes, Albert Bifet, Jesse Read, Jean Paul Barddal,  Fabricio Enembreck, Bernhard Pfharinger, Geoff Holmes, Talel Abdessalem.  Adaptive random forests for evolving data stream classification.  In Machine Learning, DOI: 10.1007/s10994-017-5642-8, Springer, 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/","title":"AdaptiveRandomForestRegressor","text":"<p>Adaptive Random Forest regressor.</p> <p>The 3 most important aspects of Adaptive Random Forest 1 are: </p> <ol> <li> <p>inducing diversity through re-sampling </p> </li> <li> <p>inducing diversity through randomly selecting subsets of features for    node splits </p> </li> <li> <p>drift detectors per base tree, which cause selective resets in response    to drifts </p> </li> </ol> <p>Notice that this implementation is slightly different from the original algorithm proposed in 2. The <code>HoeffdingTreeRegressor</code> is used as base learner, instead of <code>FIMT-DD</code>. It also adds a new strategy to monitor the predictions and check for concept drifts. The deviations of the predictions to the target are monitored and normalized in the [0, 1] range to fulfill ADWIN's requirements. We assume that the data subjected to the normalization follows a normal distribution, and thus, lies within the interval of the mean \\(\\pm3\\sigma\\).</p>"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_models (int) \u2013 defaults to <code>10</code></p> <p>Number of trees in the ensemble.</p> </li> <li> <p>max_features \u2013 defaults to <code>sqrt</code></p> <p>Max number of attributes for each node split. - If <code>int</code>, then consider <code>max_features</code> at each split. - If <code>float</code>, then <code>max_features</code> is a percentage and   <code>int(max_features * n_features)</code> features are considered per split. - If \"sqrt\", then <code>max_features=sqrt(n_features)</code>. - If \"log2\", then <code>max_features=log2(n_features)</code>. - If None, then <code>max_features=n_features</code>.</p> </li> <li> <p>aggregation_method (str) \u2013 defaults to <code>median</code></p> <p>The method to use to aggregate predictions in the ensemble. - 'mean' - 'median' - If selected will disable the weighted vote.</p> </li> <li> <p>lambda_value (int) \u2013 defaults to <code>6</code></p> <p>The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging).</p> </li> <li> <p>metric (river.metrics.base.RegressionMetric) \u2013 defaults to <code>MSE: 0.</code></p> <p>Metric used to track trees performance within the ensemble. Depending, on the configuration, this metric is also used to weight predictions from the members of the ensemble.</p> </li> <li> <p>disable_weighted_vote \u2013 defaults to <code>True</code></p> <p>If <code>True</code>, disables the weighted vote prediction, i.e. does not assign weights to individual tree's predictions and uses the arithmetic mean instead. Otherwise will use the <code>metric</code> value to weight predictions.</p> </li> <li> <p>drift_detector (base.DriftDetector) \u2013 defaults to <code>ADWIN</code></p> <p>Drift Detection method. Set to None to disable Drift detection.</p> </li> <li> <p>warning_detector (base.DriftDetector) \u2013 defaults to <code>ADWIN</code></p> <p>Warning Detection method. Set to None to disable warning detection.</p> </li> <li> <p>grace_period (int) \u2013 defaults to <code>50</code></p> <p>[Tree parameter] Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>[Tree parameter] The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>delta (float) \u2013 defaults to <code>0.01</code></p> <p>[Tree parameter] Allowed error in split decision, a value closer to 0 takes longer to decide.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>[Tree parameter] Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>adaptive</code></p> <p>[Tree parameter] Prediction mechanism used at leaves. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model (base.Regressor) \u2013 defaults to <code>None</code></p> <p>[Tree parameter] The regression model used to provide responses if <code>leaf_prediction='model'</code>. If not provided, an instance of <code>river.linear_model.LinearRegression</code> with the default hyperparameters  is used.</p> </li> <li> <p>model_selector_decay (float) \u2013 defaults to <code>0.95</code></p> <p>[Tree parameter] The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>[Tree parameter] List of Nominal attributes. If empty, then assume that all attributes are numerical.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>[Tree parameter] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters.By default, <code>tree.splitter.EBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split (int) \u2013 defaults to <code>5</code></p> <p>[Tree parameter] The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>[Tree parameter] If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>500.0</code></p> <p>[Tree parameter] Maximum memory (MB) consumed by the tree.</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>2000000</code></p> <p>[Tree parameter] Number of instances between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>[Tree parameter] If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>[Tree parameter] If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>[Tree parameter] If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>models</p> </li> <li> <p>valid_aggregation_method</p> <p>Valid aggregation_method values.</p> </li> </ul>"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     ensemble.AdaptiveRandomForestRegressor(seed=42)\n... )\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 0.800649\n</code></pre>"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#references","title":"References","text":"<ol> <li> <p>Gomes, H.M., Bifet, A., Read, J., Barddal, J.P., Enembreck, F.,   Pfharinger, B., Holmes, G. and Abdessalem, T., 2017. Adaptive random   forests for evolving data stream classification. Machine Learning,   106(9-10), pp.1469-1495.\u00a0\u21a9</p> </li> <li> <p>Gomes, H.M., Barddal, J.P., Boiko, L.E., Bifet, A., 2018.   Adaptive random forests for data stream regression. ESANN 2018.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/BOLEClassifier/","title":"BOLEClassifier","text":"<p>Boosting Online Learning Ensemble (BOLE).</p> <p>A modified version of Oza Online Boosting Algorithm 1. For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter lambda. The first model to be trained will be the one with worst correct_weight / (correct_weight + wrong_weight). The worst model's not yet trained will receive lambda values for training from the model's that incorrectly classified an instance, and the best model's not yet trained will receive lambda values for training from the model's that correctly classified an instance. For more details, see 2.</p>"},{"location":"api/ensemble/BOLEClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> <p>The classifier to boost.</p> </li> <li> <p>n_models \u2013 defaults to <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> <li> <p>error_bound \u2013 defaults to <code>0.5</code></p> <p>Error bound percentage for allowing models to vote.</p> </li> </ul>"},{"location":"api/ensemble/BOLEClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>wrong_weight (collections.defaultdict)</p> <p>Number of times a model has made a mistake when making predictions.</p> </li> <li> <p>correct_weight (collections.defaultdict)</p> <p>Number of times a model has predicted the right label when making predictions.</p> </li> <li> <p>order_position</p> <p>Array with the index of the models with best (correct_weight / correct_weight + wrong_weight) in descending order.</p> </li> <li> <p>instances_seen</p> <p>Number of instances that the ensemble trained with.</p> </li> </ul>"},{"location":"api/ensemble/BOLEClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import drift\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = datasets.Elec2().take(3000)\n\n&gt;&gt;&gt; model = ensemble.BOLEClassifier(\n...     model=drift.DriftRetrainingClassifier(\n...         model=tree.HoeffdingTreeClassifier(),\n...         drift_detector=drift.DDM()\n...     ),\n...     n_models=10,\n...     seed=42\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 93.63%\n</code></pre>"},{"location":"api/ensemble/BOLEClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/BOLEClassifier/#references","title":"References","text":"<ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> <li> <p>R. S. M. d. Barros, S. Garrido T. de Carvalho Santos and P. M. Gon\u00e7alves J\u00fanior, \"A Boosting-like Online Learning Ensemble,\" 2016 International Joint Conference on Neural Networks (IJCNN), 2016, pp. 1871-1878, doi: 10.1109/IJCNN.2016.7727427.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/BaggingClassifier/","title":"BaggingClassifier","text":"<p>Online bootstrap aggregation for classification.</p> <p>For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter 1. <code>k</code> thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do <code>scipy.stats.utils.random.poisson(1).pmf(k)</code> to obtain more detailed values.</p>"},{"location":"api/ensemble/BaggingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> <p>The classifier to bag.</p> </li> <li> <p>n_models \u2013 defaults to <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/BaggingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/BaggingClassifier/#examples","title":"Examples","text":"<p>In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression.</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = ensemble.BaggingClassifier(\n...     model=(\n...         preprocessing.StandardScaler() |\n...         linear_model.LogisticRegression()\n...     ),\n...     n_models=3,\n...     seed=42\n... )\n\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.83%\n\n&gt;&gt;&gt; print(model)\nBaggingClassifier(StandardScaler | LogisticRegression)\n</code></pre>"},{"location":"api/ensemble/BaggingClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Averages the predictions of each classifier.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/BaggingClassifier/#references","title":"References","text":"<ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/BaggingRegressor/","title":"BaggingRegressor","text":"<p>Online bootstrap aggregation for regression.</p> <p>For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter 1. <code>k</code> thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do <code>scipy.stats.utils.random.poisson(1).pmf(k)</code> for more detailed values.</p>"},{"location":"api/ensemble/BaggingRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Regressor)</p> <p>The regressor to bag.</p> </li> <li> <p>n_models \u2013 defaults to <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/BaggingRegressor/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/BaggingRegressor/#examples","title":"Examples","text":"<p>In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression.</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = preprocessing.StandardScaler()\n&gt;&gt;&gt; model |= ensemble.BaggingRegressor(\n...     model=linear_model.LinearRegression(intercept_lr=0.1),\n...     n_models=3,\n...     seed=42\n... )\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 0.68886\n</code></pre>"},{"location":"api/ensemble/BaggingRegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Averages the predictions of each regressor.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/BaggingRegressor/#references","title":"References","text":"<ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/EWARegressor/","title":"EWARegressor","text":"<p>Exponentially Weighted Average regressor.</p>"},{"location":"api/ensemble/EWARegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models (List[base.Regressor])</p> <p>The regressors to hedge.</p> </li> <li> <p>loss (optim.losses.RegressionLoss) \u2013 defaults to <code>None</code></p> <p>The loss function that has to be minimized. Defaults to <code>optim.losses.Squared</code>.</p> </li> <li> <p>learning_rate \u2013 defaults to <code>0.5</code></p> <p>The learning rate by which the model weights are multiplied at each iteration.</p> </li> </ul>"},{"location":"api/ensemble/EWARegressor/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/EWARegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; optimizers = [\n...     optim.SGD(0.01),\n...     optim.RMSProp(),\n...     optim.AdaGrad()\n... ]\n\n&gt;&gt;&gt; for optimizer in optimizers:\n...\n...     dataset = datasets.TrumpApproval()\n...     metric = metrics.MAE()\n...     model = (\n...         preprocessing.StandardScaler() |\n...         linear_model.LinearRegression(\n...             optimizer=optimizer,\n...             intercept_lr=.1\n...         )\n...     )\n...\n...     print(optimizer, evaluate.progressive_val_score(dataset, model, metric))\nSGD MAE: 0.555971\nRMSProp MAE: 0.528284\nAdaGrad MAE: 0.481461\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; metric = metrics.MAE()\n&gt;&gt;&gt; hedge = (\n...     preprocessing.StandardScaler() |\n...     ensemble.EWARegressor(\n...         [\n...             linear_model.LinearRegression(optimizer=o, intercept_lr=.1)\n...             for o in optimizers\n...         ],\n...         learning_rate=0.005\n...     )\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, hedge, metric)\nMAE: 0.494832\n</code></pre>"},{"location":"api/ensemble/EWARegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   learn_predict_one   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/EWARegressor/#references","title":"References","text":"<ol> <li> <p>Online Learning from Experts: Weighed Majority and Hedge \u21a9</p> </li> <li> <p>Wikipedia page on the multiplicative weight update method \u21a9</p> </li> <li> <p>Kivinen, J. and Warmuth, M.K., 1997. Exponentiated gradient versus gradient descent for linear predictors. information and computation, 132(1), pp.1-63. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/LeveragingBaggingClassifier/","title":"LeveragingBaggingClassifier","text":"<p>Leveraging Bagging ensemble classifier.</p> <p>Leveraging Bagging [^1] is an improvement over the Oza Bagging algorithm. The bagging performance is leveraged by increasing the re-sampling. It uses a poisson distribution to simulate the re-sampling process. To increase re-sampling it uses a higher <code>w</code> value of the Poisson distribution (agerage number of events), 6 by default, increasing the input space diversity, by attributing a different range of weights to the data samples. </p> <p>To deal with concept drift, Leveraging Bagging uses the ADWIN algorithm to monitor the performance of each member of the enemble If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.</p>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> <p>The classifier to bag.</p> </li> <li> <p>n_models (int) \u2013 defaults to <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>w (float) \u2013 defaults to <code>6</code></p> <p>Indicates the average number of events. This is the lambda parameter of the Poisson distribution used to compute the re-sampling weight.</p> </li> <li> <p>adwin_delta (float) \u2013 defaults to <code>0.002</code></p> <p>The delta parameter for the ADWIN change detector.</p> </li> <li> <p>bagging_method (str) \u2013 defaults to <code>bag</code></p> <p>The bagging method to use. Can be one of the following: * 'bag' - Leveraging Bagging using ADWIN. * 'me' - Assigns \\(weight=1\\) if sample is misclassified,   otherwise \\(weight=error/(1-error)\\). * 'half' - Use resampling without replacement for half of the instances. * 'wt' - Resample without taking out all instances. * 'subag' - Resampling without replacement.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>bagging_methods</p> <p>Valid bagging_method options.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = ensemble.LeveragingBaggingClassifier(\n...     model=(\n...         preprocessing.StandardScaler() |\n...         linear_model.LogisticRegression()\n...     ),\n...     n_models=3,\n...     seed=42\n... )\n\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 88.73%\n</code></pre>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Averages the predictions of each classifier.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/SRPClassifier/","title":"SRPClassifier","text":"<p>Streaming Random Patches ensemble classifier.</p> <p>The Streaming Random Patches (SRP) 1 is an ensemble method that simulates bagging or random subspaces. The default algorithm uses both bagging and random subspaces, namely Random Patches. The default base estimator is a Hoeffding Tree, but other base estimators can be used (differently from random forest variations).</p>"},{"location":"api/ensemble/SRPClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Estimator) \u2013 defaults to <code>None</code></p> <p>The base estimator.</p> </li> <li> <p>n_models (int) \u2013 defaults to <code>10</code></p> <p>Number of members in the ensemble.</p> </li> <li> <p>subspace_size (Union[int, float, str]) \u2013 defaults to <code>0.6</code></p> <p>Number of features per subset for each classifier where <code>M</code> is the total number of features. A negative value means <code>M - subspace_size</code>. Only applies when using random subspaces or random patches. * If <code>int</code> indicates the number of features to use. Valid range [2, M].  * If <code>float</code> indicates the percentage of features to use, Valid range (0., 1.].  * 'sqrt' - <code>sqrt(M)+1</code> * 'rmsqrt' - Residual from <code>M-(sqrt(M)+1)</code></p> </li> <li> <p>training_method (str) \u2013 defaults to <code>patches</code></p> <p>The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches.</p> </li> <li> <p>lam (int) \u2013 defaults to <code>6</code></p> <p>Lambda value for resampling.</p> </li> <li> <p>drift_detector (base.DriftDetector) \u2013 defaults to <code>None</code></p> <p>Drift detector.</p> </li> <li> <p>warning_detector (base.DriftDetector) \u2013 defaults to <code>None</code></p> <p>Warning detector.</p> </li> <li> <p>disable_detector (str) \u2013 defaults to <code>off</code></p> <p>Option to disable drift detectors: * If <code>'off'</code>, detectors are enabled. * If <code>'drift'</code>, disables concept drift detection and the background learner. * If <code>'warning'</code>, disables the background learner and ensemble members are  reset if drift is detected.</p> </li> <li> <p>disable_weighted_vote (bool) \u2013 defaults to <code>False</code></p> <p>If True, disables weighted voting.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> <li> <p>metric (Optional[river.metrics.base.ClassificationMetric]) \u2013 defaults to <code>None</code></p> <p>The metric to track members performance within the ensemble. This implementation assumes that larger values are better when using weighted votes.</p> </li> </ul>"},{"location":"api/ensemble/SRPClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/SRPClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = synth.ConceptDriftStream(\n...     seed=42,\n...     position=500,\n...     width=50\n... ).take(1000)\n\n&gt;&gt;&gt; base_model = tree.HoeffdingTreeClassifier(\n...     grace_period=50, delta=0.01,\n...     nominal_attributes=['age', 'car', 'zipcode']\n... )\n&gt;&gt;&gt; model = ensemble.SRPClassifier(\n...     model=base_model, n_models=3, seed=42,\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 72.77%\n</code></pre>"},{"location":"api/ensemble/SRPClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reset   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/SRPClassifier/#notes","title":"Notes","text":"<p>This implementation uses <code>n_models=10</code> as default given the impact on processing time. The optimal number of models depends on the data and resources available.</p>"},{"location":"api/ensemble/SRPClassifier/#references","title":"References","text":"<ol> <li> <p>Heitor Murilo Gomes, Jesse Read, Albert Bifet.   Streaming Random Patches for Evolving Data Stream Classification.   IEEE International Conference on Data Mining (ICDM), 2019.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/SRPRegressor/","title":"SRPRegressor","text":"<p>Streaming Random Patches ensemble regressor.</p> <p>The Streaming Random Patches 1 ensemble method for regression trains each base learner on a subset of features and instances from the original data, namely a random patch. This strategy to enforce diverse base models is similar to the one in the random forest, yet it is not restricted to using decision trees as base learner. </p> <p>This method is an adaptation of 2 for regression.</p>"},{"location":"api/ensemble/SRPRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Regressor) \u2013 defaults to <code>None</code></p> <p>The base estimator.</p> </li> <li> <p>n_models (int) \u2013 defaults to <code>10</code></p> <p>Number of members in the ensemble.</p> </li> <li> <p>subspace_size (Union[int, float, str]) \u2013 defaults to <code>0.6</code></p> <p>Number of features per subset for each classifier where <code>M</code> is the total number of features. A negative value means <code>M - subspace_size</code>. Only applies when using random subspaces or random patches. * If <code>int</code> indicates the number of features to use. Valid range [2, M].  * If <code>float</code> indicates the percentage of features to use, Valid range (0., 1.].  * 'sqrt' - <code>sqrt(M)+1</code> * 'rmsqrt' - Residual from <code>M-(sqrt(M)+1)</code></p> </li> <li> <p>training_method (str) \u2013 defaults to <code>patches</code></p> <p>The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches.</p> </li> <li> <p>lam (int) \u2013 defaults to <code>6</code></p> <p>Lambda value for bagging.</p> </li> <li> <p>drift_detector (base.DriftDetector) \u2013 defaults to <code>None</code></p> <p>Drift detector.</p> </li> <li> <p>warning_detector (base.DriftDetector) \u2013 defaults to <code>None</code></p> <p>Warning detector.</p> </li> <li> <p>disable_detector (str) \u2013 defaults to <code>off</code></p> <p>Option to disable drift detectors: * If <code>'off'</code>, detectors are enabled. * If <code>'drift'</code>, disables concept drift detection and the background learner. * If <code>'warning'</code>, disables the background learner and ensemble members are  reset if drift is detected.</p> </li> <li> <p>disable_weighted_vote (bool) \u2013 defaults to <code>True</code></p> <p>If True, disables weighted voting.</p> </li> <li> <p>drift_detection_criteria (str) \u2013 defaults to <code>error</code></p> <p>The criteria used to track drifts. * 'error' - absolute error. * 'prediction' - predicted target values.</p> </li> <li> <p>aggregation_method (str) \u2013 defaults to <code>mean</code></p> <p>The method to use to aggregate predictions in the ensemble. * 'mean' * 'median'</p> </li> <li> <p>seed \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> <li> <p>metric (Optional[river.metrics.base.RegressionMetric]) \u2013 defaults to <code>None</code></p> <p>The metric to track members performance within the ensemble.</p> </li> </ul>"},{"location":"api/ensemble/SRPRegressor/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/SRPRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = synth.FriedmanDrift(\n...     drift_type='gsg',\n...     position=(350, 750),\n...     transition_window=200,\n...     seed=42\n... ).take(1000)\n\n&gt;&gt;&gt; base_model = tree.HoeffdingTreeRegressor(grace_period=50)\n&gt;&gt;&gt; model = ensemble.SRPRegressor(\n...     model=base_model,\n...     training_method=\"patches\",\n...     n_models=3,\n...     seed=42\n... )\n\n&gt;&gt;&gt; metric = metrics.R2()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nR2: 0.571117\n</code></pre>"},{"location":"api/ensemble/SRPRegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reset   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/SRPRegressor/#notes","title":"Notes","text":"<p>This implementation uses <code>n_models=10</code> as default given the impact on processing time. The optimal number of models depends on the data and resources available.</p>"},{"location":"api/ensemble/SRPRegressor/#references","title":"References","text":"<ol> <li> <p>Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini,   Bernhard Pfahringer, and Albert Bifet.   On Ensemble Techniques for Data Stream Regression.   IJCNN'20. International Joint Conference on Neural Networks. 2020.\u00a0\u21a9</p> </li> <li> <p>Heitor Murilo Gomes, Jesse Read, Albert Bifet.   Streaming Random Patches for Evolving Data Stream Classification.   IEEE International Conference on Data Mining (ICDM), 2019.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/StackingClassifier/","title":"StackingClassifier","text":"<p>Stacking for binary classification.</p>"},{"location":"api/ensemble/StackingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models (List[base.Classifier])</p> </li> <li> <p>meta_classifier (base.Classifier)</p> </li> <li> <p>include_features \u2013 defaults to <code>True</code></p> <p>Indicates whether or not the original features should be provided to the meta-model along with the predictions from each model.</p> </li> </ul>"},{"location":"api/ensemble/StackingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/StackingClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model as lm\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing as pp\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     ('scale', pp.StandardScaler()),\n...     ('stack', ensemble.StackingClassifier(\n...         [\n...             lm.LogisticRegression(),\n...             lm.PAClassifier(mode=1, C=0.01),\n...             lm.PAClassifier(mode=2, C=0.01),\n...         ],\n...         meta_classifier=lm.LogisticRegression()\n...     ))\n... )\n\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 88.14%\n</code></pre>"},{"location":"api/ensemble/StackingClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/ensemble/StackingClassifier/#references","title":"References","text":"<ol> <li> <p>A Kaggler's Guide to Model Stacking in Practice \u21a9</p> </li> </ol>"},{"location":"api/ensemble/VotingClassifier/","title":"VotingClassifier","text":"<p>Voting classifier.</p> <p>A classification is made by aggregating the predictions of each model in the ensemble. The probabilities for each class are summed up if <code>use_probabilities</code> is set to <code>True</code>. If not, the probabilities are ignored and each prediction is weighted the same. In this case, it's important that you use an odd number of classifiers. A random class will be picked if the number of classifiers is even.</p>"},{"location":"api/ensemble/VotingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models (List[base.Classifier])</p> <p>The classifiers.</p> </li> <li> <p>use_probabilities \u2013 defaults to <code>True</code></p> <p>Whether or to weight each prediction with its associated probability.</p> </li> </ul>"},{"location":"api/ensemble/VotingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/VotingClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import naive_bayes\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     ensemble.VotingClassifier([\n...         linear_model.LogisticRegression(),\n...         tree.HoeffdingTreeClassifier(),\n...         naive_bayes.GaussianNB()\n...     ])\n... )\n\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.14%\n</code></pre>"},{"location":"api/ensemble/VotingClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/evaluate/BinaryClassificationTrack/","title":"BinaryClassificationTrack","text":"<p>This track evaluates a model's performance on binary classification tasks. These do not include synthetic datasets.</p>"},{"location":"api/evaluate/BinaryClassificationTrack/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/MultiClassClassificationTrack/","title":"MultiClassClassificationTrack","text":"<p>This track evaluates a model's performance on multi-class classification tasks. These do not include synthetic datasets.</p>"},{"location":"api/evaluate/MultiClassClassificationTrack/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/RegressionTrack/","title":"RegressionTrack","text":"<p>This track evaluates a model's performance on regression tasks. These do not include synthetic datasets.</p>"},{"location":"api/evaluate/RegressionTrack/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/Track/","title":"Track","text":"<p>A track evaluate a model's performance.</p> <p>The following metrics are recorded: </p> <ul> <li>Time, which should be interpreted with wisdom. Indeed time can depend on the architecture     and local resource situations. Comparison via FLOPS should be preferred. - The model's memory footprint. - The model's predictive performance on the track's dataset.</li> </ul>"},{"location":"api/evaluate/Track/#parameters","title":"Parameters","text":"<ul> <li> <p>name (str)</p> <p>The name of the track.</p> </li> <li> <p>datasets</p> <p>The datasets that compose the track.</p> </li> <li> <p>metric</p> <p>The metric(s) used to track performance.</p> </li> </ul>"},{"location":"api/evaluate/Track/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/iter-progressive-val-score/","title":"iter_progressive_val_score","text":"<p>Evaluates the performance of a model on a streaming dataset and yields results.</p> <p>This does exactly the same as <code>evaluate.progressive_val_score</code>. The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results.</p>"},{"location":"api/evaluate/iter-progressive-val-score/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset (Iterable[Tuple[dict, Any]])</p> <p>The stream of observations against which the model will be evaluated.</p> </li> <li> <p>model</p> <p>The model to evaluate.</p> </li> <li> <p>metric (river.metrics.base.Metric)</p> <p>The metric used to evaluate the model's predictions.</p> </li> <li> <p>moment (Union[str, Callable]) \u2013 defaults to <code>None</code></p> <p>The attribute used for measuring time. If a callable is passed, then it is expected to take as input a <code>dict</code> of features. If <code>None</code>, then the observations are implicitly timestamped in the order in which they arrive.</p> </li> <li> <p>delay (Union[str, int, datetime.timedelta, Callable]) \u2013 defaults to <code>None</code></p> <p>The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the <code>moment</code> value. For instance, if <code>moment</code> is a <code>datetime.date</code>, then <code>delay</code> is expected to be a <code>datetime.timedelta</code>. If a callable is passed, then it is expected to take as input a <code>dict</code> of features and the target. If a <code>str</code> is passed, then it will be used to access the relevant field from the features. If <code>None</code> is passed, then no delay will be used, which leads to doing standard online validation.</p> </li> <li> <p>step \u2013 defaults to <code>1</code></p> <p>Iteration number at which to yield results. This only takes into account the predictions, and not the training steps.</p> </li> <li> <p>measure_time \u2013 defaults to <code>False</code></p> <p>Whether or not to measure the elapsed time.</p> </li> <li> <p>measure_memory \u2013 defaults to <code>False</code></p> <p>Whether or not to measure the memory usage of the model.</p> </li> </ul>"},{"location":"api/evaluate/iter-progressive-val-score/#examples","title":"Examples","text":"<p>Take the following model:</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression()\n... )\n</code></pre> <p>We can evaluate it on the <code>Phishing</code> dataset as so:</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; steps = evaluate.iter_progressive_val_score(\n...     model=model,\n...     dataset=datasets.Phishing(),\n...     metric=metrics.ROCAUC(),\n...     step=200\n... )\n\n&gt;&gt;&gt; for step in steps:\n...     print(step)\n{'ROCAUC': ROCAUC: 89.80%, 'Step': 200}\n{'ROCAUC': ROCAUC: 92.09%, 'Step': 400}\n{'ROCAUC': ROCAUC: 93.13%, 'Step': 600}\n{'ROCAUC': ROCAUC: 93.99%, 'Step': 800}\n{'ROCAUC': ROCAUC: 94.74%, 'Step': 1000}\n{'ROCAUC': ROCAUC: 95.03%, 'Step': 1200}\n</code></pre>"},{"location":"api/evaluate/iter-progressive-val-score/#references","title":"References","text":"<ol> <li> <p>Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9</p> </li> <li> <p>Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9</p> </li> </ol>"},{"location":"api/evaluate/progressive-val-score/","title":"progressive_val_score","text":"<p>Evaluates the performance of a model on a streaming dataset.</p> <p>This method is the canonical way to evaluate a model's performance. When used correctly, it allows you to exactly assess how a model would have performed in a production scenario. </p> <p><code>dataset</code> is converted into a stream of questions and answers. At each step the model is either asked to predict an observation, or is either updated. The target is only revealed to the model after a certain amount of time, which is determined by the <code>delay</code> parameter. Note that under the hood this uses the <code>stream.simulate_qa</code> function to go through the data in arrival order. </p> <p>By default, there is no delay, which means that the samples are processed one after the other. When there is no delay, this function essentially performs progressive validation. When there is a delay, then we refer to it as delayed progressive validation. </p> <p>It is recommended to use this method when you want to determine a model's performance on a dataset. In particular, it is advised to use the <code>delay</code> parameter in order to get a reliable assessment. Indeed, in a production scenario, it is often the case that ground truths are made available after a certain amount of time. By using this method, you can reproduce this scenario and therefore truthfully assess what would have been the performance of a model on a given dataset.</p>"},{"location":"api/evaluate/progressive-val-score/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset (Iterable[Tuple[dict, Any]])</p> <p>The stream of observations against which the model will be evaluated.</p> </li> <li> <p>model</p> <p>The model to evaluate.</p> </li> <li> <p>metric (river.metrics.base.Metric)</p> <p>The metric used to evaluate the model's predictions.</p> </li> <li> <p>moment (Union[str, Callable]) \u2013 defaults to <code>None</code></p> <p>The attribute used for measuring time. If a callable is passed, then it is expected to take as input a <code>dict</code> of features. If <code>None</code>, then the observations are implicitly timestamped in the order in which they arrive.</p> </li> <li> <p>delay (Union[str, int, datetime.timedelta, Callable]) \u2013 defaults to <code>None</code></p> <p>The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the <code>moment</code> value. For instance, if <code>moment</code> is a <code>datetime.date</code>, then <code>delay</code> is expected to be a <code>datetime.timedelta</code>. If a callable is passed, then it is expected to take as input a <code>dict</code> of features and the target. If a <code>str</code> is passed, then it will be used to access the relevant field from the features. If <code>None</code> is passed, then no delay will be used, which leads to doing standard online validation.</p> </li> <li> <p>print_every \u2013 defaults to <code>0</code></p> <p>Iteration number at which to print the current metric. This only takes into account the predictions, and not the training steps.</p> </li> <li> <p>show_time \u2013 defaults to <code>False</code></p> <p>Whether or not to display the elapsed time.</p> </li> <li> <p>show_memory \u2013 defaults to <code>False</code></p> <p>Whether or not to display the memory usage of the model.</p> </li> <li> <p>print_kwargs</p> <p>Extra keyword arguments are passed to the <code>print</code> function. For instance, this allows providing a <code>file</code> argument, which indicates where to output progress.</p> </li> </ul>"},{"location":"api/evaluate/progressive-val-score/#examples","title":"Examples","text":"<p>Take the following model:</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression()\n... )\n</code></pre> <p>We can evaluate it on the <code>Phishing</code> dataset as so:</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     model=model,\n...     dataset=datasets.Phishing(),\n...     metric=metrics.ROCAUC(),\n...     print_every=200\n... )\n[200] ROCAUC: 89.80%\n[400] ROCAUC: 92.09%\n[600] ROCAUC: 93.13%\n[800] ROCAUC: 93.99%\n[1,000] ROCAUC: 94.74%\n[1,200] ROCAUC: 95.03%\nROCAUC: 95.04%\n</code></pre> <p>We haven't specified a delay, therefore this is strictly equivalent to the following piece of code:</p> <pre><code>&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression()\n... )\n\n&gt;&gt;&gt; metric = metrics.ROCAUC()\n\n&gt;&gt;&gt; for x, y in datasets.Phishing():\n...     y_pred = model.predict_proba_one(x)\n...     metric = metric.update(y, y_pred)\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; metric\nROCAUC: 95.04%\n</code></pre> <p>When <code>print_every</code> is specified, the current state is printed at regular intervals. Under the hood, Python's <code>print</code> method is being used. You can pass extra keyword arguments to modify its behavior. For instance, you may use the <code>file</code> argument if you want to log the progress to a file of your choice.</p> <pre><code>&gt;&gt;&gt; with open('progress.log', 'w') as f:\n...     metric = evaluate.progressive_val_score(\n...         model=model,\n...         dataset=datasets.Phishing(),\n...         metric=metrics.ROCAUC(),\n...         print_every=200,\n...         file=f\n...     )\n\n&gt;&gt;&gt; with open('progress.log') as f:\n...     for line in f.read().splitlines():\n...         print(line)\n[200] ROCAUC: 94.00%\n[400] ROCAUC: 94.70%\n[600] ROCAUC: 95.17%\n[800] ROCAUC: 95.42%\n[1,000] ROCAUC: 95.82%\n[1,200] ROCAUC: 96.00%\n</code></pre> <p>Note that the performance is slightly better than above because we haven't used a fresh copy of the model. Instead, we've reused the existing model which has already done a full pass on the data.</p> <pre><code>&gt;&gt;&gt; import os; os.remove('progress.log')\n</code></pre>"},{"location":"api/evaluate/progressive-val-score/#references","title":"References","text":"<ol> <li> <p>Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9</p> </li> <li> <p>Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9</p> </li> </ol>"},{"location":"api/facto/FFMClassifier/","title":"FFMClassifier","text":"<p>Field-aware Factorization Machine for binary classification.</p> <p>The model equation is defined by: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_{j, f_{j'}}\\) is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\(\\mathbf{v}_{j', f_j}\\) is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FFMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss (optim.losses.BinaryLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FFMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FFMClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman', 'time': .12}, True),\n...     ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, True),\n...     ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, True),\n...     ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, False),\n...     ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, True),\n...     ({'user': 'Bob', 'item': 'Superman', 'time': .13}, True),\n...     ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, True),\n...     ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, True),\n...     ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, False)\n... )\n\n&gt;&gt;&gt; model = facto.FFMClassifier(\n...     n_factors=10,\n...     intercept=.5,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\nTrue\n</code></pre>"},{"location":"api/facto/FFMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/facto/FFMClassifier/#references","title":"References","text":"<ol> <li>Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50).</li> </ol>"},{"location":"api/facto/FFMRegressor/","title":"FFMRegressor","text":"<p>Field-aware Factorization Machine for regression.</p> <p>The model equation is defined by: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_{j, f_{j'}}\\) is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\(\\mathbf{v}_{j', f_j}\\) is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FFMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss (optim.losses.RegressionLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FFMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FFMRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman', 'time': .12}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, 5),\n...     ({'user': 'Bob', 'item': 'Superman', 'time': .13}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, 2)\n... )\n\n&gt;&gt;&gt; model = facto.FFMRegressor(\n...     n_factors=10,\n...     intercept=5,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n5.319945\n\n&gt;&gt;&gt; report = model.debug_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n\n&gt;&gt;&gt; print(report)\nName                                       Value      Weight     Contribution\n                               Intercept    1.00000    5.23501        5.23501\n                                user_Bob    1.00000    0.11438        0.11438\n                                    time    0.14000    0.03186        0.00446\n    item_Harry Potter(time) - time(item)    0.14000    0.03153        0.00441\n             user_Bob(time) - time(user)    0.14000    0.02864        0.00401\n                       item_Harry Potter    1.00000    0.00000        0.00000\nuser_Bob(item) - item_Harry Potter(user)    1.00000   -0.04232       -0.04232\n</code></pre>"},{"location":"api/facto/FFMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/facto/FFMRegressor/#references","title":"References","text":"<ol> <li> <p>Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50). \u21a9</p> </li> </ol>"},{"location":"api/facto/FMClassifier/","title":"FMClassifier","text":"<p>Factorization Machine for binary classification.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/FMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss (optim.losses.BinaryLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FMClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, True),\n...     ({'user': 'Alice', 'item': 'Terminator'}, True),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, True),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, False),\n...     ({'user': 'Alice', 'item': 'Harry Potter '}, True),\n...     ({'user': 'Bob', 'item': 'Superman'}, True),\n...     ({'user': 'Bob', 'item': 'Terminator'}, True),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, True),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, False)\n... )\n\n&gt;&gt;&gt; model = facto.FMClassifier(\n...     n_factors=10,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'Bob': 1, 'Harry Potter': 1})\nTrue\n</code></pre>"},{"location":"api/facto/FMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/facto/FMClassifier/#references","title":"References","text":"<ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> <li> <p>Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9</p> </li> </ol>"},{"location":"api/facto/FMRegressor/","title":"FMRegressor","text":"<p>Factorization Machine for regression.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/FMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss (optim.losses.RegressionLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FMRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator'}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter '}, 5),\n...     ({'user': 'Bob', 'item': 'Superman'}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator'}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n... )\n\n&gt;&gt;&gt; model = facto.FMRegressor(\n...     n_factors=10,\n...     intercept=5,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'Bob': 1, 'Harry Potter': 1})\n5.236504\n\n&gt;&gt;&gt; report = model.debug_one({'Bob': 1, 'Harry Potter': 1})\n\n&gt;&gt;&gt; print(report)\nName                 Value      Weight     Contribution\n         Intercept    1.00000    5.23426        5.23426\nBob - Harry Potter    1.00000    0.00224        0.00224\n      Harry Potter    1.00000    0.00000        0.00000\n               Bob    1.00000    0.00000        0.00000\n</code></pre>"},{"location":"api/facto/FMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/facto/FMRegressor/#references","title":"References","text":"<ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> <li> <p>Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9</p> </li> </ol>"},{"location":"api/facto/FwFMClassifier/","title":"FwFMClassifier","text":"<p>Field-weighted Factorization Machine for binary classification.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FwFMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>int_weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the field pairs interaction weights.</p> </li> <li> <p>loss (optim.losses.BinaryLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FwFMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> <li> <p>interaction_weights</p> <p>The current interaction strengths of field pairs.</p> </li> </ul>"},{"location":"api/facto/FwFMClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, True),\n...     ({'user': 'Alice', 'item': 'Terminator'}, True),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, True),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, False),\n...     ({'user': 'Alice', 'item': 'Harry Potter '}, True),\n...     ({'user': 'Bob', 'item': 'Superman'}, True),\n...     ({'user': 'Bob', 'item': 'Terminator'}, True),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, True),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, False)\n... )\n\n&gt;&gt;&gt; model = facto.FwFMClassifier(\n...     n_factors=10,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'Bob': 1, 'Harry Potter': 1})\nTrue\n</code></pre>"},{"location":"api/facto/FwFMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/facto/FwFMClassifier/#references","title":"References","text":"<ol> <li> <p>Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9</p> </li> </ol>"},{"location":"api/facto/FwFMRegressor/","title":"FwFMRegressor","text":"<p>Field-weighted Factorization Machine for regression.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FwFMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>int_weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the field pairs interaction weights.</p> </li> <li> <p>loss (optim.losses.RegressionLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FwFMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> <li> <p>interaction_weights</p> <p>The current interaction strengths of field pairs.</p> </li> </ul>"},{"location":"api/facto/FwFMRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator'}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter '}, 5),\n...     ({'user': 'Bob', 'item': 'Superman'}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator'}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n... )\n\n&gt;&gt;&gt; model = facto.FwFMRegressor(\n...     n_factors=10,\n...     intercept=5,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'Bob': 1, 'Harry Potter': 1})\n5.236501\n\n&gt;&gt;&gt; report = model.debug_one({'Bob': 1, 'Harry Potter': 1})\n\n&gt;&gt;&gt; print(report)\nName                                    Value      Weight     Contribution\n                            Intercept    1.00000    5.23426        5.23426\nBob(Harry Potter) - Harry Potter(Bob)    1.00000    0.00224        0.00224\n                         Harry Potter    1.00000    0.00000        0.00000\n                                  Bob    1.00000    0.00000        0.00000\n</code></pre>"},{"location":"api/facto/FwFMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/facto/FwFMRegressor/#references","title":"References","text":"<ol> <li> <p>Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9</p> </li> </ol>"},{"location":"api/facto/HOFMClassifier/","title":"HOFMClassifier","text":"<p>Higher-Order Factorization Machine for binary classification.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/HOFMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>degree \u2013 defaults to <code>3</code></p> <p>Polynomial degree or model order.</p> </li> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss (optim.losses.BinaryLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/HOFMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/HOFMClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman', 'time': .12}, True),\n...     ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, True),\n...     ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, True),\n...     ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, False),\n...     ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, True),\n...     ({'user': 'Bob', 'item': 'Superman', 'time': .13}, True),\n...     ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, True),\n...     ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, True),\n...     ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, False)\n... )\n\n&gt;&gt;&gt; model = facto.HOFMClassifier(\n...     degree=3,\n...     n_factors=10,\n...     intercept=.5,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\nTrue\n</code></pre>"},{"location":"api/facto/HOFMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/facto/HOFMClassifier/#references","title":"References","text":"<ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> </ol>"},{"location":"api/facto/HOFMRegressor/","title":"HOFMRegressor","text":"<p>Higher-Order Factorization Machine for regression.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/HOFMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>degree \u2013 defaults to <code>3</code></p> <p>Polynomial degree or model order.</p> </li> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note thatthe intercept is handled separately.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss (optim.losses.RegressionLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization \u2013 defaults to <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros()</code>.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state)</code>.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/HOFMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/HOFMRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import facto\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman', 'time': .12}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, 5),\n...     ({'user': 'Bob', 'item': 'Superman', 'time': .13}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, 2)\n... )\n\n&gt;&gt;&gt; model = facto.HOFMRegressor(\n...     degree=3,\n...     n_factors=10,\n...     intercept=5,\n...     seed=42,\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n5.311745\n\n&gt;&gt;&gt; report = model.debug_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n\n&gt;&gt;&gt; print(report)\nName                                  Value      Weight     Contribution\n                          Intercept    1.00000    5.23495        5.23495\n                           user_Bob    1.00000    0.11436        0.11436\n                               time    0.14000    0.03185        0.00446\n                    user_Bob - time    0.14000    0.00884        0.00124\nuser_Bob - item_Harry Potter - time    0.14000    0.00117        0.00016\n                  item_Harry Potter    1.00000    0.00000        0.00000\n           item_Harry Potter - time    0.14000   -0.00695       -0.00097\n       user_Bob - item_Harry Potter    1.00000   -0.04246       -0.04246\n</code></pre>"},{"location":"api/facto/HOFMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/facto/HOFMRegressor/#references","title":"References","text":"<ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> </ol>"},{"location":"api/feature-extraction/Agg/","title":"Agg","text":"<p>Computes a streaming aggregate.</p> <p>This transformer allows to compute an aggregate statistic, very much like the groupby method from <code>pandas</code>, but on a streaming dataset. This makes use of the streaming statistics from the <code>stats</code> module. </p> <p>When <code>learn_one</code> is called, the running statistic <code>how</code> of group <code>by</code> is updated with the value of <code>on</code>. Meanwhile, the output of <code>transform_one</code> is a single-element dictionary, where the key is the name of the aggregate and the value is the current value of the statistic for the relevant group. The key is automatically inferred from the parameters. </p> <p>Note that you can use a <code>compose.TransformerUnion</code> to extract many aggregate statistics in a concise manner.</p>"},{"location":"api/feature-extraction/Agg/#parameters","title":"Parameters","text":"<ul> <li> <p>on (str)</p> <p>The feature on which to compute the aggregate statistic.</p> </li> <li> <p>by (Union[str, List[str], NoneType])</p> <p>The feature by which to group the data. All the data is included in the aggregate if this is <code>None</code>.</p> </li> <li> <p>how (river.stats.base.Univariate)</p> <p>The statistic to compute.</p> </li> </ul>"},{"location":"api/feature-extraction/Agg/#attributes","title":"Attributes","text":"<ul> <li> <p>state</p> <p>Return the current values for each group as a series.</p> </li> </ul>"},{"location":"api/feature-extraction/Agg/#examples","title":"Examples","text":"<p>Consider the following dataset:</p> <pre><code>&gt;&gt;&gt; X = [\n...     {'country': 'France', 'place': 'Taco Bell', 'revenue': 42},\n...     {'country': 'Sweden', 'place': 'Burger King', 'revenue': 16},\n...     {'country': 'France', 'place': 'Burger King', 'revenue': 24},\n...     {'country': 'Sweden', 'place': 'Taco Bell', 'revenue': 58},\n...     {'country': 'Sweden', 'place': 'Burger King', 'revenue': 20},\n...     {'country': 'France', 'place': 'Taco Bell', 'revenue': 50},\n...     {'country': 'France', 'place': 'Burger King', 'revenue': 10},\n...     {'country': 'Sweden', 'place': 'Taco Bell', 'revenue': 80}\n... ]\n</code></pre> <p>As an example, we can calculate the average (how) revenue (on) for each place (by):</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction as fx\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; agg = fx.Agg(\n...     on='revenue',\n...     by='place',\n...     how=stats.Mean()\n... )\n\n&gt;&gt;&gt; for x in X:\n...     agg = agg.learn_one(x)\n...     print(agg.transform_one(x))\n{'revenue_mean_by_place': 42.0}\n{'revenue_mean_by_place': 16.0}\n{'revenue_mean_by_place': 20.0}\n{'revenue_mean_by_place': 50.0}\n{'revenue_mean_by_place': 20.0}\n{'revenue_mean_by_place': 50.0}\n{'revenue_mean_by_place': 17.5}\n{'revenue_mean_by_place': 57.5}\n</code></pre> <p>You can compute an aggregate over multiple keys by passing a tuple to the <code>by</code> argument. For instance, we can compute the maximum (how) revenue (on) per place as well as per day (by):</p> <pre><code>&gt;&gt;&gt; agg = fx.Agg(\n...     on='revenue',\n...     by=['place', 'country'],\n...     how=stats.Max()\n... )\n\n&gt;&gt;&gt; for x in X:\n...     agg = agg.learn_one(x)\n...     print(agg.transform_one(x))\n{'revenue_max_by_place_and_country': 42}\n{'revenue_max_by_place_and_country': 16}\n{'revenue_max_by_place_and_country': 24}\n{'revenue_max_by_place_and_country': 58}\n{'revenue_max_by_place_and_country': 20}\n{'revenue_max_by_place_and_country': 50}\n{'revenue_max_by_place_and_country': 24}\n{'revenue_max_by_place_and_country': 80}\n</code></pre> <p>You can use a <code>compose.TransformerUnion</code> in order to calculate multiple aggregates in one go. The latter can be constructed by using the <code>+</code> operator:</p> <pre><code>&gt;&gt;&gt; agg = (\n...     fx.Agg(on='revenue', by='place', how=stats.Mean()) +\n...     fx.Agg(on='revenue', by=['place', 'country'], how=stats.Max())\n... )\n\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; for x in X:\n...     agg = agg.learn_one(x)\n...     pprint.pprint(agg.transform_one(x))\n{'revenue_max_by_place_and_country': 42, 'revenue_mean_by_place': 42.0}\n{'revenue_max_by_place_and_country': 16, 'revenue_mean_by_place': 16.0}\n{'revenue_max_by_place_and_country': 24, 'revenue_mean_by_place': 20.0}\n{'revenue_max_by_place_and_country': 58, 'revenue_mean_by_place': 50.0}\n{'revenue_max_by_place_and_country': 20, 'revenue_mean_by_place': 20.0}\n{'revenue_max_by_place_and_country': 50, 'revenue_mean_by_place': 50.0}\n{'revenue_max_by_place_and_country': 24, 'revenue_mean_by_place': 17.5}\n{'revenue_max_by_place_and_country': 80, 'revenue_mean_by_place': 57.5}\n</code></pre> <p>The <code>state</code> property returns a <code>pandas.Series</code>, which can be useful for visualizing the current state.</p> <pre><code>&gt;&gt;&gt; agg[0].state\nTaco Bell      57.5\nBurger King    17.5\nName: revenue_mean_by_place, dtype: float64\n\n&gt;&gt;&gt; agg[1].state\nplace        country\nTaco Bell    France     50\nBurger King  Sweden     20\n             France     24\nTaco Bell    Sweden     80\nName: revenue_max_by_place_and_country, dtype: int64\n</code></pre>"},{"location":"api/feature-extraction/Agg/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-extraction/Agg/#references","title":"References","text":"<ol> <li> <p>Streaming groupbys in pandas for big datasets \u21a9</p> </li> </ol>"},{"location":"api/feature-extraction/BagOfWords/","title":"BagOfWords","text":"<p>Counts tokens in sentences.</p> <p>This transformer can be used to counts tokens in a given piece of text. It takes care of normalizing the text before tokenizing it. In mini-batch settings, this transformers allows to convert a series of pandas of text into sparse dataframe. </p> <p>Note that the parameters are identical to those of <code>feature_extraction.TFIDF</code>.</p>"},{"location":"api/feature-extraction/BagOfWords/#parameters","title":"Parameters","text":"<ul> <li> <p>on ('str') \u2013 defaults to <code>None</code></p> <p>The name of the feature that contains the text to vectorize. If <code>None</code>, then each <code>learn_one</code> and <code>transform_one</code> will assume that each <code>x</code> that is provided is a <code>str</code>, andnot a <code>dict</code>.</p> </li> <li> <p>strip_accents \u2013 defaults to <code>True</code></p> <p>Whether or not to strip accent characters.</p> </li> <li> <p>lowercase \u2013 defaults to <code>True</code></p> <p>Whether or not to convert all characters to lowercase.</p> </li> <li> <p>preprocessor ('typing.Callable') \u2013 defaults to <code>None</code></p> <p>An optional preprocessing function which overrides the <code>strip_accents</code> and <code>lowercase</code> steps, while preserving the tokenizing and n-grams generation steps.</p> </li> <li> <p>stop_words ('set[str]') \u2013 defaults to <code>None</code></p> <p>An optional set of tokens to remove.</p> </li> <li> <p>tokenizer_pattern \u2013 defaults to <code>(?u)\\b\\w[\\w\\-]+\\b</code></p> <p>The tokenization pattern which is used when no <code>tokenizer</code> function is passed. A single capture group may optionally be specified.</p> </li> <li> <p>tokenizer ('typing.Callable') \u2013 defaults to <code>None</code></p> <p>A function used to convert preprocessed text into a <code>dict</code> of tokens. By default, a regex formula that works well in most cases is used.</p> </li> <li> <p>ngram_range \u2013 defaults to <code>(1, 1)</code></p> <p>The lower and upper boundary of the range n-grams to be extracted. All values of n such that <code>min_n &lt;= n &lt;= max_n</code> will be used. For example an <code>ngram_range</code> of <code>(1, 1)</code> means only unigrams, <code>(1, 2)</code> means unigrams and bigrams, and <code>(2, 2)</code> means only bigrams.</p> </li> </ul>"},{"location":"api/feature-extraction/BagOfWords/#examples","title":"Examples","text":"<p>By default, <code>BagOfWords</code> will take as input a sentence, preprocess it, tokenize the preprocessed text, and then return a <code>collections.Counter</code> containing the number of occurrences of each token.</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction as fx\n\n&gt;&gt;&gt; corpus = [\n...     'This is the first document.',\n...     'This document is the second document.',\n...     'And this is the third one.',\n...     'Is this the first document?',\n... ]\n\n&gt;&gt;&gt; bow = fx.BagOfWords()\n\n&gt;&gt;&gt; for sentence in corpus:\n...     print(bow.transform_one(sentence))\nCounter({'this': 1, 'is': 1, 'the': 1, 'first': 1, 'document': 1})\nCounter({'document': 2, 'this': 1, 'is': 1, 'the': 1, 'second': 1})\nCounter({'and': 1, 'this': 1, 'is': 1, 'the': 1, 'third': 1, 'one': 1})\nCounter({'is': 1, 'this': 1, 'the': 1, 'first': 1, 'document': 1})\n</code></pre> <p>Note that <code>learn_one</code> does not have to be called because <code>BagOfWords</code> is stateless. You can call it but it won't do anything.</p> <p>In the above example, a string is passed to <code>transform_one</code>. You can also indicate which field to access if the string is stored in a dictionary:</p> <pre><code>&gt;&gt;&gt; bow = fx.BagOfWords(on='sentence')\n\n&gt;&gt;&gt; for sentence in corpus:\n...     x = {'sentence': sentence}\n...     print(bow.transform_one(x))\nCounter({'this': 1, 'is': 1, 'the': 1, 'first': 1, 'document': 1})\nCounter({'document': 2, 'this': 1, 'is': 1, 'the': 1, 'second': 1})\nCounter({'and': 1, 'this': 1, 'is': 1, 'the': 1, 'third': 1, 'one': 1})\nCounter({'is': 1, 'this': 1, 'the': 1, 'first': 1, 'document': 1})\n</code></pre> <p>The <code>ngram_range</code> parameter can be used to extract n-grams (including unigrams):</p> <pre><code>&gt;&gt;&gt; ngrammer = fx.BagOfWords(ngram_range=(1, 2))\n\n&gt;&gt;&gt; ngrams = ngrammer.transform_one('I love the smell of napalm in the morning')\n&gt;&gt;&gt; for ngram, count in ngrams.items():\n...     print(ngram, count)\nlove 1\nthe 2\nsmell 1\nof 1\nnapalm 1\nin 1\nmorning 1\n('love', 'the') 1\n('the', 'smell') 1\n('smell', 'of') 1\n('of', 'napalm') 1\n('napalm', 'in') 1\n('in', 'the') 1\n('the', 'morning') 1\n</code></pre> <p><code>BagOfWord</code> allows to build a term-frequency pandas sparse dataframe with the <code>transform_many</code> method.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; X = pd.Series(['Hello world', 'Hello River'], index = ['river', 'rocks'])\n&gt;&gt;&gt; bow = fx.BagOfWords()\n&gt;&gt;&gt; bow.transform_many(X=X)\n       hello  world  river\nriver      1      1      0\nrocks      1      0      1\n</code></pre>"},{"location":"api/feature-extraction/BagOfWords/#methods","title":"Methods","text":"learn_many   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   process_text   transform_many <p>Transform pandas series of string into term-frequency pandas sparse dataframe.</p> <p>Parameters</p> <ul> <li>X     ('pd.Series')    </li> </ul>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-extraction/PolynomialExtender/","title":"PolynomialExtender","text":"<p>Polynomial feature extender.</p> <p>Generate features consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. </p> <p>Be aware that the number of outputted features scales polynomially in the number of input features and exponentially in the degree. High degrees can cause overfitting.</p>"},{"location":"api/feature-extraction/PolynomialExtender/#parameters","title":"Parameters","text":"<ul> <li> <p>degree \u2013 defaults to <code>2</code></p> <p>The maximum degree of the polynomial features.</p> </li> <li> <p>interaction_only \u2013 defaults to <code>False</code></p> <p>If <code>True</code> then only combinations that include an element at most once will be computed.</p> </li> <li> <p>include_bias \u2013 defaults to <code>False</code></p> <p>Whether or not to include a dummy feature which is always equal to 1.</p> </li> <li> <p>bias_name \u2013 defaults to <code>bias</code></p> <p>Name to give to the bias feature.</p> </li> </ul>"},{"location":"api/feature-extraction/PolynomialExtender/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import feature_extraction as fx\n\n&gt;&gt;&gt; X = [\n...     {'x': 0, 'y': 1},\n...     {'x': 2, 'y': 3},\n...     {'x': 4, 'y': 5}\n... ]\n\n&gt;&gt;&gt; poly = fx.PolynomialExtender(degree=2, include_bias=True)\n&gt;&gt;&gt; for x in X:\n...     print(poly.transform_one(x))\n{'x': 0, 'y': 1, 'x*x': 0, 'x*y': 0, 'y*y': 1, 'bias': 1}\n{'x': 2, 'y': 3, 'x*x': 4, 'x*y': 6, 'y*y': 9, 'bias': 1}\n{'x': 4, 'y': 5, 'x*x': 16, 'x*y': 20, 'y*y': 25, 'bias': 1}\n\n&gt;&gt;&gt; X = [\n...     {'x': 0, 'y': 1, 'z': 2},\n...     {'x': 2, 'y': 3, 'z': 2},\n...     {'x': 4, 'y': 5, 'z': 2}\n... ]\n\n&gt;&gt;&gt; poly = fx.PolynomialExtender(degree=3, interaction_only=True)\n&gt;&gt;&gt; for x in X:\n...     print(poly.transform_one(x))\n{'x': 0, 'y': 1, 'z': 2, 'x*y': 0, 'x*z': 0, 'y*z': 2, 'x*y*z': 0}\n{'x': 2, 'y': 3, 'z': 2, 'x*y': 6, 'x*z': 4, 'y*z': 6, 'x*y*z': 12}\n{'x': 4, 'y': 5, 'z': 2, 'x*y': 20, 'x*z': 8, 'y*z': 10, 'x*y*z': 40}\n</code></pre> <p>Polynomial features are typically used for a linear model to capture interactions between features. This may done by setting up a pipeline, as so:</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model as lm\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing as pp\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = (\n...     fx.PolynomialExtender() |\n...     pp.StandardScaler() |\n...     lm.LogisticRegression()\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 88.88%\n</code></pre>"},{"location":"api/feature-extraction/PolynomialExtender/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-extraction/RBFSampler/","title":"RBFSampler","text":"<p>Extracts random features which approximate an RBF kernel.</p> <p>This is a powerful way to give non-linear capacity to linear classifiers. This method is also called \"random Fourier features\" in the literature.</p>"},{"location":"api/feature-extraction/RBFSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>gamma \u2013 defaults to <code>1.0</code></p> <p>RBF kernel parameter in <code>(-gamma * x^2)</code>.</p> </li> <li> <p>n_components \u2013 defaults to <code>100</code></p> <p>Number of samples per original feature. Equals the dimensionality of the computed feature space.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number seed.</p> </li> </ul>"},{"location":"api/feature-extraction/RBFSampler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import feature_extraction as fx\n&gt;&gt;&gt; from river import linear_model as lm\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; # XOR function\n&gt;&gt;&gt; X = [[0, 0], [1, 1], [1, 0], [0, 1]]\n&gt;&gt;&gt; Y = [0, 0, 1, 1]\n\n&gt;&gt;&gt; model = lm.LogisticRegression(optimizer=optim.SGD(.1))\n\n&gt;&gt;&gt; for x, y in stream.iter_array(X, Y):\n...     model = model.learn_one(x, y)\n...     y_pred = model.predict_one(x)\n...     print(y, int(y_pred))\n0 0\n0 0\n1 0\n1 1\n\n&gt;&gt;&gt; model = (\n...     fx.RBFSampler(seed=3) |\n...     lm.LogisticRegression(optimizer=optim.SGD(.1))\n... )\n\n&gt;&gt;&gt; for x, y in stream.iter_array(X, Y):\n...     model = model.learn_one(x, y)\n...     y_pred = model.predict_one(x)\n...     print(y, int(y_pred))\n0 0\n0 0\n1 1\n1 1\n</code></pre>"},{"location":"api/feature-extraction/RBFSampler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-extraction/RBFSampler/#references","title":"References","text":"<ol> <li> <p>Rahimi, A. and Recht, B., 2008. Random features for large-scale kernel machines. In Advances in neural information processing systems (pp. 1177-1184 \u21a9</p> </li> </ol>"},{"location":"api/feature-extraction/TFIDF/","title":"TFIDF","text":"<p>Computes TF-IDF values from sentences.</p> <p>The TF-IDF formula is the same one as scikit-learn. The only difference is the fact that the document frequencies are determined online, whereas in a batch setting they can be determined by performing an initial pass through the data. </p> <p>Note that the parameters are identical to those of <code>feature_extraction.BagOfWords</code>.</p>"},{"location":"api/feature-extraction/TFIDF/#parameters","title":"Parameters","text":"<ul> <li> <p>normalize \u2013 defaults to <code>True</code></p> <p>Whether or not the TF-IDF values by their L2 norm.</p> </li> <li> <p>on ('str') \u2013 defaults to <code>None</code></p> <p>The name of the feature that contains the text to vectorize. If <code>None</code>, then the input is treated as a document instead of a set of features.</p> </li> <li> <p>strip_accents \u2013 defaults to <code>True</code></p> <p>Whether or not to strip accent characters.</p> </li> <li> <p>lowercase \u2013 defaults to <code>True</code></p> <p>Whether or not to convert all characters to lowercase.</p> </li> <li> <p>preprocessor ('typing.Callable') \u2013 defaults to <code>None</code></p> <p>An optional preprocessing function which overrides the <code>strip_accents</code> and <code>lowercase</code> steps, while preserving the tokenizing and n-grams generation steps.</p> </li> <li> <p>tokenizer ('typing.Callable') \u2013 defaults to <code>None</code></p> <p>A function used to convert preprocessed text into a <code>dict</code> of tokens. By default, a regex formula that works well in most cases is used.</p> </li> <li> <p>ngram_range \u2013 defaults to <code>(1, 1)</code></p> <p>The lower and upper boundary of the range n-grams to be extracted. All values of n such that <code>min_n &lt;= n &lt;= max_n</code> will be used. For example an <code>ngram_range</code> of <code>(1, 1)</code> means only unigrams, <code>(1, 2)</code> means unigrams and bigrams, and <code>(2, 2)</code> means only bigrams. Only works if <code>tokenizer</code> is not set to <code>False</code>.</p> </li> </ul>"},{"location":"api/feature-extraction/TFIDF/#attributes","title":"Attributes","text":"<ul> <li> <p>dfs (collections.defaultdict))</p> <p>Document counts.</p> </li> <li> <p>n (int)</p> <p>Number of scanned documents.</p> </li> </ul>"},{"location":"api/feature-extraction/TFIDF/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import feature_extraction\n\n&gt;&gt;&gt; tfidf = feature_extraction.TFIDF()\n\n&gt;&gt;&gt; corpus = [\n...     'This is the first document.',\n...     'This document is the second document.',\n...     'And this is the third one.',\n...     'Is this the first document?',\n... ]\n\n&gt;&gt;&gt; for sentence in corpus:\n...     tfidf = tfidf.learn_one(sentence)\n...     print(tfidf.transform_one(sentence))\n{'this': 0.447, 'is': 0.447, 'the': 0.447, 'first': 0.447, 'document': 0.447}\n{'this': 0.333, 'document': 0.667, 'is': 0.333, 'the': 0.333, 'second': 0.469}\n{'and': 0.497, 'this': 0.293, 'is': 0.293, 'the': 0.293, 'third': 0.497, 'one': 0.497}\n{'is': 0.384, 'this': 0.384, 'the': 0.384, 'first': 0.580, 'document': 0.469}\n</code></pre> <p>In the above example, a string is passed to <code>transform_one</code>. You can also indicate which field to access if the string is stored in a dictionary:</p> <pre><code>&gt;&gt;&gt; tfidf = feature_extraction.TFIDF(on='sentence')\n\n&gt;&gt;&gt; for sentence in corpus:\n...     x = {'sentence': sentence}\n...     tfidf = tfidf.learn_one(x)\n...     print(tfidf.transform_one(x))\n{'this': 0.447, 'is': 0.447, 'the': 0.447, 'first': 0.447, 'document': 0.447}\n{'this': 0.333, 'document': 0.667, 'is': 0.333, 'the': 0.333, 'second': 0.469}\n{'and': 0.497, 'this': 0.293, 'is': 0.293, 'the': 0.293, 'third': 0.497, 'one': 0.497}\n{'is': 0.384, 'this': 0.384, 'the': 0.384, 'first': 0.580, 'document': 0.469}\n</code></pre>"},{"location":"api/feature-extraction/TFIDF/#methods","title":"Methods","text":"learn_many   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   process_text   transform_many <p>Transform pandas series of string into term-frequency pandas sparse dataframe.</p> <p>Parameters</p> <ul> <li>X     ('pd.Series')    </li> </ul>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-extraction/TargetAgg/","title":"TargetAgg","text":"<p>Computes a streaming aggregate of the target values.</p> <p>This transformer is identical to <code>feature_extraction.Agg</code>, the only difference is that it operates on the target rather than on a feature. At each step, the running statistic <code>how</code> of target values in group <code>by</code> is updated with the target. It is therefore a supervised transformer.</p>"},{"location":"api/feature-extraction/TargetAgg/#parameters","title":"Parameters","text":"<ul> <li> <p>by (Union[str, List[str], NoneType])</p> <p>The feature by which to group the target values. All the data is included in the aggregate if this is <code>None</code>.</p> </li> <li> <p>how (river.stats.base.Univariate)</p> <p>The statistic to compute.</p> </li> <li> <p>target_name \u2013 defaults to <code>y</code></p> <p>The target name which is used in the result.</p> </li> </ul>"},{"location":"api/feature-extraction/TargetAgg/#attributes","title":"Attributes","text":"<ul> <li> <p>state</p> <p>Return the current values for each group as a series.</p> </li> <li> <p>target_name</p> </li> </ul>"},{"location":"api/feature-extraction/TargetAgg/#examples","title":"Examples","text":"<p>Consider the following dataset, where the second value of each value is the target:</p> <pre><code>&gt;&gt;&gt; dataset = [\n...     ({'country': 'France', 'place': 'Taco Bell'}, 42),\n...     ({'country': 'Sweden', 'place': 'Burger King'}, 16),\n...     ({'country': 'France', 'place': 'Burger King'}, 24),\n...     ({'country': 'Sweden', 'place': 'Taco Bell'}, 58),\n...     ({'country': 'Sweden', 'place': 'Burger King'}, 20),\n...     ({'country': 'France', 'place': 'Taco Bell'}, 50),\n...     ({'country': 'France', 'place': 'Burger King'}, 10),\n...     ({'country': 'Sweden', 'place': 'Taco Bell'}, 80)\n... ]\n</code></pre> <p>As an example, let's perform a target encoding of the <code>place</code> feature. Instead of simply updating a running average, we use a <code>stats.BayesianMean</code> which allows us to incorporate some prior knowledge. This makes subsequent models less prone to overfitting. Indeed, it dampens the fact that too few samples might have been seen within a group.</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; agg = feature_extraction.TargetAgg(\n...     by='place',\n...     how=stats.BayesianMean(\n...         prior=3,\n...         prior_weight=1\n...     )\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     print(agg.transform_one(x))\n...     agg = agg.learn_one(x, y)\n{'y_bayes_mean_by_place': 3.0}\n{'y_bayes_mean_by_place': 3.0}\n{'y_bayes_mean_by_place': 9.5}\n{'y_bayes_mean_by_place': 22.5}\n{'y_bayes_mean_by_place': 14.333}\n{'y_bayes_mean_by_place': 34.333}\n{'y_bayes_mean_by_place': 15.75}\n{'y_bayes_mean_by_place': 38.25}\n</code></pre> <p>Just like with <code>feature_extraction.Agg</code>, we can specify multiple features on which to group the data:</p> <pre><code>&gt;&gt;&gt; agg = feature_extraction.TargetAgg(\n...     by=['place', 'country'],\n...     how=stats.BayesianMean(\n...         prior=3,\n...         prior_weight=1\n...     )\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     print(agg.transform_one(x))\n...     agg = agg.learn_one(x, y)\n{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 9.5}\n{'y_bayes_mean_by_place_and_country': 22.5}\n{'y_bayes_mean_by_place_and_country': 13.5}\n{'y_bayes_mean_by_place_and_country': 30.5}\n\n&gt;&gt;&gt; agg.state\nplace        country\nTaco Bell    France     31.666667\nBurger King  Sweden     13.000000\n             France     12.333333\nTaco Bell    Sweden     47.000000\nName: y_bayes_mean_by_place_and_country, dtype: float64\n</code></pre>"},{"location":"api/feature-extraction/TargetAgg/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code> and a target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int, numbers.Number])    </li> </ul> <p>Returns</p> <p>SupervisedTransformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-extraction/TargetAgg/#references","title":"References","text":"<ol> <li>Streaming groupbys in pandas for big datasets</li> </ol>"},{"location":"api/feature-selection/PoissonInclusion/","title":"PoissonInclusion","text":"<p>Randomly selects features with an inclusion trial.</p> <p>When a new feature is encountered, it is selected with probability <code>p</code>. The number of times a feature needs to beseen before it is added to the model follows a geometric distribution with expected value <code>1 / p</code>. This feature selection method is meant to be used when you have a very large amount of sparse features.</p>"},{"location":"api/feature-selection/PoissonInclusion/#parameters","title":"Parameters","text":"<ul> <li> <p>p (float)</p> <p>Probability of including a feature the first time it is encountered.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed value used for reproducibility.</p> </li> </ul>"},{"location":"api/feature-selection/PoissonInclusion/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import feature_selection\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; selector = feature_selection.PoissonInclusion(p=0.1, seed=42)\n\n&gt;&gt;&gt; dataset = iter(datasets.TrumpApproval())\n\n&gt;&gt;&gt; feature_names = next(dataset)[0].keys()\n&gt;&gt;&gt; n = 0\n\n&gt;&gt;&gt; while True:\n...     x, y = next(dataset)\n...     xt = selector.transform_one(x)\n...     if xt.keys() == feature_names:\n...         break\n...     n += 1\n\n&gt;&gt;&gt; n\n12\n</code></pre>"},{"location":"api/feature-selection/PoissonInclusion/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-selection/PoissonInclusion/#references","title":"References","text":"<ol> <li> <p>McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9</p> </li> </ol>"},{"location":"api/feature-selection/SelectKBest/","title":"SelectKBest","text":"<p>Removes all but the \\(k\\) highest scoring features.</p>"},{"location":"api/feature-selection/SelectKBest/#parameters","title":"Parameters","text":"<ul> <li> <p>similarity (river.stats.base.Bivariate)</p> </li> <li> <p>k \u2013 defaults to <code>10</code></p> <p>The number of features to keep.</p> </li> </ul>"},{"location":"api/feature-selection/SelectKBest/#attributes","title":"Attributes","text":"<ul> <li> <p>similarities (dict)</p> <p>The similarity instances used for each feature.</p> </li> <li> <p>leaderboard (dict)</p> <p>The actual similarity measures.</p> </li> </ul>"},{"location":"api/feature-selection/SelectKBest/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; from river import feature_selection\n&gt;&gt;&gt; from river import stats\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; from sklearn import datasets\n\n&gt;&gt;&gt; X, y = datasets.make_regression(\n...     n_samples=100,\n...     n_features=10,\n...     n_informative=2,\n...     random_state=42\n... )\n\n&gt;&gt;&gt; selector = feature_selection.SelectKBest(\n...     similarity=stats.PearsonCorr(),\n...     k=2\n... )\n\n&gt;&gt;&gt; for xi, yi, in stream.iter_array(X, y):\n...     selector = selector.learn_one(xi, yi)\n\n&gt;&gt;&gt; pprint(selector.leaderboard)\nCounter({9: 0.7898,\n        7: 0.5444,\n        8: 0.1062,\n        2: 0.0638,\n        4: 0.0538,\n        5: 0.0271,\n        1: -0.0312,\n        6: -0.0657,\n        3: -0.1501,\n        0: -0.1895})\n\n&gt;&gt;&gt; selector.transform_one(xi)\n{7: -1.2795, 9: -1.8408}\n</code></pre>"},{"location":"api/feature-selection/SelectKBest/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code> and a target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int, numbers.Number])    </li> </ul> <p>Returns</p> <p>SupervisedTransformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/feature-selection/VarianceThreshold/","title":"VarianceThreshold","text":"<p>Removes low-variance features.</p>"},{"location":"api/feature-selection/VarianceThreshold/#parameters","title":"Parameters","text":"<ul> <li> <p>threshold \u2013 defaults to <code>0</code></p> <p>Only features with a variance above the threshold will be kept.</p> </li> <li> <p>min_samples \u2013 defaults to <code>2</code></p> <p>The minimum number of samples required to perform selection.</p> </li> </ul>"},{"location":"api/feature-selection/VarianceThreshold/#attributes","title":"Attributes","text":"<ul> <li> <p>variances (dict)</p> <p>The variance of each feature.</p> </li> </ul>"},{"location":"api/feature-selection/VarianceThreshold/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import feature_selection\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; X = [\n...     [0, 2, 0, 3],\n...     [0, 1, 4, 3],\n...     [0, 1, 1, 3]\n... ]\n\n&gt;&gt;&gt; selector = feature_selection.VarianceThreshold()\n\n&gt;&gt;&gt; for x, _ in stream.iter_array(X):\n...     print(selector.learn_one(x).transform_one(x))\n{0: 0, 1: 2, 2: 0, 3: 3}\n{1: 1, 2: 4}\n{1: 1, 2: 1}\n</code></pre>"},{"location":"api/feature-selection/VarianceThreshold/#methods","title":"Methods","text":"check_feature   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/imblearn/ChebyshevOverSampler/","title":"ChebyshevOverSampler","text":"<p>Over-sampling for imbalanced regression using Chebyshev's inequality.</p> <p>Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). </p> <p>Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\). For any real number \\(t &gt; 0\\), the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\). </p> <p>Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\), and assuming \\(t &gt; 1\\), the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\). </p> <p>Alternatively, one can use \\(t\\) directly to estimate a frequency weight \\(\\kappa = \\lceil t\\rceil\\) and define an over-sampling strategy for extreme and rare target values1. Each incoming instance is used \\(\\kappa\\) times to update the underlying regressor. Frequent target values contribute only once to the underlying regressor, whereas rares cases are used multiple times for training.</p>"},{"location":"api/imblearn/ChebyshevOverSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor (base.Regressor)</p> <p>The regression model that will receive the biased sample.</p> </li> </ul>"},{"location":"api/imblearn/ChebyshevOverSampler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import imblearn\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import rules\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     imblearn.ChebyshevOverSampler(\n...         regressor=rules.AMRules(\n...             n_min=50, delta=0.01\n...         )\n...     )\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     datasets.TrumpApproval(),\n...     model,\n...     metrics.MAE(),\n...     print_every=500\n... )\n[500] MAE: 1.682627\n[1,000] MAE: 1.761306\nMAE: 1.759576\n</code></pre>"},{"location":"api/imblearn/ChebyshevOverSampler/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/imblearn/ChebyshevOverSampler/#references","title":"References","text":"<ol> <li> <p>Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/imblearn/ChebyshevUnderSampler/","title":"ChebyshevUnderSampler","text":"<p>Under-sampling for imbalanced regression using Chebyshev's inequality.</p> <p>Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). </p> <p>Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\). For any real number \\(t &gt; 0\\), the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\). </p> <p>Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\), and assuming \\(t &gt; 1\\), the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\). The reciprocal of this probability is used for under-sampling1 the most frequent cases. Extreme valued or rare cases have higher probabilities of selection, whereas the most frequent cases are likely to be discarded. Still, frequent cases have a small chance of being selected (controlled via the <code>sp</code> parameter) in case few rare instances were observed.</p>"},{"location":"api/imblearn/ChebyshevUnderSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor (base.Regressor)</p> <p>The regression model that will receive the biased sample.</p> </li> <li> <p>sp (float) \u2013 defaults to <code>0.15</code></p> <p>Second chance probability. Even if an example is not initially selected for training, it still has a small chance of being selected in case the number of rare case observed so far is small.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed to support reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/ChebyshevUnderSampler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import imblearn\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import rules\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     imblearn.ChebyshevUnderSampler(\n...         regressor=rules.AMRules(\n...             n_min=50, delta=0.01,\n...         ),\n...         seed=42\n...     )\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     datasets.TrumpApproval(),\n...     model,\n...     metrics.MAE(),\n...     print_every=500\n... )\n[500] MAE: 1.787162\n[1,000] MAE: 1.515711\nMAE: 1.515236\n</code></pre>"},{"location":"api/imblearn/ChebyshevUnderSampler/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/imblearn/ChebyshevUnderSampler/#references","title":"References","text":"<ol> <li> <p>Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/imblearn/HardSamplingClassifier/","title":"HardSamplingClassifier","text":"<p>Hard sampling classifier.</p> <p>This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). </p> <p>The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place.</p>"},{"location":"api/imblearn/HardSamplingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier (base.Classifier)</p> </li> <li> <p>size (int)</p> <p>Size of the buffer.</p> </li> <li> <p>p (float)</p> <p>Probability of updating the model with a sample from the buffer instead of a new incoming sample.</p> </li> <li> <p>loss (Union[optim.losses.BinaryLoss, optim.losses.MultiClassLoss]) \u2013 defaults to <code>None</code></p> <p>Criterion used to evaluate the hardness of a sample.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed.</p> </li> </ul>"},{"location":"api/imblearn/HardSamplingClassifier/#attributes","title":"Attributes","text":"<ul> <li>classifier</li> </ul>"},{"location":"api/imblearn/HardSamplingClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import imblearn\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     imblearn.HardSamplingClassifier(\n...         classifier=linear_model.LogisticRegression(),\n...         p=0.1,\n...         size=40,\n...         seed=42,\n...     )\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     dataset=datasets.Phishing(),\n...     model=model,\n...     metric=metrics.ROCAUC(),\n...     print_every=500,\n... )\n[500] ROCAUC: 92.71%\n[1,000] ROCAUC: 94.75%\nROCAUC: 95.05%\n</code></pre>"},{"location":"api/imblearn/HardSamplingClassifier/#methods","title":"Methods","text":"learn_one   predict_one   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/imblearn/HardSamplingRegressor/","title":"HardSamplingRegressor","text":"<p>Hard sampling regressor.</p> <p>This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). </p> <p>The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place.</p>"},{"location":"api/imblearn/HardSamplingRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor (base.Regressor)</p> </li> <li> <p>size (int)</p> <p>Size of the buffer.</p> </li> <li> <p>p (float)</p> <p>Probability of updating the model with a sample from the buffer instead of a new incoming sample.</p> </li> <li> <p>loss (optim.losses.RegressionLoss) \u2013 defaults to <code>None</code></p> <p>Criterion used to evaluate the hardness of a sample.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed.</p> </li> </ul>"},{"location":"api/imblearn/HardSamplingRegressor/#attributes","title":"Attributes","text":"<ul> <li>regressor</li> </ul>"},{"location":"api/imblearn/HardSamplingRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import imblearn\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     imblearn.HardSamplingRegressor(\n...         regressor=linear_model.LinearRegression(),\n...         p=.2,\n...         size=30,\n...         seed=42,\n...     )\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     datasets.TrumpApproval(),\n...     model,\n...     metrics.MAE(),\n...     print_every=500\n... )\n[500] MAE: 2.292501\n[1,000] MAE: 1.395797\nMAE: 1.394693\n</code></pre>"},{"location":"api/imblearn/HardSamplingRegressor/#methods","title":"Methods","text":"learn_one   predict_one"},{"location":"api/imblearn/RandomOverSampler/","title":"RandomOverSampler","text":"<p>Random over-sampling.</p> <p>This is a wrapper for classifiers. It will train the provided classifier by over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of reverse rejection sampling. </p> <p>See Working with imbalanced data for example usage.</p>"},{"location":"api/imblearn/RandomOverSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier (base.Classifier)</p> </li> <li> <p>desired_dist (dict)</p> <p>The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/RandomOverSampler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import imblearn\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = imblearn.RandomOverSampler(\n...     (\n...         preprocessing.StandardScaler() |\n...         linear_model.LogisticRegression()\n...     ),\n...     desired_dist={False: 0.4, True: 0.6},\n...     seed=42\n... )\n\n&gt;&gt;&gt; dataset = datasets.CreditCard().take(3000)\n\n&gt;&gt;&gt; metric = metrics.LogLoss()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nLogLoss: 0.054338\n</code></pre>"},{"location":"api/imblearn/RandomOverSampler/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/imblearn/RandomSampler/","title":"RandomSampler","text":"<p>Random sampling by mixing under-sampling and over-sampling.</p> <p>This is a wrapper for classifiers. It will train the provided classifier by both under-sampling and over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. </p> <p>See Working with imbalanced data for example usage.</p>"},{"location":"api/imblearn/RandomSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier (base.Classifier)</p> </li> <li> <p>desired_dist (dict)</p> <p>The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. If set to <code>None</code>, then the observations will be sampled uniformly at random, which is stricly equivalent to using <code>ensemble.BaggingClassifier</code>.</p> </li> <li> <p>sampling_rate \u2013 defaults to <code>1.0</code></p> <p>The desired ratio of data to sample.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/RandomSampler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import imblearn\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = imblearn.RandomSampler(\n...     (\n...         preprocessing.StandardScaler() |\n...         linear_model.LogisticRegression()\n...     ),\n...     desired_dist={False: 0.4, True: 0.6},\n...     sampling_rate=0.8,\n...     seed=42\n... )\n\n&gt;&gt;&gt; dataset = datasets.CreditCard().take(3000)\n\n&gt;&gt;&gt; metric = metrics.LogLoss()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nLogLoss: 0.131988\n</code></pre>"},{"location":"api/imblearn/RandomSampler/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/imblearn/RandomUnderSampler/","title":"RandomUnderSampler","text":"<p>Random under-sampling.</p> <p>This is a wrapper for classifiers. It will train the provided classifier by under-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of rejection sampling. </p> <p>See Working with imbalanced data for example usage.</p>"},{"location":"api/imblearn/RandomUnderSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier (base.Classifier)</p> </li> <li> <p>desired_dist (dict)</p> <p>The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/RandomUnderSampler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import imblearn\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = imblearn.RandomUnderSampler(\n...     (\n...         preprocessing.StandardScaler() |\n...         linear_model.LogisticRegression()\n...     ),\n...     desired_dist={False: 0.4, True: 0.6},\n...     seed=42\n... )\n\n&gt;&gt;&gt; dataset = datasets.CreditCard().take(3000)\n\n&gt;&gt;&gt; metric = metrics.LogLoss()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nLogLoss: 0.0728\n</code></pre>"},{"location":"api/imblearn/RandomUnderSampler/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/imblearn/RandomUnderSampler/#references","title":"References","text":"<ol> <li> <p>Under-sampling a dataset with desired ratios \u21a9</p> </li> <li> <p>Wikipedia article on rejection sampling \u21a9</p> </li> </ol>"},{"location":"api/linear-model/ALMAClassifier/","title":"ALMAClassifier","text":"<p>Approximate Large Margin Algorithm (ALMA).</p>"},{"location":"api/linear-model/ALMAClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>p \u2013 defaults to <code>2</code></p> </li> <li> <p>alpha \u2013 defaults to <code>0.9</code></p> </li> <li> <p>B \u2013 defaults to <code>1.1111111111111112</code></p> </li> <li> <p>C \u2013 defaults to <code>1.4142135623730951</code></p> </li> </ul>"},{"location":"api/linear-model/ALMAClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>w (collections.defaultdict)</p> <p>The current weights.</p> </li> <li> <p>k (int)</p> <p>The number of instances seen during training.</p> </li> </ul>"},{"location":"api/linear-model/ALMAClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.ALMAClassifier()\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 82.64%\n</code></pre>"},{"location":"api/linear-model/ALMAClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/linear-model/ALMAClassifier/#references","title":"References","text":"<ol> <li> <p>Gentile, Claudio. \"A new approximate maximal margin classification algorithm.\" Journal of Machine Learning Research 2.Dec (2001): 213-242 \u21a9</p> </li> </ol>"},{"location":"api/linear-model/BayesianLinearRegression/","title":"BayesianLinearRegression","text":"<p>Bayesian linear regression.</p> <p>An advantage of Bayesian linear regression over standard linear regression is that features do not have to scaled beforehand. Another attractive property is that this flavor of linear regression is somewhat insensitive to its hyperparameters. Finally, this model can output instead a predictive distribution rather than just a point estimate. </p> <p>The downside is that the learning step runs in <code>O(n^2)</code> time, whereas the learning step of standard linear regression takes <code>O(n)</code> time.</p>"},{"location":"api/linear-model/BayesianLinearRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha \u2013 defaults to <code>1</code></p> <p>Prior parameter.</p> </li> <li> <p>beta \u2013 defaults to <code>1</code></p> <p>Noise parameter.</p> </li> </ul>"},{"location":"api/linear-model/BayesianLinearRegression/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; model = linear_model.BayesianLinearRegression()\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric).get()\n0.5818\n\n&gt;&gt;&gt; x, _ = next(iter(dataset))\n&gt;&gt;&gt; model.predict_one(x)\n43.61\n\n&gt;&gt;&gt; model.predict_one(x, with_dist=True)\n\ud835\udca9(\u03bc=43.616, \u03c3=1.003)\n</code></pre>"},{"location":"api/linear-model/BayesianLinearRegression/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>with_dist     \u2013 defaults to <code>False</code> </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/linear-model/BayesianLinearRegression/#references","title":"References","text":"<ol> <li> <p>Pattern Recognition and Machine Learning, page 52 \u2014 Christopher M. Bishop \u21a9</p> </li> <li> <p>Bayesian/Streaming Algorithms \u2014 Vincent Warmerdam \u21a9</p> </li> <li> <p>Bayesian linear regression for practitioners \u2014 Max Halford \u21a9</p> </li> </ol>"},{"location":"api/linear-model/LinearRegression/","title":"LinearRegression","text":"<p>Linear regression.</p> <p>This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: <code>learn_many</code>, <code>predict_many</code>, <code>predict_proba_many</code>. Each method takes as input a <code>pandas.DataFrame</code> where each column represents a feature. </p> <p>It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a <code>preprocessing.StandardScaler</code>.</p>"},{"location":"api/linear-model/LinearRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately.</p> </li> <li> <p>loss (optim.losses.RegressionLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2 \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>l1 \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>intercept_init \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[optim.base.Scheduler, float]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/LinearRegression/#attributes","title":"Attributes","text":"<ul> <li> <p>weights (dict)</p> <p>The current weights.</p> </li> </ul>"},{"location":"api/linear-model/LinearRegression/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LinearRegression(intercept_lr=.1)\n... )\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 0.555971\n\n&gt;&gt;&gt; model['LinearRegression'].intercept\n35.617670\n</code></pre> <p>You can call the <code>debug_one</code> method to break down a prediction. This works even if the linear regression is part of a pipeline.</p> <pre><code>&gt;&gt;&gt; x, y = next(iter(dataset))\n&gt;&gt;&gt; report = model.debug_one(x)\n&gt;&gt;&gt; print(report)\n0. Input\n--------\ngallup: 43.84321 (float)\nipsos: 46.19925 (float)\nmorning_consult: 48.31875 (float)\nordinal_date: 736389 (int)\nrasmussen: 44.10469 (float)\nyou_gov: 43.63691 (float)\n&lt;BLANKLINE&gt;\n1. StandardScaler\n-----------------\ngallup: 1.18810 (float)\nipsos: 2.10348 (float)\nmorning_consult: 2.73545 (float)\nordinal_date: -1.73032 (float)\nrasmussen: 1.26872 (float)\nyou_gov: 1.48391 (float)\n&lt;BLANKLINE&gt;\n2. LinearRegression\n-------------------\nName              Value      Weight      Contribution\n      Intercept    1.00000    35.61767       35.61767\n          ipsos    2.10348     0.62689        1.31866\nmorning_consult    2.73545     0.24180        0.66144\n         gallup    1.18810     0.43568        0.51764\n      rasmussen    1.26872     0.28118        0.35674\n        you_gov    1.48391     0.03123        0.04634\n   ordinal_date   -1.73032     3.45162       -5.97242\n&lt;BLANKLINE&gt;\nPrediction: 32.54607\n</code></pre>"},{"location":"api/linear-model/LinearRegression/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the linear regression.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>decimals     (int)     \u2013 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p>   learn_many <p>Update the model with a mini-batch of features <code>X</code> and real-valued targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)    </li> <li>w     (Union[float, pandas.core.series.Series])     \u2013 defaults to <code>1</code> </li> </ul> <p>Returns</p> <p>MiniBatchRegressor:     self</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>The predicted outcomes.</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/linear-model/LogisticRegression/","title":"LogisticRegression","text":"<p>Logistic regression.</p> <p>This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: <code>learn_many</code>, <code>predict_many</code>, <code>predict_proba_many</code>. Each method takes as input a <code>pandas.DataFrame</code> where each column represents a feature. </p> <p>It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a <code>preprocessing.StandardScaler</code>.</p>"},{"location":"api/linear-model/LogisticRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the weights. Note that the intercept is handled separately.</p> </li> <li> <p>loss (optim.losses.BinaryLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for. Defaults to <code>optim.losses.Log</code>.</p> </li> <li> <p>l2 \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>l1 \u2013 defaults to <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>intercept_init \u2013 defaults to <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr (Union[float, optim.base.Scheduler]) \u2013 defaults to <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/LogisticRegression/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights.</p> </li> </ul>"},{"location":"api/linear-model/LogisticRegression/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer=optim.SGD(.1))\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 88.96%\n</code></pre>"},{"location":"api/linear-model/LogisticRegression/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and boolean targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)    </li> <li>w     (Union[float, pandas.core.series.Series])     \u2013 defaults to <code>1</code> </li> </ul> <p>Returns</p> <p>MiniBatchClassifier:     self</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_many <p>Predict the outcome probabilities for each given sample.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul> <p>Returns</p> <p>DataFrame:     A dataframe with probabilities of <code>True</code> and <code>False</code> for each sample.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/linear-model/PAClassifier/","title":"PAClassifier","text":"<p>Passive-aggressive learning for classification.</p>"},{"location":"api/linear-model/PAClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>C \u2013 defaults to <code>1.0</code></p> </li> <li> <p>mode \u2013 defaults to <code>1</code></p> </li> <li> <p>learn_intercept \u2013 defaults to <code>True</code></p> </li> </ul>"},{"location":"api/linear-model/PAClassifier/#examples","title":"Examples","text":"<p>The following example is taken from this blog post.</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from sklearn import datasets\n&gt;&gt;&gt; from sklearn import model_selection\n\n&gt;&gt;&gt; np.random.seed(1000)\n&gt;&gt;&gt; X, y = datasets.make_classification(\n...     n_samples=5000,\n...     n_features=4,\n...     n_informative=2,\n...     n_redundant=0,\n...     n_repeated=0,\n...     n_classes=2,\n...     n_clusters_per_class=2\n... )\n\n&gt;&gt;&gt; X_train, X_test, y_train, y_test = model_selection.train_test_split(\n...     X,\n...     y,\n...     test_size=0.35,\n...     random_state=1000\n... )\n\n&gt;&gt;&gt; model = linear_model.PAClassifier(\n...     C=0.01,\n...     mode=1\n... )\n\n&gt;&gt;&gt; for xi, yi in stream.iter_array(X_train, y_train):\n...     y_pred = model.learn_one(xi, yi)\n\n&gt;&gt;&gt; metric = metrics.Accuracy() + metrics.LogLoss()\n\n&gt;&gt;&gt; for xi, yi in stream.iter_array(X_test, y_test):\n...     metric = metric.update(yi, model.predict_proba_one(xi))\n\n&gt;&gt;&gt; print(metric)\nAccuracy: 88.46%, LogLoss: 0.325727\n</code></pre>"},{"location":"api/linear-model/PAClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/linear-model/PAClassifier/#references","title":"References","text":"<ol> <li> <p>Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585 \u21a9</p> </li> </ol>"},{"location":"api/linear-model/PARegressor/","title":"PARegressor","text":"<p>Passive-aggressive learning for regression.</p>"},{"location":"api/linear-model/PARegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>C \u2013 defaults to <code>1.0</code></p> </li> <li> <p>mode \u2013 defaults to <code>1</code></p> </li> <li> <p>eps \u2013 defaults to <code>0.1</code></p> </li> <li> <p>learn_intercept \u2013 defaults to <code>True</code></p> </li> </ul>"},{"location":"api/linear-model/PARegressor/#examples","title":"Examples","text":"<p>The following example is taken from this blog post.</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from sklearn import datasets\n\n&gt;&gt;&gt; np.random.seed(1000)\n&gt;&gt;&gt; X, y = datasets.make_regression(n_samples=500, n_features=4)\n\n&gt;&gt;&gt; model = linear_model.PARegressor(\n...     C=0.01,\n...     mode=2,\n...     eps=0.1,\n...     learn_intercept=False\n... )\n&gt;&gt;&gt; metric = metrics.MAE() + metrics.MSE()\n\n&gt;&gt;&gt; for xi, yi in stream.iter_array(X, y):\n...     y_pred = model.predict_one(xi)\n...     model = model.learn_one(xi, yi)\n...     metric = metric.update(yi, y_pred)\n\n&gt;&gt;&gt; print(metric)\nMAE: 9.809402, MSE: 472.393532\n</code></pre>"},{"location":"api/linear-model/PARegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/linear-model/PARegressor/#references","title":"References","text":"<ol> <li> <p>Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585. \u21a9</p> </li> </ol>"},{"location":"api/linear-model/Perceptron/","title":"Perceptron","text":"<p>Perceptron classifier.</p> <p>In this implementation, the Perceptron is viewed as a special case of the logistic regression. The loss function that is used is the Hinge loss with a threshold set to 0, whilst the learning rate of the stochastic gradient descent procedure is set to 1 for both the weights and the intercept.</p>"},{"location":"api/linear-model/Perceptron/#parameters","title":"Parameters","text":"<ul> <li> <p>l2 \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/Perceptron/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights.</p> </li> </ul>"},{"location":"api/linear-model/Perceptron/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model as lm\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing as pp\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = pp.StandardScaler() | lm.Perceptron()\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 85.84%\n</code></pre>"},{"location":"api/linear-model/Perceptron/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and boolean targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)    </li> <li>w     (Union[float, pandas.core.series.Series])     \u2013 defaults to <code>1</code> </li> </ul> <p>Returns</p> <p>MiniBatchClassifier:     self</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_many <p>Predict the outcome probabilities for each given sample.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul> <p>Returns</p> <p>DataFrame:     A dataframe with probabilities of <code>True</code> and <code>False</code> for each sample.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/linear-model/SoftmaxRegression/","title":"SoftmaxRegression","text":"<p>Softmax regression is a generalization of logistic regression to multiple classes.</p> <p>Softmax regression is also known as \"multinomial logistic regression\". There are a set weights for each class, hence the <code>weights</code> attribute is a nested <code>collections.defaultdict</code>. The main advantage of using this instead of a one-vs-all logistic regression is that the probabilities will be calibrated. Moreover softmax regression is more robust to outliers.</p>"},{"location":"api/linear-model/SoftmaxRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used to tune the weights.</p> </li> <li> <p>loss (optim.losses.MultiClassLoss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2 \u2013 defaults to <code>0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> </ul>"},{"location":"api/linear-model/SoftmaxRegression/#attributes","title":"Attributes","text":"<ul> <li>weights (collections.defaultdict)</li> </ul>"},{"location":"api/linear-model/SoftmaxRegression/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.ImageSegments()\n\n&gt;&gt;&gt; model = preprocessing.StandardScaler()\n&gt;&gt;&gt; model |= linear_model.SoftmaxRegression()\n\n&gt;&gt;&gt; metric = metrics.MacroF1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMacroF1: 81.88%\n</code></pre>"},{"location":"api/linear-model/SoftmaxRegression/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/linear-model/SoftmaxRegression/#references","title":"References","text":"<ol> <li> <p>Course on classification stochastic gradient descent \u21a9</p> </li> <li> <p>Binary vs. Multi-Class Logistic Regression \u21a9</p> </li> </ol>"},{"location":"api/linear-model/base/GLM/","title":"GLM","text":"<p>Generalized Linear Model.</p> <p>This serves as a base class for linear and logistic regression.</p>"},{"location":"api/linear-model/base/GLM/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer</p> <p>The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately.</p> </li> <li> <p>loss</p> <p>The loss function to optimize for.</p> </li> <li> <p>l2</p> <p>Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>l1</p> <p>Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>intercept_init</p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient</p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer</p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/base/GLM/#attributes","title":"Attributes","text":"<ul> <li>weights</li> </ul>"},{"location":"api/linear-model/base/GLM/#methods","title":"Methods","text":"learn_many   learn_one"},{"location":"api/metrics/Accuracy/","title":"Accuracy","text":"<p>Accuracy score, which is the percentage of exact matches.</p>"},{"location":"api/metrics/Accuracy/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Accuracy/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Accuracy/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [True, False, True, True, True]\n&gt;&gt;&gt; y_pred = [True, True, False, True, True]\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nAccuracy: 60.00%\n</code></pre>"},{"location":"api/metrics/Accuracy/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/AdjustedMutualInfo/","title":"AdjustedMutualInfo","text":"<p>Adjusted Mutual Information between two clusterings.</p> <p>Adjusted Mutual Information (AMI) is an adjustment of the Mutual Information score that accounts for chance. It corrects the effect of agreement solely due to chance between clusterings, similar to the way the Adjusted Rand Index corrects the Rand Index. It is closely related to variation of information. The adjusted measure, however, is no longer metrical. </p> <p>For two clusterings \\(U\\) and \\(V\\), the Adjusted Mutual Information is calculated as: </p> \\[ AMI(U, V) = \\frac{MI(U, V) - E(MI(U, V))}{avg(H(U), H(V)) - E(MI(U, V))} \\] <p>This metric is independent of the permutation of the class or cluster label values; furthermore, it is also symmetric. This can be useful to measure the agreement of two label assignments strategies on the same dataset, regardless of the ground truth. </p> <p>However, due to the complexity of the Expected Mutual Info Score, the computation of this metric is an order of magnitude slower than most other metrics, in general.</p>"},{"location":"api/metrics/AdjustedMutualInfo/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>average_method \u2013 defaults to <code>arithmetic</code></p> <p>This parameter defines how to compute the normalizer in the denominator. Possible options include <code>min</code>, <code>max</code>, <code>arithmetic</code> and <code>geometric</code>.</p> </li> </ul>"},{"location":"api/metrics/AdjustedMutualInfo/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/AdjustedMutualInfo/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [1, 1, 2, 2, 3, 3]\n&gt;&gt;&gt; y_pred = [1, 1, 1, 2, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.AdjustedMutualInfo()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n1.0\n1.0\n0.0\n0.0\n0.105891\n0.298792\n\n&gt;&gt;&gt; metric\nAdjustedMutualInfo: 0.298792\n</code></pre>"},{"location":"api/metrics/AdjustedMutualInfo/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/AdjustedMutualInfo/#references","title":"References","text":"<ol> <li> <p>Wikipedia contributors. (2021, March 17). Mutual information.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Mutual_information&amp;oldid=1012714929\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/AdjustedRand/","title":"AdjustedRand","text":"<p>Adjusted Rand Index.</p> <p>The Adjusted Rand Index is the corrected-for-chance version of the Rand Index 1 2. Such a correction for chance establishes a baseline by using the expected similarity of all pair-wise comparisions between clusterings specified by a random model. </p> <p>Traditionally, the Rand Index was corrected using the Permutation Model for Clustering. However, the premises of the permutation model are frequently violated; in many clustering scenarios, either the number of clusters or the size distribution of those clusters vary drastically. Variations of the adjusted Rand Index account for different models of random clusterings. </p> <p>Though the Rand Index may only yield a value between 0 and 1, the Adjusted Rand index can yield negative values if the index is less than the expected index.</p>"},{"location":"api/metrics/AdjustedRand/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/AdjustedRand/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/AdjustedRand/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 0, 0, 1, 1, 1]\n&gt;&gt;&gt; y_pred = [0, 0, 1, 1, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.AdjustedRand()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n1.0\n1.0\n0.0\n0.0\n0.09090909090909091\n0.24242424242424243\n\n&gt;&gt;&gt; metric\nAdjustedRand: 0.242424\n</code></pre>"},{"location":"api/metrics/AdjustedRand/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/AdjustedRand/#references","title":"References","text":"<ol> <li> <p>Wikipedia contributors. (2021, January 13). Rand index.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Rand_index&amp;oldid=1000098911\u00a0\u21a9</p> </li> <li> <p>W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\".   Journal of the American Statistical Association. American Statistical Association.   66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/BalancedAccuracy/","title":"BalancedAccuracy","text":"<p>Balanced accuracy.</p> <p>Balanced accuracy is the average of recall obtained on each class. It is used to deal with imbalanced datasets in binary and multi-class classification problems.</p>"},{"location":"api/metrics/BalancedAccuracy/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/BalancedAccuracy/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/BalancedAccuracy/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; y_true = [True, False, True, True, False, True]\n&gt;&gt;&gt; y_pred = [True, False, True, True, True, False]\n\n&gt;&gt;&gt; metric = metrics.BalancedAccuracy()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nBalancedAccuracy: 62.50%\n\n&gt;&gt;&gt; y_true = [0, 1, 0, 0, 1, 0]\n&gt;&gt;&gt; y_pred = [0, 1, 0, 0, 0, 1]\n&gt;&gt;&gt; metric = metrics.BalancedAccuracy()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nBalancedAccuracy: 62.50%\n</code></pre>"},{"location":"api/metrics/BalancedAccuracy/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/ClassificationReport/","title":"ClassificationReport","text":"<p>A report for monitoring a classifier.</p> <p>This class maintains a set of metrics and updates each of them every time <code>update</code> is called. You can print this class at any time during a model's lifetime to get a tabular visualization of various metrics. </p> <p>You can wrap a <code>metrics.ClassificationReport</code> with <code>utils.Rolling</code> in order to obtain a classification report over a window of observations. You can also wrap it with <code>utils.TimeRolling</code> to obtain a report over a period of time.</p>"},{"location":"api/metrics/ClassificationReport/#parameters","title":"Parameters","text":"<ul> <li> <p>decimals \u2013 defaults to <code>2</code></p> <p>The number of decimals to display in each cell.</p> </li> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/ClassificationReport/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/ClassificationReport/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = ['pear', 'apple', 'banana', 'banana', 'banana']\n&gt;&gt;&gt; y_pred = ['apple', 'pear', 'banana', 'banana', 'apple']\n\n&gt;&gt;&gt; report = metrics.ClassificationReport()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     report = report.update(yt, yp)\n\n&gt;&gt;&gt; print(report)\n               Precision   Recall   F1       Support\n&lt;BLANKLINE&gt;\n   apple       0.00%    0.00%    0.00%         1\n  banana     100.00%   66.67%   80.00%         3\n    pear       0.00%    0.00%    0.00%         1\n&lt;BLANKLINE&gt;\n   Macro      33.33%   22.22%   26.67%\n   Micro      40.00%   40.00%   40.00%\nWeighted      60.00%   40.00%   48.00%\n&lt;BLANKLINE&gt;\n                 40.00% accuracy\n</code></pre>"},{"location":"api/metrics/ClassificationReport/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/CohenKappa/","title":"CohenKappa","text":"<p>Cohen's Kappa score.</p> <p>Cohen's Kappa expresses the level of agreement between two annotators on a classification problem. It is defined as </p> \\[ \\kappa = (p_o - p_e) / (1 - p_e) \\] <p>where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the expected agreement when both annotators assign labels randomly.</p>"},{"location":"api/metrics/CohenKappa/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/CohenKappa/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/CohenKappa/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = ['cat', 'ant', 'cat', 'cat', 'ant', 'bird']\n&gt;&gt;&gt; y_pred = ['ant', 'ant', 'cat', 'cat', 'ant', 'cat']\n\n&gt;&gt;&gt; metric = metrics.CohenKappa()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nCohenKappa: 42.86%\n</code></pre>"},{"location":"api/metrics/CohenKappa/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/CohenKappa/#references","title":"References","text":"<ol> <li> <p>J. Cohen (1960). \"A coefficient of agreement for nominal scales\". Educational and Psychological Measurement 20(1):37-46. doi:10.1177/001316446002000104.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Completeness/","title":"Completeness","text":"<p>Completeness Score.</p> <p>Completeness 1 is symmetrical to homogeneity. In order to satisfy the completeness criteria, a clustering must assign all of those datapoints that are members of a single class to a single cluster. To evaluate completeness, we examine the distribution cluster assignments within each class. In a perfectly complete clustering solution, each of these distributions will be completely skewed to a single cluster. </p> <p>We can evaluate this degree of skew by calculating the conditional entropy of the proposed cluster distribution given the class of the component data points. However, in the worst case scenario, each class is represented by every cluster with a distribution equal to the distribution of cluster sizes. Therefore, symmetric to the claculation above, we define completeness as: </p> \\[ c = \\begin{cases} 1 if H(K) = 0, \\\\ 1 - \\frac{H(K|C)}{H(K)} otherwise. \\end{cases}. \\]"},{"location":"api/metrics/Completeness/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Completeness/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Completeness/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [1, 1, 2, 2, 3, 3]\n&gt;&gt;&gt; y_pred = [1, 1, 1, 2, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.Completeness()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n1.0\n1.0\n1.0\n0.3836885465963443\n0.5880325916843805\n0.6666666666666667\n\n&gt;&gt;&gt; metric\nCompleteness: 66.67%\n</code></pre>"},{"location":"api/metrics/Completeness/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/Completeness/#references","title":"References","text":"<ol> <li> <p>Andrew Rosenberg and Julia Hirschberg (2007).   V-Measure: A conditional entropy-based external cluster evaluation measure.   Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language   Processing and Computational Natural Language Learning, pp. 410 - 420,   Prague, June 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/ConfusionMatrix/","title":"ConfusionMatrix","text":"<p>Confusion Matrix for binary and multi-class classification.</p>"},{"location":"api/metrics/ConfusionMatrix/#parameters","title":"Parameters","text":"<ul> <li> <p>classes \u2013 defaults to <code>None</code></p> <p>The initial set of classes. This is optional and serves only for displaying purposes.</p> </li> </ul>"},{"location":"api/metrics/ConfusionMatrix/#attributes","title":"Attributes","text":"<ul> <li> <p>classes</p> </li> <li> <p>total_false_negatives</p> </li> <li> <p>total_false_positives</p> </li> <li> <p>total_true_negatives</p> </li> <li> <p>total_true_positives</p> </li> </ul>"},{"location":"api/metrics/ConfusionMatrix/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = ['cat', 'ant', 'cat', 'cat', 'ant', 'bird']\n&gt;&gt;&gt; y_pred = ['ant', 'ant', 'cat', 'cat', 'ant', 'cat']\n\n&gt;&gt;&gt; cm = metrics.ConfusionMatrix()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     cm = cm.update(yt, yp)\n\n&gt;&gt;&gt; cm\n       ant  bird   cat\n ant     2     0     0\nbird     0     0     1\n cat     1     0     2\n\n&gt;&gt;&gt; cm['bird']['cat']\n1.0\n</code></pre>"},{"location":"api/metrics/ConfusionMatrix/#methods","title":"Methods","text":"false_negatives   false_positives   revert   support   true_negatives   true_positives   update"},{"location":"api/metrics/ConfusionMatrix/#notes","title":"Notes","text":"<p>This confusion matrix is a 2D matrix of shape <code>(n_classes, n_classes)</code>, corresponding to a single-target (binary and multi-class) classification task.</p> <p>Each row represents <code>true</code> (actual) class-labels, while each column corresponds to the <code>predicted</code> class-labels. For example, an entry in position <code>[1, 2]</code> means that the true class-label is 1, and the predicted class-label is 2 (incorrect prediction).</p> <p>This structure is used to keep updated statistics about a single-output classifier's performance and to compute multiple evaluation metrics.</p>"},{"location":"api/metrics/CrossEntropy/","title":"CrossEntropy","text":"<p>Multiclass generalization of the logarithmic loss.</p>"},{"location":"api/metrics/CrossEntropy/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/CrossEntropy/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2]\n&gt;&gt;&gt; y_pred = [\n...     {0: 0.29450637, 1: 0.34216758, 2: 0.36332605},\n...     {0: 0.21290077, 1: 0.32728332, 2: 0.45981591},\n...     {0: 0.42860913, 1: 0.33380113, 2: 0.23758974},\n...     {0: 0.44941979, 1: 0.32962558, 2: 0.22095463}\n... ]\n\n&gt;&gt;&gt; metric = metrics.CrossEntropy()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n...     print(metric.get())\n1.222454\n1.169691\n1.258864\n1.321597\n\n&gt;&gt;&gt; metric\nCrossEntropy: 1.321598\n</code></pre>"},{"location":"api/metrics/CrossEntropy/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/F1/","title":"F1","text":"<p>Binary F1 score.</p>"},{"location":"api/metrics/F1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/F1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/F1/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [False, False, False, True, True, True]\n&gt;&gt;&gt; y_pred = [False, False, True, True, False, False]\n\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nF1: 40.00%\n</code></pre>"},{"location":"api/metrics/F1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/FBeta/","title":"FBeta","text":"<p>Binary F-Beta score.</p> <p>The FBeta score is a weighted harmonic mean between precision and recall. The higher the <code>beta</code> value, the higher the recall will be taken into account. When <code>beta</code> equals 1, precision and recall and equivalently weighted, which results in the F1 score (see <code>metrics.F1</code>).</p>"},{"location":"api/metrics/FBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta (float)</p> <p>Weight of precision in the harmonic mean.</p> </li> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/FBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>precision (metrics.Precision)</p> </li> <li> <p>recall (metrics.Recall)</p> </li> </ul>"},{"location":"api/metrics/FBeta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [False, False, False, True, True, True]\n&gt;&gt;&gt; y_pred = [False, False, True, True, False, False]\n\n&gt;&gt;&gt; metric = metrics.FBeta(beta=2)\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nFBeta: 35.71%\n</code></pre>"},{"location":"api/metrics/FBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/FowlkesMallows/","title":"FowlkesMallows","text":"<p>Fowlkes-Mallows Index.</p> <p>The Fowlkes-Mallows Index 1 2 is an external evaluation method that is used to determine the similarity between two clusterings, and also a metric to measure confusion matrices. The measure of similarity could be either between two hierarchical clusterings or a clustering and a benchmark classification. A higher value for the Fowlkes-Mallows index indicates a greater similarity between the clusters and the benchmark classifications. </p> <p>The Fowlkes-Mallows Index, for two cluster algorithms, is defined as: </p> \\[ FM = \\sqrt{PPV \\times TPR} = \\sqrt{\\frac{TP}{TP+FP} \\times \\frac{TP}{TP+FN}} \\] <p>where </p> <ul> <li> <p>TP, FP, FN are respectively the number of true positives, false positives and false negatives; </p> </li> <li> <p>TPR is the True Positive Rate (or Sensitivity/Recall), PPV is the Positive Predictive Rate (or Precision).</p> </li> </ul>"},{"location":"api/metrics/FowlkesMallows/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/FowlkesMallows/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/FowlkesMallows/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 0, 0, 1, 1, 1]\n&gt;&gt;&gt; y_pred = [0, 0, 1, 1, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.FowlkesMallows()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nFowlkesMallows: 0.00%\nFowlkesMallows: 100.00%\nFowlkesMallows: 57.74%\nFowlkesMallows: 40.82%\nFowlkesMallows: 35.36%\nFowlkesMallows: 47.14%\n</code></pre>"},{"location":"api/metrics/FowlkesMallows/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/FowlkesMallows/#references","title":"References","text":"<ol> <li> <p>Wikipedia contributors. (2020, December 22).   Fowlkes\u2013Mallows index. In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Fowlkes%E2%80%93Mallows_index&amp;oldid=995714222\u00a0\u21a9</p> </li> <li> <p>E. B. Fowkles and C. L. Mallows (1983).   \u201cA method for comparing two hierarchical clusterings\u201d.   Journal of the American Statistical Association\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/GeometricMean/","title":"GeometricMean","text":"<p>Geometric mean score.</p> <p>The geometric mean is a good indicator of a classifier's performance in the presence of class imbalance because it is independent of the distribution of examples between classes. This implementation computes the geometric mean of class-wise sensitivity (recall). </p> \\[ gm = \\sqrt[n]{s_1\\cdot s_2\\cdot s_3\\cdot \\ldots\\cdot s_n} \\] <p>where \\(s_i\\) is the sensitivity (recall) of class \\(i\\) and \\(n\\) is the number of classes.</p>"},{"location":"api/metrics/GeometricMean/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/GeometricMean/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/GeometricMean/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = ['cat', 'ant', 'cat', 'cat', 'ant', 'bird', 'bird']\n&gt;&gt;&gt; y_pred = ['ant', 'ant', 'cat', 'cat', 'ant', 'cat', 'bird']\n\n&gt;&gt;&gt; metric = metrics.GeometricMean()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nGeometricMean: 69.34%\n</code></pre>"},{"location":"api/metrics/GeometricMean/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/GeometricMean/#references","title":"References","text":"<ol> <li> <p>Barandela, R. et al. \u201cStrategies for learning in class imbalance problems\u201d, Pattern Recognition, 36(3), (2003), pp 849-851.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Homogeneity/","title":"Homogeneity","text":"<p>Homogeneity Score.</p> <p>Homogeneity metric 1 of a cluster labeling given a ground truth. </p> <p>In order to satisfy the homogeneity criteria, a clustering must assign only those data points that are members of a single class to a single cluster. That is, the class distribution within each cluster should be skewed to a single class, that is, zero entropy. We determine how close a given clustering is to this ideal by examining the conditional entropy of the class distribution given the proposed clustering. </p> <p>However, in an imperfect situation, the size of this value is dependent on the size of the dataset and the distribution of class sizes. Therefore, instead of taking the raw conditional entropy, we normalize by the maximum reduction in entropy the clustering information could provide. </p> <p>As such, we define homogeneity as: </p> \\[ h = \\begin{cases} 1 if H(C) = 0, \\\\ 1 - \\frac{H(C|K)}{H(C)} otherwise. \\end{cases}. \\]"},{"location":"api/metrics/Homogeneity/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Homogeneity/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Homogeneity/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [1, 1, 2, 2, 3, 3]\n&gt;&gt;&gt; y_pred = [1, 1, 1, 2, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.Homogeneity()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n1.0\n1.0\n0.0\n0.311278\n0.37515\n0.42062\n\n&gt;&gt;&gt; metric\nHomogeneity: 42.06%\n</code></pre>"},{"location":"api/metrics/Homogeneity/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/Homogeneity/#references","title":"References","text":"<ol> <li> <p>Andrew Rosenberg and Julia Hirschberg (2007).   V-Measure: A conditional entropy-based external cluster evaluation measure.   Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language   Processing and Computational Natural Language Learning, pp. 410 - 420,   Prague, June 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Jaccard/","title":"Jaccard","text":"<p>Jaccard score.</p>"},{"location":"api/metrics/Jaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/Jaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Jaccard/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [False, True, True]\n&gt;&gt;&gt; y_pred = [True, True, True]\n\n&gt;&gt;&gt; metric = metrics.Jaccard()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nJaccard: 0.00%\nJaccard: 50.00%\nJaccard: 66.67%\n</code></pre>"},{"location":"api/metrics/Jaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/Jaccard/#references","title":"References","text":"<ol> <li> <p>Jaccard index \u21a9</p> </li> </ol>"},{"location":"api/metrics/LogLoss/","title":"LogLoss","text":"<p>Binary logarithmic loss.</p>"},{"location":"api/metrics/LogLoss/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/LogLoss/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [True, False, False, True]\n&gt;&gt;&gt; y_pred = [0.9,  0.1,   0.2,   0.65]\n\n&gt;&gt;&gt; metric = metrics.LogLoss()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n...     print(metric.get())\n0.105360\n0.105360\n0.144621\n0.216161\n\n&gt;&gt;&gt; metric\nLogLoss: 0.216162\n</code></pre>"},{"location":"api/metrics/LogLoss/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/MAE/","title":"MAE","text":"<p>Mean absolute error.</p>"},{"location":"api/metrics/MAE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MAE/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]\n&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n0.5\n0.5\n0.333\n0.5\n\n&gt;&gt;&gt; metric\nMAE: 0.5\n</code></pre>"},{"location":"api/metrics/MAE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/MCC/","title":"MCC","text":"<p>Matthews correlation coefficient.</p>"},{"location":"api/metrics/MCC/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/MCC/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MCC/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [True, True, True, False]\n&gt;&gt;&gt; y_pred = [True, False, True, True]\n\n&gt;&gt;&gt; mcc = metrics.MCC()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     mcc = mcc.update(yt, yp)\n\n&gt;&gt;&gt; mcc\nMCC: -0.333333\n</code></pre>"},{"location":"api/metrics/MCC/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MCC/#references","title":"References","text":"<ol> <li> <p>Wikipedia article \u21a9</p> </li> </ol>"},{"location":"api/metrics/MSE/","title":"MSE","text":"<p>Mean squared error.</p>"},{"location":"api/metrics/MSE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MSE/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]\n&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]\n\n&gt;&gt;&gt; metric = metrics.MSE()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n0.25\n0.25\n0.1666\n0.375\n</code></pre>"},{"location":"api/metrics/MSE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/MacroF1/","title":"MacroF1","text":"<p>Macro-average F1 score.</p> <p>This works by computing the F1 score per class, and then performs a global average.</p>"},{"location":"api/metrics/MacroF1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroF1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroF1/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MacroF1()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMacroF1: 100.00%\nMacroF1: 33.33%\nMacroF1: 55.56%\nMacroF1: 55.56%\nMacroF1: 48.89%\n</code></pre>"},{"location":"api/metrics/MacroF1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MacroFBeta/","title":"MacroFBeta","text":"<p>Macro-average F-Beta score.</p> <p>This works by computing the F-Beta score per class, and then performs a global average.</p>"},{"location":"api/metrics/MacroFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta</p> <p>Weight of precision in harmonic mean.</p> </li> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroFBeta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MacroFBeta(beta=.8)\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMacroFBeta: 100.00%\nMacroFBeta: 31.06%\nMacroFBeta: 54.04%\nMacroFBeta: 54.04%\nMacroFBeta: 48.60%\n</code></pre>"},{"location":"api/metrics/MacroFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MacroJaccard/","title":"MacroJaccard","text":"<p>Macro-average Jaccard score.</p>"},{"location":"api/metrics/MacroJaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroJaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroJaccard/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MacroJaccard()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMacroJaccard: 100.00%\nMacroJaccard: 25.00%\nMacroJaccard: 50.00%\nMacroJaccard: 50.00%\nMacroJaccard: 38.89%\n</code></pre>"},{"location":"api/metrics/MacroJaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MacroPrecision/","title":"MacroPrecision","text":"<p>Macro-average precision score.</p>"},{"location":"api/metrics/MacroPrecision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroPrecision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroPrecision/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MacroPrecision()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMacroPrecision: 100.00%\nMacroPrecision: 25.00%\nMacroPrecision: 50.00%\nMacroPrecision: 50.00%\nMacroPrecision: 50.00%\n</code></pre>"},{"location":"api/metrics/MacroPrecision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MacroRecall/","title":"MacroRecall","text":"<p>Macro-average recall score.</p>"},{"location":"api/metrics/MacroRecall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroRecall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroRecall/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MacroRecall()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMacroRecall: 100.00%\nMacroRecall: 50.00%\nMacroRecall: 66.67%\nMacroRecall: 66.67%\nMacroRecall: 55.56%\n</code></pre>"},{"location":"api/metrics/MacroRecall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MicroF1/","title":"MicroF1","text":"<p>Micro-average F1 score.</p> <p>This computes the F1 score by merging all the predictions and true labels, and then computes a global F1 score.</p>"},{"location":"api/metrics/MicroF1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroF1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroF1/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 0]\n&gt;&gt;&gt; y_pred = [0, 1, 1, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MicroF1()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nMicroF1: 60.00%\n</code></pre>"},{"location":"api/metrics/MicroF1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MicroF1/#references","title":"References","text":"<ol> <li> <p>Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9</p> </li> </ol>"},{"location":"api/metrics/MicroFBeta/","title":"MicroFBeta","text":"<p>Micro-average F-Beta score.</p> <p>This computes the F-Beta score by merging all the predictions and true labels, and then computes a global F-Beta score.</p>"},{"location":"api/metrics/MicroFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta (float)</p> <p>Weight of precision in the harmonic mean.</p> </li> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroFBeta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 0]\n&gt;&gt;&gt; y_pred = [0, 1, 1, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MicroFBeta(beta=2)\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nMicroFBeta: 60.00%\n</code></pre>"},{"location":"api/metrics/MicroFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MicroFBeta/#references","title":"References","text":"<ol> <li>Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem?</li> </ol>"},{"location":"api/metrics/MicroJaccard/","title":"MicroJaccard","text":"<p>Micro-average Jaccard score.</p>"},{"location":"api/metrics/MicroJaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroJaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroJaccard/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MicroJaccard()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMicroJaccard: 100.00%\nMicroJaccard: 33.33%\nMicroJaccard: 50.00%\nMicroJaccard: 60.00%\nMicroJaccard: 42.86%\n</code></pre>"},{"location":"api/metrics/MicroJaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MicroPrecision/","title":"MicroPrecision","text":"<p>Micro-average precision score.</p> <p>The micro-average precision score is exactly equivalent to the micro-average recall as well as the micro-average F1 score.</p>"},{"location":"api/metrics/MicroPrecision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroPrecision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroPrecision/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MicroPrecision()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMicroPrecision: 100.00%\nMicroPrecision: 50.00%\nMicroPrecision: 66.67%\nMicroPrecision: 75.00%\nMicroPrecision: 60.00%\n</code></pre>"},{"location":"api/metrics/MicroPrecision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MicroPrecision/#references","title":"References","text":"<ol> <li> <p>Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9</p> </li> </ol>"},{"location":"api/metrics/MicroRecall/","title":"MicroRecall","text":"<p>Micro-average recall score.</p> <p>The micro-average recall is exactly equivalent to the micro-average precision as well as the micro-average F1 score.</p>"},{"location":"api/metrics/MicroRecall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroRecall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroRecall/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MicroRecall()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMicroRecall: 100.00%\nMicroRecall: 50.00%\nMicroRecall: 66.67%\nMicroRecall: 75.00%\nMicroRecall: 60.00%\n</code></pre>"},{"location":"api/metrics/MicroRecall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MicroRecall/#references","title":"References","text":"<ol> <li> <p>Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9</p> </li> </ol>"},{"location":"api/metrics/MultiFBeta/","title":"MultiFBeta","text":"<p>Multi-class F-Beta score with different betas per class.</p> <p>The multiclass F-Beta score is the arithmetic average of the binary F-Beta scores of each class. The mean can be weighted by providing class weights.</p>"},{"location":"api/metrics/MultiFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>betas</p> <p>Weight of precision in the harmonic mean of each class.</p> </li> <li> <p>weights</p> <p>Class weights. If not provided then uniform weights will be used.</p> </li> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MultiFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MultiFBeta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.MultiFBeta(\n...     betas={0: 0.25, 1: 1, 2: 4},\n...     weights={0: 1, 1: 1, 2: 2}\n... )\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nMultiFBeta: 100.00%\nMultiFBeta: 25.76%\nMultiFBeta: 62.88%\nMultiFBeta: 62.88%\nMultiFBeta: 46.88%\n</code></pre>"},{"location":"api/metrics/MultiFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MutualInfo/","title":"MutualInfo","text":"<p>Mutual Information between two clusterings.</p> <p>The Mutual Information 1 is a measure of the similarity between two labels of the same data. Where \\(|U_i|\\) is the number of samples in cluster \\(U_i\\) and \\(|V_j|\\) is the number of the samples in cluster \\(V_j\\), the Mutual Information between clusterings \\(U\\) and \\(V\\) can be calculated as: </p> \\[ MI(U,V) = \\sum_{i=1}^{|U|} \\sum_{v=1}^{|V|} \\frac{|U_i \\cup V_j|}{N} \\log \\frac{N |U_i \\cup V_j|}{|U_i| |V_j|} \\] <p>This metric is independent of the absolute values of the labels: a permutation of the class or cluster label values won't change the score. </p> <p>This metric is furthermore symmetric: switching <code>y_true</code> and <code>y_pred</code> will return the same score value. This can be useful to measure the agreement of two independent label assignments strategies on the same dataset when the real ground truth is not known. </p> <p>The Mutual Information can be equivalently expressed as: </p> \\[ MI(U,V) = H(U) - H(U | V) = H(V) - H(V | U) \\] <p>where \\(H(U)\\) and \\(H(V)\\) are the marginal entropies, \\(H(U | V)\\) and \\(H(V | U)\\) are the conditional entropies.</p>"},{"location":"api/metrics/MutualInfo/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MutualInfo/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MutualInfo/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [1, 1, 2, 2, 3, 3]\n&gt;&gt;&gt; y_pred = [1, 1, 1, 2, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.MutualInfo()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n0.0\n0.0\n0.0\n0.215761\n0.395752\n0.462098\n\n&gt;&gt;&gt; metric\nMutualInfo: 0.462098\n</code></pre>"},{"location":"api/metrics/MutualInfo/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/MutualInfo/#references","title":"References","text":"<ol> <li> <p>Wikipedia contributors. (2021, March 17). Mutual information.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Mutual_information&amp;oldid=1012714929\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/NormalizedMutualInfo/","title":"NormalizedMutualInfo","text":"<p>Normalized Mutual Information between two clusterings.</p> <p>Normalized Mutual Information (NMI) is a normalized version of the Mutual Information (MI) score to scale the results between the range of 0 (no mutual information) and 1 (perfectly mutual information). In the formula, the mutual information will be normalized by a generalized mean of the entropy of true and predicted labels, defined by the <code>average_method</code>. </p> <p>We note that this measure is not adjusted for chance (i.e corrected the effect of result agreement solely due to chance); as a result, the Adjusted Mutual Info Score will mostly be preferred. However, this metric is still symmetric, which means that switching true and predicted labels will not alter the score value. This fact can be useful when the metric is used to measure the agreement between two indepedent label solutions on the same dataset, when the ground truth remains unknown. </p> <p>Another advantage of the metric is that as it is based on the calculation of entropy-related measures, it is independent of the permutation of class/cluster labels.</p>"},{"location":"api/metrics/NormalizedMutualInfo/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>average_method \u2013 defaults to <code>arithmetic</code></p> <p>This parameter defines how to compute the normalizer in the denominator. Possible options include <code>min</code>, <code>max</code>, <code>arithmetic</code> and <code>geometric</code>.</p> </li> </ul>"},{"location":"api/metrics/NormalizedMutualInfo/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/NormalizedMutualInfo/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [1, 1, 2, 2, 3, 3]\n&gt;&gt;&gt; y_pred = [1, 1, 1, 2, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.NormalizedMutualInfo()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n1.0\n1.0\n0.0\n0.343711\n0.458065\n0.515803\n\n&gt;&gt;&gt; metric\nNormalizedMutualInfo: 0.515804\n</code></pre>"},{"location":"api/metrics/NormalizedMutualInfo/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/NormalizedMutualInfo/#references","title":"References","text":"<ol> <li> <p>Wikipedia contributors. (2021, March 17). Mutual information.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Mutual_information&amp;oldid=1012714929\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Precision/","title":"Precision","text":"<p>Binary precision score.</p>"},{"location":"api/metrics/Precision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/Precision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Precision/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [True, False, True, True, True]\n&gt;&gt;&gt; y_pred = [True, True, False, True, True]\n\n&gt;&gt;&gt; metric = metrics.Precision()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nPrecision: 100.00%\nPrecision: 50.00%\nPrecision: 50.00%\nPrecision: 66.67%\nPrecision: 75.00%\n</code></pre>"},{"location":"api/metrics/Precision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/R2/","title":"R2","text":"<p>Coefficient of determination (\\(R^2\\)) score</p> <p>The coefficient of determination, denoted \\(R^2\\) or \\(r^2\\), is the proportion of the variance in the dependent variable that is predictable from the independent variable(s). 1 </p> <p>Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of \\(y\\), disregarding the input features, would get a \\(R^2\\) score of 0.0. </p> <p>\\(R^2\\) is not defined when less than 2 samples have been observed. This implementation returns 0.0 in this case.</p>"},{"location":"api/metrics/R2/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/R2/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]\n&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]\n\n&gt;&gt;&gt; metric = metrics.R2()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n0.0\n0.9183\n0.9230\n0.9486\n</code></pre>"},{"location":"api/metrics/R2/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/R2/#references","title":"References","text":"<ol> <li> <p>Coefficient of determination (Wikipedia) \u21a9</p> </li> </ol>"},{"location":"api/metrics/RMSE/","title":"RMSE","text":"<p>Root mean squared error.</p>"},{"location":"api/metrics/RMSE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/RMSE/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]\n&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]\n\n&gt;&gt;&gt; metric = metrics.RMSE()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n0.5\n0.5\n0.408248\n0.612372\n\n&gt;&gt;&gt; metric\nRMSE: 0.612372\n</code></pre>"},{"location":"api/metrics/RMSE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/RMSLE/","title":"RMSLE","text":"<p>Root mean squared logarithmic error.</p>"},{"location":"api/metrics/RMSLE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/RMSLE/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]\n&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]\n\n&gt;&gt;&gt; metric = metrics.RMSLE()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nRMSLE: 0.357826\n</code></pre>"},{"location":"api/metrics/RMSLE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/ROCAUC/","title":"ROCAUC","text":"<p>Receiving Operating Characteristic Area Under the Curve.</p> <p>This metric is an approximation of the true ROC AUC. Computing the true ROC AUC would require storing all the predictions and ground truths, which isn't desirable. The approximation error is not significant as long as the predicted probabilities are well calibrated. In any case, this metric can still be used to reliably compare models between each other.</p>"},{"location":"api/metrics/ROCAUC/#parameters","title":"Parameters","text":"<ul> <li> <p>n_thresholds \u2013 defaults to <code>10</code></p> <p>The number of thresholds used for discretizing the ROC curve. A higher value will lead to more accurate results, but will also cost more time and memory.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/ROCAUC/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/ROCAUC/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [ 0,  0,   1,  1]\n&gt;&gt;&gt; y_pred = [.1, .4, .35, .8]\n\n&gt;&gt;&gt; metric = metrics.ROCAUC()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nROCAUC: 87.50%\n</code></pre> <p>The true ROC AUC is in fact 0.75. We can improve the accuracy by increasing the amount of thresholds. This comes at the cost more computation time and more memory usage.</p> <pre><code>&gt;&gt;&gt; metric = metrics.ROCAUC(n_thresholds=20)\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nROCAUC: 75.00%\n</code></pre>"},{"location":"api/metrics/ROCAUC/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/Rand/","title":"Rand","text":"<p>Rand Index.</p> <p>The Rand Index 1 2 is a measure of the similarity between two data clusterings. Given a set of elements <code>S</code> and two partitions of <code>S</code> to compare, <code>X</code> and <code>Y</code>, define the following: </p> <ul> <li> <p>a, the number of pairs of elements in <code>S</code> that are in the same subset in <code>X</code> and in the same subset in <code>Y</code> </p> </li> <li> <p>b, the number of pairs of elements in <code>S</code> that are in the different subset in <code>X</code> and in different subsets in <code>Y</code> </p> </li> <li> <p>c, the number of pairs of elements in <code>S</code> that are in the same subset in <code>X</code> and in different subsets in <code>Y</code> </p> </li> <li> <p>d, the number of pairs of elements in <code>S</code> that are in the different subset in <code>X</code> and in the same subset in <code>Y</code> </p> </li> </ul> <p>The Rand index, R, is </p> \\[ R = \frac{a+b}{a+b+c+d} = \frac{a+b}{\frac{n(n-1)}{2}}. \\]"},{"location":"api/metrics/Rand/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Rand/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Rand/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 0, 0, 1, 1, 1]\n&gt;&gt;&gt; y_pred = [0, 0, 1, 1, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.Rand()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nRand: 0.666667\n</code></pre>"},{"location":"api/metrics/Rand/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/Rand/#references","title":"References","text":"<ol> <li> <p>Wikipedia contributors. (2021, January 13). Rand index.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Rand_index&amp;oldid=1000098911\u00a0\u21a9</p> </li> <li> <p>W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\".   Journal of the American Statistical Association. American Statistical Association.   66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Recall/","title":"Recall","text":"<p>Binary recall score.</p>"},{"location":"api/metrics/Recall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/Recall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Recall/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [True, False, True, True, True]\n&gt;&gt;&gt; y_pred = [True, True, False, True, True]\n\n&gt;&gt;&gt; metric = metrics.Recall()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nRecall: 100.00%\nRecall: 100.00%\nRecall: 50.00%\nRecall: 66.67%\nRecall: 75.00%\n</code></pre>"},{"location":"api/metrics/Recall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/SMAPE/","title":"SMAPE","text":"<p>Symmetric mean absolute percentage error.</p>"},{"location":"api/metrics/SMAPE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/SMAPE/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 0.07533, 0.07533, 0.07533, 0.07533, 0.07533, 0.07533, 0.0672, 0.0672]\n&gt;&gt;&gt; y_pred = [0, 0.102, 0.107, 0.047, 0.1, 0.032, 0.047, 0.108, 0.089]\n\n&gt;&gt;&gt; metric = metrics.SMAPE()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nSMAPE: 37.869392\n</code></pre>"},{"location":"api/metrics/SMAPE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/Silhouette/","title":"Silhouette","text":"<p>Silhouette coefficient 1, roughly speaking, is the ratio between cohesion and the average distances from the points to their second-closest centroid. It rewards the clustering algorithm where points are very close to their assigned centroids and far from any other centroids, that is, clustering results with good cohesion and good separation.</p> <p>It rewards clusterings where points are very close to their assigned centroids and far from any other centroids, that is clusterings with good cohesion and good separation. 2 </p> <p>The definition of Silhouette coefficient for online clustering evaluation is different from that of batch learning. It does not store information and calculate pairwise distances between all points at the same time, since the practice is too expensive for an incremental metric.</p>"},{"location":"api/metrics/Silhouette/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicates if a high value is better than a low one or not.</p> </li> </ul>"},{"location":"api/metrics/Silhouette/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import cluster\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; X = [\n...     [1, 2],\n...     [1, 4],\n...     [1, 0],\n...     [4, 2],\n...     [4, 4],\n...     [4, 0],\n...     [-2, 2],\n...     [-2, 4],\n...     [-2, 0]\n... ]\n\n&gt;&gt;&gt; k_means = cluster.KMeans(n_clusters=3, halflife=0.4, sigma=3, seed=0)\n&gt;&gt;&gt; metric = metrics.Silhouette()\n\n&gt;&gt;&gt; for x, _ in stream.iter_array(X):\n...     k_means = k_means.learn_one(x)\n...     y_pred = k_means.predict_one(x)\n...     metric = metric.update(x, y_pred, k_means.centers)\n\n&gt;&gt;&gt; metric\nSilhouette: 0.32145\n</code></pre>"},{"location":"api/metrics/Silhouette/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>x </li> <li>y_pred </li> <li>centers </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>x </li> <li>y_pred </li> <li>centers </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/Silhouette/#references","title":"References","text":"<ol> <li> <p>Rousseeuw, P. (1987). Silhouettes: a graphical aid to the intepretation and validation   of cluster analysis 20, 53 - 65. DOI: 10.1016/0377-0427(87)90125-7\u00a0\u21a9</p> </li> <li> <p>Bifet, A. et al. (2018). \"Machine Learning for Data Streams\".   DOI: 10.7551/mitpress/10654.001.0001.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/VBeta/","title":"VBeta","text":"<p>VBeta.</p> <p>VBeta (or V-Measure) 1 is an external entropy-based cluster evaluation measure. It provides an elegant solution to many problems that affect previously defined cluster evaluation measures including </p> <ul> <li> <p>Dependance of clustering algorithm or dataset, </p> </li> <li> <p>The \"problem of matching\", where the clustering of only a portion of data points are evaluated, and </p> </li> <li> <p>Accurate evaluation and combination of two desirable aspects of clustering, homogeneity and completeness. </p> </li> </ul> <p>Based upon the calculations of homogeneity and completeness, a clustering solution's V-measure is calculated by computing the weighted harmonic mean of homogeneity and completeness, </p> \\[ V_{\\beta} = \\frac{(1 + \\beta) \\times h \\times c}{\\beta \\times h + c}. \\]"},{"location":"api/metrics/VBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta (float) \u2013 defaults to <code>1.0</code></p> <p>Weight of Homogeneity in the harmonic mean.</p> </li> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/VBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/VBeta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [1, 1, 2, 2, 3, 3]\n&gt;&gt;&gt; y_pred = [1, 1, 1, 2, 2, 2]\n\n&gt;&gt;&gt; metric = metrics.VBeta(beta=1.0)\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp).get())\n1.0\n1.0\n0.0\n0.3437110184854507\n0.4580652856440158\n0.5158037429793888\n\n&gt;&gt;&gt; metric\nVBeta: 51.58%\n</code></pre>"},{"location":"api/metrics/VBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/VBeta/#references","title":"References","text":"<ol> <li> <p>Andrew Rosenberg and Julia Hirschberg (2007).   V-Measure: A conditional entropy-based external cluster evaluation measure.   Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language   Processing and Computational Natural Language Learning, pp. 410 - 420,   Prague, June 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/WeightedF1/","title":"WeightedF1","text":"<p>Weighted-average F1 score.</p> <p>This works by computing the F1 score per class, and then performs a global weighted average by using the support of each class.</p>"},{"location":"api/metrics/WeightedF1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedF1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedF1/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.WeightedF1()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nWeightedF1: 100.00%\nWeightedF1: 33.33%\nWeightedF1: 55.56%\nWeightedF1: 66.67%\nWeightedF1: 61.33%\n</code></pre>"},{"location":"api/metrics/WeightedF1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/WeightedFBeta/","title":"WeightedFBeta","text":"<p>Weighted-average F-Beta score.</p> <p>This works by computing the F-Beta score per class, and then performs a global weighted average according to the support of each class.</p>"},{"location":"api/metrics/WeightedFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta</p> <p>Weight of precision in the harmonic mean.</p> </li> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedFBeta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.WeightedFBeta(beta=0.8)\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nWeightedFBeta: 100.00%\nWeightedFBeta: 31.06%\nWeightedFBeta: 54.04%\nWeightedFBeta: 65.53%\nWeightedFBeta: 62.63%\n</code></pre>"},{"location":"api/metrics/WeightedFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/WeightedJaccard/","title":"WeightedJaccard","text":"<p>Weighted average Jaccard score.</p>"},{"location":"api/metrics/WeightedJaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedJaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedJaccard/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.WeightedJaccard()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nWeightedJaccard: 100.00%\nWeightedJaccard: 25.00%\nWeightedJaccard: 50.00%\nWeightedJaccard: 62.50%\nWeightedJaccard: 50.00%\n</code></pre>"},{"location":"api/metrics/WeightedJaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/WeightedPrecision/","title":"WeightedPrecision","text":"<p>Weighted-average precision score.</p> <p>This uses the support of each label to compute an average score, whereas <code>metrics.MacroPrecision</code> ignores the support.</p>"},{"location":"api/metrics/WeightedPrecision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedPrecision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedPrecision/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.WeightedPrecision()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nWeightedPrecision: 100.00%\nWeightedPrecision: 25.00%\nWeightedPrecision: 50.00%\nWeightedPrecision: 62.50%\nWeightedPrecision: 70.00%\n</code></pre>"},{"location":"api/metrics/WeightedPrecision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/WeightedRecall/","title":"WeightedRecall","text":"<p>Weighted-average recall score.</p> <p>This uses the support of each label to compute an average score, whereas <code>MacroRecall</code> ignores the support.</p>"},{"location":"api/metrics/WeightedRecall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedRecall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedRecall/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2, 2]\n&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 1]\n\n&gt;&gt;&gt; metric = metrics.WeightedRecall()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(metric.update(yt, yp))\nWeightedRecall: 100.00%\nWeightedRecall: 50.00%\nWeightedRecall: 66.67%\nWeightedRecall: 75.00%\nWeightedRecall: 60.00%\n</code></pre>"},{"location":"api/metrics/WeightedRecall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/base/BinaryMetric/","title":"BinaryMetric","text":"<p>Mother class for all binary classification metrics.</p>"},{"location":"api/metrics/base/BinaryMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val \u2013 defaults to <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/base/BinaryMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/BinaryMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (bool)    </li> <li>y_pred     (Union[bool, float, Dict[bool, float]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/base/ClassificationMetric/","title":"ClassificationMetric","text":"<p>Mother class for all classification metrics.</p>"},{"location":"api/metrics/base/ClassificationMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/base/ClassificationMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/ClassificationMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/base/Metric/","title":"Metric","text":"<p>Mother class for all metrics.</p>"},{"location":"api/metrics/base/Metric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/Metric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/base/Metrics/","title":"Metrics","text":"<p>A container class for handling multiple metrics at once.</p>"},{"location":"api/metrics/base/Metrics/#parameters","title":"Parameters","text":"<ul> <li> <p>metrics</p> </li> <li> <p>str_sep \u2013 defaults to <code>,</code></p> </li> </ul>"},{"location":"api/metrics/base/Metrics/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/Metrics/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   get <p>Return the current value of the metric.</p>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   is_better_than   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   sort   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/base/MultiClassMetric/","title":"MultiClassMetric","text":"<p>Mother class for all multi-class classification metrics.</p>"},{"location":"api/metrics/base/MultiClassMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.confusion.ConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/base/MultiClassMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/MultiClassMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/base/RegressionMetric/","title":"RegressionMetric","text":"<p>Mother class for all regression metrics.</p>"},{"location":"api/metrics/base/RegressionMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/RegressionMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (numbers.Number)    </li> <li>y_pred     (numbers.Number)    </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/base/WrapperMetric/","title":"WrapperMetric","text":""},{"location":"api/metrics/base/WrapperMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/WrapperMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/multioutput/ExactMatch/","title":"ExactMatch","text":"<p>Exact match score.</p> <p>This is the most strict multi-label metric, defined as the number of samples that have all their labels correctly classified, divided by the total number of samples.</p>"},{"location":"api/metrics/multioutput/ExactMatch/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/ExactMatch/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; y_true = [\n...     {0: False, 1: True, 2: True},\n...     {0: True, 1: True, 2: False},\n...     {0: True, 1: True, 2: False},\n... ]\n\n&gt;&gt;&gt; y_pred = [\n...     {0: True, 1: True, 2: True},\n...     {0: True, 1: False, 2: False},\n...     {0: True, 1: True, 2: False},\n... ]\n\n&gt;&gt;&gt; metric = metrics.multioutput.ExactMatch()\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     metric = metric.update(yt, yp)\n\n&gt;&gt;&gt; metric\nExactMatch: 33.33%\n</code></pre>"},{"location":"api/metrics/multioutput/ExactMatch/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (Dict[Union[str, int], Union[bool, str, int]])    </li> <li>y_pred     (Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (Dict[Union[str, int], Union[bool, str, int]])    </li> <li>y_pred     (Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul>"},{"location":"api/metrics/multioutput/MacroAverage/","title":"MacroAverage","text":"<p>Macro-average wrapper.</p> <p>A copy of the provided metric is made for each output. The arithmetic average of all the metrics is returned.</p>"},{"location":"api/metrics/multioutput/MacroAverage/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>A classification or a regression metric.</p> </li> </ul>"},{"location":"api/metrics/multioutput/MacroAverage/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/MacroAverage/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/multioutput/MicroAverage/","title":"MicroAverage","text":"<p>Micro-average wrapper.</p> <p>The provided metric is updated with the value of each output.</p>"},{"location":"api/metrics/multioutput/MicroAverage/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>A classification or a regression metric.</p> </li> </ul>"},{"location":"api/metrics/multioutput/MicroAverage/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/MicroAverage/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/","title":"MultiLabelConfusionMatrix","text":"<p>Multi-label confusion matrix.</p> <p>Under the hood, this stores one <code>metrics.ConfusionMatrix</code> for each output.</p>"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; cm = metrics.multioutput.MultiLabelConfusionMatrix()\n\n&gt;&gt;&gt; y_true = [\n...     {0: False, 1: True, 2: True},\n...     {0: True, 1: True, 2: False}\n... ]\n\n&gt;&gt;&gt; y_pred = [\n...     {0: True, 1: True, 2: True},\n...     {0: True, 1: False, 2: False}\n... ]\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     cm = cm.update(yt, yp)\n\n&gt;&gt;&gt; cm\n0\n            False   True\n    False       0      1\n     True       0      1\n&lt;BLANKLINE&gt;\n1\n            False   True\n    False       0      0\n     True       1      1\n&lt;BLANKLINE&gt;\n2\n            False   True\n    False       1      0\n     True       0      1\n</code></pre>"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/#methods","title":"Methods","text":"revert   update"},{"location":"api/metrics/multioutput/PerOutput/","title":"PerOutput","text":"<p>Per-output wrapper.</p> <p>A copy of the metric is maintained for each output.</p>"},{"location":"api/metrics/multioutput/PerOutput/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>A classification or a regression metric.</p> </li> </ul>"},{"location":"api/metrics/multioutput/PerOutput/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/PerOutput/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/","title":"MultiOutputClassificationMetric","text":"<p>Mother class for all multi-output classification metrics.</p>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm (river.metrics.multioutput.confusion.MultiLabelConfusionMatrix) \u2013 defaults to <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (Dict[Union[str, int], Union[bool, str, int]])    </li> <li>y_pred     (Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (Dict[Union[str, int], Union[bool, str, int]])    </li> <li>y_pred     (Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]])    </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/","title":"MultiOutputRegressionMetric","text":"<p>Mother class for all multi-output regression metrics.</p>"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p>   is_better_than   revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     (Dict[Union[str, int], Union[float, int]])    </li> <li>y_pred     (Dict[Union[str, int], Union[float, int]])    </li> </ul>   update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     (Dict[Union[str, int], Union[float, int]])    </li> <li>y_pred     (Dict[Union[str, int], Union[float, int]])    </li> </ul>   works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     (river.base.estimator.Estimator)    </li> </ul>"},{"location":"api/misc/SDFT/","title":"SDFT","text":"<p>Sliding Discrete Fourier Transform (SDFT).</p> <p>Initially, the coefficients are all equal to 0, up until enough values have been seen. A call to <code>numpy.fft.fft</code> is triggered once <code>window_size</code> values have been seen. Subsequent values will update the coefficients online. This is much faster than recomputing an FFT from scratch for every new value.</p>"},{"location":"api/misc/SDFT/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>The size of the window.</p> </li> </ul>"},{"location":"api/misc/SDFT/#attributes","title":"Attributes","text":"<ul> <li>window_size</li> </ul>"},{"location":"api/misc/SDFT/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from river import misc\n\n&gt;&gt;&gt; X = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n&gt;&gt;&gt; window_size = 5\n&gt;&gt;&gt; sdft = misc.SDFT(window_size)\n\n&gt;&gt;&gt; for i, x in enumerate(X):\n...     sdft = sdft.update(x)\n...\n...     if i + 1 &gt;= window_size:\n...         assert np.allclose(sdft.coefficients, np.fft.fft(X[i+1 - window_size:i+1]))\n</code></pre>"},{"location":"api/misc/SDFT/#methods","title":"Methods","text":"update"},{"location":"api/misc/SDFT/#references","title":"References","text":"<ol> <li> <p>Jacobsen, E. and Lyons, R., 2003. The sliding DFT. IEEE Signal Processing Magazine, 20(2), pp.74-80. \u21a9</p> </li> <li> <p>Understanding and Implementing the Sliding DFT \u21a9</p> </li> </ol>"},{"location":"api/misc/Skyline/","title":"Skyline","text":"<p>A skyline is set of points which is not dominated by any other point.</p> <p>This implementation uses a block nested loop. Identical observations are all part of the skyline if applicable.</p>"},{"location":"api/misc/Skyline/#parameters","title":"Parameters","text":"<ul> <li> <p>minimize (list) \u2013 defaults to <code>None</code></p> <p>A list of features for which the values need to be minimized. Can be omitted as long as <code>maximize</code> is specified.</p> </li> <li> <p>maximize (list) \u2013 defaults to <code>None</code></p> <p>A list of features for which the values need to be maximized. Can be omitted as long as <code>minimize</code> is specified.</p> </li> </ul>"},{"location":"api/misc/Skyline/#examples","title":"Examples","text":"<p>Here is an example taken from this blog post.</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import misc\n\n&gt;&gt;&gt; city_prices = {\n...     'Bordeaux': 4045,\n...     'Lyon': 4547,\n...     'Toulouse': 3278\n... }\n\n&gt;&gt;&gt; def random_house():\n...     city = random.choice(['Bordeaux', 'Lyon', 'Toulouse'])\n...     size = round(random.gauss(200, 50))\n...     price = round(random.uniform(0.8, 1.2) * city_prices[city] * size)\n...     return {'city': city, 'size': size, 'price': price}\n\n&gt;&gt;&gt; skyline = misc.Skyline(minimize=['price'], maximize=['size'])\n\n&gt;&gt;&gt; random.seed(42)\n\n&gt;&gt;&gt; for _ in range(100):\n...     house = random_house()\n...     skyline = skyline.update(house)\n\n&gt;&gt;&gt; print(len(skyline))\n13\n\n&gt;&gt;&gt; print(skyline[0])\n{'city': 'Toulouse', 'size': 280, 'price': 763202}\n</code></pre> <p>Here is another example using the kart data from Mario Kart: Double Dash!!.</p> <pre><code>&gt;&gt;&gt; import collections\n&gt;&gt;&gt; from river import misc\n\n&gt;&gt;&gt; Kart = collections.namedtuple(\n...      'Kart',\n...      'name speed off_road acceleration weight turbo'\n... )\n\n&gt;&gt;&gt; karts = [\n...     Kart('Red Fire', 5, 4, 4, 5, 2),\n...     Kart('Green Fire', 7, 3, 3, 4, 2),\n...     Kart('Heart Coach', 4, 6, 6, 5, 2),\n...     Kart('Bloom Coach', 6, 4, 5, 3, 2),\n...     Kart('Turbo Yoshi', 4, 5, 6, 6, 2),\n...     Kart('Turbo Birdo', 6, 4, 4, 7, 2),\n...     Kart('Goo-Goo Buggy', 1, 9, 9, 2, 3),\n...     Kart('Rattle Buggy', 2, 9, 8, 2, 3),\n...     Kart('Toad Kart', 3, 9, 7, 2, 3),\n...     Kart('Toadette Kart', 1, 9, 9, 2, 3),\n...     Kart('Koopa Dasher', 2, 8, 8, 3, 3),\n...     Kart('Para-Wing', 1, 8, 9, 3, 3),\n...     Kart('DK Jumbo', 8, 2, 2, 8, 1),\n...     Kart('Barrel Train', 8, 7, 3, 5, 3),\n...     Kart('Koopa King', 9, 1, 1, 9, 1),\n...     Kart('Bullet Blaster', 8, 1, 4, 1, 3),\n...     Kart('Wario Car', 7, 3, 3, 7, 1),\n...     Kart('Waluigi Racer', 5, 9, 5, 6, 2),\n...     Kart('Piranha Pipes', 8, 7, 2, 9, 1),\n...     Kart('Boo Pipes', 2, 9, 8, 9, 1),\n...     Kart('Parade Kart', 7, 3, 4, 7, 3)\n... ]\n\n&gt;&gt;&gt; skyline = misc.Skyline(\n...     maximize=['speed', 'off_road', 'acceleration', 'turbo'],\n...     minimize=['weight']\n... )\n\n&gt;&gt;&gt; for kart in karts:\n...     skyline = skyline.update(kart._asdict())\n\n&gt;&gt;&gt; best_cart_names = [kart['name'] for kart in skyline]\n&gt;&gt;&gt; for name in best_cart_names:\n...     print(f'- {name}')\n- Green Fire\n- Heart Coach\n- Bloom Coach\n- Goo-Goo Buggy\n- Rattle Buggy\n- Toad Kart\n- Toadette Kart\n- Barrel Train\n- Koopa King\n- Bullet Blaster\n- Waluigi Racer\n- Parade Kart\n\n&gt;&gt;&gt; for name in sorted(set(kart.name for kart in karts) - set(best_cart_names)):\n...     print(f'- {name}')\n- Boo Pipes\n- DK Jumbo\n- Koopa Dasher\n- Para-Wing\n- Piranha Pipes\n- Red Fire\n- Turbo Birdo\n- Turbo Yoshi\n- Wario Car\n</code></pre>"},{"location":"api/misc/Skyline/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort   update"},{"location":"api/misc/Skyline/#references","title":"References","text":"<ol> <li> <p>Skyline queries in Python \u21a9</p> </li> <li> <p>Borzsony, S., Kossmann, D. and Stocker, K., 2001, April. The skyline operator. In Proceedings 17th international conference on data engineering (pp. 421-430). IEEE. \u21a9</p> </li> <li> <p>Tao, Y. and Papadias, D., 2006. Maintaining sliding window skylines on data streams. IEEE Transactions on Knowledge and Data Engineering, 18(3), pp.377-391. \u21a9</p> </li> </ol>"},{"location":"api/model-selection/BanditRegressor/","title":"BanditRegressor","text":"<p>Bandit-based model selection.</p> <p>Each model is associated with an arm. At each <code>learn_one</code> call, the policy decides which arm/model to pull. The reward is the performance of the model on the provided sample. The <code>predict_one</code> method uses the current best model.</p>"},{"location":"api/model-selection/BanditRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>The models to select from.</p> </li> <li> <p>metric (river.metrics.base.RegressionMetric)</p> <p>The metric that is used to measure the performance of each model.</p> </li> <li> <p>policy (river.bandit.base.Policy)</p> <p>The bandit policy to use.</p> </li> </ul>"},{"location":"api/model-selection/BanditRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/BanditRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import bandit\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import model_selection\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; models = [\n...     linear_model.LinearRegression(optimizer=optim.SGD(lr=lr))\n...     for lr in [0.0001, 0.001, 1e-05, 0.01]\n... ]\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     model_selection.BanditRegressor(\n...         models,\n...         metric=metrics.MAE(),\n...         policy=bandit.EpsilonGreedy(\n...             epsilon=0.1,\n...             decay=0.001,\n...             burn_in=100,\n...             seed=42\n...         )\n...     )\n... )\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 2.544434\n</code></pre> <p>Here's another example using the UCB policy. The latter is more sensitive to the target scale, and usually works better when the target is rescaled.</p> <pre><code>&gt;&gt;&gt; models = [\n...     linear_model.LinearRegression(optimizer=optim.SGD(lr=lr))\n...     for lr in [0.0001, 0.001, 1e-05, 0.01]\n... ]\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     preprocessing.TargetStandardScaler(\n...         model_selection.BanditRegressor(\n...             models,\n...             metric=metrics.MAE(),\n...             policy=bandit.UCB(\n...                 delta=1,\n...                 burn_in=100\n...             )\n...         )\n...     )\n... )\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 0.857745\n</code></pre>"},{"location":"api/model-selection/BanditRegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/model-selection/GreedyRegressor/","title":"GreedyRegressor","text":"<p>Greedy selection regressor.</p> <p>This selection method simply updates each model at each time step. The current best model is used to make predictions. It's greedy in the sense that updating each model can be costly. On the other hand, bandit-like algorithms are more temperate in that only update a subset of the models at each step.</p>"},{"location":"api/model-selection/GreedyRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models (List[base.Regressor])</p> <p>The models to select from.</p> </li> <li> <p>metric (river.metrics.base.RegressionMetric) \u2013 defaults to <code>None</code></p> <p>The metric that is used to measure the performance of each model.</p> </li> </ul>"},{"location":"api/model-selection/GreedyRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/GreedyRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import model_selection\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; models = [\n...     linear_model.LinearRegression(optimizer=optim.SGD(lr=lr))\n...     for lr in [1e-5, 1e-4, 1e-3, 1e-2]\n... ]\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; metric = metrics.MAE()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     model_selection.GreedyRegressor(models, metric)\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 1.35\n</code></pre>"},{"location":"api/model-selection/GreedyRegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/model-selection/SuccessiveHalvingClassifier/","title":"SuccessiveHalvingClassifier","text":"<p>Successive halving algorithm for classification.</p> <p>Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most <code>budget</code> model updates will be performed in total. </p> <p>If you have <code>k</code> combinations of hyperparameters and that your dataset contains <code>n</code> observations, then the maximal budget you can allocate is: </p> \\[\\frac{2kn}{eta}\\] <p>It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. </p> <p>If you have a budget of <code>B</code>, and that your dataset contains <code>n</code> observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: </p> \\[\\left\\lceil\\left\\lfloor\\frac{B}{2n}\\right\\rfloor \\times eta \\right\\rceil\\]"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>The models to compare.</p> </li> <li> <p>metric (river.metrics.base.Metric)</p> <p>Metric used for comparing models with.</p> </li> <li> <p>budget (int)</p> <p>Total number of model updates you wish to allocate.</p> </li> <li> <p>eta \u2013 defaults to <code>2</code></p> <p>Rate of elimination. At every rung, <code>math.ceil(k / eta)</code> models are kept, where <code>k</code> is the number of models that have reached the rung. A higher <code>eta</code> value will focus on less models but will allocate more iterations to the best models.</p> </li> <li> <p>verbose \u2013 defaults to <code>False</code></p> <p>Whether to display progress or not.</p> </li> <li> <p>print_kwargs</p> <p>Extra keyword arguments are passed to the <code>print</code> function. For instance, this allows providing a <code>file</code> argument, which indicates where to output progress.</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#examples","title":"Examples","text":"<p>As an example, let's use successive halving to tune the optimizer of a logistic regression. We'll first define the model.</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression()\n... )\n</code></pre> <p>Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates.</p> <pre><code>&gt;&gt;&gt; from river import utils\n&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; models = utils.expand_param_grid(model, {\n...     'LogisticRegression': {\n...         'optimizer': [\n...             (optim.SGD, {'lr': [.1, .01, .005]}),\n...             (optim.Adam, {'beta_1': [.01, .001], 'lr': [.1, .01, .001]}),\n...             (optim.Adam, {'beta_1': [.1], 'lr': [.001]}),\n...         ]\n...     }\n... })\n</code></pre> <p>We can check how many models we've created.</p> <pre><code>&gt;&gt;&gt; len(models)\n10\n</code></pre> <p>We can now pass these models to a <code>SuccessiveHalvingClassifier</code>. We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest.</p> <pre><code>&gt;&gt;&gt; from river import model_selection\n\n&gt;&gt;&gt; sh = model_selection.SuccessiveHalvingClassifier(\n...     models,\n...     metric=metrics.Accuracy(),\n...     budget=2000,\n...     eta=2,\n...     verbose=True\n... )\n</code></pre> <p>A <code>SuccessiveHalvingClassifier</code> is also a classifier with a <code>learn_one</code> and a <code>predict_proba_one</code> method. We can therefore evaluate it like any other classifier with <code>evaluate.progressive_val_score</code>.</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     dataset=datasets.Phishing(),\n...     model=sh,\n...     metric=metrics.ROCAUC()\n... )\n[1] 5 removed       5 left  50 iterations   budget used: 500        budget left: 1500       best Accuracy: 80.00%\n[2] 2 removed       3 left  100 iterations  budget used: 1000       budget left: 1000       best Accuracy: 84.00%\n[3] 1 removed       2 left  166 iterations  budget used: 1498       budget left: 502        best Accuracy: 86.14%\n[4] 1 removed       1 left  250 iterations  budget used: 1998       budget left: 2  best Accuracy: 84.80%\nROCAUC: 95.29%\n</code></pre> <p>We can now view the best model.</p> <pre><code>&gt;&gt;&gt; sh.best_model\nPipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LogisticRegression (\n    optimizer=Adam (\n      lr=Constant (\n        learning_rate=0.01\n      )\n      beta_1=0.01\n      beta_2=0.999\n      eps=1e-08\n    )\n    loss=Log (\n      weight_pos=1.\n      weight_neg=1.\n    )\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</code></pre>"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#references","title":"References","text":"<ol> <li> <p>Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9</p> </li> </ol>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/","title":"SuccessiveHalvingRegressor","text":"<p>Successive halving algorithm for regression.</p> <p>Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most <code>budget</code> model updates will be performed in total. </p> <p>If you have <code>k</code> combinations of hyperparameters and that your dataset contains <code>n</code> observations, then the maximal budget you can allocate is: </p> \\[\\frac{2kn}{eta}\\] <p>It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. </p> <p>If you have a budget of <code>B</code>, and that your dataset contains <code>n</code> observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: </p> \\[\\left\\lceil\\left\\lfloor\\frac{B}{2n}\\right\\rfloor \\times eta \\right\\rceil\\]"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>The models to compare.</p> </li> <li> <p>metric (river.metrics.base.Metric)</p> <p>Metric used for comparing models with.</p> </li> <li> <p>budget (int)</p> <p>Total number of model updates you wish to allocate.</p> </li> <li> <p>eta \u2013 defaults to <code>2</code></p> <p>Rate of elimination. At every rung, <code>math.ceil(k / eta)</code> models are kept, where <code>k</code> is the number of models that have reached the rung. A higher <code>eta</code> value will focus on less models but will allocate more iterations to the best models.</p> </li> <li> <p>verbose \u2013 defaults to <code>False</code></p> <p>Whether to display progress or not.</p> </li> <li> <p>print_kwargs</p> <p>Extra keyword arguments are passed to the <code>print</code> function. For instance, this allows providing a <code>file</code> argument, which indicates where to output progress.</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#examples","title":"Examples","text":"<p>As an example, let's use successive halving to tune the optimizer of a linear regression. We'll first define the model.</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LinearRegression(intercept_lr=.1)\n... )\n</code></pre> <p>Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates.</p> <pre><code>&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; models = utils.expand_param_grid(model, {\n...     'LinearRegression': {\n...         'optimizer': [\n...             (optim.SGD, {'lr': [.1, .01, .005]}),\n...             (optim.Adam, {'beta_1': [.01, .001], 'lr': [.1, .01, .001]}),\n...             (optim.Adam, {'beta_1': [.1], 'lr': [.001]}),\n...         ]\n...     }\n... })\n</code></pre> <p>We can check how many models we've created.</p> <pre><code>&gt;&gt;&gt; len(models)\n10\n</code></pre> <p>We can now pass these models to a <code>SuccessiveHalvingRegressor</code>. We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest.</p> <pre><code>&gt;&gt;&gt; from river import model_selection\n\n&gt;&gt;&gt; sh = model_selection.SuccessiveHalvingRegressor(\n...     models,\n...     metric=metrics.MAE(),\n...     budget=2000,\n...     eta=2,\n...     verbose=True\n... )\n</code></pre> <p>A <code>SuccessiveHalvingRegressor</code> is also a regressor with a <code>learn_one</code> and a <code>predict_one</code> method. We can therefore evaluate it like any other classifier with <code>evaluate.progressive_val_score</code>.</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; evaluate.progressive_val_score(\n...     dataset=datasets.TrumpApproval(),\n...     model=sh,\n...     metric=metrics.MAE()\n... )\n[1] 5 removed       5 left  50 iterations   budget used: 500        budget left: 1500       best MAE: 4.540491\n[2] 2 removed       3 left  100 iterations  budget used: 1000       budget left: 1000       best MAE: 2.458765\n[3] 1 removed       2 left  166 iterations  budget used: 1498       budget left: 502        best MAE: 1.583751\n[4] 1 removed       1 left  250 iterations  budget used: 1998       budget left: 2  best MAE: 1.147296\nMAE: 0.488387\n</code></pre> <p>We can now view the best model.</p> <pre><code>&gt;&gt;&gt; sh.best_model\nPipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=Adam (\n      lr=Constant (\n        learning_rate=0.1\n      )\n      beta_1=0.01\n      beta_2=0.999\n      eps=1e-08\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.1\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</code></pre>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#references","title":"References","text":"<ol> <li> <p>Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9</p> </li> </ol>"},{"location":"api/model-selection/base/ModelSelectionClassifier/","title":"ModelSelectionClassifier","text":"<p>A model selector for classification.</p>"},{"location":"api/model-selection/base/ModelSelectionClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models (Iterator[base.Estimator])</p> </li> <li> <p>metric (river.metrics.base.Metric)</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionClassifier/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/model-selection/base/ModelSelectionRegressor/","title":"ModelSelectionRegressor","text":"<p>A model selector for regression.</p>"},{"location":"api/model-selection/base/ModelSelectionRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models (Iterator[base.Estimator])</p> </li> <li> <p>metric (river.metrics.base.Metric)</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionRegressor/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/multiclass/OneVsOneClassifier/","title":"OneVsOneClassifier","text":"<p>One-vs-One (OvO) multiclass strategy.</p> <p>This strategy consists in fitting one binary classifier for each pair of classes. Because we are in a streaming context, the number of classes isn't known from the start, hence new classifiers are instantiated on the fly. </p> <p>The number of classifiers is <code>k * (k - 1) / 2</code>, where <code>k</code> is the number of classes. However, each call to <code>learn_one</code> only requires training <code>k - 1</code> models. Indeed, only the models that pertain to the given label have to be trained. Meanwhile, making a prediction requires going through each and every model.</p>"},{"location":"api/multiclass/OneVsOneClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>A binary classifier, although a multi-class classifier will work too.</p> </li> </ul>"},{"location":"api/multiclass/OneVsOneClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>classifiers (dict)</p> <p>A mapping between pairs of classes and classifiers. The keys are tuples which contain a pair of classes. Each pair is sorted in lexicographical order.</p> </li> </ul>"},{"location":"api/multiclass/OneVsOneClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import multiclass\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.ImageSegments()\n\n&gt;&gt;&gt; scaler = preprocessing.StandardScaler()\n&gt;&gt;&gt; ovo = multiclass.OneVsOneClassifier(linear_model.LogisticRegression())\n&gt;&gt;&gt; model = scaler | ovo\n\n&gt;&gt;&gt; metric = metrics.MacroF1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMacroF1: 80.76%\n</code></pre>"},{"location":"api/multiclass/OneVsOneClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/multiclass/OneVsRestClassifier/","title":"OneVsRestClassifier","text":"<p>One-vs-the-rest (OvR) multiclass strategy.</p> <p>This strategy consists in fitting one binary classifier per class. Because we are in a streaming context, the number of classes isn't known from the start. Hence, new classifiers are instantiated on the fly. Likewise, the predicted probabilities will only include the classes seen up to a given point in time. </p> <p>Note that this classifier supports mini-batches as well as single instances. </p> <p>The computational complexity for both learning and predicting grows linearly with the number of classes. If you have a very large number of classes, then you might want to consider using an <code>multiclass.OutputCodeClassifier</code> instead.</p>"},{"location":"api/multiclass/OneVsRestClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier ('base.Classifier')</p> <p>A binary classifier, although a multi-class classifier will work too.</p> </li> </ul>"},{"location":"api/multiclass/OneVsRestClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>classifiers (dict)</p> <p>A mapping between classes and classifiers.</p> </li> </ul>"},{"location":"api/multiclass/OneVsRestClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import multiclass\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.ImageSegments()\n\n&gt;&gt;&gt; scaler = preprocessing.StandardScaler()\n&gt;&gt;&gt; ovr = multiclass.OneVsRestClassifier(linear_model.LogisticRegression())\n&gt;&gt;&gt; model = scaler | ovr\n\n&gt;&gt;&gt; metric = metrics.MacroF1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMacroF1: 77.46%\n</code></pre> <p>This estimator also also supports mini-batching.</p> <pre><code>&gt;&gt;&gt; for X in pd.read_csv(dataset.path, chunksize=64):\n...     y = X.pop('category')\n...     y_pred = model.predict_many(X)\n...     model = model.learn_many(X, y)\n</code></pre>"},{"location":"api/multiclass/OneVsRestClassifier/#methods","title":"Methods","text":"learn_many   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_many   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_many   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>"},{"location":"api/multiclass/OutputCodeClassifier/","title":"OutputCodeClassifier","text":"<p>Output-code multiclass strategy.</p> <p>This also referred to as \"error-correcting output codes\". </p> <p>This class allows to learn a multi-class classification problem with a binary classifier. Each class is converted to a code of 0s and 1s. The length of the code is called  the code size. A copy of the classifier made for code. The codes associated with the classes are stored in a code book. </p> <p>When a new sample arrives, the label's code is retrieved from the code book. Then, each classifier is trained on the relevant part of code, which is either a 0 or a 1. </p> <p>For predicting, each classifier outputs a probability. These are then compared to each code in the code book, and the label which is the \"closest\" is chosen as the most likely class. Closeness is determined in terms of Manhattan distance. </p> <p>One specificity of online learning is that we don't how many classes there are initially. Therefore, a random procedure generates random codes on the fly whenever a previously unseed label appears.</p>"},{"location":"api/multiclass/OutputCodeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier (base.Classifier)</p> <p>A binary classifier, although a multi-class classifier will work too.</p> </li> <li> <p>code_size (int)</p> <p>The code size, which dictates how many copies of the provided classifiers to train. Must be strictly positive.</p> </li> <li> <p>coding_method (str) \u2013 defaults to <code>random</code></p> <p>The method used to generate the codes. Can be either 'exact' or 'random'. The 'exact' method generates all possible codes of a given size in memory, and streams them in a random order. The 'random' method generates random codes of a given size on the fly. The 'exact' method necessarily generates different codes for each class, but requires more memory. The 'random' method can generate duplicate codes for different classes, but requires less memory.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>A random seed number that can be set for reproducibility.</p> </li> </ul>"},{"location":"api/multiclass/OutputCodeClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import multiclass\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.ImageSegments()\n\n&gt;&gt;&gt; scaler = preprocessing.StandardScaler()\n&gt;&gt;&gt; ooc = multiclass.OutputCodeClassifier(\n...     classifier=linear_model.LogisticRegression(),\n...     code_size=10,\n...     coding_method='random',\n...     seed=1\n... )\n&gt;&gt;&gt; model = scaler | ooc\n\n&gt;&gt;&gt; metric = metrics.MacroF1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMacroF1: 79.32%\n</code></pre>"},{"location":"api/multiclass/OutputCodeClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/multiclass/OutputCodeClassifier/#references","title":"References","text":"<ol> <li> <p>Dietterich, T.G. and Bakiri, G., 1994. Solving multiclass learning problems via error-correcting output codes. Journal of artificial intelligence research, 2, pp.263-286. \u21a9</p> </li> <li> <p>James, G. and Hastie, T., 1998. The error coding method and PICTs. Journal of Computational and Graphical statistics, 7(3), pp.377-387. \u21a9</p> </li> </ol>"},{"location":"api/multioutput/ClassifierChain/","title":"ClassifierChain","text":"<p>A multi-output model that arranges classifiers into a chain.</p> <p>This will create one model per output. The prediction of the first output will be used as a feature in the second model. The prediction for the second output will be used as a feature for the third model, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.</p>"},{"location":"api/multioutput/ClassifierChain/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> </li> <li> <p>order (list) \u2013 defaults to <code>None</code></p> <p>A list with the targets order in which to construct the chain. If <code>None</code> then the order will be inferred from the order of the keys in the target.</p> </li> </ul>"},{"location":"api/multioutput/ClassifierChain/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import feature_selection\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import multioutput\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; from sklearn import datasets\n\n&gt;&gt;&gt; dataset = stream.iter_sklearn_dataset(\n...     dataset=datasets.fetch_openml('yeast', version=4, as_frame=False),\n...     shuffle=True,\n...     seed=42\n... )\n\n&gt;&gt;&gt; model = feature_selection.VarianceThreshold(threshold=0.01)\n&gt;&gt;&gt; model |= preprocessing.StandardScaler()\n&gt;&gt;&gt; model |= multioutput.ClassifierChain(\n...     model=linear_model.LogisticRegression(),\n...     order=list(range(14))\n... )\n\n&gt;&gt;&gt; metric = metrics.multioutput.MicroAverage(metrics.Jaccard())\n\n&gt;&gt;&gt; for x, y in dataset:\n...     # Convert y values to booleans\n...     y = {i: yi == 'TRUE' for i, yi in y.items()}\n...     y_pred = model.predict_one(x)\n...     metric = metric.update(y, y_pred)\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; metric\nMicroAverage(Jaccard): 41.95%\n</code></pre>"},{"location":"api/multioutput/ClassifierChain/#methods","title":"Methods","text":"clear <p>D.clear() -&gt; None.  Remove all items from D.</p>   copy   fromkeys   get <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   items <p>D.items() -&gt; a set-like object providing a view on D's items</p>   keys <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>&lt;object object at 0x7f8ffb4c0150&gt;</code> </li> </ul>   popitem <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   setdefault <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   update <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F. If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p> <p>Parameters</p> <ul> <li>other     \u2013 defaults to <code>()</code> </li> <li>kwds </li> </ul>   values <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/multioutput/ClassifierChain/#references","title":"References","text":"<ol> <li> <p>Multi-Output Chain Models and their Application in Data Streams \u21a9</p> </li> </ol>"},{"location":"api/multioutput/MonteCarloClassifierChain/","title":"MonteCarloClassifierChain","text":"<p>Monte Carlo Sampling Classifier Chains.</p> <p>Probabilistic Classifier Chains using Monte Carlo sampling, as described in 1. </p> <p>m samples are taken from the posterior distribution. Therefore we need a probabilistic interpretation of the output, and thus, this is a particular variety of ProbabilisticClassifierChain.</p>"},{"location":"api/multioutput/MonteCarloClassifierChain/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Classifier)</p> </li> <li> <p>m (int) \u2013 defaults to <code>10</code></p> <p>Number of samples to take from the posterior distribution.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/multioutput/MonteCarloClassifierChain/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import feature_selection\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import multioutput\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Logical(seed=42, n_tiles=100)\n\n&gt;&gt;&gt; model = multioutput.MonteCarloClassifierChain(\n...     model=linear_model.LogisticRegression(),\n...     m=10,\n...     seed=42\n... )\n\n&gt;&gt;&gt; metric = metrics.multioutput.MicroAverage(metrics.Jaccard())\n\n&gt;&gt;&gt; for x, y in dataset:\n...    y_pred = model.predict_one(x)\n...    metric = metric.update(y, y_pred)\n...    model = model.learn_one(x, y)\n\n&gt;&gt;&gt; metric\nMicroAverage(Jaccard): 51.92%\n</code></pre>"},{"location":"api/multioutput/MonteCarloClassifierChain/#methods","title":"Methods","text":"clear <p>D.clear() -&gt; None.  Remove all items from D.</p>   copy   fromkeys   get <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   items <p>D.items() -&gt; a set-like object providing a view on D's items</p>   keys <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>&lt;object object at 0x7f8ffb4c0150&gt;</code> </li> </ul>   popitem <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   setdefault <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   update <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F. If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p> <p>Parameters</p> <ul> <li>other     \u2013 defaults to <code>()</code> </li> <li>kwds </li> </ul>   values <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/multioutput/MonteCarloClassifierChain/#references","title":"References","text":"<ol> <li> <p>Read, J., Martino, L., &amp; Luengo, D. (2014). Efficient monte carlo   methods for multi-dimensional learning with classifier chains.   Pattern Recognition, 47(3), 1535-1546.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/multioutput/ProbabilisticClassifierChain/","title":"ProbabilisticClassifierChain","text":"<p>Probabilistic Classifier Chains.</p> <p>The Probabilistic Classifier Chains (PCC) 1 is a Bayes-optimal method based on the Classifier Chains (CC). </p> <p>Consider the concept of chaining classifiers as searching a path in a binary tree whose leaf nodes are associated with a label \\(y \\in Y\\). While CC searches only a single path in the aforementioned binary tree, PCC looks at each of the \\(2^l\\) paths, where \\(l\\) is the number of labels. This limits the applicability of the method to data sets with a small to moderate number of labels. The authors recommend no more than about 15 labels for real-world applications.</p>"},{"location":"api/multioutput/ProbabilisticClassifierChain/#parameters","title":"Parameters","text":"<ul> <li>model (base.Classifier)</li> </ul>"},{"location":"api/multioutput/ProbabilisticClassifierChain/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import feature_selection\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import multioutput\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river.datasets import synth\n\n&gt;&gt;&gt; dataset = synth.Logical(seed=42, n_tiles=100)\n\n&gt;&gt;&gt; model = multioutput.ProbabilisticClassifierChain(\n...     model=linear_model.LogisticRegression()\n... )\n\n&gt;&gt;&gt; metric = metrics.multioutput.MicroAverage(metrics.Jaccard())\n\n&gt;&gt;&gt; for x, y in dataset:\n...    y_pred = model.predict_one(x)\n...    metric = metric.update(y, y_pred)\n...    model = model.learn_one(x, y)\n\n&gt;&gt;&gt; metric\nMicroAverage(Jaccard): 51.97%\n</code></pre>"},{"location":"api/multioutput/ProbabilisticClassifierChain/#methods","title":"Methods","text":"clear <p>D.clear() -&gt; None.  Remove all items from D.</p>   copy   fromkeys   get <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   items <p>D.items() -&gt; a set-like object providing a view on D's items</p>   keys <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>&lt;object object at 0x7f8ffb4c0150&gt;</code> </li> </ul>   popitem <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   setdefault <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   update <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F. If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p> <p>Parameters</p> <ul> <li>other     \u2013 defaults to <code>()</code> </li> <li>kwds </li> </ul>   values <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/multioutput/ProbabilisticClassifierChain/#references","title":"References","text":"<ol> <li> <p>Cheng, W., H\u00fcllermeier, E., &amp; Dembczynski, K. J. (2010).   Bayes optimal multilabel classification via probabilistic classifier   chains. In Proceedings of the 27th international conference on   machine learning (ICML-10) (pp. 279-286).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/multioutput/RegressorChain/","title":"RegressorChain","text":"<p>A multi-output model that arranges regressor into a chain.</p> <p>This will create one model per output. The prediction of the first output will be used as a feature in the second output. The prediction for the second output will be used as a feature for the third, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.</p>"},{"location":"api/multioutput/RegressorChain/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Regressor)</p> </li> <li> <p>order (list) \u2013 defaults to <code>None</code></p> <p>A list with the targets order in which to construct the chain. If <code>None</code> then the order will be inferred from the order of the keys in the target.</p> </li> </ul>"},{"location":"api/multioutput/RegressorChain/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import multioutput\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; from sklearn import datasets\n\n&gt;&gt;&gt; dataset = stream.iter_sklearn_dataset(\n...     dataset=datasets.load_linnerud(),\n...     shuffle=True,\n...     seed=42\n... )\n\n&gt;&gt;&gt; model = multioutput.RegressorChain(\n...     model=(\n...         preprocessing.StandardScaler() |\n...         linear_model.LinearRegression(intercept_lr=0.3)\n...     ),\n...     order=[0, 1, 2]\n... )\n\n&gt;&gt;&gt; metric = metrics.multioutput.MicroAverage(metrics.MAE())\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMicroAverage(MAE): 12.649592\n</code></pre>"},{"location":"api/multioutput/RegressorChain/#methods","title":"Methods","text":"clear <p>D.clear() -&gt; None.  Remove all items from D.</p>   copy   fromkeys   get <p>D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   items <p>D.items() -&gt; a set-like object providing a view on D's items</p>   keys <p>D.keys() -&gt; a set-like object providing a view on D's keys</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   pop <p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>&lt;object object at 0x7f8ffb4c0150&gt;</code> </li> </ul>   popitem <p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>   setdefault <p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p> <p>Parameters</p> <ul> <li>key </li> <li>default     \u2013 defaults to <code>None</code> </li> </ul>   update <p>D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F. If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</p> <p>Parameters</p> <ul> <li>other     \u2013 defaults to <code>()</code> </li> <li>kwds </li> </ul>   values <p>D.values() -&gt; an object providing a view on D's values</p>"},{"location":"api/naive-bayes/BernoulliNB/","title":"BernoulliNB","text":"<p>Bernoulli Naive Bayes.</p> <p>Bernoulli Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.</p>"},{"location":"api/naive-bayes/BernoulliNB/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha \u2013 defaults to <code>1.0</code></p> <p>Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).</p> </li> <li> <p>true_threshold \u2013 defaults to <code>0.0</code></p> <p>Threshold for binarizing (mapping to booleans) features.</p> </li> </ul>"},{"location":"api/naive-bayes/BernoulliNB/#attributes","title":"Attributes","text":"<ul> <li> <p>class_counts (collections.Counter)</p> <p>Number of times each class has been seen.</p> </li> <li> <p>feature_counts (collections.defaultdict)</p> <p>Total frequencies per feature and class.</p> </li> </ul>"},{"location":"api/naive-bayes/BernoulliNB/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import feature_extraction\n&gt;&gt;&gt; from river import naive_bayes\n\n&gt;&gt;&gt; docs = [\n...     (\"Chinese Beijing Chinese\", \"yes\"),\n...     (\"Chinese Chinese Shanghai\", \"yes\"),\n...     (\"Chinese Macao\", \"yes\"),\n...     (\"Tokyo Japan Chinese\", \"no\")\n... ]\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n...     (\"nb\", naive_bayes.BernoulliNB(alpha=1))\n... )\n\n&gt;&gt;&gt; for sentence, label in docs:\n...     model = model.learn_one(sentence, label)\n\n&gt;&gt;&gt; model[\"nb\"].p_class(\"yes\")\n0.75\n&gt;&gt;&gt; model[\"nb\"].p_class(\"no\")\n0.25\n\n&gt;&gt;&gt; model.predict_proba_one(\"test\")\n{'yes': 0.8831539823829913, 'no': 0.11684601761700895}\n\n&gt;&gt;&gt; model.predict_one(\"test\")\n'yes'\n</code></pre> <p>You can train the model and make predictions in mini-batch mode using the class methods <code>learn_many</code> and <code>predict_many</code>.</p> <pre><code>&gt;&gt;&gt; df_docs = pd.DataFrame(docs, columns = [\"docs\", \"y\"])\n\n&gt;&gt;&gt; X = pd.Series([\n...    \"Chinese Beijing Chinese\",\n...    \"Chinese Chinese Shanghai\",\n...    \"Chinese Macao\",\n...    \"Tokyo Japan Chinese\"\n... ])\n\n&gt;&gt;&gt; y = pd.Series([\"yes\", \"yes\", \"yes\", \"no\"])\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n...     (\"nb\", naive_bayes.BernoulliNB(alpha=1))\n... )\n\n&gt;&gt;&gt; model = model.learn_many(X, y)\n\n&gt;&gt;&gt; unseen = pd.Series([\"Taiwanese Taipei\", \"Chinese Shanghai\"])\n\n&gt;&gt;&gt; model.predict_proba_many(unseen)\n         no       yes\n0  0.116846  0.883154\n1  0.047269  0.952731\n\n&gt;&gt;&gt; model.predict_many(unseen)\n0    yes\n1    yes\ndtype: object\n</code></pre>"},{"location":"api/naive-bayes/BernoulliNB/#methods","title":"Methods","text":"joint_log_likelihood <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>float:     Mapping between classes and joint log likelihood.</p>   joint_log_likelihood_many <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul> <p>Returns</p> <p>DataFrame:     Input samples joint log likelihood.</p>   learn_many <p>Learn from a batch of count vectors.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)    </li> </ul> <p>Returns</p> <p>MiniBatchClassifier:     self</p>   learn_one <p>Updates the model with a single observation.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   p_class   p_class_many   p_feature_given_class   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_many <p>Return probabilities using the log-likelihoods in mini-batchs setting.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul>   predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>"},{"location":"api/naive-bayes/BernoulliNB/#references","title":"References","text":"<ol> <li> <p>The Bernoulli model \u21a9</p> </li> </ol>"},{"location":"api/naive-bayes/ComplementNB/","title":"ComplementNB","text":"<p>Naive Bayes classifier for multinomial models.</p> <p>Complement Naive Bayes model learns from occurrences between features such as word counts and discrete classes. ComplementNB is suitable for imbalance dataset. The input vector must contain positive values, such as counts or TF-IDF values.</p>"},{"location":"api/naive-bayes/ComplementNB/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha \u2013 defaults to <code>1.0</code></p> <p>Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).</p> </li> </ul>"},{"location":"api/naive-bayes/ComplementNB/#attributes","title":"Attributes","text":"<ul> <li> <p>class_dist (proba.Multinomial)</p> <p>Class prior probability distribution.</p> </li> <li> <p>feature_counts (collections.defaultdict)</p> <p>Total frequencies per feature and class.</p> </li> <li> <p>class_totals (collections.Counter)</p> <p>Total frequencies per class.</p> </li> </ul>"},{"location":"api/naive-bayes/ComplementNB/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import feature_extraction\n&gt;&gt;&gt; from river import naive_bayes\n\n&gt;&gt;&gt; docs = [\n...     (\"Chinese Beijing Chinese\", \"yes\"),\n...     (\"Chinese Chinese Shanghai\", \"yes\"),\n...     (\"Chinese Macao\", \"maybe\"),\n...     (\"Tokyo Japan Chinese\", \"no\")\n... ]\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n...     (\"nb\", naive_bayes.ComplementNB(alpha=1))\n... )\n\n&gt;&gt;&gt; for sentence, label in docs:\n...     model = model.learn_one(sentence, label)\n\n&gt;&gt;&gt; model[\"nb\"].p_class(\"yes\")\n0.5\n\n&gt;&gt;&gt; model[\"nb\"].p_class(\"no\")\n0.25\n\n&gt;&gt;&gt; model[\"nb\"].p_class(\"maybe\")\n0.25\n\n&gt;&gt;&gt; model.predict_proba_one(\"test\")\n{'yes': 0.275, 'maybe': 0.375, 'no': 0.35}\n\n&gt;&gt;&gt; model.predict_one(\"test\")\n'maybe'\n</code></pre> <p>You can train the model and make predictions in mini-batch mode using the class methods <code>learn_many</code> and <code>predict_many</code>.</p> <pre><code>&gt;&gt;&gt; df_docs = pd.DataFrame(docs, columns = [\"docs\", \"y\"])\n\n&gt;&gt;&gt; X = pd.Series([\n...    \"Chinese Beijing Chinese\",\n...    \"Chinese Chinese Shanghai\",\n...    \"Chinese Macao\",\n...    \"Tokyo Japan Chinese\"\n... ])\n\n&gt;&gt;&gt; y = pd.Series([\"yes\", \"yes\", \"maybe\", \"no\"])\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n...     (\"nb\", naive_bayes.ComplementNB(alpha=1))\n... )\n\n&gt;&gt;&gt; model = model.learn_many(X, y)\n\n&gt;&gt;&gt; unseen = pd.Series([\"Taiwanese Taipei\", \"Chinese Shanghai\"])\n\n&gt;&gt;&gt; model.predict_proba_many(unseen)\n      maybe        no       yes\n0  0.415129  0.361624  0.223247\n1  0.248619  0.216575  0.534807\n\n&gt;&gt;&gt; model.predict_many(unseen)\n0    maybe\n1      yes\ndtype: object\n</code></pre>"},{"location":"api/naive-bayes/ComplementNB/#methods","title":"Methods","text":"joint_log_likelihood <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>float:     Mapping between classes and joint log likelihood.</p>   joint_log_likelihood_many <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul> <p>Returns</p> <p>DataFrame:     Input samples joint log likelihood.</p>   learn_many <p>Learn from a batch of count vectors.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)    </li> </ul> <p>Returns</p> <p>MiniBatchClassifier:     self</p>   learn_one <p>Updates the model with a single observation.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   p_class   p_class_many   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_many <p>Return probabilities using the log-likelihoods in mini-batchs setting.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul>   predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>"},{"location":"api/naive-bayes/ComplementNB/#references","title":"References","text":"<ol> <li> <p>Rennie, J.D., Shih, L., Teevan, J. and Karger, D.R., 2003. Tackling the poor assumptions of naive bayes text classifiers. In Proceedings of the 20th international conference on machine learning (ICML-03) (pp. 616-623) \u21a9</p> </li> <li> <p>StackExchange discussion \u21a9</p> </li> </ol>"},{"location":"api/naive-bayes/GaussianNB/","title":"GaussianNB","text":"<p>Gaussian Naive Bayes.</p> <p>A Gaussian distribution \\(G_{cf}\\) is maintained for each class \\(c\\) and each feature \\(f\\). Each Gaussian is updated using the amount associated with each feature; the details can be be found in <code>proba.Gaussian</code>. The joint log-likelihood is then obtained by summing the log probabilities of each feature associated with each class.</p>"},{"location":"api/naive-bayes/GaussianNB/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import naive_bayes\n&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])\n&gt;&gt;&gt; Y = np.array([1, 1, 1, 2, 2, 2])\n\n&gt;&gt;&gt; model = naive_bayes.GaussianNB()\n\n&gt;&gt;&gt; for x, y in stream.iter_array(X, Y):\n...     _ = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({0: -0.8, 1: -1})\n1\n</code></pre>"},{"location":"api/naive-bayes/GaussianNB/#methods","title":"Methods","text":"joint_log_likelihood   joint_log_likelihood_many   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   p_class   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>"},{"location":"api/naive-bayes/MultinomialNB/","title":"MultinomialNB","text":"<p>Naive Bayes classifier for multinomial models.</p> <p>Multinomial Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.</p>"},{"location":"api/naive-bayes/MultinomialNB/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha \u2013 defaults to <code>1.0</code></p> <p>Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).</p> </li> </ul>"},{"location":"api/naive-bayes/MultinomialNB/#attributes","title":"Attributes","text":"<ul> <li> <p>class_dist (proba.Multinomial)</p> <p>Class prior probability distribution.</p> </li> <li> <p>feature_counts (collections.defaultdict)</p> <p>Total frequencies per feature and class.</p> </li> <li> <p>class_totals (collections.Counter)</p> <p>Total frequencies per class.</p> </li> </ul>"},{"location":"api/naive-bayes/MultinomialNB/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import feature_extraction\n&gt;&gt;&gt; from river import naive_bayes\n\n&gt;&gt;&gt; docs = [\n...     (\"Chinese Beijing Chinese\", \"yes\"),\n...     (\"Chinese Chinese Shanghai\", \"yes\"),\n...     (\"Chinese Macao\", \"maybe\"),\n...     (\"Tokyo Japan Chinese\", \"no\")\n... ]\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n...     (\"nb\", naive_bayes.MultinomialNB(alpha=1))\n... )\n\n&gt;&gt;&gt; for sentence, label in docs:\n...     model = model.learn_one(sentence, label)\n\n&gt;&gt;&gt; model[\"nb\"].p_class(\"yes\")\n0.5\n\n&gt;&gt;&gt; model[\"nb\"].p_class(\"no\")\n0.25\n\n&gt;&gt;&gt; model[\"nb\"].p_class(\"maybe\")\n0.25\n\n&gt;&gt;&gt; model.predict_proba_one(\"test\")\n{'yes': 0.413, 'maybe': 0.310, 'no': 0.275}\n\n&gt;&gt;&gt; model.predict_one(\"test\")\n'yes'\n</code></pre> <p>You can train the model and make predictions in mini-batch mode using the class methods <code>learn_many</code> and <code>predict_many</code>.</p> <pre><code>&gt;&gt;&gt; df_docs = pd.DataFrame(docs, columns = [\"docs\", \"y\"])\n\n&gt;&gt;&gt; X = pd.Series([\n...    \"Chinese Beijing Chinese\",\n...    \"Chinese Chinese Shanghai\",\n...    \"Chinese Macao\",\n...    \"Tokyo Japan Chinese\"\n... ])\n\n&gt;&gt;&gt; y = pd.Series([\"yes\", \"yes\", \"maybe\", \"no\"])\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n...     (\"nb\", naive_bayes.MultinomialNB(alpha=1))\n... )\n\n&gt;&gt;&gt; model = model.learn_many(X, y)\n\n&gt;&gt;&gt; unseen = pd.Series([\"Taiwanese Taipei\", \"Chinese Shanghai\"])\n\n&gt;&gt;&gt; model.predict_proba_many(unseen)\n      maybe        no       yes\n0  0.373272  0.294931  0.331797\n1  0.160396  0.126733  0.712871\n\n&gt;&gt;&gt; model.predict_many(unseen)\n0    maybe\n1      yes\ndtype: object\n</code></pre>"},{"location":"api/naive-bayes/MultinomialNB/#methods","title":"Methods","text":"joint_log_likelihood <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>float:     Mapping between classes and joint log likelihood.</p>   joint_log_likelihood_many <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul> <p>Returns</p> <p>DataFrame:     Input samples joint log likelihood.</p>   learn_many <p>Learn from a batch of count vectors.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> <li>y     (pandas.core.series.Series)    </li> </ul> <p>Returns</p> <p>MiniBatchClassifier:     self</p>   learn_one <p>Updates the model with a single observation.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   p_class   p_class_many   p_feature_given_class   predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_many <p>Return probabilities using the log-likelihoods in mini-batchs setting.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul>   predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul>"},{"location":"api/naive-bayes/MultinomialNB/#references","title":"References","text":"<ol> <li> <p>Naive Bayes text classification \u21a9</p> </li> </ol>"},{"location":"api/neighbors/KNNClassifier/","title":"KNNClassifier","text":"<p>K-Nearest Neighbors (KNN) for classification.</p> <p>This works by storing a buffer with the <code>window_size</code> most recent observations. A brute-force search is used to find the <code>n_neighbors</code> nearest observations in the buffer to make a prediction. See the NearestNeighbors parent class for more details.</p>"},{"location":"api/neighbors/KNNClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_neighbors (int) \u2013 defaults to <code>5</code></p> <p>The number of nearest neighbors to search for.</p> </li> <li> <p>window_size (int) \u2013 defaults to <code>1000</code></p> <p>The maximum size of the window storing the last observed samples.</p> </li> <li> <p>min_distance_keep (float) \u2013 defaults to <code>0.0</code></p> <p>The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates. Default is 0.05 to add similar but not exactly the same points.</p> </li> <li> <p>weighted (bool) \u2013 defaults to <code>True</code></p> <p>Weight the contribution of each neighbor by it's inverse distance.</p> </li> <li> <p>cleanup_every (int) \u2013 defaults to <code>0</code></p> <p>This determines at which rate old classes are cleaned up. Classes that have been seen in the past but that are not present in the current window are dropped. Classes are never dropped when this is set to 0.</p> </li> <li> <p>distance_func (river.neighbors.base.DistanceFunc) \u2013 defaults to <code>None</code></p> <p>An optional distance function that should accept an a=, b=, and any custom set of kwargs. If not defined, the Minkowski distance is used with p=2 (Euclidean distance). See the example section for more details.</p> </li> <li> <p>softmax (bool) \u2013 defaults to <code>False</code></p> <p>Whether or not to use softmax normalization to normalize the neighbors contributions. Votes are divided by the total number of votes if this is <code>False</code>.</p> </li> </ul>"},{"location":"api/neighbors/KNNClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import neighbors\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     neighbors.KNNClassifier(window_size=50)\n... )\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metrics.Accuracy())\nAccuracy: 84.55%\n</code></pre> <p>When defining a custom distance function you can rely on <code>functools.partial</code> to set default parameter values. For instance, let's use the Manhattan function instead of the default Euclidean distance:</p> <pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; from river import utils\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     neighbors.KNNClassifier(\n...         window_size=50,\n...         distance_func=functools.partial(utils.math.minkowski_distance, p=1)\n...     )\n... )\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metrics.Accuracy())\nAccuracy: 86.87%\n</code></pre>"},{"location":"api/neighbors/KNNClassifier/#methods","title":"Methods","text":"clean_up_classes <p>Clean up classes added to the window.</p> <p>Classes that are added (and removed) from the window may no longer be valid. This method cleans up the window and and ensures only known classes are added, and we do not consider \"None\" a class. It is called every <code>cleanup_every</code> step, or can be called manually.</p>   learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/neighbors/KNNClassifier/#notes","title":"Notes","text":"<p>Note that since the window is moving and we keep track of all classes that are added at some point, a class might be returned in a result (with a value of 0) if it is no longer in the window. You can call model.clean_up_classes(), or set <code>cleanup_every</code> to a non-zero value.</p>"},{"location":"api/neighbors/KNNRegressor/","title":"KNNRegressor","text":"<p>K-Nearest Neighbors regressor.</p> <p>This non-parametric regression method keeps track of the last <code>window_size</code> training samples. Predictions are obtained by aggregating the values of the closest n_neighbors stored samples with respect to a query sample.</p>"},{"location":"api/neighbors/KNNRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_neighbors (int) \u2013 defaults to <code>5</code></p> <p>The number of nearest neighbors to search for.</p> </li> <li> <p>window_size (int) \u2013 defaults to <code>1000</code></p> <p>The maximum size of the window storing the last observed samples.</p> </li> <li> <p>aggregation_method (str) \u2013 defaults to <code>mean</code></p> <p>The method to aggregate the target values of neighbors.     | 'mean'     | 'median'     | 'weighted_mean'</p> </li> <li> <p>min_distance_keep (float) \u2013 defaults to <code>0.0</code></p> <p>The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates.</p> </li> <li> <p>distance_func (river.neighbors.base.DistanceFunc) \u2013 defaults to <code>None</code></p> <p>An optional distance function that should accept an a=, b=, and any custom set of kwargs. If not defined, the Minkowski distance is used with p=2 (Euclidean distance). See the example section for more details.</p> </li> </ul>"},{"location":"api/neighbors/KNNRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import neighbors\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = neighbors.KNNRegressor(window_size=50)\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metrics.RMSE())\nRMSE: 1.427746\n</code></pre> <p>When defining a custom distance function you can rely on <code>functools.partial</code> to set default parameter values. For instance, let's use the Manhattan function instead of the default Euclidean distance:</p> <pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; from river.utils.math import minkowski_distance\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     neighbors.KNNRegressor(\n...         window_size=50,\n...         distance_func=functools.partial(minkowski_distance, p=1)\n...     )\n... )\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metrics.RMSE())\nRMSE: 1.460385\n</code></pre>"},{"location":"api/neighbors/KNNRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/neighbors/NearestNeighbors/","title":"NearestNeighbors","text":"<p>Exact nearest neighbors search data structure.</p>"},{"location":"api/neighbors/NearestNeighbors/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size (int)</p> <p>Size of the sliding window use to search neighbors with.</p> </li> <li> <p>min_distance_keep (float)</p> <p>The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates.</p> </li> <li> <p>distance_func (Union[river.neighbors.base.DistanceFunc, river.neighbors.base.FunctionWrapper])</p> <p>A distance function which accepts two input items to compare.</p> </li> </ul>"},{"location":"api/neighbors/NearestNeighbors/#methods","title":"Methods","text":"append <p>Add a point to the window, optionally with extra metadata.</p> <p>Parameters</p> <ul> <li>item     (Any)    </li> <li>extra     (Optional[Any])     \u2013 defaults to <code>None</code> </li> </ul>   find_nearest <p>Find the <code>n_neighbors</code> closest points to <code>item</code>, along with their distances.</p> <p>Parameters</p> <ul> <li>item     (Any)    </li> <li>n_neighbors     (int)     \u2013 defaults to <code>1</code> </li> </ul>   update <p>Update the window with a new point, only added if &gt; min distance.</p> <p>If min distance is 0, we do not need to do the calculation. The item (and extra metadata) will not be added to the window if it is too close to an existing point.</p> <p>Parameters</p> <ul> <li>item     (Any)    </li> <li>n_neighbors     (int)     \u2013 defaults to <code>1</code> </li> <li>extra     (Optional[Any])     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>A boolean (true/false) to indicate if the point was added.</p>"},{"location":"api/neighbors/NearestNeighbors/#notes","title":"Notes","text":"<p>Updates are by default stored by the FIFO (first in first out) method, which means that when the size limit is reached, old samples are dumped to give room for new samples. This is circular, meaning that older points are dumped first. This also gives the implementation a temporal aspect, because older samples are replaced with newer ones.</p> <p>The parameter <code>min_dinstance_keep</code> controls the addition of new items to the window - items that are far enough away (&gt; min_distance_keep) are added to the window. Thus a value of 0 indicates that we add all points, and increasing from 0 makes it less likely we will keep a new item.</p>"},{"location":"api/neural-net/MLPRegressor/","title":"MLPRegressor","text":"<p>Multi-layer Perceptron for regression.</p> <p>This model is still work in progress. Here are some features that still need implementing: </p> <ul> <li><code>learn_one</code> and <code>predict_one</code> just cast the input <code>dict</code> to a single row dataframe and then     call <code>learn_many</code> and <code>predict_many</code> respectively. This is very inefficient. - Not all of the optimizers in the <code>optim</code> module can be used as they are not all vectorised. - Emerging and disappearing features are not supported. Each instance/batch has to have the     same features. - The gradient haven't been numerically checked.</li> </ul>"},{"location":"api/neural-net/MLPRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>hidden_dims</p> <p>The dimensions of the hidden layers. For example, specifying <code>(10, 20)</code> means that there are two hidden layers with 10 and 20 neurons, respectively. Note that the number of layers the network contains is equal to the number of hidden layers plus two (to account for the input and output layers).</p> </li> <li> <p>activations</p> <p>The activation functions to use at each layer, including the input and output layers. Therefore you need to specify three activation if you specify one hidden layer.</p> </li> <li> <p>loss ('optim.losses.Loss') \u2013 defaults to <code>None</code></p> <p>Loss function. Defaults to <code>optim.losses.Squared</code>.</p> </li> <li> <p>optimizer ('optim.base.Optimizer') \u2013 defaults to <code>None</code></p> <p>Optimizer. Defaults to <code>optim.SGD(.01)</code>.</p> </li> <li> <p>seed ('int') \u2013 defaults to <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/neural-net/MLPRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>n_layers</p> <p>Return the number of layers in the network.  The number of layers is equal to the number of hidden layers plus 2. The 2 accounts for the input layer and the output layer.</p> </li> </ul>"},{"location":"api/neural-net/MLPRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import neural_net as nn\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing as pp\n&gt;&gt;&gt; from river import metrics\n\n&gt;&gt;&gt; model = (\n...     pp.StandardScaler() |\n...     nn.MLPRegressor(\n...         hidden_dims=(5,),\n...         activations=(\n...             nn.activations.ReLU,\n...             nn.activations.ReLU,\n...             nn.activations.Identity\n...         ),\n...         optimizer=optim.SGD(1e-3),\n...         seed=42\n...     )\n... )\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 1.589827\n</code></pre> <p>You can also use this to process mini-batches of data.</p> <pre><code>&gt;&gt;&gt; model = (\n...     pp.StandardScaler() |\n...     nn.MLPRegressor(\n...         hidden_dims=(10,),\n...         activations=(\n...             nn.activations.ReLU,\n...             nn.activations.ReLU,\n...             nn.activations.ReLU\n...         ),\n...         optimizer=optim.SGD(1e-4),\n...         seed=42\n...     )\n... )\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; batch_size = 32\n\n&gt;&gt;&gt; for epoch in range(10):\n...     for xb in pd.read_csv(dataset.path, chunksize=batch_size):\n...         yb = xb.pop('five_thirty_eight')\n...         y_pred = model.predict_many(xb)\n...         model = model.learn_many(xb, yb)\n\n&gt;&gt;&gt; model.predict_many(xb)\n      five_thirty_eight\n992           39.361609\n993           46.398536\n994           42.094086\n995           40.195802\n996           40.782954\n997           40.839678\n998           40.896403\n999           48.362659\n1000          42.021849\n</code></pre>"},{"location":"api/neural-net/MLPRegressor/#methods","title":"Methods","text":"call <p>Make predictions.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul>   learn_many <p>Train the network.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> <li>y     ('pd.DataFrame')    </li> </ul>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_many   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/neural-net/activations/Identity/","title":"Identity","text":"<p>Identity activation function.</p>"},{"location":"api/neural-net/activations/Identity/#methods","title":"Methods","text":"apply <p>Apply the activation function to a layer output z.</p> <ul> <li>z </li> </ul>   gradient <p>Return the gradient with respect to a layer output z.</p> <ul> <li>z </li> </ul>"},{"location":"api/neural-net/activations/ReLU/","title":"ReLU","text":"<p>Rectified Linear Unit (ReLU) activation function.</p>"},{"location":"api/neural-net/activations/ReLU/#methods","title":"Methods","text":"apply <p>Apply the activation function to a layer output z.</p> <ul> <li>z </li> </ul>   gradient <p>Return the gradient with respect to a layer output z.</p> <ul> <li>z </li> </ul>"},{"location":"api/neural-net/activations/Sigmoid/","title":"Sigmoid","text":"<p>Sigmoid activation function.</p>"},{"location":"api/neural-net/activations/Sigmoid/#methods","title":"Methods","text":"apply <p>Apply the activation function to a layer output z.</p> <ul> <li>z </li> </ul>   gradient <p>Return the gradient with respect to a layer output z.</p> <ul> <li>z </li> </ul>"},{"location":"api/optim/AMSGrad/","title":"AMSGrad","text":"<p>AMSGrad optimizer.</p>"},{"location":"api/optim/AMSGrad/#parameters","title":"Parameters","text":"<ul> <li> <p>lr ('int | float | optim.base.Scheduler') \u2013 defaults to <code>0.1</code></p> <p>The learning rate.</p> </li> <li> <p>beta_1 \u2013 defaults to <code>0.9</code></p> </li> <li> <p>beta_2 \u2013 defaults to <code>0.999</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> <li> <p>correct_bias \u2013 defaults to <code>True</code></p> </li> </ul>"},{"location":"api/optim/AMSGrad/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>v (collections.defaultdict)</p> </li> <li> <p>v_hat (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AMSGrad/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.AMSGrad()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 86.57%\n</code></pre>"},{"location":"api/optim/AMSGrad/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/AMSGrad/#references","title":"References","text":"<ol> <li> <p>Reddi, S.J., Kale, S. and Kumar, S., 2019. On the convergence of adam and beyond. arXiv preprint arXiv:1904.09237 \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaBound/","title":"AdaBound","text":"<p>AdaBound optimizer.</p>"},{"location":"api/optim/AdaBound/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.001</code></p> <p>The learning rate.</p> </li> <li> <p>beta_1 \u2013 defaults to <code>0.9</code></p> </li> <li> <p>beta_2 \u2013 defaults to <code>0.999</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> <li> <p>gamma \u2013 defaults to <code>0.001</code></p> </li> <li> <p>final_lr \u2013 defaults to <code>0.1</code></p> </li> </ul>"},{"location":"api/optim/AdaBound/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>s (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AdaBound/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.AdaBound()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.90%\n</code></pre>"},{"location":"api/optim/AdaBound/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/AdaBound/#references","title":"References","text":"<ol> <li> <p>Luo, L., Xiong, Y., Liu, Y. and Sun, X., 2019. Adaptive gradient methods with dynamic bound of learning rate. arXiv preprint arXiv:1902.09843 \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaDelta/","title":"AdaDelta","text":"<p>AdaDelta optimizer.</p>"},{"location":"api/optim/AdaDelta/#parameters","title":"Parameters","text":"<ul> <li> <p>rho \u2013 defaults to <code>0.95</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/AdaDelta/#attributes","title":"Attributes","text":"<ul> <li> <p>g2 (collections.defaultdict)</p> </li> <li> <p>s2 (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AdaDelta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.AdaDelta()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 80.56%\n</code></pre>"},{"location":"api/optim/AdaDelta/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/AdaDelta/#references","title":"References","text":"<ol> <li> <p>Zeiler, M.D., 2012. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701. \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaGrad/","title":"AdaGrad","text":"<p>AdaGrad optimizer.</p>"},{"location":"api/optim/AdaGrad/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.1</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/AdaGrad/#attributes","title":"Attributes","text":"<ul> <li>g2 (collections.defaultdict)</li> </ul>"},{"location":"api/optim/AdaGrad/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.AdaGrad()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 88.01%\n</code></pre>"},{"location":"api/optim/AdaGrad/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/AdaGrad/#references","title":"References","text":"<ol> <li> <p>Duchi, J., Hazan, E. and Singer, Y., 2011. Adaptive subgradient methods for online learning and stochastic optimization. Journal of machine learning research, 12(Jul), pp.2121-2159. \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaMax/","title":"AdaMax","text":"<p>AdaMax optimizer.</p>"},{"location":"api/optim/AdaMax/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.1</code></p> </li> <li> <p>beta_1 \u2013 defaults to <code>0.9</code></p> </li> <li> <p>beta_2 \u2013 defaults to <code>0.999</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/AdaMax/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>v (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AdaMax/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.AdaMax()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.53%\n</code></pre>"},{"location":"api/optim/AdaMax/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/AdaMax/#references","title":"References","text":"<ol> <li> <p>Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9</p> </li> <li> <p>Ruder, S., 2016. An overview of gradient descent optimization algorithms. arXiv preprint arXiv:1609.04747. \u21a9</p> </li> </ol>"},{"location":"api/optim/Adam/","title":"Adam","text":"<p>Adam optimizer.</p>"},{"location":"api/optim/Adam/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.1</code></p> </li> <li> <p>beta_1 \u2013 defaults to <code>0.9</code></p> </li> <li> <p>beta_2 \u2013 defaults to <code>0.999</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/Adam/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>v (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/Adam/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.Adam()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 86.50%\n</code></pre>"},{"location":"api/optim/Adam/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/Adam/#references","title":"References","text":"<ol> <li> <p>Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9</p> </li> </ol>"},{"location":"api/optim/Averager/","title":"Averager","text":"<p>Averaged stochastic gradient descent.</p> <p>This is a wrapper that can be applied to any stochastic gradient descent optimiser. Note that this implementation differs than what may be found elsewhere. Essentially, the average of the weights is usually only used at the end of the optimisation, once all the data has been seen. However, in this implementation the optimiser returns the current averaged weights.</p>"},{"location":"api/optim/Averager/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer ('optim.base.Optimizer')</p> <p>An optimizer for which the produced weights will be averaged.</p> </li> <li> <p>start ('int') \u2013 defaults to <code>0</code></p> <p>Indicates the number of iterations to wait before starting the average. Essentially, nothing happens differently before the number of iterations reaches this value.</p> </li> </ul>"},{"location":"api/optim/Averager/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/Averager/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.Averager(optim.SGD(0.01), 100)\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.89%\n</code></pre>"},{"location":"api/optim/Averager/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/Averager/#references","title":"References","text":"<ol> <li> <p>Bottou, L., 2010. Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT'2010 (pp. 177-186). Physica-Verlag HD. \u21a9</p> </li> <li> <p>Stochastic Algorithms for One-Pass Learning slides by L\u00e9on Bottou \u21a9</p> </li> <li> <p>Xu, W., 2011. Towards optimal one pass large scale learning with averaged stochastic gradient descent. arXiv preprint arXiv:1107.2490. \u21a9</p> </li> </ol>"},{"location":"api/optim/FTRLProximal/","title":"FTRLProximal","text":"<p>FTRL-Proximal optimizer.</p>"},{"location":"api/optim/FTRLProximal/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha \u2013 defaults to <code>0.05</code></p> </li> <li> <p>beta \u2013 defaults to <code>1.0</code></p> </li> <li> <p>l1 \u2013 defaults to <code>0.0</code></p> </li> <li> <p>l2 \u2013 defaults to <code>1.0</code></p> </li> </ul>"},{"location":"api/optim/FTRLProximal/#attributes","title":"Attributes","text":"<ul> <li> <p>z (collections.defaultdict)</p> </li> <li> <p>n (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/FTRLProximal/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.FTRLProximal()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.66%\n</code></pre>"},{"location":"api/optim/FTRLProximal/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/FTRLProximal/#references","title":"References","text":"<ol> <li> <p>McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9</p> </li> <li> <p>Tensorflow's <code>FtrlOptimizer</code> \u21a9</p> </li> </ol>"},{"location":"api/optim/Momentum/","title":"Momentum","text":"<p>Momentum optimizer.</p>"},{"location":"api/optim/Momentum/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.1</code></p> </li> <li> <p>rho \u2013 defaults to <code>0.9</code></p> </li> </ul>"},{"location":"api/optim/Momentum/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/Momentum/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.Momentum()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 84.16%\n</code></pre>"},{"location":"api/optim/Momentum/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/Nadam/","title":"Nadam","text":"<p>Nadam optimizer.</p>"},{"location":"api/optim/Nadam/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.1</code></p> </li> <li> <p>beta_1 \u2013 defaults to <code>0.9</code></p> </li> <li> <p>beta_2 \u2013 defaults to <code>0.999</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/Nadam/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/Nadam/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.Nadam()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 86.60%\n</code></pre>"},{"location":"api/optim/Nadam/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/Nadam/#references","title":"References","text":"<ol> <li> <p>Nadam: A combination of adam and nesterov \u21a9</p> </li> </ol>"},{"location":"api/optim/NesterovMomentum/","title":"NesterovMomentum","text":"<p>Nesterov Momentum optimizer.</p>"},{"location":"api/optim/NesterovMomentum/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.1</code></p> </li> <li> <p>rho \u2013 defaults to <code>0.9</code></p> </li> </ul>"},{"location":"api/optim/NesterovMomentum/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/NesterovMomentum/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.NesterovMomentum()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 84.29%\n</code></pre>"},{"location":"api/optim/NesterovMomentum/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/RMSProp/","title":"RMSProp","text":"<p>RMSProp optimizer.</p>"},{"location":"api/optim/RMSProp/#parameters","title":"Parameters","text":"<ul> <li> <p>lr \u2013 defaults to <code>0.1</code></p> </li> <li> <p>rho \u2013 defaults to <code>0.9</code></p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/RMSProp/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/RMSProp/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.RMSProp()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.24%\n</code></pre>"},{"location":"api/optim/RMSProp/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/RMSProp/#references","title":"References","text":"<ol> <li> <p>Divide the gradient by a running average of itsrecent magnitude \u21a9</p> </li> </ol>"},{"location":"api/optim/SGD/","title":"SGD","text":"<p>Plain stochastic gradient descent.</p>"},{"location":"api/optim/SGD/#parameters","title":"Parameters","text":"<ul> <li>lr \u2013 defaults to <code>0.01</code></li> </ul>"},{"location":"api/optim/SGD/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/SGD/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; optimizer = optim.SGD(0.1)\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     linear_model.LogisticRegression(optimizer)\n... )\n&gt;&gt;&gt; metric = metrics.F1()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nF1: 87.85%\n</code></pre>"},{"location":"api/optim/SGD/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/SGD/#references","title":"References","text":"<ol> <li> <p>Robbins, H. and Monro, S., 1951. A stochastic approximation method. The annals of mathematical statistics, pp.400-407 \u21a9</p> </li> </ol>"},{"location":"api/optim/base/Initializer/","title":"Initializer","text":"<p>An initializer is used to set initial weights in a model.</p>"},{"location":"api/optim/base/Initializer/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2013 defaults to <code>1</code> </li> </ul>"},{"location":"api/optim/base/Loss/","title":"Loss","text":"<p>Base class for all loss functions.</p>"},{"location":"api/optim/base/Loss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/base/Optimizer/","title":"Optimizer","text":"<p>Optimizer interface.</p> <p>Every optimizer inherits from this base interface.</p>"},{"location":"api/optim/base/Optimizer/#parameters","title":"Parameters","text":"<ul> <li>lr ('int | float | Scheduler')</li> </ul>"},{"location":"api/optim/base/Optimizer/#attributes","title":"Attributes","text":"<ul> <li> <p>learning_rate (float)</p> <p>Returns the current learning rate value.</p> </li> </ul>"},{"location":"api/optim/base/Optimizer/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     ('dict')    </li> </ul>   step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     ('dict | VectorLike')    </li> <li>g     ('dict | VectorLike')    </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p>"},{"location":"api/optim/base/Scheduler/","title":"Scheduler","text":"<p>Can be used to program the learning rate schedule of an <code>optim.base.Optimizer</code>.</p>"},{"location":"api/optim/base/Scheduler/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     ('int')    </li> </ul>"},{"location":"api/optim/initializers/Constant/","title":"Constant","text":"<p>Constant initializer which always returns the same value.</p>"},{"location":"api/optim/initializers/Constant/#parameters","title":"Parameters","text":"<ul> <li>value (float)</li> </ul>"},{"location":"api/optim/initializers/Constant/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; init = optim.initializers.Constant(value=3.14)\n\n&gt;&gt;&gt; init(shape=1)\n3.14\n\n&gt;&gt;&gt; init(shape=2)\narray([3.14, 3.14])\n</code></pre>"},{"location":"api/optim/initializers/Constant/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2013 defaults to <code>1</code> </li> </ul>"},{"location":"api/optim/initializers/Normal/","title":"Normal","text":"<p>Random normal initializer which simulate a normal distribution with specified parameters.</p>"},{"location":"api/optim/initializers/Normal/#parameters","title":"Parameters","text":"<ul> <li> <p>mu \u2013 defaults to <code>0.0</code></p> <p>The mean of the normal distribution</p> </li> <li> <p>sigma \u2013 defaults to <code>1.0</code></p> <p>The standard deviation of the normal distribution</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generation seed that can be set for reproducibility.</p> </li> </ul>"},{"location":"api/optim/initializers/Normal/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; init = optim.initializers.Normal(mu=0, sigma=1, seed=42)\n\n&gt;&gt;&gt; init(shape=1)\n0.496714\n\n&gt;&gt;&gt; init(shape=2)\narray([-0.1382643 ,  0.64768854])\n</code></pre>"},{"location":"api/optim/initializers/Normal/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2013 defaults to <code>1</code> </li> </ul>"},{"location":"api/optim/initializers/Zeros/","title":"Zeros","text":"<p>Constant initializer which always returns zeros.</p>"},{"location":"api/optim/initializers/Zeros/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; init = optim.initializers.Zeros()\n\n&gt;&gt;&gt; init(shape=1)\n0.0\n\n&gt;&gt;&gt; init(shape=2)\narray([0., 0.])\n</code></pre>"},{"location":"api/optim/initializers/Zeros/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2013 defaults to <code>1</code> </li> </ul>"},{"location":"api/optim/losses/Absolute/","title":"Absolute","text":"<p>Absolute loss, also known as the mean absolute error or L1 loss.</p> <p>Mathematically, it is defined as </p> \\[L = |p_i - y_i|\\] <p>It's gradient w.r.t. to \\(p_i\\) is </p> \\[\\frac{\\partial L}{\\partial p_i} = sgn(p_i - y_i)\\]"},{"location":"api/optim/losses/Absolute/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; loss = optim.losses.Absolute()\n&gt;&gt;&gt; loss(-42, 42)\n84\n&gt;&gt;&gt; loss.gradient(1, 2)\n1\n&gt;&gt;&gt; loss.gradient(2, 1)\n-1\n</code></pre>"},{"location":"api/optim/losses/Absolute/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/BinaryFocalLoss/","title":"BinaryFocalLoss","text":"<p>Binary focal loss.</p> <p>This implements the \"star\" algorithm from the appendix of the focal loss paper.</p>"},{"location":"api/optim/losses/BinaryFocalLoss/#parameters","title":"Parameters","text":"<ul> <li> <p>gamma \u2013 defaults to <code>2</code></p> </li> <li> <p>beta \u2013 defaults to <code>1</code></p> </li> </ul>"},{"location":"api/optim/losses/BinaryFocalLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/BinaryFocalLoss/#references","title":"References","text":"<ol> <li>Lin, T.Y., Goyal, P., Girshick, R., He, K. and Doll\u00e1r, P., 2017. Focal loss for dense object detection. In Proceedings of the IEEE international conference on computer vision (pp. 2980-2988)</li> </ol>"},{"location":"api/optim/losses/BinaryLoss/","title":"BinaryLoss","text":"<p>A loss appropriate for binary classification tasks.</p>"},{"location":"api/optim/losses/BinaryLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Cauchy/","title":"Cauchy","text":"<p>Cauchy loss function.</p>"},{"location":"api/optim/losses/Cauchy/#parameters","title":"Parameters","text":"<ul> <li>C \u2013 defaults to <code>80</code></li> </ul>"},{"location":"api/optim/losses/Cauchy/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Cauchy/#references","title":"References","text":"<ol> <li> <p>\"Effect of MAE\" Kaggle discussion \u21a9</p> </li> <li> <p>Paris Madness Kaggle kernel \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/CrossEntropy/","title":"CrossEntropy","text":"<p>Cross entropy loss.</p> <p>This is a generalization of logistic loss to multiple classes.</p>"},{"location":"api/optim/losses/CrossEntropy/#parameters","title":"Parameters","text":"<ul> <li> <p>class_weight (Dict[Union[bool, str, int], float]) \u2013 defaults to <code>None</code></p> <p>A dictionary that indicates what weight to associate with each class.</p> </li> </ul>"},{"location":"api/optim/losses/CrossEntropy/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; y_true = [0, 1, 2, 2]\n&gt;&gt;&gt; y_pred = [\n...     {0: 0.29450637, 1: 0.34216758, 2: 0.36332605},\n...     {0: 0.21290077, 1: 0.32728332, 2: 0.45981591},\n...     {0: 0.42860913, 1: 0.33380113, 2: 0.23758974},\n...     {0: 0.44941979, 1: 0.32962558, 2: 0.22095463}\n... ]\n\n&gt;&gt;&gt; loss = optim.losses.CrossEntropy()\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(loss(yt, yp))\n1.222454\n1.116929\n1.437209\n1.509797\n\n&gt;&gt;&gt; for yt, yp in zip(y_true, y_pred):\n...     print(loss.gradient(yt, yp))\n{0: -0.70549363, 1: 0.34216758, 2: 0.36332605}\n{0: 0.21290077, 1: -0.67271668, 2: 0.45981591}\n{0: 0.42860913, 1: 0.33380113, 2: -0.76241026}\n{0: 0.44941979, 1: 0.32962558, 2: -0.77904537}\n</code></pre>"},{"location":"api/optim/losses/CrossEntropy/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/CrossEntropy/#references","title":"References","text":"<ol> <li> <p>What is Softmax regression and how is it related to Logistic regression? \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/","title":"EpsilonInsensitiveHinge","text":"<p>Epsilon-insensitive hinge loss.</p>"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#parameters","title":"Parameters","text":"<ul> <li>eps \u2013 defaults to <code>0.1</code></li> </ul>"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Hinge/","title":"Hinge","text":"<p>Computes the hinge loss.</p> <p>Mathematically, it is defined as </p> \\[L = max(0, 1 - p_i * y_i)\\] <p>It's gradient w.r.t. to \\(p_i\\) is </p> \\[ \\\\frac{\\\\partial L}{\\\\partial y_i} = \\\\left\\{ \\\\begin{array}{ll}     \\\\ 0  &amp;   p_iy_i \\geqslant 1  \\\\\\\\     \\\\ - y_i &amp; p_iy_i &lt; 1 \\\\end{array} \\\\right. \\]"},{"location":"api/optim/losses/Hinge/#parameters","title":"Parameters","text":"<ul> <li> <p>threshold \u2013 defaults to <code>1.0</code></p> <p>Margin threshold. 1 yield the loss used in SVMs, whilst 0 is equivalent to the loss used in the Perceptron algorithm.</p> </li> </ul>"},{"location":"api/optim/losses/Hinge/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; loss = optim.losses.Hinge(threshold=1)\n&gt;&gt;&gt; loss(1, .2)\n0.8\n\n&gt;&gt;&gt; loss.gradient(1, .2)\n-1\n</code></pre>"},{"location":"api/optim/losses/Hinge/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Huber/","title":"Huber","text":"<p>Huber loss.</p> <p>Variant of the squared loss that is robust to outliers.</p>"},{"location":"api/optim/losses/Huber/#parameters","title":"Parameters","text":"<ul> <li>epsilon \u2013 defaults to <code>0.1</code></li> </ul>"},{"location":"api/optim/losses/Huber/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Huber/#references","title":"References","text":"<ol> <li>Huber loss function - Wikipedia</li> </ol>"},{"location":"api/optim/losses/Log/","title":"Log","text":"<p>Logarithmic loss.</p> <p>This loss function expects each provided <code>y_pred</code> to be a logit. In other words if must be the raw output of a linear model or a neural network.</p>"},{"location":"api/optim/losses/Log/#parameters","title":"Parameters","text":"<ul> <li> <p>weight_pos \u2013 defaults to <code>1.0</code></p> </li> <li> <p>weight_neg \u2013 defaults to <code>1.0</code></p> </li> </ul>"},{"location":"api/optim/losses/Log/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Log/#references","title":"References","text":"<ol> <li> <p>Logit Wikipedia page \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/MultiClassLoss/","title":"MultiClassLoss","text":"<p>A loss appropriate for multi-class classification tasks.</p>"},{"location":"api/optim/losses/MultiClassLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Poisson/","title":"Poisson","text":"<p>Poisson loss.</p> <p>The Poisson loss is usually more suited for regression with count data than the squared loss. </p> <p>Mathematically, it is defined as </p> \\[L = exp(p_i) - y_i \\times p_i\\] <p>It's gradient w.r.t. to \\(p_i\\) is </p> \\[\\frac{\\partial L}{\\partial p_i} = exp(p_i) - y_i\\]"},{"location":"api/optim/losses/Poisson/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Quantile/","title":"Quantile","text":"<p>Quantile loss.</p>"},{"location":"api/optim/losses/Quantile/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha \u2013 defaults to <code>0.5</code></p> <p>Desired quantile to attain.</p> </li> </ul>"},{"location":"api/optim/losses/Quantile/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; loss = optim.losses.Quantile(0.5)\n&gt;&gt;&gt; loss(1, 3)\n1.0\n\n&gt;&gt;&gt; loss.gradient(1, 3)\n0.5\n\n&gt;&gt;&gt; loss.gradient(3, 1)\n-0.5\n</code></pre>"},{"location":"api/optim/losses/Quantile/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Quantile/#references","title":"References","text":"<ol> <li> <p>Wikipedia article on quantile regression \u21a9</p> </li> <li> <p>Derivative from WolframAlpha \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/RegressionLoss/","title":"RegressionLoss","text":"<p>A loss appropriate for regression tasks.</p>"},{"location":"api/optim/losses/RegressionLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/losses/Squared/","title":"Squared","text":"<p>Squared loss, also known as the L2 loss.</p> <p>Mathematically, it is defined as </p> \\[L = (p_i - y_i) ^ 2\\] <p>It's gradient w.r.t. to \\(p_i\\) is </p> \\[\\frac{\\partial L}{\\partial p_i} = 2       imes (p_i - y_i)\\] <p>One thing to note is that this convention is consistent with Vowpal Wabbit and PyTorch, but not with scikit-learn. Indeed, scikit-learn divides the loss by 2, making the 2 disappear in the gradient.</p>"},{"location":"api/optim/losses/Squared/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n\n&gt;&gt;&gt; loss = optim.losses.Squared()\n&gt;&gt;&gt; loss(-4, 5)\n81\n&gt;&gt;&gt; loss.gradient(-4, 5)\n18\n&gt;&gt;&gt; loss.gradient(5, -4)\n-18\n</code></pre>"},{"location":"api/optim/losses/Squared/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p>   gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p>   mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p>"},{"location":"api/optim/schedulers/Constant/","title":"Constant","text":"<p>Always uses the same learning rate.</p>"},{"location":"api/optim/schedulers/Constant/#parameters","title":"Parameters","text":"<ul> <li>learning_rate ('int | float')</li> </ul>"},{"location":"api/optim/schedulers/Constant/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     ('int')    </li> </ul>"},{"location":"api/optim/schedulers/InverseScaling/","title":"InverseScaling","text":"<p>Reduces the learning rate using a power schedule.</p> <p>Assuming an initial learning rate \\(\\eta\\), the learning rate at step \\(t\\) is: </p> \\[\\\\frac{eta}{(t + 1) ^ p}\\] <p>where \\(p\\) is a user-defined parameter.</p>"},{"location":"api/optim/schedulers/InverseScaling/#parameters","title":"Parameters","text":"<ul> <li> <p>learning_rate ('float')</p> </li> <li> <p>power \u2013 defaults to <code>0.5</code></p> </li> </ul>"},{"location":"api/optim/schedulers/InverseScaling/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     ('int')    </li> </ul>"},{"location":"api/optim/schedulers/Optimal/","title":"Optimal","text":"<p>Optimal learning schedule as proposed by L\u00e9on Bottou.</p>"},{"location":"api/optim/schedulers/Optimal/#parameters","title":"Parameters","text":"<ul> <li> <p>loss ('optim.losses.Loss')</p> </li> <li> <p>alpha \u2013 defaults to <code>0.0001</code></p> </li> </ul>"},{"location":"api/optim/schedulers/Optimal/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     ('int')    </li> </ul>"},{"location":"api/optim/schedulers/Optimal/#references","title":"References","text":"<ol> <li> <p>Bottou, L., 2012. Stochastic gradient descent tricks. In Neural networks: Tricks of the trade (pp. 421-436). Springer, Berlin, Heidelberg. \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/AdaptiveStandardScaler/","title":"AdaptiveStandardScaler","text":"<p>Scales data using exponentially weighted moving average and variance.</p> <p>Under the hood, a exponentially weighted running mean and variance are maintained for each feature. This can potentially provide better results for drifting data in comparison to <code>preprocessing.StandardScaler</code>. Indeed, the latter computes a global mean and variance for each feature, whereas this scaler weights data in proportion to their recency.</p>"},{"location":"api/preprocessing/AdaptiveStandardScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor \u2013 defaults to <code>0.3</code></p> <p>This parameter is passed to <code>stats.EWVar</code>. It is expected to be in [0, 1]. More weight is assigned to recent samples the closer <code>fading_factor</code> is to 1.</p> </li> </ul>"},{"location":"api/preprocessing/AdaptiveStandardScaler/#examples","title":"Examples","text":"<p>Consider the following series which contains a positive trend.</p> <pre><code>&gt;&gt;&gt; import random\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; X = [\n...     {'x': random.uniform(4 + i, 6 + i)}\n...     for i in range(8)\n... ]\n&gt;&gt;&gt; for x in X:\n...     print(x)\n{'x': 5.278}\n{'x': 5.050}\n{'x': 6.550}\n{'x': 7.446}\n{'x': 9.472}\n{'x': 10.353}\n{'x': 11.784}\n{'x': 11.173}\n</code></pre> <p>This scaler works well with this kind of data because it uses statistics that assign higher weight to more recent data.</p> <pre><code>&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; scaler = preprocessing.AdaptiveStandardScaler(fading_factor=.6)\n\n&gt;&gt;&gt; for x in X:\n...     print(scaler.learn_one(x).transform_one(x))\n{'x': 0.0}\n{'x': -0.816}\n{'x': 0.812}\n{'x': 0.695}\n{'x': 0.754}\n{'x': 0.598}\n{'x': 0.651}\n{'x': 0.124}\n</code></pre>"},{"location":"api/preprocessing/AdaptiveStandardScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/Binarizer/","title":"Binarizer","text":"<p>Binarizes the data to 0 or 1 according to a threshold.</p>"},{"location":"api/preprocessing/Binarizer/#parameters","title":"Parameters","text":"<ul> <li> <p>threshold \u2013 defaults to <code>0.0</code></p> <p>Values above this are replaced by 1 and the others by 0.</p> </li> <li> <p>dtype \u2013 defaults to <code>&lt;class 'bool'&gt;</code></p> <p>The desired data type to apply.</p> </li> </ul>"},{"location":"api/preprocessing/Binarizer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import river\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; rng = np.random.RandomState(42)\n&gt;&gt;&gt; X = [{'x1': v, 'x2': int(v)} for v in rng.uniform(low=-4, high=4, size=6)]\n\n&gt;&gt;&gt; binarizer = river.preprocessing.Binarizer()\n&gt;&gt;&gt; for x in X:\n...     print(binarizer.learn_one(x).transform_one(x))\n{'x1': False, 'x2': False}\n{'x1': True, 'x2': True}\n{'x1': True, 'x2': True}\n{'x1': True, 'x2': False}\n{'x1': False, 'x2': False}\n{'x1': False, 'x2': False}\n</code></pre>"},{"location":"api/preprocessing/Binarizer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/FeatureHasher/","title":"FeatureHasher","text":"<p>Implements the hashing trick.</p> <p>Each pair of (name, value) features is hashed into a random integer. A module operator is then used to make sure the hash is in a certain range. We use the Murmurhash implementation from scikit-learn.</p>"},{"location":"api/preprocessing/FeatureHasher/#parameters","title":"Parameters","text":"<ul> <li> <p>n_features \u2013 defaults to <code>1048576</code></p> <p>The number by which each hash will be moduloed by.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Set the seed to produce identical results.</p> </li> </ul>"},{"location":"api/preprocessing/FeatureHasher/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import river\n\n&gt;&gt;&gt; hasher = river.preprocessing.FeatureHasher(n_features=10, seed=42)\n\n&gt;&gt;&gt; X = [\n...     {'dog': 1, 'cat': 2, 'elephant': 4},\n...     {'dog': 2, 'run': 5}\n... ]\n&gt;&gt;&gt; for x in X:\n...     print(hasher.transform_one(x))\nCounter({1: 4, 9: 2, 8: 1})\nCounter({4: 5, 8: 2})\n</code></pre>"},{"location":"api/preprocessing/FeatureHasher/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/FeatureHasher/#references","title":"References","text":"<ol> <li> <p>Wikipedia article on feature vectorization using the hashing trick \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/LDA/","title":"LDA","text":"<p>Online Latent Dirichlet Allocation with Infinite Vocabulary.</p> <p>Latent Dirichlet allocation (LDA) is a probabilistic approach for exploring topics in document collections. The key advantage of this variant is that it assumes an infinite vocabulary, meaning that the set of tokens does not have to known in advance, as opposed to the implementation from sklearn The results produced by this implementation are identical to those from the original implementation proposed by the method's authors. </p> <p>This class takes as input token counts. Therefore, it requires you to tokenize beforehand. You can do so by using a <code>feature_extraction.BagOfWords</code> instance, as shown in the example below.</p>"},{"location":"api/preprocessing/LDA/#parameters","title":"Parameters","text":"<ul> <li> <p>n_components \u2013 defaults to <code>10</code></p> <p>Number of topics of the latent Drichlet allocation.</p> </li> <li> <p>number_of_documents \u2013 defaults to <code>1000000.0</code></p> <p>Estimated number of documents.</p> </li> <li> <p>alpha_theta \u2013 defaults to <code>0.5</code></p> <p>Hyper-parameter of the Dirichlet distribution of topics.</p> </li> <li> <p>alpha_beta \u2013 defaults to <code>100.0</code></p> <p>Hyper-parameter of the Dirichlet process of distribution over words.</p> </li> <li> <p>tau \u2013 defaults to <code>64.0</code></p> <p>Learning inertia to prevent premature convergence.</p> </li> <li> <p>kappa \u2013 defaults to <code>0.75</code></p> <p>The learning rate kappa controls how quickly new parameters estimates replace the old ones. kappa \u2208 (0.5, 1] is required for convergence.</p> </li> <li> <p>vocab_prune_interval \u2013 defaults to <code>10</code></p> <p>Interval at which to refresh the words topics distribution.</p> </li> <li> <p>number_of_samples \u2013 defaults to <code>10</code></p> <p>Number of iteration to computes documents topics distribution.</p> </li> <li> <p>ranking_smooth_factor \u2013 defaults to <code>1e-12</code></p> </li> <li> <p>burn_in_sweeps \u2013 defaults to <code>5</code></p> <p>Number of iteration necessaries while analyzing a document before updating document topics distribution.</p> </li> <li> <p>maximum_size_vocabulary \u2013 defaults to <code>4000</code></p> <p>Maximum size of the stored vocabulary.</p> </li> <li> <p>seed ('int') \u2013 defaults to <code>None</code></p> <p>Random number seed used for reproducibility.</p> </li> </ul>"},{"location":"api/preprocessing/LDA/#attributes","title":"Attributes","text":"<ul> <li> <p>counter (int)</p> <p>The current number of observed documents.</p> </li> <li> <p>truncation_size_prime (int)</p> <p>Number of distincts words stored in the vocabulary. Updated before processing a document.</p> </li> <li> <p>truncation_size (int)</p> <p>Number of distincts words stored in the vocabulary. Updated after processing a document.</p> </li> <li> <p>word_to_index (dict)</p> <p>Words as keys and indexes as values.</p> </li> <li> <p>index_to_word (dict)</p> <p>Indexes as keys and words as values.</p> </li> <li> <p>nu_1 (dict)</p> <p>Weights of the words. Component of the variational inference.</p> </li> <li> <p>nu_2 (dict)</p> <p>Weights of the words. Component of the variational inference.</p> </li> </ul>"},{"location":"api/preprocessing/LDA/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import feature_extraction\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; X = [\n...    'weather cold',\n...    'weather hot dry',\n...    'weather cold rainy',\n...    'weather hot',\n...    'weather cold humid',\n... ]\n\n&gt;&gt;&gt; lda = compose.Pipeline(\n...     feature_extraction.BagOfWords(),\n...     preprocessing.LDA(\n...         n_components=2,\n...         number_of_documents=60,\n...         seed=42\n...     )\n... )\n\n&gt;&gt;&gt; for x in X:\n...     lda = lda.learn_one(x)\n...     topics = lda.transform_one(x)\n...     print(topics)\n{0: 0.5, 1: 2.5}\n{0: 1.5, 1: 2.5}\n{0: 3.5, 1: 0.5}\n{0: 1.5, 1: 1.5}\n{0: 2.5, 1: 1.5}\n</code></pre>"},{"location":"api/preprocessing/LDA/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   learn_transform_one <p>Equivalent to <code>lda.learn_one(x).transform_one(x)</code>s, but faster.</p> <p>Parameters</p> <ul> <li>x     ('dict')    </li> </ul> <p>Returns</p> <p>dict:     Component attributions for the input document.</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/LDA/#references","title":"References","text":"<ol> <li> <p>Zhai, K. and Boyd-Graber, J., 2013, February. Online latent Dirichlet allocation with infinite vocabulary. In International Conference on Machine Learning (pp. 561-569). \u21a9</p> </li> <li> <p>PyInfVoc on GitHub \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/MaxAbsScaler/","title":"MaxAbsScaler","text":"<p>Scales the data to a [-1, 1] range based on absolute maximum.</p> <p>Under the hood a running absolute max is maintained. This scaler is meant for data that is already centered at zero or sparse data. It does not shift/center the data, and thus does not destroy any sparsity.</p>"},{"location":"api/preprocessing/MaxAbsScaler/#attributes","title":"Attributes","text":"<ul> <li> <p>abs_max (dict)</p> <p>Mapping between features and instances of <code>stats.AbsMax</code>.</p> </li> </ul>"},{"location":"api/preprocessing/MaxAbsScaler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; X = [{'x': random.uniform(8, 12)} for _ in range(5)]\n&gt;&gt;&gt; for x in X:\n...     print(x)\n{'x': 10.557707}\n{'x': 8.100043}\n{'x': 9.100117}\n{'x': 8.892842}\n{'x': 10.945884}\n\n&gt;&gt;&gt; scaler = preprocessing.MaxAbsScaler()\n\n&gt;&gt;&gt; for x in X:\n...     print(scaler.learn_one(x).transform_one(x))\n{'x': 1.0}\n{'x': 0.767216}\n{'x': 0.861940}\n{'x': 0.842308}\n{'x': 1.0}\n</code></pre>"},{"location":"api/preprocessing/MaxAbsScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/MinMaxScaler/","title":"MinMaxScaler","text":"<p>Scales the data to a fixed range from 0 to 1.</p> <p>Under the hood a running min and a running peak to peak (max - min) are maintained.</p>"},{"location":"api/preprocessing/MinMaxScaler/#attributes","title":"Attributes","text":"<ul> <li> <p>min (dict)</p> <p>Mapping between features and instances of <code>stats.Min</code>.</p> </li> <li> <p>max (dict)</p> <p>Mapping between features and instances of <code>stats.Max</code>.</p> </li> </ul>"},{"location":"api/preprocessing/MinMaxScaler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; X = [{'x': random.uniform(8, 12)} for _ in range(5)]\n&gt;&gt;&gt; for x in X:\n...     print(x)\n{'x': 10.557707}\n{'x': 8.100043}\n{'x': 9.100117}\n{'x': 8.892842}\n{'x': 10.945884}\n\n&gt;&gt;&gt; scaler = preprocessing.MinMaxScaler()\n\n&gt;&gt;&gt; for x in X:\n...     print(scaler.learn_one(x).transform_one(x))\n{'x': 0.0}\n{'x': 0.0}\n{'x': 0.406920}\n{'x': 0.322582}\n{'x': 1.0}\n</code></pre>"},{"location":"api/preprocessing/MinMaxScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/Normalizer/","title":"Normalizer","text":"<p>Scales a set of features so that it has unit norm.</p> <p>This is particularly useful when used after a <code>feature_extraction.TFIDF</code>.</p>"},{"location":"api/preprocessing/Normalizer/#parameters","title":"Parameters","text":"<ul> <li> <p>order \u2013 defaults to <code>2</code></p> <p>Order of the norm (e.g. 2 corresponds to the \\(L^2\\) norm).</p> </li> </ul>"},{"location":"api/preprocessing/Normalizer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; scaler = preprocessing.Normalizer(order=2)\n\n&gt;&gt;&gt; X = [[4, 1, 2, 2],\n...      [1, 3, 9, 3],\n...      [5, 7, 5, 1]]\n\n&gt;&gt;&gt; for x, _ in stream.iter_array(X):\n...     print(scaler.transform_one(x))\n{0: 0.8, 1: 0.2, 2: 0.4, 3: 0.4}\n{0: 0.1, 1: 0.3, 2: 0.9, 3: 0.3}\n{0: 0.5, 1: 0.7, 2: 0.5, 3: 0.1}\n</code></pre>"},{"location":"api/preprocessing/Normalizer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/OneHotEncoder/","title":"OneHotEncoder","text":"<p>One-hot encoding.</p> <p>This transformer will encode every feature it is provided with. If a list or set is provided, this transformer will encode every entry in the list/set. You can apply it to a subset of features by composing it  with <code>compose.Select</code> or <code>compose.SelectType</code>.</p>"},{"location":"api/preprocessing/OneHotEncoder/#parameters","title":"Parameters","text":"<ul> <li> <p>sparse \u2013 defaults to <code>False</code></p> <p>Whether or not 0s should be made explicit or not.</p> </li> </ul>"},{"location":"api/preprocessing/OneHotEncoder/#examples","title":"Examples","text":"<p>Let us first create an example dataset.</p> <pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; import string\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; alphabet = list(string.ascii_lowercase)\n&gt;&gt;&gt; X = [\n...     {\n...         'c1': random.choice(alphabet),\n...         'c2': random.choice(alphabet),\n...     }\n...     for _ in range(4)\n... ]\n&gt;&gt;&gt; pprint(X)\n[{'c1': 'u', 'c2': 'd'},\n    {'c1': 'a', 'c2': 'x'},\n    {'c1': 'i', 'c2': 'h'},\n    {'c1': 'h', 'c2': 'e'}]\n</code></pre> <p>We can now apply one-hot encoding. All the provided are one-hot encoded, there is therefore no need to specify which features to encode.</p> <pre><code>&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; oh = preprocessing.OneHotEncoder(sparse=True)\n&gt;&gt;&gt; for x in X:\n...     oh = oh.learn_one(x)\n...     pprint(oh.transform_one(x))\n{'c1_u': 1, 'c2_d': 1}\n{'c1_a': 1, 'c2_x': 1}\n{'c1_i': 1, 'c2_h': 1}\n{'c1_h': 1, 'c2_e': 1}\n</code></pre> <p>The <code>sparse</code> parameter can be set to <code>False</code> in order to include the values that are not present in the output.</p> <pre><code>&gt;&gt;&gt; oh = preprocessing.OneHotEncoder(sparse=False)\n&gt;&gt;&gt; for x in X[:2]:\n...     oh = oh.learn_one(x)\n...     pprint(oh.transform_one(x))\n{'c1_u': 1, 'c2_d': 1}\n{'c1_a': 1, 'c1_u': 0, 'c2_d': 0, 'c2_x': 1}\n</code></pre> <p>A subset of the features can be one-hot encoded by using an instance of <code>compose.Select</code>.</p> <pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; pp = compose.Select('c1') | preprocessing.OneHotEncoder()\n\n&gt;&gt;&gt; for x in X:\n...     pp = pp.learn_one(x)\n...     pprint(pp.transform_one(x))\n{'c1_u': 1}\n{'c1_a': 1, 'c1_u': 0}\n{'c1_a': 0, 'c1_i': 1, 'c1_u': 0}\n{'c1_a': 0, 'c1_h': 1, 'c1_i': 0, 'c1_u': 0}\n</code></pre> <p>You can preserve the <code>c2</code> feature by using a union:</p> <pre><code>&gt;&gt;&gt; pp = compose.Select('c1') | preprocessing.OneHotEncoder()\n&gt;&gt;&gt; pp += compose.Select('c2')\n\n&gt;&gt;&gt; for x in X:\n...     pp = pp.learn_one(x)\n...     pprint(pp.transform_one(x))\n{'c1_u': 1, 'c2': 'd'}\n{'c1_a': 1, 'c1_u': 0, 'c2': 'x'}\n{'c1_a': 0, 'c1_i': 1, 'c1_u': 0, 'c2': 'h'}\n{'c1_a': 0, 'c1_h': 1, 'c1_i': 0, 'c1_u': 0, 'c2': 'e'}\n</code></pre> <p>Similar to the above examples, we can also pass values as a list. This will one-hot encode all of the entries individually.</p> <pre><code>&gt;&gt;&gt; X = [{'c1': ['u', 'a'], 'c2': ['d']},\n...     {'c1': ['a', 'b'], 'c2': ['x']},\n...     {'c1': ['i'], 'c2': ['h', 'z']},\n...     {'c1': ['h', 'b'], 'c2': ['e']}]\n\n&gt;&gt;&gt; oh = preprocessing.OneHotEncoder(sparse=True)\n&gt;&gt;&gt; for x in X:\n...     oh = oh.learn_one(x)\n...     pprint(oh.transform_one(x))\n{'c1_a': 1, 'c1_u': 1, 'c2_d': 1}\n{'c1_a': 1, 'c1_b': 1, 'c2_x': 1}\n{'c1_i': 1, 'c2_h': 1, 'c2_z': 1}\n{'c1_b': 1, 'c1_h': 1, 'c2_e': 1}\n</code></pre> <p>Processing mini-batches is also possible.</p> <pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; import string\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; alphabet = list(string.ascii_lowercase)\n&gt;&gt;&gt; X = pd.DataFrame(\n...     {\n...         'c1': random.choice(alphabet),\n...         'c2': random.choice(alphabet),\n...     }\n...     for _ in range(4)\n... )\n&gt;&gt;&gt; X\n  c1 c2\n0  u  d\n1  a  x\n2  i  h\n3  h  e\n\n&gt;&gt;&gt; oh = preprocessing.OneHotEncoder(sparse=True)\n&gt;&gt;&gt; oh = oh.learn_many(X)\n\n&gt;&gt;&gt; df = oh.transform_many(X)\n&gt;&gt;&gt; df.loc[:, sorted(df.columns)]\n    c1_a  c1_h  c1_i  c1_u  c2_d  c2_e  c2_h  c2_x\n0     0     0     0     1     1     0     0     0\n1     1     0     0     0     0     0     0     1\n2     0     0     1     0     0     0     1     0\n3     0     1     0     0     0     1     0     0\n</code></pre> <p>Keep in mind that ability for sparse transformations is limited in mini-batch case, which might affect speed/memory footprint of your training loop.</p> <p>Here's a non-sparse example:</p> <pre><code>&gt;&gt;&gt; oh = preprocessing.OneHotEncoder(sparse=False)\n&gt;&gt;&gt; X_init = pd.DataFrame([{'c1': \"Oranges\", 'c2': \"Apples\"}])\n&gt;&gt;&gt; oh = oh.learn_many(X_init)\n&gt;&gt;&gt; oh = oh.learn_many(X)\n\n&gt;&gt;&gt; df = oh.transform_many(X)\n&gt;&gt;&gt; df.loc[:, sorted(df.columns)]\n    c1_Oranges  c1_a  c1_h  c1_i  c1_u  c2_Apples  c2_d  c2_e  c2_h  c2_x\n0           0     0     0     0     1          0     1     0     0     0\n1           0     1     0     0     0          0     0     0     0     1\n2           0     0     0     1     0          0     0     0     1     0\n3           0     0     1     0     0          0     0     1     0     0\n</code></pre>"},{"location":"api/preprocessing/OneHotEncoder/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     ('pd.DataFrame')    </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/PredClipper/","title":"PredClipper","text":"<p>Clips the target after predicting.</p>"},{"location":"api/preprocessing/PredClipper/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor (base.Regressor)</p> <p>Regressor model for which to clip the predictions.</p> </li> <li> <p>y_min (float)</p> <p>minimum value.</p> </li> <li> <p>y_max (float)</p> <p>maximum value.</p> </li> </ul>"},{"location":"api/preprocessing/PredClipper/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = (\n...     ({'a': 2, 'b': 4}, 80),\n...     ({'a': 3, 'b': 5}, 100),\n...     ({'a': 4, 'b': 6}, 120)\n... )\n\n&gt;&gt;&gt; model = preprocessing.PredClipper(\n...     regressor=linear_model.LinearRegression(),\n...     y_min=0,\n...     y_max=200\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(x, y)\n\n&gt;&gt;&gt; model.predict_one({'a': -100, 'b': -200})\n0\n\n&gt;&gt;&gt; model.predict_one({'a': 50, 'b': 60})\n200\n</code></pre>"},{"location":"api/preprocessing/PredClipper/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/preprocessing/PreviousImputer/","title":"PreviousImputer","text":"<p>Imputes missing values by using the most recent value.</p>"},{"location":"api/preprocessing/PreviousImputer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; imputer = preprocessing.PreviousImputer()\n\n&gt;&gt;&gt; imputer = imputer.learn_one({'x': 1, 'y': 2})\n&gt;&gt;&gt; imputer.transform_one({'y': None})\n{'y': 2}\n\n&gt;&gt;&gt; imputer.transform_one({'x': None})\n{'x': 1}\n</code></pre>"},{"location":"api/preprocessing/PreviousImputer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/RobustScaler/","title":"RobustScaler","text":"<p>Scale features using statistics that are robust to outliers.</p> <p>This Scaler removes the median and scales the data according to the interquantile range.</p>"},{"location":"api/preprocessing/RobustScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>with_centering \u2013 defaults to <code>True</code></p> <p>Whether to centre the data before scaling.</p> </li> <li> <p>with_scaling \u2013 defaults to <code>True</code></p> <p>Whether to scale data to IQR.</p> </li> <li> <p>q_inf \u2013 defaults to <code>0.25</code></p> <p>Desired inferior quantile, must be between 0 and 1.</p> </li> <li> <p>q_sup \u2013 defaults to <code>0.75</code></p> <p>Desired superior quantile, must be between 0 and 1.</p> </li> </ul>"},{"location":"api/preprocessing/RobustScaler/#attributes","title":"Attributes","text":"<ul> <li> <p>median (dict)</p> <p>Mapping between features and instances of <code>stats.Quantile(0.5)</code>.</p> </li> <li> <p>iqr (dict)</p> <p>Mapping between features and instances of <code>stats.IQR</code>.</p> </li> </ul>"},{"location":"api/preprocessing/RobustScaler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; X = [{'x': random.uniform(8, 12)} for _ in range(5)]\n&gt;&gt;&gt; pprint(X)\n[{'x': 10.557707},\n    {'x': 8.100043},\n    {'x': 9.100117},\n    {'x': 8.892842},\n    {'x': 10.945884}]\n\n&gt;&gt;&gt; scaler = preprocessing.RobustScaler()\n\n&gt;&gt;&gt; for x in X:\n...     print(scaler.learn_one(x).transform_one(x))\n{'x': 0.0}\n{'x': -0.0}\n{'x': -0.6861149618420798}\n{'x': -0.2614459368525924}\n{'x': 2.3281631460423204}\n</code></pre>"},{"location":"api/preprocessing/RobustScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/StandardScaler/","title":"StandardScaler","text":"<p>Scales the data so that it has zero mean and unit variance.</p> <p>Under the hood, a running mean and a running variance are maintained. The scaling is slightly different than when scaling the data in batch because the exact means and variances are not known in advance. However, this doesn't have a detrimental impact on performance in the long run. </p> <p>This transformer supports mini-batches as well as single instances. In the mini-batch case, the number of columns and the ordering of the columns are allowed to change between subsequent calls. In other words, this transformer will keep working even if you add and/or remove features every time you call <code>learn_many</code> and <code>transform_many</code>.</p>"},{"location":"api/preprocessing/StandardScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>with_std \u2013 defaults to <code>True</code></p> <p>Whether or not each feature should be divided by its standard deviation.</p> </li> </ul>"},{"location":"api/preprocessing/StandardScaler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; X = [{'x': random.uniform(8, 12), 'y': random.uniform(8, 12)} for _ in range(6)]\n&gt;&gt;&gt; for x in X:\n...     print(x)\n{'x': 10.557, 'y': 8.100}\n{'x': 9.100, 'y': 8.892}\n{'x': 10.945, 'y': 10.706}\n{'x': 11.568, 'y': 8.347}\n{'x': 9.687, 'y': 8.119}\n{'x': 8.874, 'y': 10.021}\n\n&gt;&gt;&gt; scaler = preprocessing.StandardScaler()\n\n&gt;&gt;&gt; for x in X:\n...     print(scaler.learn_one(x).transform_one(x))\n{'x': 0.0, 'y': 0.0}\n{'x': -0.999, 'y': 0.999}\n{'x': 0.937, 'y': 1.350}\n{'x': 1.129, 'y': -0.651}\n{'x': -0.776, 'y': -0.729}\n{'x': -1.274, 'y': 0.992}\n</code></pre> <p>This transformer also supports mini-batch updates. You can call <code>learn_many</code> and provide a <code>pandas.DataFrame</code>:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; X = pd.DataFrame.from_dict(X)\n\n&gt;&gt;&gt; scaler = preprocessing.StandardScaler()\n&gt;&gt;&gt; scaler = scaler.learn_many(X[:3])\n&gt;&gt;&gt; scaler = scaler.learn_many(X[3:])\n</code></pre> <p>You can then call <code>transform_many</code> to scale a mini-batch of features:</p> <pre><code>&gt;&gt;&gt; scaler.transform_many(X)\n    x         y\n0  0.444600 -0.933384\n1 -1.044259 -0.138809\n2  0.841106  1.679208\n3  1.477301 -0.685117\n4 -0.444084 -0.914195\n5 -1.274664  0.992296\n</code></pre>"},{"location":"api/preprocessing/StandardScaler/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>Note that the update formulas for mean and variance are slightly different than in the single instance case, but they produce exactly the same result.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul>   learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_many <p>Scale a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     (pandas.core.frame.DataFrame)    </li> </ul>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/StandardScaler/#references","title":"References","text":"<ol> <li> <p>Welford's Method (and Friends) \u21a9</p> </li> <li> <p>Batch updates for simple statistics \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/StatImputer/","title":"StatImputer","text":"<p>Replaces missing values with a statistic.</p> <p>This transformer allows you to replace missing values with the value of a running statistic. During a call to <code>learn_one</code>, for each feature, a statistic is updated whenever a numeric feature is observed. When <code>transform_one</code> is called, each feature with a <code>None</code> value is replaced with the current value of the corresponding statistic.</p>"},{"location":"api/preprocessing/StatImputer/#parameters","title":"Parameters","text":"<ul> <li> <p>imputers</p> <p>A list of tuples where each tuple has two elements. The first elements is a feature name and the second value is an instance of <code>stats.base.Univariate</code>. The second value can also be an arbitrary value, such as -1, in which case the missing values will be replaced with it.</p> </li> </ul>"},{"location":"api/preprocessing/StatImputer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import stats\n</code></pre> <p>For numeric data, we can use a <code>stats.Mean()</code> to replace missing values by the running average of the previously seen values:</p> <pre><code>&gt;&gt;&gt; X = [\n...     {'temperature': 1},\n...     {'temperature': 8},\n...     {'temperature': 3},\n...     {'temperature': None},\n...     {'temperature': 4}\n... ]\n\n&gt;&gt;&gt; imp = preprocessing.StatImputer(('temperature', stats.Mean()))\n\n&gt;&gt;&gt; for x in X:\n...     imp = imp.learn_one(x)\n...     print(imp.transform_one(x))\n{'temperature': 1}\n{'temperature': 8}\n{'temperature': 3}\n{'temperature': 4.0}\n{'temperature': 4}\n</code></pre> <p>For discrete/categorical data, a common practice is to <code>stats.Mode</code> to replace missing values by the most commonly seen value:</p> <pre><code>&gt;&gt;&gt; X = [\n...     {'weather': 'sunny'},\n...     {'weather': 'rainy'},\n...     {'weather': 'sunny'},\n...     {'weather': None},\n...     {'weather': 'rainy'},\n...     {'weather': 'rainy'},\n...     {'weather': None}\n... ]\n\n&gt;&gt;&gt; imp = preprocessing.StatImputer(('weather', stats.Mode()))\n\n&gt;&gt;&gt; for x in X:\n...     imp = imp.learn_one(x)\n...     print(imp.transform_one(x))\n{'weather': 'sunny'}\n{'weather': 'rainy'}\n{'weather': 'sunny'}\n{'weather': 'sunny'}\n{'weather': 'rainy'}\n{'weather': 'rainy'}\n{'weather': 'rainy'}\n</code></pre> <p>You can also choose to replace missing values with a constant value, as so:</p> <pre><code>&gt;&gt;&gt; imp = preprocessing.StatImputer(('weather', 'missing'))\n\n&gt;&gt;&gt; for x in X:\n...     imp = imp.learn_one(x)\n...     print(imp.transform_one(x))\n{'weather': 'sunny'}\n{'weather': 'rainy'}\n{'weather': 'sunny'}\n{'weather': 'missing'}\n{'weather': 'rainy'}\n{'weather': 'rainy'}\n{'weather': 'missing'}\n</code></pre> <p>Multiple imputers can be defined by providing a tuple for each feature which you want to impute:</p> <pre><code>&gt;&gt;&gt; X = [\n...     {'weather': 'sunny', 'temperature': 8},\n...     {'weather': 'rainy', 'temperature': 3},\n...     {'weather': 'sunny', 'temperature': None},\n...     {'weather': None, 'temperature': 4},\n...     {'weather': 'snowy', 'temperature': -4},\n...     {'weather': 'snowy', 'temperature': -3},\n...     {'weather': 'snowy', 'temperature': -3},\n...     {'weather': None, 'temperature': None}\n... ]\n\n&gt;&gt;&gt; imp = preprocessing.StatImputer(\n...     ('temperature', stats.Mean()),\n...     ('weather', stats.Mode())\n... )\n\n&gt;&gt;&gt; for x in X:\n...     imp = imp.learn_one(x)\n...     print(imp.transform_one(x))\n{'weather': 'sunny', 'temperature': 8}\n{'weather': 'rainy', 'temperature': 3}\n{'weather': 'sunny', 'temperature': 5.5}\n{'weather': 'sunny', 'temperature': 4}\n{'weather': 'snowy', 'temperature': -4}\n{'weather': 'snowy', 'temperature': -3}\n{'weather': 'snowy', 'temperature': -3}\n{'weather': 'snowy', 'temperature': 0.8333}\n</code></pre> <p>A sophisticated way to go about imputation is condition the statistics on a given feature. For instance, we might want to replace a missing temperature with the average temperature of a particular weather condition. As an example, consider the following dataset where the temperature is missing, but not the weather condition:</p> <pre><code>&gt;&gt;&gt; X = [\n...     {'weather': 'sunny', 'temperature': 8},\n...     {'weather': 'rainy', 'temperature': 3},\n...     {'weather': 'sunny', 'temperature': None},\n...     {'weather': 'rainy', 'temperature': 4},\n...     {'weather': 'sunny', 'temperature': 10},\n...     {'weather': 'sunny', 'temperature': None},\n...     {'weather': 'sunny', 'temperature': 12},\n...     {'weather': 'rainy', 'temperature': None}\n... ]\n</code></pre> <p>Each missing temperature can be replaced with the average temperature of the corresponding weather condition as so:</p> <pre><code>&gt;&gt;&gt; from river import compose\n\n&gt;&gt;&gt; imp = compose.Grouper(\n...     preprocessing.StatImputer(('temperature', stats.Mean())),\n...     by='weather'\n... )\n\n&gt;&gt;&gt; for x in X:\n...     imp = imp.learn_one(x)\n...     print(imp.transform_one(x))\n{'weather': 'sunny', 'temperature': 8}\n{'weather': 'rainy', 'temperature': 3}\n{'weather': 'sunny', 'temperature': 8.0}\n{'weather': 'rainy', 'temperature': 4}\n{'weather': 'sunny', 'temperature': 10}\n{'weather': 'sunny', 'temperature': 9.0}\n{'weather': 'sunny', 'temperature': 12}\n{'weather': 'rainy', 'temperature': 3.5}\n</code></pre> <p>Note that you can also create a <code>Grouper</code> with the <code>*</code> operator:</p> <pre><code>&gt;&gt;&gt; imp = preprocessing.StatImputer(('temperature', stats.Mean())) * 'weather'\n</code></pre>"},{"location":"api/preprocessing/StatImputer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Transformer:     self</p>   transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p>"},{"location":"api/preprocessing/TargetStandardScaler/","title":"TargetStandardScaler","text":"<p>Applies standard scaling to the target.</p>"},{"location":"api/preprocessing/TargetStandardScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor (base.Regressor)</p> <p>Regression model to wrap.</p> </li> </ul>"},{"location":"api/preprocessing/TargetStandardScaler/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     preprocessing.TargetStandardScaler(\n...         regressor=linear_model.LinearRegression(intercept_lr=0.15)\n...     )\n... )\n&gt;&gt;&gt; metric = metrics.MSE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMSE: 2.003724\n</code></pre>"},{"location":"api/preprocessing/TargetStandardScaler/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p>"},{"location":"api/proba/Beta/","title":"Beta","text":"<p>Beta distribution for binary data.</p> <p>A Beta distribution is very similar to a Bernoulli distribution in that it counts occurrences of boolean events. The differences lies in what is being measured. A Binomial distribution models the probability of an event occurring, whereas a Beta distribution models the probability distribution itself. In other words, it's a probability distribution over probability distributions.</p>"},{"location":"api/proba/Beta/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha (int) \u2013 defaults to <code>1</code></p> <p>Initial alpha parameter.</p> </li> <li> <p>beta (int) \u2013 defaults to <code>1</code></p> <p>Initial beta parameter.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/Beta/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/Beta/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import proba\n\n&gt;&gt;&gt; successes = 81\n&gt;&gt;&gt; failures = 219\n&gt;&gt;&gt; beta = proba.Beta(successes, failures)\n\n&gt;&gt;&gt; beta(.21), beta(.35)\n(0.867..., 0.165...)\n\n&gt;&gt;&gt; for success in range(100):\n...     beta = beta.update(True)\n&gt;&gt;&gt; for failure in range(200):\n...     beta = beta.update(False)\n\n&gt;&gt;&gt; beta(.21), beta(.35)\n(2.525...e-05, 0.841...)\n</code></pre>"},{"location":"api/proba/Beta/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>p     (float)    </li> </ul>   cdf <p>Cumulative density function, i.e. P(X &lt;= x).</p> <p>Parameters</p> <ul> <li>x     (float)    </li> </ul>   revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     (float)    </li> </ul>   sample <p>Sample a random value from the distribution.</p>   update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     (float)    </li> </ul>"},{"location":"api/proba/Beta/#references","title":"References","text":"<ol> <li> <p>What is the intuition behind beta distribution? \u21a9</p> </li> </ol>"},{"location":"api/proba/Gaussian/","title":"Gaussian","text":"<p>Normal distribution with parameters mu and sigma.</p>"},{"location":"api/proba/Gaussian/#parameters","title":"Parameters","text":"<ul> <li> <p>seed \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/Gaussian/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>mu</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> <li> <p>sigma</p> </li> </ul>"},{"location":"api/proba/Gaussian/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import proba\n\n&gt;&gt;&gt; p = proba.Gaussian().update(6).update(7)\n\n&gt;&gt;&gt; p\n\ud835\udca9(\u03bc=6.500, \u03c3=0.707)\n\n&gt;&gt;&gt; p(6.5)\n0.564189\n\n&gt;&gt;&gt; p.revert(7)\n\ud835\udca9(\u03bc=6.000, \u03c3=0.000)\n</code></pre>"},{"location":"api/proba/Gaussian/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     (Any)    </li> </ul>   cdf <p>Cumulative density function, i.e. P(X &lt;= x).</p> <p>Parameters</p> <ul> <li>x     (float)    </li> </ul>   revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     (float)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul>   sample <p>Sample a random value from the distribution.</p>   update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     (float)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul>"},{"location":"api/proba/Multinomial/","title":"Multinomial","text":"<p>Multinomial distribution for categorical data.</p>"},{"location":"api/proba/Multinomial/#parameters","title":"Parameters","text":"<ul> <li> <p>events (Union[dict, list]) \u2013 defaults to <code>None</code></p> <p>An optional list of events that already occurred.</p> </li> <li> <p>seed \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/Multinomial/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/Multinomial/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import proba\n\n&gt;&gt;&gt; p = proba.Multinomial(['green'] * 3)\n&gt;&gt;&gt; p = p.update('red')\n\n&gt;&gt;&gt; p('red')\n0.25\n\n&gt;&gt;&gt; p = p.update('red').update('red')\n&gt;&gt;&gt; p('green')\n0.5\n\n&gt;&gt;&gt; p = p.revert('red').revert('red')\n&gt;&gt;&gt; p('red')\n0.25\n</code></pre> <p>You can wrap this with a <code>utils.Rolling</code> to measure a distribution over a window:</p> <pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; X = ['red', 'green', 'green', 'blue', 'blue']\n\n&gt;&gt;&gt; dist = utils.Rolling(\n...     proba.Multinomial(),\n...     window_size=3\n... )\n\n&gt;&gt;&gt; for x in X:\n...     dist = dist.update(x)\n...     print(dist)\n...     print()\nP(red) = 1.000\n&lt;BLANKLINE&gt;\nP(red) = 0.500\nP(green) = 0.500\n&lt;BLANKLINE&gt;\nP(green) = 0.667\nP(red) = 0.333\n&lt;BLANKLINE&gt;\nP(green) = 0.667\nP(blue) = 0.333\nP(red) = 0.000\n&lt;BLANKLINE&gt;\nP(blue) = 0.667\nP(green) = 0.333\nP(red) = 0.000\n&lt;BLANKLINE&gt;\n</code></pre> <p>You can wrap this with a <code>utils.Rolling</code> to measure a distribution over a window of time:</p> <pre><code>&gt;&gt;&gt; import datetime as dt\n\n&gt;&gt;&gt; X = ['red', 'green', 'green', 'blue']\n&gt;&gt;&gt; days = [1, 2, 3, 4]\n\n&gt;&gt;&gt; dist = utils.TimeRolling(\n...     proba.Multinomial(),\n...     period=dt.timedelta(days=2)\n... )\n\n&gt;&gt;&gt; for x, day in zip(X, days):\n...     dist = dist.update(x, t=dt.datetime(2019, 1, day))\n...     print(dist)\n...     print()\nP(red) = 1.000\n&lt;BLANKLINE&gt;\nP(red) = 0.500\nP(green) = 0.500\n&lt;BLANKLINE&gt;\nP(green) = 1.000\nP(red) = 0.000\n&lt;BLANKLINE&gt;\nP(green) = 0.500\nP(blue) = 0.500\nP(red) = 0.000\n&lt;BLANKLINE&gt;\n</code></pre>"},{"location":"api/proba/Multinomial/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     (Any)    </li> </ul>   revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     (Hashable)    </li> </ul>   sample <p>Sample a random value from the distribution.</p>   update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     (Hashable)    </li> </ul>"},{"location":"api/proba/base/BinaryDistribution/","title":"BinaryDistribution","text":"<p>A probability distribution for discrete values.</p>"},{"location":"api/proba/base/BinaryDistribution/#parameters","title":"Parameters","text":"<ul> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/base/BinaryDistribution/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/base/BinaryDistribution/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     (Any)    </li> </ul>   revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     (bool)    </li> </ul>   sample <p>Sample a random value from the distribution.</p>   update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     (bool)    </li> </ul>"},{"location":"api/proba/base/ContinuousDistribution/","title":"ContinuousDistribution","text":"<p>A probability distribution for continuous values.</p>"},{"location":"api/proba/base/ContinuousDistribution/#parameters","title":"Parameters","text":"<ul> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/base/ContinuousDistribution/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/base/ContinuousDistribution/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     (Any)    </li> </ul>   cdf <p>Cumulative density function, i.e. P(X &lt;= x).</p> <p>Parameters</p> <ul> <li>x     (float)    </li> </ul>   revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     (float)    </li> </ul>   sample <p>Sample a random value from the distribution.</p>   update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     (float)    </li> </ul>"},{"location":"api/proba/base/DiscreteDistribution/","title":"DiscreteDistribution","text":"<p>A probability distribution for discrete values.</p>"},{"location":"api/proba/base/DiscreteDistribution/#parameters","title":"Parameters","text":"<ul> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/base/DiscreteDistribution/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/base/DiscreteDistribution/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     (Any)    </li> </ul>   revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     (Hashable)    </li> </ul>   sample <p>Sample a random value from the distribution.</p>   update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     (Hashable)    </li> </ul>"},{"location":"api/reco/Baseline/","title":"Baseline","text":"<p>Baseline for recommender systems.</p> <p>A first-order approximation of the bias involved in target. The model equation is defined as: </p> \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i}\\] <p>Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. </p> <p>This model expects a dict input with a <code>user</code> and an <code>item</code> entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.</p>"},{"location":"api/reco/Baseline/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the weights.</p> </li> <li> <p>loss (optim.base.Loss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2 \u2013 defaults to <code>0.0</code></p> <p>regularization amount used to push weights towards 0.</p> </li> <li> <p>initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed \u2013 defaults to <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/Baseline/#attributes","title":"Attributes","text":"<ul> <li> <p>global_mean (stats.Mean)</p> <p>The target arithmetic mean.</p> </li> <li> <p>u_biases (collections.defaultdict)</p> <p>The user bias weights.</p> </li> <li> <p>i_biases (collections.defaultdict)</p> <p>The item bias weights.</p> </li> <li> <p>u_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user bias weights.</p> </li> <li> <p>i_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item bias weights.</p> </li> </ul>"},{"location":"api/reco/Baseline/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import reco\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator'}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n...     ({'user': 'Bob', 'item': 'Superman'}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator'}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n... )\n\n&gt;&gt;&gt; model = reco.Baseline(optimizer=optim.SGD(0.005))\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(**x, y=y)\n\n&gt;&gt;&gt; model.predict_one(user='Bob', item='Harry Potter')\n6.538120\n</code></pre>"},{"location":"api/reco/Baseline/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>y     (Union[numbers.Number, bool])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>   predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>typing.Union[numbers.Number, bool]:     The predicted preference from the user for the item.</p>   rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>items     (Set[Union[str, int]])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/reco/Baseline/#references","title":"References","text":"<ol> <li> <p>Matrix factorization techniques for recommender systems \u21a9</p> </li> </ol>"},{"location":"api/reco/BiasedMF/","title":"BiasedMF","text":"<p>Biased Matrix Factorization for recommender systems.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle\\] <p>Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. The last term being simply the dot product between the latent vectors of the given user-item pair: </p> \\[\\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] <p>where \\(k\\) is the number of latent factors. </p> <p>This model expects a dict input with a <code>user</code> and an <code>item</code> entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.</p>"},{"location":"api/reco/BiasedMF/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>bias_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the bias weights.</p> </li> <li> <p>latent_optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent weights.</p> </li> <li> <p>loss (optim.base.Loss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2_bias \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push bias weights towards 0.</p> </li> <li> <p>l2_latent \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>weight_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Weights initialization scheme.</p> </li> <li> <p>latent_initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed \u2013 defaults to <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/BiasedMF/#attributes","title":"Attributes","text":"<ul> <li> <p>global_mean (stats.Mean)</p> <p>The target arithmetic mean.</p> </li> <li> <p>u_biases (collections.defaultdict)</p> <p>The user bias weights.</p> </li> <li> <p>i_biases (collections.defaultdict)</p> <p>The item bias weights.</p> </li> <li> <p>u_latents (collections.defaultdict)</p> <p>The user latent vectors randomly initialized.</p> </li> <li> <p>i_latents (collections.defaultdict)</p> <p>The item latent vectors randomly initialized.</p> </li> <li> <p>u_bias_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user bias weights.</p> </li> <li> <p>i_bias_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item bias weights.</p> </li> <li> <p>u_latent_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user latent weights.</p> </li> <li> <p>i_latent_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item latent weights.</p> </li> </ul>"},{"location":"api/reco/BiasedMF/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import reco\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator'}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n...     ({'user': 'Bob', 'item': 'Superman'}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator'}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n... )\n\n&gt;&gt;&gt; model = reco.BiasedMF(\n...     n_factors=10,\n...     bias_optimizer=optim.SGD(0.025),\n...     latent_optimizer=optim.SGD(0.025),\n...     latent_initializer=optim.initializers.Normal(mu=0., sigma=0.1, seed=71)\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(**x, y=y)\n\n&gt;&gt;&gt; model.predict_one(user='Bob', item='Harry Potter')\n6.489025\n</code></pre>"},{"location":"api/reco/BiasedMF/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>y     (Union[numbers.Number, bool])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>   predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>typing.Union[numbers.Number, bool]:     The predicted preference from the user for the item.</p>   rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>items     (Set[Union[str, int]])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/reco/BiasedMF/#references","title":"References","text":"<ol> <li> <p>Paterek, A., 2007, August. Improving regularized singular value decomposition for collaborative filtering. In Proceedings of KDD cup and workshop (Vol. 2007, pp. 5-8) \u21a9</p> </li> <li> <p>Matrix factorization techniques for recommender systems \u21a9</p> </li> </ol>"},{"location":"api/reco/FunkMF/","title":"FunkMF","text":"<p>Funk Matrix Factorization for recommender systems.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] <p>where \\(k\\) is the number of latent factors. </p> <p>This model expects a dict input with a <code>user</code> and an <code>item</code> entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.</p>"},{"location":"api/reco/FunkMF/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors \u2013 defaults to <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>optimizer (optim.base.Optimizer) \u2013 defaults to <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss (optim.base.Loss) \u2013 defaults to <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2 \u2013 defaults to <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>initializer (optim.base.Initializer) \u2013 defaults to <code>None</code></p> <p>Latent factors initialization scheme.</p> </li> <li> <p>clip_gradient \u2013 defaults to <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed \u2013 defaults to <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/FunkMF/#attributes","title":"Attributes","text":"<ul> <li> <p>u_latents (collections.defaultdict)</p> <p>The user latent vectors randomly initialized.</p> </li> <li> <p>i_latents (collections.defaultdict)</p> <p>The item latent vectors randomly initialized.</p> </li> <li> <p>u_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user latent weights.</p> </li> <li> <p>i_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item latent weights.</p> </li> </ul>"},{"location":"api/reco/FunkMF/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import reco\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator'}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n...     ({'user': 'Bob', 'item': 'Superman'}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator'}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n... )\n\n&gt;&gt;&gt; model = reco.FunkMF(\n...     n_factors=10,\n...     optimizer=optim.SGD(0.1),\n...     initializer=optim.initializers.Normal(mu=0., sigma=0.1, seed=11),\n... )\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(**x, y=y)\n\n&gt;&gt;&gt; model.predict_one(user='Bob', item='Harry Potter')\n1.866272\n</code></pre>"},{"location":"api/reco/FunkMF/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>y     (Union[numbers.Number, bool])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>   predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>typing.Union[numbers.Number, bool]:     The predicted preference from the user for the item.</p>   rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>items     (Set[Union[str, int]])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/reco/FunkMF/#references","title":"References","text":"<ol> <li> <p>Netflix update: Try this at home \u21a9</p> </li> <li> <p>Matrix factorization techniques for recommender systems \u21a9</p> </li> </ol>"},{"location":"api/reco/RandomNormal/","title":"RandomNormal","text":"<p>Predicts random values sampled from a normal distribution.</p> <p>The parameters of the normal distribution are fitted with running statistics. They parameters are independent of the user, the item, or the context, and are instead fitted globally. This recommender therefore acts as a dummy model that any serious model should easily outperform.</p>"},{"location":"api/reco/RandomNormal/#parameters","title":"Parameters","text":"<ul> <li> <p>seed \u2013 defaults to <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/RandomNormal/#attributes","title":"Attributes","text":"<ul> <li> <p>mean</p> <p>stats.Mean</p> </li> <li> <p>variance</p> <p>stats.Var</p> </li> </ul>"},{"location":"api/reco/RandomNormal/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import reco\n\n&gt;&gt;&gt; dataset = (\n...     ({'user': 'Alice', 'item': 'Superman'}, 8),\n...     ({'user': 'Alice', 'item': 'Terminator'}, 9),\n...     ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n...     ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n...     ({'user': 'Bob', 'item': 'Superman'}, 8),\n...     ({'user': 'Bob', 'item': 'Terminator'}, 9),\n...     ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n...     ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n... )\n\n&gt;&gt;&gt; model = reco.RandomNormal(seed=42)\n\n&gt;&gt;&gt; for x, y in dataset:\n...     _ = model.learn_one(**x, y=y)\n\n&gt;&gt;&gt; model.predict_one(user='Bob', item='Harry Potter')\n6.147299621751425\n</code></pre>"},{"location":"api/reco/RandomNormal/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>y     (Union[numbers.Number, bool])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>   predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>typing.Union[numbers.Number, bool]:     The predicted preference from the user for the item.</p>   rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>items     (Set[Union[str, int]])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/reco/base/Ranker/","title":"Ranker","text":"<p>Base class for ranking models.</p>"},{"location":"api/reco/base/Ranker/#parameters","title":"Parameters","text":"<ul> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/base/Ranker/#attributes","title":"Attributes","text":"<ul> <li>is_contextual</li> </ul>"},{"location":"api/reco/base/Ranker/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>y     (Union[numbers.Number, bool])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>   predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>item     (Union[str, int])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>typing.Union[numbers.Number, bool]:     The predicted preference from the user for the item.</p>   rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     (Union[str, int])    </li> <li>items     (Set[Union[str, int]])    </li> <li>x     (dict)     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/rules/AMRules/","title":"AMRules","text":"<p>Adaptive Model Rules.</p> <p>AMRules1 is a rule-based algorithm for incremental regression tasks. AMRules relies on the Hoeffding bound to build its rule set, similarly to Hoeffding Trees. The Variance-Ratio heuristic is used to evaluate rules' splits. Moreover, this rule-based regressor has additional capacities not usually found in decision trees. </p> <p>Firstly, each created decision rule has a built-in drift detection mechanism. Every time a drift is detected, the affected decision rule is removed. In addition, AMRules' rules also have anomaly detection capabilities. After a warm-up period, each rule tests whether or not the incoming instances are anomalies. Anomalous instances are not used for training. </p> <p>Every time no rule is covering an incoming example, a default rule is used to learn from it. A rule covers an instance when all of the rule's literals (tests joined by the logical operation <code>and</code>) match the input case. The default rule is also applied for predicting examples not covered by any rules from the rule set.</p>"},{"location":"api/rules/AMRules/#parameters","title":"Parameters","text":"<ul> <li> <p>n_min (int) \u2013 defaults to <code>200</code></p> <p>The total weight that must be observed by a rule between expansion attempts.</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>The split test significance. The split confidence is given by <code>1 - delta</code>.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>The tie-breaking threshold.</p> </li> <li> <p>pred_type (str) \u2013 defaults to <code>adaptive</code></p> <p>The prediction strategy used by the decision rules. Can be either: - <code>\"mean\"</code>: outputs the target mean within the partitions defined by the decision rules. - <code>\"model\"</code>: always use instances of the model passed <code>pred_model</code> to make predictions. - <code>\"adaptive\"</code>: dynamically selects between \"mean\" and \"model\" for each incoming example. The most accurate option at the moment will be used.</p> </li> <li> <p>pred_model (base.Regressor) \u2013 defaults to <code>None</code></p> <p>The regression model that will be replicated for every rule when <code>pred_type</code> is either <code>\"model\"</code> or <code>\"adaptive\"</code>.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>drift_detector (base.DriftDetector) \u2013 defaults to <code>None</code></p> <p>The drift detection model that is used by each rule. Care must be taken to avoid the triggering of too many false alarms or delaying too much the concept drift detection. By default, <code>drift.ADWIN</code> is used if <code>drift_detector</code> is <code>None</code>.</p> </li> <li> <p>fading_factor (float) \u2013 defaults to <code>0.99</code></p> <p>The exponential decaying factor applied to the learning models' absolute errors, that are monitored if <code>pred_type='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>anomaly_threshold (float) \u2013 defaults to <code>-0.75</code></p> <p>The threshold below which instances will be considered anomalies by the rules.</p> </li> <li> <p>m_min (int) \u2013 defaults to <code>30</code></p> <p>The minimum total weight a rule must observe before it starts to skip anomalous instances during training.</p> </li> <li> <p>ordered_rule_set (bool) \u2013 defaults to <code>True</code></p> <p>If <code>True</code>, only the first rule that covers an instance will be used for training or prediction. If <code>False</code>, all the rules covering an instance will be updated during training, and the predictions for an instance will be the average prediction of all rules covering that example.</p> </li> <li> <p>min_samples_split (int) \u2013 defaults to <code>5</code></p> <p>The minimum number of samples each partition of a binary split candidate must have to be considered valid.</p> </li> </ul>"},{"location":"api/rules/AMRules/#attributes","title":"Attributes","text":"<ul> <li> <p>n_drifts_detected</p> <p>The number of detected concept drifts.</p> </li> </ul>"},{"location":"api/rules/AMRules/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import drift\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import rules\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     rules.AMRules(\n...         delta=0.01,\n...         n_min=50,\n...         drift_detector=drift.ADWIN()\n...     )\n... )\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 1.117705\n</code></pre>"},{"location":"api/rules/AMRules/#methods","title":"Methods","text":"anomaly_score <p>Aggregated anomaly score computed using all the rules that cover the input instance.</p> <p>Returns the mean anomaly score, the standard deviation of the score, and the proportion of rules that cover the instance (support). If the support is zero, it means that the default rule was used (not other rule covered <code>x</code>).</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>typing.Tuple[float, float, float]:     mean_anomaly_score, std_anomaly_score, support</p>   debug_one <p>Return an explanation of how <code>x</code> is predicted</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>str:     A representation of the rules that cover the input and their prediction.</p>   learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> <li>w     (int)     \u2013 defaults to <code>1</code> </li> </ul> <p>Returns</p> <p>AMRules:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/rules/AMRules/#notes","title":"Notes","text":"<p>AMRules treats all the non-numerical inputs as nominal features. All instances of <code>numbers.Number</code> will be treated as continuous, even if they represent integer categories. When using nominal features, <code>pred_type</code> should be set to \"mean\", otherwise errors will be thrown while trying to update the underlying rules' prediction models. Prediction strategies other than \"mean\" can be used, as long as the prediction model passed to <code>pred_model</code> supports nominal features.</p>"},{"location":"api/rules/AMRules/#references","title":"References","text":"<ol> <li> <p>Duarte, J., Gama, J. and Bifet, A., 2016. Adaptive model rules from high-speed data streams. ACM Transactions on Knowledge Discovery from Data (TKDD), 10(3), pp.1-22.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/sketch/Counter/","title":"Counter","text":"<p>Counting using the Count-Min Sketch (CMS) algorithm.</p> <p>Contrary to an exhaustive approach, e.g., using a <code>collections.Counter</code>, CMS uses a limited and fixed amount of memory. The CMS algorithm uses a sketch structure consisting of a matrix \\(w \\times d\\). </p> <p>These dimensions are obtained via: </p> <ul> <li> <p>\\(w = \\lceil \\frac{e}{\\epsilon} \\rceil\\), where \\(e\\) is the Euler number. </p> </li> <li> <p>\\(d = \\lceil \\ln\\left(\\frac{1}{\\delta} \\right) \\rceil\\). </p> </li> </ul> <p>Decreasing the values of \\(\\epsilon\\) (<code>epsilon</code>) and \\(\\delta\\) (<code>delta</code>) increase the accuracy of the algorithm, at the cost of increased memory usage. The values of <code>w</code> and <code>d</code> control the hash tables' capability and the amount of hash collisions, respectively. </p> <p>CMS works by keeping <code>d</code> hash tables with <code>w</code> slots each. Elements are mapped to a slot in each hash table. These tables store the counting estimates. This implementation assumes the turnstile case described in the paper, i.e., count values and updates can be negative. </p> <p>The count values obtained by CMS are always overestimates. Suppose \\(c_i\\) and \\(\\hat{c}_i\\) are the ground truth and estimated count values, respectively, for a given element \\(i\\). CMS guarantees that \\(c_i \\le \\hat{c}_i\\) and, with probability \\(1 - \\delta\\), \\(\\hat{c}_i \\le c_i + \\epsilon||\\mathbf{c}||_1\\). In the expression, \\(||\\mathbf{c}||_1 = \\sum_i |c_i|\\).</p>"},{"location":"api/sketch/Counter/#parameters","title":"Parameters","text":"<ul> <li> <p>epsilon (float) \u2013 defaults to <code>0.1</code></p> <p>The approximation error parameter. The error in answering a query is within a factor of <code>epsilon</code> with probability <code>delta</code>.</p> </li> <li> <p>delta (float) \u2013 defaults to <code>0.05</code></p> <p>A query estimates have a probability of <code>1 - delta</code> of having errors which are a factor of <code>epsilon</code>. See the CMS description above for more details.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/sketch/Counter/#attributes","title":"Attributes","text":"<ul> <li> <p>n_slots</p> <p>The number of slots in each hash table.</p> </li> <li> <p>n_tables</p> <p>The number of stored hash tables.</p> </li> </ul>"},{"location":"api/sketch/Counter/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import collections\n&gt;&gt;&gt; from river import sketch\n\n&gt;&gt;&gt; cms = sketch.Counter(epsilon=0.005, seed=0)\n\n&gt;&gt;&gt; # To generate random numbers\n&gt;&gt;&gt; rng = random.Random(7)\n\n&gt;&gt;&gt; counter = collections.Counter()\n</code></pre> <p>We can check the number of slots per hash table: <pre><code>&gt;&gt;&gt; cms.n_slots\n544\n</code></pre></p> <p>And the number of hash tables: <pre><code>&gt;&gt;&gt; cms.n_tables\n3\n</code></pre></p> <p>Let's compare the sketch against a brute force approach:</p> <pre><code>&gt;&gt;&gt; vals = []\n&gt;&gt;&gt; for _ in range(10000):\n...     v = rng.randint(-1000, 1000)\n...     cms = cms.update(v)\n...     counter[v] += 1\n...     vals.append(v)\n</code></pre> <p>Now, we can compare the estimates of CMS against the exhaustive counting strategy:</p> <pre><code>&gt;&gt;&gt; counter[7]\n5\n&gt;&gt;&gt; cms[7]\n12\n&gt;&gt;&gt; counter[532]\n4\n&gt;&gt;&gt; cms[532]\n15\n</code></pre> <p>Keep in mind that CMS is an approximate sketch algorithm. Couting estimates for unseen values might not be always reliable:</p> <pre><code>&gt;&gt;&gt; cms[1001]\n9\n</code></pre> <p>We can check the number of elements stored by each approach:</p> <pre><code>&gt;&gt;&gt; len(counter), len(cms)\n(1982, 1632)\n</code></pre> <p>And also retrieve the total sum of counts:</p> <pre><code>&gt;&gt;&gt; cms.total()\n10000\n</code></pre> <p>We can decrease the error by allocating more memory in the CMS:</p> <pre><code>&gt;&gt;&gt; cms_a = sketch.Counter(epsilon=0.001, delta=0.01, seed=0)\n&gt;&gt;&gt; for v in vals:\n...     cms_a = cms_a.update(v)\n\n&gt;&gt;&gt; cms_a[7]\n5\n&gt;&gt;&gt; cms_a[532]\n4\n</code></pre> <p>We can also obtain estimates of the dot product between two instances of <code>river.collections.Counter</code>. This could be useful, for instance, to estimate the cosine distance between the data monitored in two different counter sketch instances. Suppose we create another CMS instance (the number of slots and hash tables must match) that monitors another sample of the same data generating process:</p> <pre><code>&gt;&gt;&gt; cms_b = sketch.Counter(epsilon=0.001, delta=0.01, seed=7)\n\n&gt;&gt;&gt; for _ in range(10000):\n...     v = rng.randint(-1000, 1000)\n...     cms_b = cms_b.update(v)\n</code></pre> <p>Now, we can define a cosine distance function:</p> <pre><code>&gt;&gt;&gt; def cosine_dist(cms_a, cms_b):\n...     num = cms_a @ cms_b\n...     den = math.sqrt(cms_a @ cms_a) * math.sqrt(cms_b @ cms_b)\n...     return num / den\n</code></pre> <p>And use it to calculate the cosine distance between the elements monitored in <code>cms_a</code> and <code>cms_b</code>:</p> <pre><code>&gt;&gt;&gt; cosine_dist(cms_a, cms_b)\n0.175363...\n</code></pre>"},{"location":"api/sketch/Counter/#methods","title":"Methods","text":"total <p>Return the total count.</p>   update"},{"location":"api/sketch/Counter/#references","title":"References","text":"<ol> <li> <p>Cormode, G., &amp; Muthukrishnan, S. (2005). An improved data stream summary: the count-min sketch and its applications. Journal of Algorithms, 55(1), 58-75. \u21a9</p> </li> <li> <p>Count-Min Sketch \u21a9</p> </li> <li> <p>Hash functions family generator in Python \u21a9</p> </li> </ol>"},{"location":"api/sketch/HeavyHitters/","title":"HeavyHitters","text":"<p>Find the Heavy Hitters using the Lossy Count with Forgetting factor algorithm1.</p> <p>Keep track of the most frequent item(set)s in a data stream and apply a forgetting factor to discard previous frequent items that do not often appear anymore. This is an approximation algorithm designed to work with a limited amount of memory rather than accounting for every possible solution (thus using an unbounded memory footprint). Any hashable type can be passed as input, hence tuples or frozensets can also be monitored. </p> <p>Considering a data stream where <code>n</code> elements were observed so far, the Lossy Count algorithm has the following properties: </p> <ul> <li> <p>All item(set)s whose true frequency exceeds <code>support * n</code> are output. There are no false negatives; </p> </li> <li> <p>No item(set) whose true frequency is less than <code>(support - epsilon) * n</code> is outputted; </p> </li> <li> <p>Estimated frequencies are less than the true frequencies by at most <code>epsilon * n</code>.</p> </li> </ul>"},{"location":"api/sketch/HeavyHitters/#parameters","title":"Parameters","text":"<ul> <li> <p>support (float) \u2013 defaults to <code>0.001</code></p> <p>The support threshold used to determine if an item is frequent. The value of <code>support</code> must be in \\([0, 1]\\). Elements whose frequency is higher than <code>support</code> times the number of observations seen so far are outputted.</p> </li> <li> <p>epsilon (float) \u2013 defaults to <code>0.005</code></p> <p>Error parameter to control the accuracy-memory tradeoff. The value of <code>epsilon</code> must be in \\((0, 1]\\) and typically <code>epsilon</code> \\(\\ll\\) <code>support</code>. The smaller the <code>epsilon</code>, the more accurate the estimates will be, but the count sketch will have an increased memory footprint.</p> </li> <li> <p>fading_factor (float) \u2013 defaults to <code>0.999</code></p> <p>Forgetting factor applied to the frequency estimates to reduce the impact of old items. The value of <code>fading_factor</code> must be in \\((0, 1]\\).</p> </li> </ul>"},{"location":"api/sketch/HeavyHitters/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; import string\n&gt;&gt;&gt; from river import sketch\n\n&gt;&gt;&gt; rng = random.Random(42)\n&gt;&gt;&gt; hh = sketch.HeavyHitters()\n</code></pre> <p>We will feed the counter with printable ASCII characters:</p> <pre><code>&gt;&gt;&gt; for _ in range(10_000):\n...     hh = hh.update(rng.choice(string.printable))\n</code></pre> <p>We can retrieve estimates of the <code>n</code> top elements and their frequencies. Let's try <code>n=3</code> <pre><code>&gt;&gt;&gt; hh.most_common(3)\n[(',', 122.099142...), ('[', 116.049510...), ('W', 115.013402...)]\n</code></pre></p> <p>We can also access estimates of individual elements:</p> <pre><code>&gt;&gt;&gt; hh['A']\n99.483575...\n</code></pre> <p>Unobserved elements are handled just fine: <pre><code>&gt;&gt;&gt; hh[(1, 2, 3)]\n0.0\n</code></pre></p>"},{"location":"api/sketch/HeavyHitters/#methods","title":"Methods","text":"most_common   update"},{"location":"api/sketch/HeavyHitters/#references","title":"References","text":"<ol> <li> <p>Veloso, B., Tabassum, S., Martins, C., Espanha, R., Azevedo, R., &amp; Gama, J. (2020). Interconnect bypass fraud detection: a case study. Annals of Telecommunications, 75(9), 583-596.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/sketch/Histogram/","title":"Histogram","text":"<p>Streaming histogram.</p>"},{"location":"api/sketch/Histogram/#parameters","title":"Parameters","text":"<ul> <li> <p>max_bins \u2013 defaults to <code>256</code></p> <p>Maximal number of bins.</p> </li> </ul>"},{"location":"api/sketch/Histogram/#attributes","title":"Attributes","text":"<ul> <li> <p>n</p> <p>Total number of seen values.</p> </li> </ul>"},{"location":"api/sketch/Histogram/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import sketch\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; np.random.seed(42)\n\n&gt;&gt;&gt; values = np.hstack((\n...     np.random.normal(-3, 1, 1000),\n...     np.random.normal(3, 1, 1000),\n... ))\n\n&gt;&gt;&gt; hist = sketch.Histogram(max_bins=60)\n\n&gt;&gt;&gt; for x in values:\n...     hist = hist.update(x)\n\n&gt;&gt;&gt; ax = plt.bar(\n...     x=[(b.left + b.right) / 2 for b in hist],\n...     height=[b.count for b in hist],\n...     width=[(b.right - b.left) / 2 for b in hist]\n... )\n</code></pre> <p>.. image:: ../../docs/img/histogram_docstring.svg     :align: center</p>"},{"location":"api/sketch/Histogram/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul>   cdf <p>Cumulative distribution function.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   iter_cdf <p>Yields CDF values for a sorted iterable of values.</p> <p>This is faster than calling <code>cdf</code> with many values.</p> <p>Parameters</p> <ul> <li>X </li> <li>verbose     \u2013 defaults to <code>False</code> </li> </ul>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort   update"},{"location":"api/sketch/Histogram/#references","title":"References","text":"<ol> <li> <p>Ben-Haim, Y. and Tom-Tov, E., 2010. A streaming parallel decision tree algorithm. Journal of Machine Learning Research, 11(Feb), pp.849-872. \u21a9</p> </li> <li> <p>Go implementation \u21a9</p> </li> </ol>"},{"location":"api/sketch/Set/","title":"Set","text":"<p>Approximate tracking of observed items using Bloom filters.</p> <p>Bloom filters enable using a limited amount of memory to check whether a given item was already observed in a stream. They can be used similarly to Python's built-in sets with the difference that items are not explicitly stored. For that reason, element removal and set difference are not currently supported. </p> <p>Bloom filters store a bit array and map incoming items to <code>k</code> index positions in the such array. The selected positions are set to <code>True</code>. Therefore, a binary code representation is created for each item. Membership works by projecting the query item and checking if every position of its binary code is <code>True</code>. If that is not the case, the item was not observed yet. A nice property of Bloom filters is that they do not yield false negatives: unobserved items might be signalized as observed, but observed items are never signalized as unobserved. </p> <p>If more than one item has the same binary code, i.e., hash collisions happen, the accuracy of the Bloom filter decreases, and false positives are produced. For instance, a previously unobserved item is signalized as observed. Increasing the size of the binary array and the value of <code>k</code> increase the filter's accuracy as hash collisions are avoided. Nonetheless, even using an increased number of hash functions, hash collisions will frequently happen if the array capacity is too small. The length of the bit array and the number of hash functions are inferred automatically from the supplied <code>capacity</code> and <code>fp_rate</code>.</p>"},{"location":"api/sketch/Set/#parameters","title":"Parameters","text":"<ul> <li> <p>capacity (int) \u2013 defaults to <code>2048</code></p> <p>The maximum capacity of the Bloom filter, i.e., the maximum number of distinct items to store given the selected <code>fp_rate</code>.</p> </li> <li> <p>fp_rate (float) \u2013 defaults to <code>0.01</code></p> <p>The allowed rate of false positives. The probability of obtaining a true positive is <code>1 - fp_rate</code>.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/sketch/Set/#attributes","title":"Attributes","text":"<ul> <li> <p>n_bits</p> <p>Return the size of the binary array used by the Bloom filter.</p> </li> <li> <p>n_hash</p> <p>Return the number of used hash functions.</p> </li> </ul>"},{"location":"api/sketch/Set/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; from river import sketch\n\n&gt;&gt;&gt; rng = random.Random(42)\n&gt;&gt;&gt; s_set = sketch.Set(capacity=100, seed=0)\n</code></pre> <p>We can retrieve the number of selected hash functions:</p> <pre><code>&gt;&gt;&gt; s_set.n_hash\n7\n</code></pre> <p>And the size of the binary array used by the Bloom filter: <pre><code>&gt;&gt;&gt; s_set.n_bits\n959\n</code></pre></p> <p>We can add new items and check for membership using the same calls used by Python's standard sets: <pre><code>&gt;&gt;&gt; for _ in range(1000):\n...     s_set.add(rng.randint(0, 200))\n\n&gt;&gt;&gt; 1 in s_set\nTrue\n</code></pre></p> <p>False positives might happen if the capacity is not large enough: <pre><code>&gt;&gt;&gt; -10 in s_set\nTrue\n</code></pre></p> <p>Iterables can also be supplied to perform multiple updates with a single call to <code>update</code>: <pre><code>&gt;&gt;&gt; s_set = s_set.update([1, 2, 3, 4, 5, 6, 7])\n</code></pre></p> <p>We can also combine instances of <code>sketch.Set</code> using the intersection and union operations, as long as they share the same hash functions and capability. In other words, all they hyperparameters match. Let's create two instances that will monitor different portions of a stream of random numbers:</p> <pre><code>&gt;&gt;&gt; s1 = sketch.Set(seed=8)\n&gt;&gt;&gt; s2 = sketch.Set(seed=8)\n\n&gt;&gt;&gt; for _ in range(1000):\n...     s1.add(rng.randint(0, 5000))\n\n&gt;&gt;&gt; for _ in range(1000):\n...     s2.add(rng.randint(0, 5000))\n\n&gt;&gt;&gt; 43 in s1\nTrue\n&gt;&gt;&gt; 43 in s2\nFalse\n</code></pre> <p>We can get the intersection between the two instances by using:</p> <pre><code>&gt;&gt;&gt; s_intersection = s1 &amp; s2\n&gt;&gt;&gt; 43 in s_intersection\nFalse\n</code></pre> <p>We can also obtain the set union:</p> <pre><code>&gt;&gt;&gt; s_union = s1 | s2\n\n&gt;&gt;&gt; 43 in s_union\nTrue\n</code></pre> <p>The same effect of the non-inplace dunder methods can be achieved via explicit method calls:</p> <pre><code>&gt;&gt;&gt; 43 in s1.intersection(s2)\nFalse\n\n&gt;&gt;&gt; 43 in s1.union(s2)\nTrue\n</code></pre>"},{"location":"api/sketch/Set/#methods","title":"Methods","text":"add   intersection <p>Set intersection.</p> <p>Return a new instance that results from the set intersection between the current <code>Set</code> object and <code>other</code>. Dunder operators can be used to replace the method call, i.e., <code>a &amp;= b</code> and <code>a &amp; b</code> for inplace and non-inplace intersections, respectively.</p> <p>Parameters</p> <ul> <li>other     ('Set')    </li> </ul>   union <p>Set union.</p> <p>Return a new instance that results from the set union between the current <code>Set</code> object and <code>other</code>. Dunder operators can be used to replace the method call, i.e., <code>a |= b</code> and <code>a | b</code> for inplace and non-inplace unions, respectively.</p> <p>Parameters</p> <ul> <li>other     ('Set')    </li> </ul>   update"},{"location":"api/sketch/Set/#notes","title":"Notes","text":"<p>This implementation uses an integer to represent the binary array. Bitwise operations are performed in the integer to reflect the Bloom filter updates.</p>"},{"location":"api/sketch/Set/#references","title":"References","text":"<ol> <li> <p>Florian Hartmann's blog article on Bloom Filters.\u00a0\u21a9</p> </li> <li> <p>Wikipedia entry on Bloom filters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/stats/AbsMax/","title":"AbsMax","text":"<p>Running absolute max.</p>"},{"location":"api/stats/AbsMax/#attributes","title":"Attributes","text":"<ul> <li> <p>abs_max (float)</p> <p>The current absolute max.</p> </li> </ul>"},{"location":"api/stats/AbsMax/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 5, -6]\n&gt;&gt;&gt; abs_max = stats.AbsMax()\n&gt;&gt;&gt; for x in X:\n...     print(abs_max.update(x).get())\n1\n4\n4\n4\n5\n6\n</code></pre>"},{"location":"api/stats/AbsMax/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/AutoCorr/","title":"AutoCorr","text":"<p>Measures the serial correlation.</p> <p>This method computes the Pearson correlation between the current value and the value seen <code>n</code> steps before.</p>"},{"location":"api/stats/AutoCorr/#parameters","title":"Parameters","text":"<ul> <li>lag (int)</li> </ul>"},{"location":"api/stats/AutoCorr/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/AutoCorr/#examples","title":"Examples","text":"<p>The following examples are taken from the pandas documentation.</p> <pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; auto_corr = stats.AutoCorr(lag=1)\n&gt;&gt;&gt; for x in [0.25, 0.5, 0.2, -0.05]:\n...     print(auto_corr.update(x).get())\n0\n0\n-1.0\n0.103552\n\n&gt;&gt;&gt; auto_corr = stats.AutoCorr(lag=2)\n&gt;&gt;&gt; for x in [0.25, 0.5, 0.2, -0.05]:\n...     print(auto_corr.update(x).get())\n0\n0\n0\n-1.0\n\n&gt;&gt;&gt; auto_corr = stats.AutoCorr(lag=1)\n&gt;&gt;&gt; for x in [1, 0, 0, 0]:\n...     print(auto_corr.update(x).get())\n0\n0\n0\n0\n</code></pre>"},{"location":"api/stats/AutoCorr/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/BayesianMean/","title":"BayesianMean","text":"<p>Estimates a mean using outside information.</p>"},{"location":"api/stats/BayesianMean/#parameters","title":"Parameters","text":"<ul> <li> <p>prior (float)</p> </li> <li> <p>prior_weight (float)</p> </li> </ul>"},{"location":"api/stats/BayesianMean/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/BayesianMean/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   revert   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/BayesianMean/#references","title":"References","text":"<ol> <li> <p>Additive smoothing \u21a9</p> </li> <li> <p>Bayesian average \u21a9</p> </li> <li> <p>Practical example of Bayes estimators \u21a9</p> </li> </ol>"},{"location":"api/stats/Count/","title":"Count","text":"<p>A simple counter.</p>"},{"location":"api/stats/Count/#attributes","title":"Attributes","text":"<ul> <li> <p>n (int)</p> <p>The current number of observations.</p> </li> </ul>"},{"location":"api/stats/Count/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/stats/Cov/","title":"Cov","text":"<p>Covariance.</p>"},{"location":"api/stats/Cov/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof \u2013 defaults to <code>1</code></p> <p>Delta Degrees of Freedom.</p> </li> </ul>"},{"location":"api/stats/Cov/#attributes","title":"Attributes","text":"<ul> <li>n</li> </ul>"},{"location":"api/stats/Cov/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; x = [-2.1,  -1,  4.3]\n&gt;&gt;&gt; y = [   3, 1.1, 0.12]\n\n&gt;&gt;&gt; cov = stats.Cov()\n\n&gt;&gt;&gt; for xi, yi in zip(x, y):\n...     print(cov.update(xi, yi).get())\n0.0\n-1.044999\n-4.286\n</code></pre> <p>This class has a <code>revert</code> method, and can thus be wrapped by <code>utils.Rolling</code>:</p> <pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; x = [-2.1,  -1, 4.3, 1, -2.1,  -1, 4.3]\n&gt;&gt;&gt; y = [   3, 1.1, .12, 1,    3, 1.1, .12]\n\n&gt;&gt;&gt; rcov = utils.Rolling(stats.Cov(), window_size=3)\n\n&gt;&gt;&gt; for xi, yi in zip(x, y):\n...     print(rcov.update(xi, yi).get())\n0.0\n-1.045\n-4.286\n-1.382\n-4.589\n-1.415\n-4.286\n</code></pre>"},{"location":"api/stats/Cov/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   revert   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul>   update_many"},{"location":"api/stats/Cov/#notes","title":"Notes","text":"<p>The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\).</p>"},{"location":"api/stats/Cov/#references","title":"References","text":"<ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> <li> <p>Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-) variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/stats/EWMean/","title":"EWMean","text":"<p>Exponentially weighted mean.</p>"},{"location":"api/stats/EWMean/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor \u2013 defaults to <code>0.5</code></p> <p>The closer <code>fading_factor</code> is to 1 the more the statistic will adapt to recent values.</p> </li> </ul>"},{"location":"api/stats/EWMean/#attributes","title":"Attributes","text":"<ul> <li> <p>mean (float)</p> <p>The running exponentially weighted mean.</p> </li> </ul>"},{"location":"api/stats/EWMean/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, 3, 5, 4, 6, 8, 7, 9, 11]\n&gt;&gt;&gt; ewm = stats.EWMean(fading_factor=0.5)\n&gt;&gt;&gt; for x in X:\n...     print(ewm.update(x).get())\n1.0\n2.0\n3.5\n3.75\n4.875\n6.4375\n6.71875\n7.859375\n9.4296875\n</code></pre>"},{"location":"api/stats/EWMean/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/EWMean/#references","title":"References","text":"<ol> <li> <p>Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9</p> </li> <li> <p>Exponential Moving Average on Streaming Data \u21a9</p> </li> </ol>"},{"location":"api/stats/EWVar/","title":"EWVar","text":"<p>Exponentially weighted variance.</p> <p>To calculate the variance we use the fact that Var(X) = Mean(x^2) - Mean(x)^2 and internally we use the exponentially weighted mean of x/x^2 to calculate this.</p>"},{"location":"api/stats/EWVar/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor \u2013 defaults to <code>0.5</code></p> <p>The closer <code>fading_factor</code> is to 1 the more the statistic will adapt to recent values.</p> </li> </ul>"},{"location":"api/stats/EWVar/#attributes","title":"Attributes","text":"<ul> <li> <p>variance (float)</p> <p>The running exponentially weighted variance.</p> </li> </ul>"},{"location":"api/stats/EWVar/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, 3, 5, 4, 6, 8, 7, 9, 11]\n&gt;&gt;&gt; ewv = stats.EWVar(fading_factor=0.5)\n&gt;&gt;&gt; for x in X:\n...     print(ewv.update(x).get())\n0.0\n1.0\n2.75\n1.4375\n1.984375\n3.43359375\n1.7958984375\n2.198974609375\n3.56536865234375\n</code></pre>"},{"location":"api/stats/EWVar/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/EWVar/#references","title":"References","text":"<ol> <li> <p>Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9</p> </li> <li> <p>Exponential Moving Average on Streaming Data \u21a9</p> </li> </ol>"},{"location":"api/stats/Entropy/","title":"Entropy","text":"<p>Running entropy.</p>"},{"location":"api/stats/Entropy/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor \u2013 defaults to <code>1</code></p> <p>Fading factor.</p> </li> <li> <p>eps \u2013 defaults to <code>1e-08</code></p> <p>Small value that will be added to the denominator to avoid division by zero.</p> </li> </ul>"},{"location":"api/stats/Entropy/#attributes","title":"Attributes","text":"<ul> <li> <p>entropy (float)</p> <p>The running entropy.</p> </li> <li> <p>n (int)</p> <p>The current number of observations.</p> </li> <li> <p>counter (collections.Counter)</p> <p>Count the number of times the values have occurred</p> </li> </ul>"},{"location":"api/stats/Entropy/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from scipy.stats import entropy\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; def entropy_list(labels, base=None):\n...   value,counts = np.unique(labels, return_counts=True)\n...   return entropy(counts, base=base)\n\n&gt;&gt;&gt; SEED = 42 * 1337\n&gt;&gt;&gt; random.seed(SEED)\n\n&gt;&gt;&gt; entro = stats.Entropy(fading_factor=1)\n\n&gt;&gt;&gt; list_animal = []\n&gt;&gt;&gt; for animal, num_val in zip(['cat', 'dog', 'bird'],[301, 401, 601]):\n...     list_animal += [animal for i in range(num_val)]\n&gt;&gt;&gt; random.shuffle(list_animal)\n\n&gt;&gt;&gt; for animal in list_animal:\n...     _ = entro.update(animal)\n\n&gt;&gt;&gt; print(f'{entro.get():.6f}')\n1.058093\n&gt;&gt;&gt; print(f'{entropy_list(list_animal):.6f}')\n1.058093\n</code></pre>"},{"location":"api/stats/Entropy/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Entropy/#references","title":"References","text":"<ol> <li> <p>Sovdat, B., 2014. Updating Formulas and Algorithms for Computing Entropy and Gini Index from Time-Changing Data Streams. arXiv preprint arXiv:1403.6348. \u21a9</p> </li> </ol>"},{"location":"api/stats/IQR/","title":"IQR","text":"<p>Computes the interquartile range.</p>"},{"location":"api/stats/IQR/#parameters","title":"Parameters","text":"<ul> <li> <p>q_inf \u2013 defaults to <code>0.25</code></p> <p>Desired inferior quantile, must be between 0 and 1. Defaults to <code>0.25</code>.</p> </li> <li> <p>q_sup \u2013 defaults to <code>0.75</code></p> <p>Desired superior quantile, must be between 0 and 1. Defaults to <code>0.75</code>.</p> </li> </ul>"},{"location":"api/stats/IQR/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/IQR/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; iqr = stats.IQR(q_inf=0.25, q_sup=0.75)\n\n&gt;&gt;&gt; for i in range(0, 1001):\n...     iqr = iqr.update(i)\n...     if i % 100 == 0:\n...         print(iqr.get())\n0.0\n50.0\n100.0\n150.0\n200.0\n250.0\n300.0\n350.0\n400.0\n450.0\n500.0\n</code></pre>"},{"location":"api/stats/IQR/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Kurtosis/","title":"Kurtosis","text":"<p>Running kurtosis using Welford's algorithm.</p>"},{"location":"api/stats/Kurtosis/#parameters","title":"Parameters","text":"<ul> <li> <p>bias \u2013 defaults to <code>False</code></p> <p>If <code>False</code>, then the calculations are corrected for statistical bias.</p> </li> </ul>"},{"location":"api/stats/Kurtosis/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Kurtosis/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n&gt;&gt;&gt; import scipy.stats\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; X = np.random.normal(loc=0, scale=1, size=10)\n\n&gt;&gt;&gt; kurtosis = stats.Kurtosis(bias=False)\n&gt;&gt;&gt; for x in X:\n...     print(kurtosis.update(x).get())\n-3.0\n-2.0\n-1.5\n1.4130027920707047\n0.15367976585756438\n0.46142633246812653\n-1.620647789230658\n-1.3540178492487054\n-1.2310268787102745\n-0.9490372374384453\n\n&gt;&gt;&gt; for i in range(2, len(X)+1):\n...     print(scipy.stats.kurtosis(X[:i], bias=False))\n-2.0\n-1.4999999999999998\n1.4130027920707082\n0.15367976585756082\n0.46142633246812403\n-1.620647789230658\n-1.3540178492487063\n-1.2310268787102738\n-0.9490372374384459\n\n&gt;&gt;&gt; kurtosis = stats.Kurtosis(bias=True)\n&gt;&gt;&gt; for x in X:\n...     print(kurtosis.update(x).get())\n-3.0\n-2.0\n-1.5\n-1.011599627723906\n-0.9615800585356089\n-0.6989395431537853\n-1.4252699121794408\n-1.311437071070812\n-1.246289111322894\n-1.082283689864171\n\n&gt;&gt;&gt; for i in range(2, len(X)+1):\n...     print(scipy.stats.kurtosis(X[:i], bias=True))\n-2.0\n-1.4999999999999998\n-1.0115996277239057\n-0.9615800585356098\n-0.6989395431537861\n-1.425269912179441\n-1.3114370710708125\n-1.2462891113228936\n-1.0822836898641714\n</code></pre>"},{"location":"api/stats/Kurtosis/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Kurtosis/#references","title":"References","text":"<ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> </ol>"},{"location":"api/stats/Link/","title":"Link","text":"<p>A link joins two univariate statistics as a sequence.</p> <p>This can be used to pipe the output of one statistic to the input of another. This can be used, for instance, to calculate the mean of the variance of a variable. It can also be used to compute shifted statistics by piping statistics with an instance of <code>stats.Shift</code>. </p> <p>Note that a link is not meant to be instantiated via this class definition. Instead, users can link statistics together via the <code>|</code> operator.</p>"},{"location":"api/stats/Link/#parameters","title":"Parameters","text":"<ul> <li> <p>left (river.stats.base.Univariate)</p> </li> <li> <p>right (river.stats.base.Univariate)</p> <p>The output from <code>left</code>'s <code>get</code> method is passed to <code>right</code>'s <code>update</code> method if <code>left</code>'s <code>get</code> method doesn't produce <code>None.</code></p> </li> </ul>"},{"location":"api/stats/Link/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Link/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n&gt;&gt;&gt; stat = stats.Shift(1) | stats.Mean()\n</code></pre> <p>No values have been seen, therefore <code>get</code> defaults to the initial value of <code>stats.Mean</code>, which is 0.</p> <pre><code>&gt;&gt;&gt; stat.get()\n0.\n</code></pre> <p>Let us now call <code>update</code>.</p> <pre><code>&gt;&gt;&gt; stat = stat.update(1)\n</code></pre> <p>The output from <code>get</code> will still be 0. The reason is that <code>stats.Shift</code> has not enough values, and therefore outputs it's default value, which is <code>None</code>. The <code>stats.Mean</code> instance is therefore not updated.</p> <pre><code>&gt;&gt;&gt; stat.get()\n0.0\n</code></pre> <p>On the next call to <code>update</code>, the <code>stats.Shift</code> instance has seen enough values, and therefore the mean can be updated. The mean is therefore equal to 1, because that's the only value from the past.</p> <pre><code>&gt;&gt;&gt; stat = stat.update(3)\n&gt;&gt;&gt; stat.get()\n1.0\n</code></pre> <p>On the subsequent call to update, the mean will be updated with the value 3.</p> <pre><code>&gt;&gt;&gt; stat = stat.update(4)\n&gt;&gt;&gt; stat.get()\n2.0\n</code></pre> <p>Note that composing statistics returns a new statistic with it's own name.</p> <pre><code>&gt;&gt;&gt; stat.name\n'mean_of_shift_1'\n</code></pre>"},{"location":"api/stats/Link/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/MAD/","title":"MAD","text":"<p>Median Absolute Deviation (MAD).</p> <p>The median absolute deviation is the median of the absolute differences between each data point and the data's overall median. In an online setting, the median of the data is unknown beforehand. Therefore, both the median of the data and the median of the differences of the data with respect to the latter are updated online. To be precise, the median of the data is updated before the median of the differences. As a consequence, this online version of the MAD does not coincide exactly with its batch counterpart.</p>"},{"location":"api/stats/MAD/#attributes","title":"Attributes","text":"<ul> <li> <p>median (stats.Median)</p> <p>The median of the data.</p> </li> </ul>"},{"location":"api/stats/MAD/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [4, 2, 5, 3, 0, 4]\n\n&gt;&gt;&gt; mad = stats.MAD()\n&gt;&gt;&gt; for x in X:\n...     print(mad.update(x).get())\n0.0\n0.0\n0.0\n3.0\n3.0\n2.0\n</code></pre>"},{"location":"api/stats/MAD/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/MAD/#references","title":"References","text":"<ol> <li> <p>Median absolute deviation article on Wikipedia \u21a9</p> </li> </ol>"},{"location":"api/stats/Max/","title":"Max","text":"<p>Running max.</p>"},{"location":"api/stats/Max/#attributes","title":"Attributes","text":"<ul> <li> <p>max (float)</p> <p>The current max.</p> </li> </ul>"},{"location":"api/stats/Max/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 5, -6]\n&gt;&gt;&gt; _max = stats.Max()\n&gt;&gt;&gt; for x in X:\n...     print(_max.update(x).get())\n1\n1\n3\n3\n5\n5\n</code></pre>"},{"location":"api/stats/Max/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Mean/","title":"Mean","text":"<p>Running mean.</p>"},{"location":"api/stats/Mean/#attributes","title":"Attributes","text":"<ul> <li> <p>n (float)</p> <p>The current sum of weights. If each passed weight was 1, then this is equal to the number of seen observations.</p> </li> </ul>"},{"location":"api/stats/Mean/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [-5, -3, -1, 1, 3, 5]\n&gt;&gt;&gt; mean = stats.Mean()\n&gt;&gt;&gt; for x in X:\n...     print(mean.update(x).get())\n-5.0\n-4.0\n-3.0\n-2.0\n-1.0\n0.0\n</code></pre> <p>You can calculate a rolling average by wrapping a <code>utils.Rolling</code> around:</p> <pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; X = [1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; rmean = utils.Rolling(stats.Mean(), window_size=2)\n\n&gt;&gt;&gt; for x in X:\n...     print(rmean.update(x).get())\n1.0\n1.5\n2.5\n3.5\n4.5\n5.5\n</code></pre>"},{"location":"api/stats/Mean/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   revert   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul>   update_many"},{"location":"api/stats/Mean/#references","title":"References","text":"<ol> <li> <p>West, D. H. D. (1979). Updating mean and variance estimates: An improved method. Communications of the ACM, 22(9), 532-535. \u21a9</p> </li> <li> <p>Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9</p> </li> <li> <p>Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9</p> </li> </ol>"},{"location":"api/stats/Min/","title":"Min","text":"<p>Running min.</p>"},{"location":"api/stats/Min/#attributes","title":"Attributes","text":"<ul> <li> <p>min (float)</p> <p>The current min.</p> </li> </ul>"},{"location":"api/stats/Min/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Mode/","title":"Mode","text":"<p>Running mode.</p> <p>The mode is simply the most common value. An approximate mode can be computed by setting the number of first unique values to count.</p>"},{"location":"api/stats/Mode/#parameters","title":"Parameters","text":"<ul> <li> <p>k \u2013 defaults to <code>25</code></p> <p>Only the first <code>k</code> unique values will be included. If <code>k</code> equals -1, the exact mode is computed.</p> </li> </ul>"},{"location":"api/stats/Mode/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Mode/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = ['sunny', 'cloudy', 'cloudy', 'rainy', 'rainy', 'rainy']\n&gt;&gt;&gt; mode = stats.Mode(k=2)\n&gt;&gt;&gt; for x in X:\n...     print(mode.update(x).get())\nsunny\nsunny\ncloudy\ncloudy\ncloudy\ncloudy\n\n&gt;&gt;&gt; mode = stats.Mode(k=-1)\n&gt;&gt;&gt; for x in X:\n...     print(mode.update(x).get())\nsunny\nsunny\ncloudy\ncloudy\ncloudy\nrainy\n</code></pre>"},{"location":"api/stats/Mode/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/NUnique/","title":"NUnique","text":"<p>Approximate number of unique values counter.</p> <p>This is basically an implementation of the HyperLogLog algorithm. Adapted from <code>hypy</code>. The code is a bit too terse but it will do for now.</p>"},{"location":"api/stats/NUnique/#parameters","title":"Parameters","text":"<ul> <li> <p>error_rate \u2013 defaults to <code>0.01</code></p> <p>Desired error rate. Memory usage is inversely proportional to this value.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Set the seed to produce identical results.</p> </li> </ul>"},{"location":"api/stats/NUnique/#attributes","title":"Attributes","text":"<ul> <li> <p>n_bits (int)</p> </li> <li> <p>n_buckets (int)</p> </li> <li> <p>buckets (list)</p> </li> </ul>"},{"location":"api/stats/NUnique/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import string\n&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; alphabet = string.ascii_lowercase\n&gt;&gt;&gt; n_unique = stats.NUnique(error_rate=0.2, seed=42)\n\n&gt;&gt;&gt; n_unique.update('a').get()\n1\n\n&gt;&gt;&gt; n_unique.update('b').get()\n2\n\n&gt;&gt;&gt; for letter in alphabet:\n...     n_unique = n_unique.update(letter)\n&gt;&gt;&gt; n_unique.get()\n31\n</code></pre> <p>Lowering the <code>error_rate</code> parameter will increase the precision.</p> <pre><code>&gt;&gt;&gt; n_unique = stats.NUnique(error_rate=0.01, seed=42)\n&gt;&gt;&gt; for letter in alphabet:\n...     n_unique = n_unique.update(letter)\n&gt;&gt;&gt; n_unique.get()\n26\n</code></pre>"},{"location":"api/stats/NUnique/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/NUnique/#references","title":"References","text":"<ol> <li> <p>My favorite algorithm (and data structure): HyperLogLog \u21a9</p> </li> <li> <p>Flajolet, P., Fusy, \u00c9., Gandouet, O. and Meunier, F., 2007, June. Hyperloglog: the analysis of a near-optimal cardinality estimation algorithm. \u21a9</p> </li> </ol>"},{"location":"api/stats/PeakToPeak/","title":"PeakToPeak","text":"<p>Running peak to peak (max - min).</p>"},{"location":"api/stats/PeakToPeak/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/PeakToPeak/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 2, 4]\n&gt;&gt;&gt; ptp = stats.PeakToPeak()\n&gt;&gt;&gt; for x in X:\n...     print(ptp.update(x).get())\n0.\n5.\n7.\n7.\n7.\n8.\n</code></pre>"},{"location":"api/stats/PeakToPeak/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/PearsonCorr/","title":"PearsonCorr","text":"<p>Online Pearson correlation.</p>"},{"location":"api/stats/PearsonCorr/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof \u2013 defaults to <code>1</code></p> <p>Delta Degrees of Freedom.</p> </li> </ul>"},{"location":"api/stats/PearsonCorr/#attributes","title":"Attributes","text":"<ul> <li> <p>var_x (stats.Var)</p> <p>Running variance of <code>x</code>.</p> </li> <li> <p>var_y (stats.Var)</p> <p>Running variance of <code>y</code>.</p> </li> <li> <p>cov_xy (stats.Cov)</p> <p>Running covariance of <code>x</code> and <code>y</code>.</p> </li> </ul>"},{"location":"api/stats/PearsonCorr/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; x = [0, 0, 0, 1, 1, 1, 1]\n&gt;&gt;&gt; y = [0, 1, 2, 3, 4, 5, 6]\n\n&gt;&gt;&gt; pearson = stats.PearsonCorr()\n\n&gt;&gt;&gt; for xi, yi in zip(x, y):\n...     print(pearson.update(xi, yi).get())\n0\n0\n0\n0.774596\n0.866025\n0.878310\n0.866025\n</code></pre> <p>You can also do this in a rolling fashion:</p> <pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; x = [0, 0, 0, 1, 1, 1, 1]\n&gt;&gt;&gt; y = [0, 1, 2, 3, 4, 5, 6]\n\n&gt;&gt;&gt; pearson = utils.Rolling(stats.PearsonCorr(), window_size=4)\n\n&gt;&gt;&gt; for xi, yi in zip(x, y):\n...     print(pearson.update(xi, yi).get())\n0\n0\n0\n0.7745966692414834\n0.8944271909999159\n0.7745966692414832\n-4.712160915387242e-09\n</code></pre>"},{"location":"api/stats/PearsonCorr/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   revert   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul>"},{"location":"api/stats/Quantile/","title":"Quantile","text":"<p>Running quantile.</p> <p>Uses the P\u00b2 algorithm, which is also known as the \"Piecewise-Parabolic quantile estimator\". The code is inspired by LiveStat's implementation 2.</p>"},{"location":"api/stats/Quantile/#parameters","title":"Parameters","text":"<ul> <li> <p>q (float) \u2013 defaults to <code>0.5</code></p> <p>Determines which quantile to compute, must be comprised between 0 and 1.</p> </li> </ul>"},{"location":"api/stats/Quantile/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Quantile/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; np.random.seed(42 * 1337)\n&gt;&gt;&gt; mu, sigma = 0, 1\n&gt;&gt;&gt; s = np.random.normal(mu, sigma, 500)\n\n&gt;&gt;&gt; median = stats.Quantile(0.5)\n&gt;&gt;&gt; for x in s:\n...    _ = median.update(x)\n&gt;&gt;&gt; print(f'The estimated value of the 50th (median) quantile is {median.get():.4f}')\nThe estimated value of the 50th (median) quantile is -0.0275\n\n&gt;&gt;&gt; print(f'The real value of the 50th (median) quantile is {np.median(s):.4f}')\nThe real value of the 50th (median) quantile is -0.0135\n\n&gt;&gt;&gt; percentile_17 = stats.Quantile(0.17)\n&gt;&gt;&gt; for x in s:\n...    _ = percentile_17.update(x)\n&gt;&gt;&gt; print(f'The estimated value of the 17th quantile is {percentile_17.get():.4f}')\nThe estimated value of the 17th quantile is -0.8652\n\n&gt;&gt;&gt; print(f'The real value of the 17th quantile is {np.percentile(s,17):.4f}')\nThe real value of the 17th quantile is -0.9072\n</code></pre>"},{"location":"api/stats/Quantile/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Quantile/#references","title":"References","text":"<ol> <li> <p>The P\u00b2 Algorithm for Dynamic Univariateal Computing Calculation of Quantiles and Editor Histograms Without Storing Observations \u21a9</p> </li> <li> <p>LiveStats \u21a9</p> </li> <li> <p>P\u00b2 quantile estimator: estimating the median without storing values \u21a9</p> </li> </ol>"},{"location":"api/stats/RollingAbsMax/","title":"RollingAbsMax","text":"<p>Running absolute max over a window.</p>"},{"location":"api/stats/RollingAbsMax/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size (int)</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingAbsMax/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingAbsMax/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 2, 1]\n&gt;&gt;&gt; rolling_absmax = stats.RollingAbsMax(window_size=2)\n&gt;&gt;&gt; for x in X:\n...     print(rolling_absmax.update(x).get())\n1\n4\n4\n3\n2\n2\n</code></pre>"},{"location":"api/stats/RollingAbsMax/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/RollingIQR/","title":"RollingIQR","text":"<p>Computes the rolling interquartile range.</p>"},{"location":"api/stats/RollingIQR/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size (int)</p> <p>Size of the window.</p> </li> <li> <p>q_inf \u2013 defaults to <code>0.25</code></p> <p>Desired inferior quantile, must be between 0 and 1. Defaults to <code>0.25</code>.</p> </li> <li> <p>q_sup \u2013 defaults to <code>0.75</code></p> <p>Desired superior quantile, must be between 0 and 1. Defaults to <code>0.75</code>.</p> </li> </ul>"},{"location":"api/stats/RollingIQR/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingIQR/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n&gt;&gt;&gt; rolling_iqr = stats.RollingIQR(\n...     q_inf=0.25,\n...     q_sup=0.75,\n...     window_size=101\n... )\n\n&gt;&gt;&gt; for i in range(0, 1001):\n...     rolling_iqr = rolling_iqr.update(i)\n...     if i % 100 == 0:\n...         print(rolling_iqr.get())\n0.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n</code></pre>"},{"location":"api/stats/RollingIQR/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/RollingMax/","title":"RollingMax","text":"<p>Running max over a window.</p>"},{"location":"api/stats/RollingMax/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size (int)</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingMax/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingMax/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 2, 1]\n&gt;&gt;&gt; rolling_max = stats.RollingMax(window_size=2)\n&gt;&gt;&gt; for x in X:\n...     print(rolling_max.update(x).get())\n1\n1\n3\n3\n2\n2\n</code></pre>"},{"location":"api/stats/RollingMax/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/RollingMin/","title":"RollingMin","text":"<p>Running min over a window.</p>"},{"location":"api/stats/RollingMin/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size (int)</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingMin/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingMin/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 2, 1]\n&gt;&gt;&gt; rolling_min = stats.RollingMin(2)\n&gt;&gt;&gt; for x in X:\n...     print(rolling_min.update(x).get())\n1\n-4\n-4\n-2\n-2\n1\n</code></pre>"},{"location":"api/stats/RollingMin/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/RollingMode/","title":"RollingMode","text":"<p>Running mode over a window.</p> <p>The mode is the most common value.</p>"},{"location":"api/stats/RollingMode/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size (int)</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingMode/#attributes","title":"Attributes","text":"<ul> <li> <p>counts (collections.defaultdict)</p> <p>Value counts.</p> </li> </ul>"},{"location":"api/stats/RollingMode/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = ['sunny', 'sunny', 'sunny', 'rainy', 'rainy', 'rainy', 'rainy']\n&gt;&gt;&gt; rolling_mode = stats.RollingMode(window_size=2)\n&gt;&gt;&gt; for x in X:\n...     print(rolling_mode.update(x).get())\nsunny\nsunny\nsunny\nsunny\nrainy\nrainy\nrainy\n\n&gt;&gt;&gt; rolling_mode = stats.RollingMode(window_size=5)\n&gt;&gt;&gt; for x in X:\n...     print(rolling_mode.update(x).get())\nsunny\nsunny\nsunny\nsunny\nsunny\nrainy\nrainy\n</code></pre>"},{"location":"api/stats/RollingMode/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/RollingPeakToPeak/","title":"RollingPeakToPeak","text":"<p>Running peak to peak (max - min) over a window.</p>"},{"location":"api/stats/RollingPeakToPeak/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size (int)</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingPeakToPeak/#attributes","title":"Attributes","text":"<ul> <li> <p>max (stats.RollingMax)</p> <p>The running rolling max.</p> </li> <li> <p>min (stats.RollingMin)</p> <p>The running rolling min.</p> </li> </ul>"},{"location":"api/stats/RollingPeakToPeak/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 2, 1]\n&gt;&gt;&gt; ptp = stats.RollingPeakToPeak(window_size=2)\n&gt;&gt;&gt; for x in X:\n...     print(ptp.update(x).get())\n0\n5\n7\n5\n4\n1\n</code></pre>"},{"location":"api/stats/RollingPeakToPeak/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/RollingQuantile/","title":"RollingQuantile","text":"<p>Running quantile over a window.</p>"},{"location":"api/stats/RollingQuantile/#parameters","title":"Parameters","text":"<ul> <li> <p>q (float)</p> <p>Determines which quantile to compute, must be comprised between 0 and 1.</p> </li> <li> <p>window_size (int)</p> <p>Size of the window.</p> </li> </ul>"},{"location":"api/stats/RollingQuantile/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingQuantile/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; rolling_quantile = stats.RollingQuantile(\n...     q=.5,\n...     window_size=101,\n... )\n\n&gt;&gt;&gt; for i in range(1001):\n...     rolling_quantile = rolling_quantile.update(i)\n...     if i % 100 == 0:\n...         print(rolling_quantile.get())\n0.0\n50.0\n150.0\n250.0\n350.0\n450.0\n550.0\n650.0\n750.0\n850.0\n950.0\n</code></pre>"},{"location":"api/stats/RollingQuantile/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/RollingQuantile/#references","title":"References","text":"<ol> <li> <p>Left sorted \u21a9</p> </li> </ol>"},{"location":"api/stats/SEM/","title":"SEM","text":"<p>Running standard error of the mean using Welford's algorithm.</p>"},{"location":"api/stats/SEM/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof \u2013 defaults to <code>1</code></p> <p>Delta Degrees of Freedom. The divisor used in calculations is <code>n - ddof</code>, where <code>n</code> is the number of seen elements.</p> </li> </ul>"},{"location":"api/stats/SEM/#attributes","title":"Attributes","text":"<ul> <li> <p>n (int)</p> <p>Number of observations.</p> </li> </ul>"},{"location":"api/stats/SEM/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [3, 5, 4, 7, 10, 12]\n\n&gt;&gt;&gt; sem = stats.SEM()\n&gt;&gt;&gt; for x in X:\n...     print(sem.update(x).get())\n0.0\n1.0\n0.577350\n0.853912\n1.240967\n1.447219\n\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; X = [1, 4, 2, -4, -8, 0]\n\n&gt;&gt;&gt; rolling_sem = utils.Rolling(stats.SEM(ddof=1), window_size=3)\n&gt;&gt;&gt; for x in X:\n...     print(rolling_sem.update(x).get())\n0.0\n1.5\n0.881917\n2.403700\n2.905932\n2.309401\n</code></pre>"},{"location":"api/stats/SEM/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   revert   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul>   update_many"},{"location":"api/stats/SEM/#references","title":"References","text":"<ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> </ol>"},{"location":"api/stats/Shift/","title":"Shift","text":"<p>Shifts a data stream by returning past values.</p> <p>This can be used to compute statistics over past data. For instance, if you're computing daily averages, then shifting by 7 will be equivalent to computing averages from a week ago. </p> <p>Shifting values is useful when you're calculating an average over a target value. Indeed, in this case it's important to shift the values in order not to introduce leakage. The recommended way to do this is to <code>feature_extraction.TargetAgg</code>, which already takes care of shifting the target values once.</p>"},{"location":"api/stats/Shift/#parameters","title":"Parameters","text":"<ul> <li> <p>amount \u2013 defaults to <code>1</code></p> <p>Shift amount. The <code>get</code> method will return the <code>t - amount</code> value, where <code>t</code> is the current moment.</p> </li> <li> <p>fill_value \u2013 defaults to <code>None</code></p> <p>This value will be returned by the <code>get</code> method if not enough values have been observed.</p> </li> </ul>"},{"location":"api/stats/Shift/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Shift/#examples","title":"Examples","text":"<p>It is rare to have to use <code>Shift</code> by itself. A more common usage is to compose it with other statistics. This can be done via the <code>|</code> operator.</p> <pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; stat = stats.Shift(1) | stats.Mean()\n\n&gt;&gt;&gt; for i in range(5):\n...     stat = stat.update(i)\n...     print(stat.get())\n0.0\n0.0\n0.5\n1.0\n1.5\n</code></pre> <p>A common usecase for using <code>Shift</code> is when computing statistics on shifted data. For instance, say you have a dataset which records the amount of sales for a set of shops. You might then have a <code>shop</code> field and a <code>sales</code> field. Let's say you want to look at the average amount of sales per shop. You can do this by using a <code>feature_extraction.Agg</code>. When you call <code>transform_one</code>, you're expecting it to return the average amount of sales, without including today's sales. You can do this by prepending an instance of <code>stats.Mean</code> with an instance of <code>stats.Shift</code>.</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction\n\n&gt;&gt;&gt; agg = feature_extraction.Agg(\n...     on='sales',\n...     how=stats.Shift(1) | stats.Mean(),\n...     by='shop'\n... )\n</code></pre> <p>Let's define a little example dataset.</p> <pre><code>&gt;&gt;&gt; X = iter([\n...     {'shop': 'Ikea', 'sales': 10},\n...     {'shop': 'Ikea', 'sales': 15},\n...     {'shop': 'Ikea', 'sales': 20}\n... ])\n</code></pre> <p>Now let's call the <code>learn_one</code> method to update our feature extractor.</p> <pre><code>&gt;&gt;&gt; x = next(X)\n&gt;&gt;&gt; agg = agg.learn_one(x)\n</code></pre> <p>At this point, the average defaults to the initial value of <code>stats.Mean</code>, which is 0.</p> <pre><code>&gt;&gt;&gt; agg.transform_one(x)\n{'sales_mean_of_shift_1_by_shop': 0.0}\n</code></pre> <p>We can now update our feature extractor with the next data point and check the output.</p> <pre><code>&gt;&gt;&gt; agg = agg.learn_one(next(X))\n&gt;&gt;&gt; agg.transform_one(x)\n{'sales_mean_of_shift_1_by_shop': 10.0}\n\n&gt;&gt;&gt; agg = agg.learn_one(next(X))\n&gt;&gt;&gt; agg.transform_one(x)\n{'sales_mean_of_shift_1_by_shop': 12.5}\n</code></pre>"},{"location":"api/stats/Shift/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Skew/","title":"Skew","text":"<p>Running skew using Welford's algorithm.</p>"},{"location":"api/stats/Skew/#parameters","title":"Parameters","text":"<ul> <li> <p>bias \u2013 defaults to <code>False</code></p> <p>If <code>False</code>, then the calculations are corrected for statistical bias.</p> </li> </ul>"},{"location":"api/stats/Skew/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Skew/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; X = np.random.normal(loc=0, scale=1, size=10)\n\n&gt;&gt;&gt; skew = stats.Skew(bias=False)\n&gt;&gt;&gt; for x in X:\n...     print(skew.update(x).get())\n0.0\n0.0\n-1.4802398132849872\n0.5127437186677888\n0.7803466510704751\n1.056115628922055\n0.5057840774320389\n0.3478402420400934\n0.4536710660918704\n0.4123070197493227\n\n&gt;&gt;&gt; skew = stats.Skew(bias=True)\n&gt;&gt;&gt; for x in X:\n...     print(skew.update(x).get())\n0.0\n0.0\n-0.6043053732501439\n0.2960327239981376\n0.5234724473423674\n0.7712778043924866\n0.39022088752624845\n0.278892645224261\n0.37425953513864063\n0.3476878073823696\n</code></pre>"},{"location":"api/stats/Skew/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Skew/#references","title":"References","text":"<ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> </ol>"},{"location":"api/stats/Sum/","title":"Sum","text":"<p>Running sum.</p>"},{"location":"api/stats/Sum/#attributes","title":"Attributes","text":"<ul> <li> <p>sum (float)</p> <p>The running sum.</p> </li> </ul>"},{"location":"api/stats/Sum/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [-5, -3, -1, 1, 3, 5]\n&gt;&gt;&gt; mean = stats.Sum()\n&gt;&gt;&gt; for x in X:\n...     print(mean.update(x).get())\n-5.0\n-8.0\n-9.0\n-8.0\n-5.0\n0.0\n\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; X = [1, -4, 3, -2, 2, 1]\n&gt;&gt;&gt; rolling_sum = utils.Rolling(stats.Sum(), window_size=2)\n&gt;&gt;&gt; for x in X:\n...     print(rolling_sum.update(x).get())\n1.0\n-3.0\n-1.0\n1.0\n0.0\n3.0\n</code></pre>"},{"location":"api/stats/Sum/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   revert   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stats/Var/","title":"Var","text":"<p>Running variance using Welford's algorithm.</p>"},{"location":"api/stats/Var/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof \u2013 defaults to <code>1</code></p> <p>Delta Degrees of Freedom. The divisor used in calculations is <code>n - ddof</code>, where <code>n</code> represents the number of seen elements.</p> </li> </ul>"},{"location":"api/stats/Var/#attributes","title":"Attributes","text":"<ul> <li> <p>mean</p> <p>It is necessary to calculate the mean of the data in order to calculate its variance.</p> </li> </ul>"},{"location":"api/stats/Var/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stats\n\n&gt;&gt;&gt; X = [3, 5, 4, 7, 10, 12]\n\n&gt;&gt;&gt; var = stats.Var()\n&gt;&gt;&gt; for x in X:\n...     print(var.update(x).get())\n0.0\n2.0\n1.0\n2.916666\n7.7\n12.56666\n</code></pre> <p>You can measure a rolling variance by using a <code>utils.Rolling</code> wrapper:</p> <pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; X = [1, 4, 2, -4, -8, 0]\n&gt;&gt;&gt; rvar = utils.Rolling(stats.Var(ddof=1), window_size=3)\n&gt;&gt;&gt; for x in X:\n...     print(rvar.update(x).get())\n0.0\n4.5\n2.333333\n17.333333\n25.333333\n16.0\n</code></pre>"},{"location":"api/stats/Var/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   revert   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul>   update_many"},{"location":"api/stats/Var/#notes","title":"Notes","text":"<p>The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\).</p>"},{"location":"api/stats/Var/#references","title":"References","text":"<ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> <li> <p>Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9</p> </li> <li> <p>Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-)variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/stats/base/Bivariate/","title":"Bivariate","text":"<p>A bivariate statistic measures a relationship between two variables.</p>"},{"location":"api/stats/base/Bivariate/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul>"},{"location":"api/stats/base/Univariate/","title":"Univariate","text":"<p>A univariate statistic measures a property of a variable.</p>"},{"location":"api/stats/base/Univariate/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/base/Univariate/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p>   update <p>Update and return the called instance.</p> <p>Parameters</p> <ul> <li>x     (numbers.Number)    </li> </ul>"},{"location":"api/stream/Cache/","title":"Cache","text":"<p>Utility for caching iterables.</p> <p>This can be used to save a stream of data to the disk in order to iterate over it faster the following time. This can save time depending on the nature of stream. The more processing happens in a stream, the more time will be saved. Even in the case where no processing is done apart from reading the data, the cache will save some time because it is using the pickle binary protocol. It can thus improve the speed in common cases such as reading from a CSV file.</p>"},{"location":"api/stream/Cache/#parameters","title":"Parameters","text":"<ul> <li> <p>directory \u2013 defaults to <code>None</code></p> <p>The path where to store the pickled data streams. If not provided, then it will be automatically inferred whenever possible, if not an exception will be raised.</p> </li> </ul>"},{"location":"api/stream/Cache/#attributes","title":"Attributes","text":"<ul> <li> <p>keys (set)</p> <p>The set of keys that are being cached.</p> </li> </ul>"},{"location":"api/stream/Cache/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import time\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; cache = stream.Cache()\n</code></pre> <p>The cache can be used by wrapping it around an iterable. Because this is the first time are iterating over the data, nothing is cached.</p> <pre><code>&gt;&gt;&gt; tic = time.time()\n&gt;&gt;&gt; for x, y in cache(dataset, key='phishing'):\n...     pass\n&gt;&gt;&gt; toc = time.time()\n&gt;&gt;&gt; print(toc - tic)  # doctest: +SKIP\n0.012813\n</code></pre> <p>If we do the same thing again, we can see the loop is now faster.</p> <pre><code>&gt;&gt;&gt; tic = time.time()\n&gt;&gt;&gt; for x, y in cache(dataset, key='phishing'):\n...     pass\n&gt;&gt;&gt; toc = time.time()\n&gt;&gt;&gt; print(toc - tic)  # doctest: +SKIP\n0.001927\n</code></pre> <p>We can see an overview of the cache. The first line indicates the location of the cache.</p> <pre><code>&gt;&gt;&gt; cache  # doctest: +SKIP\n/tmp\nphishing - 125.2KiB\n</code></pre> <p>Finally, we can clear the stream from the cache.</p> <pre><code>&gt;&gt;&gt; cache.clear('phishing')\n&gt;&gt;&gt; cache  # doctest: +SKIP\n/tmp\n</code></pre> <p>There is also a <code>clear_all</code> method to remove all the items in the cache.</p> <pre><code>&gt;&gt;&gt; cache.clear_all()\n</code></pre>"},{"location":"api/stream/Cache/#methods","title":"Methods","text":"call <p>Call self as a function.</p> <p>Parameters</p> <ul> <li>stream </li> <li>key     \u2013 defaults to <code>None</code> </li> </ul>   clear <p>Delete the cached stream associated with the given key.</p> <p>Parameters</p> <ul> <li>key     (str)    </li> </ul>   clear_all <p>Delete all the cached streams.</p>"},{"location":"api/stream/TwitchChatStream/","title":"TwitchChatStream","text":"<p>Twitch chat stream client.</p> <p>This client gives access to a live stream of chat messages in Twitch channels using IRC protocol. You need to have a Twitch account and receive an OAuth token from https://twitchapps.com/tmi/.</p>"},{"location":"api/stream/TwitchChatStream/#parameters","title":"Parameters","text":"<ul> <li> <p>nickname (str)</p> <p>The nickname of your account.</p> </li> <li> <p>token (str)</p> <p>OAuth token which has been generated.</p> </li> <li> <p>channels (List[str])</p> <p>A list of channel names like <code>[\"asmongold\", \"shroud\"]</code> you want to collect messages from.</p> </li> <li> <p>buffer_size (int) \u2013 defaults to <code>2048</code></p> <p>Size of buffer in bytes used for receiving responses from Twitch with IRC (default 2 kB).</p> </li> <li> <p>timeout (int) \u2013 defaults to <code>60</code></p> <p>A timeout value in seconds for waiting response from Twitch (default 60s). It can be useful if all requested channels are offline or chat is not active enough.</p> </li> </ul>"},{"location":"api/stream/TwitchChatStream/#examples","title":"Examples","text":"<p>The live stream is instantiated by passing your Twitch account nickname, OAuth token and list of channels. Other parameters are optional.</p> <pre><code>&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; twitch_chat = stream.TwitchChatStream(\n...     nickname=\"twitch_user1\",\n...     token=\"oauth:okrip6j6fjio8n5xpy2oum1lph4fbve\",\n...     channels=[\"asmongold\", \"shroud\"]\n... )\n</code></pre> <p>The stream can be iterated over like this:</p> <pre><code>for item in twitch_chat:\n    print(item)\n</code></pre> <p>Here's a single stream item example: <pre><code>{\n    'dt': datetime.datetime(2022, 9, 14, 10, 33, 37, 989560),\n    'channel': 'asmongold',\n    'username': 'moojiejaa',\n    'msg': 'damn this chat mod are wild'\n}\n</code></pre></p>"},{"location":"api/stream/TwitchChatStream/#references","title":"References","text":"<ol> <li> <p>Twitch IRC doc \u21a9</p> </li> </ol>"},{"location":"api/stream/TwitterLiveStream/","title":"TwitterLiveStream","text":"<p>Twitter API v2 live stream client.</p> <p>This client gives access to a live stream of Tweets. That is, Tweets that have just been     published. This is different to <code>stream.TwitterRecentStream</code>, which also covers Tweets that     have been published over recent days, and not necessarily in real-time. </p> <p>A list of filtering rules has to be provided. For instance, this allows focusing on a subset of     topics and/or users. </p>  <p>Note</p> <p>Using this requires having the <code>requests</code>         package installed.</p>"},{"location":"api/stream/TwitterLiveStream/#parameters","title":"Parameters","text":"<ul> <li> <p>rules</p> <p>See the documentation[^2] for a comprehensive overview of filtering rules.</p> </li> <li> <p>bearer_token</p> <p>A bearer token that is available in each account's developer portal.</p> </li> </ul>"},{"location":"api/stream/TwitterLiveStream/#examples","title":"Examples","text":"<p>The live stream is instantiated by passing a list of filtering rules, as well as a bearer     token. For instance, we can listen to all the breaking news Tweets from the BBC and CNN.</p> <pre><code>&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; tweets = stream.TwitterLiveStream(\n...     rules=[\"from:BBCBreaking\", \"from:cnnbrk\"],\n...     bearer_token=\"&lt;insert_bearer_token&gt;\"\n... )\n\nThe stream can then be iterated over, possibly in an infinite loop. This will listen to the\nlive feed of Tweets and produce a Tweet right after it's been published.\n\n```py\nimport logging\n\nwhile True:\n    try:\n        for tweet in tweets:\n            print(tweet)\n    except requests.exceptions.RequestException as e:\n        logging.warning(str(e))\n        time.sleep(10)\n```\n\nHere's a Tweet example:\n\n```py\n{\n    'data': {\n        'author_id': '428333',\n        'created_at': '2022-08-26T12:59:48.000Z',\n        'id': '1563149212774445058',\n        'text': \"Ukraine's Zaporizhzhia nuclear power plant, which is currently held by\n</code></pre> <p>Russian forces, has been reconnected to Ukraine's electricity grid, according to the country's nuclear operator https://t.co/xfylkBs4JR\"         },         'includes': {             'users': [                 {                     'created_at': '2007-01-02T01:48:14.000Z',                     'id': '428333',                     'name': 'CNN Breaking News',                     'username': 'cnnbrk'                 }             ]         },         'matching_rules': [{'id': '1563148866333151233', 'tag': 'from:cnnbrk'}]     }     ```</p>"},{"location":"api/stream/TwitterLiveStream/#references","title":"References","text":"<pre><code>[^1]: [Filtered stream introduction](https://developer.twitter.com/en/docs/twitter-api/tweets/filtered-stream/introduction)\n[^2]: [Building rules for filtered stream](https://developer.twitter.com/en/docs/twitter-api/tweets/filtered-stream/integrate/build-a-rule)\n[^3]: [Stream Tweets in real-time](https://developer.twitter.com/en/docs/tutorials/stream-tweets-in-real-time)\n</code></pre>"},{"location":"api/stream/iter-arff/","title":"iter_arff","text":"<p>Iterates over rows from an ARFF file.</p>"},{"location":"api/stream/iter-arff/#parameters","title":"Parameters","text":"<ul> <li> <p>filepath_or_buffer</p> <p>Either a string indicating the location of a file, or a buffer object that has a <code>read</code> method.</p> </li> <li> <p>target (str) \u2013 defaults to <code>None</code></p> <p>Name of the target field.</p> </li> <li> <p>compression \u2013 defaults to <code>infer</code></p> <p>For on-the-fly decompression of on-disk data. If this is set to 'infer' and <code>filepath_or_buffer</code> is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.</p> </li> </ul>"},{"location":"api/stream/iter-array/","title":"iter_array","text":"<p>Iterates over the rows from an array of features and an array of targets.</p> <p>This method is intended to work with <code>numpy</code> arrays, but should also work with Python lists.</p>"},{"location":"api/stream/iter-array/#parameters","title":"Parameters","text":"<ul> <li> <p>X (numpy.ndarray)</p> <p>A 2D array of features. This can also be a 1D array of strings, which can be the case if you're working with text.</p> </li> <li> <p>y (numpy.ndarray) \u2013 defaults to <code>None</code></p> <p>An optional array of targets.</p> </li> <li> <p>feature_names (List[Hashable]) \u2013 defaults to <code>None</code></p> <p>An optional list of feature names. The features will be labeled with integers if no names are provided.</p> </li> <li> <p>target_names (List[Hashable]) \u2013 defaults to <code>None</code></p> <p>An optional list of output names. The outputs will be labeled with integers if no names are provided. Only applies if there are multiple outputs, i.e. if <code>y</code> is a 2D array.</p> </li> <li> <p>shuffle (bool) \u2013 defaults to <code>False</code></p> <p>Indicates whether or not to shuffle the input arrays before iterating over them.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed used for shuffling the data.</p> </li> </ul>"},{"location":"api/stream/iter-array/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stream\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; X = np.array([[1, 2, 3], [11, 12, 13]])\n&gt;&gt;&gt; Y = np.array([True, False])\n\n&gt;&gt;&gt; dataset = stream.iter_array(\n...     X, Y,\n...     feature_names=['x1', 'x2', 'x3']\n... )\n&gt;&gt;&gt; for x, y in dataset:\n...     print(x, y)\n{'x1': 1, 'x2': 2, 'x3': 3} True\n{'x1': 11, 'x2': 12, 'x3': 13} False\n</code></pre> <p>This also works with a array of texts:</p> <pre><code>&gt;&gt;&gt; X = [\"foo\", \"bar\"]\n&gt;&gt;&gt; dataset = stream.iter_array(\n...     X, Y,\n...     feature_names=['x1', 'x2', 'x3']\n... )\n&gt;&gt;&gt; for x, y in dataset:\n...     print(x, y)\nfoo True\nbar False\n</code></pre>"},{"location":"api/stream/iter-csv/","title":"iter_csv","text":"<p>Iterates over rows from a CSV file.</p> <p>Reading CSV files can be quite slow. If, for whatever reason, you're going to loop through the same file multiple times, then we recommend that you to use the <code>stream.Cache</code> utility.</p>"},{"location":"api/stream/iter-csv/#parameters","title":"Parameters","text":"<ul> <li> <p>filepath_or_buffer</p> <p>Either a string indicating the location of a file, or a buffer object that has a <code>read</code> method.</p> </li> <li> <p>target (Union[str, List[str]]) \u2013 defaults to <code>None</code></p> <p>A single target column is assumed if a string is passed. A multiple output scenario is assumed if a list of strings is passed. A <code>None</code> value will be assigned to each <code>y</code> if this parameter is omitted.</p> </li> <li> <p>converters (dict) \u2013 defaults to <code>None</code></p> <p>All values in the CSV are interpreted as strings by default. You can use this parameter to cast values to the desired type. This should be a <code>dict</code> mapping feature names to callables used to parse their associated values. Note that a callable may be a type, such as <code>float</code> and <code>int</code>.</p> </li> <li> <p>parse_dates (dict) \u2013 defaults to <code>None</code></p> <p>A <code>dict</code> mapping feature names to a format passed to the <code>datetime.datetime.strptime</code> method.</p> </li> <li> <p>drop (List[str]) \u2013 defaults to <code>None</code></p> <p>Fields to ignore.</p> </li> <li> <p>drop_nones \u2013 defaults to <code>False</code></p> <p>Whether or not to drop fields where the value is a <code>None</code>.</p> </li> <li> <p>fraction \u2013 defaults to <code>1.0</code></p> <p>Sampling fraction.</p> </li> <li> <p>compression \u2013 defaults to <code>infer</code></p> <p>For on-the-fly decompression of on-disk data. If this is set to 'infer' and <code>filepath_or_buffer</code> is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>If specified, the sampling will be deterministic.</p> </li> <li> <p>field_size_limit (int) \u2013 defaults to <code>None</code></p> <p>If not <code>None</code>, this will be passed to the <code>csv.field_size_limit</code> function.</p> </li> <li> <p>kwargs</p> <p>All other keyword arguments are passed to the underlying <code>csv.DictReader</code>.</p> </li> </ul>"},{"location":"api/stream/iter-csv/#examples","title":"Examples","text":"<p>Although this function is designed to handle different kinds of inputs, the most common use case is to read a file on the disk. We'll first create a little CSV file to illustrate.</p> <pre><code>&gt;&gt;&gt; tv_shows = '''name,year,rating\n... Planet Earth II,2016,9.5\n... Planet Earth,2006,9.4\n... Band of Brothers,2001,9.4\n... Breaking Bad,2008,9.4\n... Chernobyl,2019,9.4\n... '''\n&gt;&gt;&gt; with open('tv_shows.csv', mode='w') as f:\n...     _ = f.write(tv_shows)\n</code></pre> <p>We can now go through the rows one by one. We can use the <code>converters</code> parameter to cast the <code>rating</code> field value as a <code>float</code>. We can also convert the <code>year</code> to a <code>datetime</code> via the <code>parse_dates</code> parameter.</p> <pre><code>&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; params = {\n...     'converters': {'rating': float},\n...     'parse_dates': {'year': '%Y'}\n... }\n&gt;&gt;&gt; for x, y in stream.iter_csv('tv_shows.csv', **params):\n...     print(x, y)\n{'name': 'Planet Earth II', 'year': datetime.datetime(2016, 1, 1, 0, 0), 'rating': 9.5} None\n{'name': 'Planet Earth', 'year': datetime.datetime(2006, 1, 1, 0, 0), 'rating': 9.4} None\n{'name': 'Band of Brothers', 'year': datetime.datetime(2001, 1, 1, 0, 0), 'rating': 9.4} None\n{'name': 'Breaking Bad', 'year': datetime.datetime(2008, 1, 1, 0, 0), 'rating': 9.4} None\n{'name': 'Chernobyl', 'year': datetime.datetime(2019, 1, 1, 0, 0), 'rating': 9.4} None\n</code></pre> <p>The value of <code>y</code> is always <code>None</code> because we haven't provided a value for the <code>target</code> parameter. Here is an example where a <code>target</code> is provided:</p> <pre><code>&gt;&gt;&gt; dataset = stream.iter_csv('tv_shows.csv', target='rating', **params)\n&gt;&gt;&gt; for x, y in dataset:\n...     print(x, y)\n{'name': 'Planet Earth II', 'year': datetime.datetime(2016, 1, 1, 0, 0)} 9.5\n{'name': 'Planet Earth', 'year': datetime.datetime(2006, 1, 1, 0, 0)} 9.4\n{'name': 'Band of Brothers', 'year': datetime.datetime(2001, 1, 1, 0, 0)} 9.4\n{'name': 'Breaking Bad', 'year': datetime.datetime(2008, 1, 1, 0, 0)} 9.4\n{'name': 'Chernobyl', 'year': datetime.datetime(2019, 1, 1, 0, 0)} 9.4\n</code></pre> <p>Finally, let's delete the example file.</p> <pre><code>&gt;&gt;&gt; import os; os.remove('tv_shows.csv')\n</code></pre>"},{"location":"api/stream/iter-libsvm/","title":"iter_libsvm","text":"<p>Iterates over a dataset in LIBSVM format.</p> <p>The LIBSVM format is a popular way in the machine learning community to store sparse datasets. Only numerical feature values are supported. The feature names will be considered as strings.</p>"},{"location":"api/stream/iter-libsvm/#parameters","title":"Parameters","text":"<ul> <li> <p>filepath_or_buffer (str)</p> <p>Either a string indicating the location of a file, or a buffer object that has a <code>read</code> method.</p> </li> <li> <p>target_type \u2013 defaults to <code>&lt;class 'float'&gt;</code></p> <p>The type of the target value.</p> </li> <li> <p>compression \u2013 defaults to <code>infer</code></p> <p>For on-the-fly decompression of on-disk data. If this is set to 'infer' and <code>filepath_or_buffer</code> is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.</p> </li> </ul>"},{"location":"api/stream/iter-libsvm/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; data = io.StringIO('''+1 x:-134.26 y:0.2563\n... 1 x:-12 z:0.3\n... -1 y:.25\n... ''')\n\n&gt;&gt;&gt; for x, y in stream.iter_libsvm(data, target_type=int):\n...     print(y, x)\n1 {'x': -134.26, 'y': 0.2563}\n1 {'x': -12.0, 'z': 0.3}\n-1 {'y': 0.25}\n</code></pre>"},{"location":"api/stream/iter-libsvm/#references","title":"References","text":"<ol> <li> <p>LIBSVM documentation \u21a9</p> </li> </ol>"},{"location":"api/stream/iter-pandas/","title":"iter_pandas","text":"<p>Iterates over the rows of a <code>pandas.DataFrame</code>.</p>"},{"location":"api/stream/iter-pandas/#parameters","title":"Parameters","text":"<ul> <li> <p>X (pandas.core.frame.DataFrame)</p> <p>A dataframe of features.</p> </li> <li> <p>y (Union[pandas.core.series.Series, pandas.core.frame.DataFrame]) \u2013 defaults to <code>None</code></p> <p>A series or a dataframe with one column per target.</p> </li> <li> <p>kwargs</p> <p>Extra keyword arguments are passed to the underlying call to <code>stream.iter_array</code>.</p> </li> </ul>"},{"location":"api/stream/iter-pandas/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; X = pd.DataFrame({\n...     'x1': [1, 2, 3, 4],\n...     'x2': ['blue', 'yellow', 'yellow', 'blue'],\n...     'y': [True, False, False, True]\n... })\n&gt;&gt;&gt; y = X.pop('y')\n\n&gt;&gt;&gt; for xi, yi in stream.iter_pandas(X, y):\n...     print(xi, yi)\n{'x1': 1, 'x2': 'blue'} True\n{'x1': 2, 'x2': 'yellow'} False\n{'x1': 3, 'x2': 'yellow'} False\n{'x1': 4, 'x2': 'blue'} True\n</code></pre>"},{"location":"api/stream/iter-sklearn-dataset/","title":"iter_sklearn_dataset","text":"<p>Iterates rows from one of the datasets provided by scikit-learn.</p> <p>This allows you to use any dataset from scikit-learn's <code>datasets</code> module. For instance, you can use the <code>fetch_openml</code> function to get access to all of the datasets from the OpenML website.</p>"},{"location":"api/stream/iter-sklearn-dataset/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset ('sklearn.utils.Bunch')</p> <p>A scikit-learn dataset.</p> </li> <li> <p>kwargs</p> <p>Extra keyword arguments are passed to the underlying call to <code>stream.iter_array</code>.</p> </li> </ul>"},{"location":"api/stream/iter-sklearn-dataset/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; from sklearn import datasets\n&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; dataset = datasets.load_diabetes()\n\n&gt;&gt;&gt; for xi, yi in stream.iter_sklearn_dataset(dataset):\n...     pprint.pprint(xi)\n...     print(yi)\n...     break\n{'age': 0.038075906433423026,\n 'bmi': 0.061696206518683294,\n 'bp': 0.0218723855140367,\n 's1': -0.04422349842444599,\n 's2': -0.03482076283769895,\n 's3': -0.04340084565202491,\n 's4': -0.002592261998183278,\n 's5': 0.019907486170462722,\n 's6': -0.01764612515980379,\n 'sex': 0.05068011873981862}\n151.0\n</code></pre>"},{"location":"api/stream/iter-sql/","title":"iter_sql","text":"<p>Iterates over the results from an SQL query.</p> <p>By default, SQLAlchemy prefetches results. Therefore, even though you can iterate over the resulting rows one by one, the results are in fact loaded in batch. You can modify this behavior by configuring the connection you pass to <code>iter_sql</code>. For instance, you can set the <code>stream_results</code> parameter to <code>True</code>, as explained in SQLAlchemy's documentation. Note, however, that this isn't available for all database engines.</p>"},{"location":"api/stream/iter-sql/#parameters","title":"Parameters","text":"<ul> <li> <p>query (Union[str, sqlalchemy.sql.selectable.Selectable])</p> <p>SQL query to be executed.</p> </li> <li> <p>conn (sqlalchemy.engine.interfaces.Connectable)</p> <p>An SQLAlchemy construct which has an <code>execute</code> method. In other words you can pass an engine, a connection, or a session.</p> </li> <li> <p>target_name (str) \u2013 defaults to <code>None</code></p> <p>The name of the target field. If this is <code>None</code>, then <code>y</code> will also be <code>None</code>.</p> </li> </ul>"},{"location":"api/stream/iter-sql/#examples","title":"Examples","text":"<p>As an example we'll create an in-memory database with SQLAlchemy.</p> <pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; import sqlalchemy\n\n&gt;&gt;&gt; engine = sqlalchemy.create_engine('sqlite://')\n\n&gt;&gt;&gt; metadata = sqlalchemy.MetaData()\n\n&gt;&gt;&gt; t_sales = sqlalchemy.Table('sales', metadata,\n...     sqlalchemy.Column('shop', sqlalchemy.String, primary_key=True),\n...     sqlalchemy.Column('date', sqlalchemy.Date, primary_key=True),\n...     sqlalchemy.Column('amount', sqlalchemy.Integer)\n... )\n\n&gt;&gt;&gt; metadata.create_all(engine)\n\n&gt;&gt;&gt; sales = [\n...     {'shop': 'Hema', 'date': dt.date(2016, 8, 2), 'amount': 20},\n...     {'shop': 'Ikea', 'date': dt.date(2016, 8, 2), 'amount': 18},\n...     {'shop': 'Hema', 'date': dt.date(2016, 8, 3), 'amount': 22},\n...     {'shop': 'Ikea', 'date': dt.date(2016, 8, 3), 'amount': 14},\n...     {'shop': 'Hema', 'date': dt.date(2016, 8, 4), 'amount': 12},\n...     {'shop': 'Ikea', 'date': dt.date(2016, 8, 4), 'amount': 16}\n... ]\n\n&gt;&gt;&gt; with engine.connect() as conn:\n...     _ = conn.execute(t_sales.insert(), sales)\n</code></pre> <p>We can now query the database. We will set <code>amount</code> to be the target field.</p> <pre><code>&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; with engine.connect() as conn:\n...     query = 'SELECT * FROM sales;'\n...     dataset = stream.iter_sql(query, conn, target_name='amount')\n...     for x, y in dataset:\n...         print(x, y)\n{'shop': 'Hema', 'date': '2016-08-02'} 20\n{'shop': 'Ikea', 'date': '2016-08-02'} 18\n{'shop': 'Hema', 'date': '2016-08-03'} 22\n{'shop': 'Ikea', 'date': '2016-08-03'} 14\n{'shop': 'Hema', 'date': '2016-08-04'} 12\n{'shop': 'Ikea', 'date': '2016-08-04'} 16\n</code></pre>"},{"location":"api/stream/shuffle/","title":"shuffle","text":"<p>Shuffles a stream of data.</p> <p>This works by maintaining a buffer of elements. The first <code>buffer_size</code> elements are stored in memory. Once the buffer is full, a random element inside the buffer is yielded. Every time an element is yielded, the next element in the stream replaces it and the buffer is sampled again. Increasing <code>buffer_size</code> will improve the quality of the shuffling. </p> <p>If you really want to stream over your dataset in a \"good\" random order, the best way is to split your dataset into smaller datasets and loop over them in a round-robin fashion. You may do this by using the <code>roundrobin</code> recipe from the <code>itertools</code> module.</p>"},{"location":"api/stream/shuffle/#parameters","title":"Parameters","text":"<ul> <li> <p>stream (Iterator)</p> <p>The stream to shuffle.</p> </li> <li> <p>buffer_size (int)</p> <p>The size of the buffer which contains the elements help in memory. Increasing this will increase randomness but will incur more memory usage.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed used for sampling.</p> </li> </ul>"},{"location":"api/stream/shuffle/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import stream\n\n&gt;&gt;&gt; for i in stream.shuffle(range(15), buffer_size=5, seed=42):\n...     print(i)\n0\n5\n2\n1\n8\n9\n6\n4\n11\n12\n10\n7\n14\n13\n3\n</code></pre>"},{"location":"api/stream/shuffle/#references","title":"References","text":"<ol> <li> <p>Visualizing TensorFlow's streaming shufflers \u21a9</p> </li> </ol>"},{"location":"api/stream/simulate-qa/","title":"simulate_qa","text":"<p>Simulate a time-ordered question and answer session.</p> <p>This method allows looping through a dataset in the order in which it arrived. Indeed, it usually is the case that labels arrive after features. Being able to go through a dataset in arrival order enables assessing a model's performance in a reliable manner. For instance, the <code>evaluate.progressive_val_score</code> is a high-level method that can be used to score a model on a dataset. Under the hood it uses this method to determine the correct arrival order.</p>"},{"location":"api/stream/simulate-qa/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset ('base.typing.Dataset')</p> <p>A stream of (features, target) tuples.</p> </li> <li> <p>moment ('str | typing.Callable[[dict], dt.datetime] | None')</p> <p>The attribute used for measuring time. If a callable is passed, then it is expected to take as input a <code>dict</code> of features. If <code>None</code>, then the observations are implicitly timestamped in the order in which they arrive. If a <code>str</code> is passed, then it will be used to obtain the time from the input features.</p> </li> <li> <p>delay ('str | int | dt.timedelta | typing.Callable | None')</p> <p>The amount of time to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the <code>moment</code> value. For instance, if <code>moment</code> is a <code>datetime.date</code>, then <code>delay</code> is expected to be a <code>datetime.timedelta</code>. If a callable is passed, then it is expected to take as input a <code>dict</code> of features and the target. If a <code>str</code> is passed, then it will be used to access the relevant field from the features. If <code>None</code> is passed, then no delay will be used, which leads to doing standard online validation. If a scalar is passed, such an <code>int</code> or a <code>datetime.timedelta</code>, then the delay is constant.</p> </li> <li> <p>copy ('bool') \u2013 defaults to <code>True</code></p> <p>If <code>True</code>, then a separate copy of the features are yielded the second time around. This ensures that inadvertent modifications in downstream code don't have any effect.</p> </li> </ul>"},{"location":"api/stream/simulate-qa/#examples","title":"Examples","text":"<p>The arrival delay isn't usually indicated in a dataset, but it might be able to be inferred from the features. As an example, we'll simulate the departure and arrival time of taxi trips. Let's first create a time table which records the departure time and the duration of seconds of several taxi trips.</p> <pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; time_table = [\n...     (dt.datetime(2020, 1, 1, 20,  0, 0),  900),\n...     (dt.datetime(2020, 1, 1, 20, 10, 0), 1800),\n...     (dt.datetime(2020, 1, 1, 20, 20, 0),  300),\n...     (dt.datetime(2020, 1, 1, 20, 45, 0),  400),\n...     (dt.datetime(2020, 1, 1, 20, 50, 0),  240),\n...     (dt.datetime(2020, 1, 1, 20, 55, 0),  450)\n... ]\n</code></pre> <p>We can now create a streaming dataset where the features are the departure dates and the targets are the durations.</p> <pre><code>&gt;&gt;&gt; dataset = (\n...     ({'date': date}, duration)\n...     for date, duration in time_table\n... )\n</code></pre> <p>Now, we can use <code>simulate_qa</code> to iterate over the events in the order in which they are meant to occur.</p> <pre><code>&gt;&gt;&gt; delay = lambda _, y: dt.timedelta(seconds=y)\n\n&gt;&gt;&gt; for i, x, y in simulate_qa(dataset, moment='date', delay=delay):\n...     if y is None:\n...         print(f'{x[\"date\"]} - trip #{i} departs')\n...     else:\n...         arrival_date = x['date'] + dt.timedelta(seconds=y)\n...         print(f'{arrival_date} - trip #{i} arrives after {y} seconds')\n2020-01-01 20:00:00 - trip #0 departs\n2020-01-01 20:10:00 - trip #1 departs\n2020-01-01 20:15:00 - trip #0 arrives after 900 seconds\n2020-01-01 20:20:00 - trip #2 departs\n2020-01-01 20:25:00 - trip #2 arrives after 300 seconds\n2020-01-01 20:40:00 - trip #1 arrives after 1800 seconds\n2020-01-01 20:45:00 - trip #3 departs\n2020-01-01 20:50:00 - trip #4 departs\n2020-01-01 20:51:40 - trip #3 arrives after 400 seconds\n2020-01-01 20:54:00 - trip #4 arrives after 240 seconds\n2020-01-01 20:55:00 - trip #5 departs\n2020-01-01 21:02:30 - trip #5 arrives after 450 seconds\n</code></pre> <p>This function is extremely practical because it provides a reliable way to evaluate the performance of a model in a real scenario. Indeed, it allows to make predictions and perform model updates in exactly the same manner that would happen live. For instance, it is used in <code>evaluate.progressive_val_score</code>, which is a higher level function for evaluating models in an online manner.</p>"},{"location":"api/time-series/ForecastingMetric/","title":"ForecastingMetric","text":""},{"location":"api/time-series/ForecastingMetric/#methods","title":"Methods","text":"get <p>Return the current performance along the horizon.</p> <p>Returns</p> <p>list[float]:     The current performance.</p>   update <p>Update the metric at each step along the horizon.</p> <p>Parameters</p> <ul> <li>y_true     ('list[Number]')    </li> <li>y_pred     ('list[Number]')    </li> </ul> <p>Returns</p> <p>ForecastingMetric:     self</p>"},{"location":"api/time-series/HoltWinters/","title":"HoltWinters","text":"<p>Holt-Winters forecaster.</p> <p>This is a standard implementation of the Holt-Winters forecasting method. Certain parametrisations result in special cases, such as simple exponential smoothing. </p> <p>Optimal parameters and initialisation values can be determined in a batch setting. However, in an online setting, it is necessary to wait and observe enough values. The first <code>k = max(2, seasonality)</code> values are indeed used to initialize the components. </p> <p>Level initialization </p> \\[l = \\frac{1}{k} \\sum_{i=1}{k} y_i\\] <p>Trend initialization </p> \\[t = \\frac{1}{k - 1} \\sum_{i=2}{k} y_i - y_{i-1}\\] <p>Trend initialization </p> \\[s_i = \\frac{y_i}{k}\\]"},{"location":"api/time-series/HoltWinters/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Smoothing parameter for the level.</p> </li> <li> <p>beta \u2013 defaults to <code>None</code></p> <p>Smoothing parameter for the trend.</p> </li> <li> <p>gamma \u2013 defaults to <code>None</code></p> <p>Smoothing parameter for the seasonality.</p> </li> <li> <p>seasonality \u2013 defaults to <code>0</code></p> <p>The number of periods in a season. For instance, this should be 4 for quarterly data, and 12 for yearly data.</p> </li> <li> <p>multiplicative \u2013 defaults to <code>False</code></p> <p>Whether or not to use a multiplicative formulation.</p> </li> </ul>"},{"location":"api/time-series/HoltWinters/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import time_series\n\n&gt;&gt;&gt; dataset = datasets.AirlinePassengers()\n\n&gt;&gt;&gt; model = time_series.HoltWinters(\n...     alpha=0.3,\n...     beta=0.1,\n...     gamma=0.6,\n...     seasonality=12,\n...     multiplicative=True\n... )\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; time_series.evaluate(\n...     dataset,\n...     model,\n...     metric,\n...     horizon=12\n... )\n+1  MAE: 25.899087\n+2  MAE: 26.26131\n+3  MAE: 25.735903\n+4  MAE: 25.625678\n+5  MAE: 26.093842\n+6  MAE: 26.90249\n+7  MAE: 28.634398\n+8  MAE: 29.284769\n+9  MAE: 31.018351\n+10 MAE: 32.252349\n+11 MAE: 33.518946\n+12 MAE: 33.975057\n</code></pre>"},{"location":"api/time-series/HoltWinters/#methods","title":"Methods","text":"forecast <p>Makes forecast at each step of the given horizon.</p> <p>Parameters</p> <ul> <li>horizon     ('int')    </li> <li>xs     ('list[dict] | None')     \u2013 defaults to <code>None</code> </li> </ul>   learn_one <p>Updates the model.</p> <p>Parameters</p> <ul> <li>y     ('float')    </li> <li>x     ('dict')     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/time-series/HoltWinters/#references","title":"References","text":"<ol> <li> <p>Exponential smoothing \u2014 Wikipedia \u21a9</p> </li> <li> <p>Exponential smoothing \u2014 Forecasting: Principles and Practice \u21a9</p> </li> <li> <p>What is Exponential Smoothing? \u2014 Engineering statistics handbook \u21a9</p> </li> </ol>"},{"location":"api/time-series/HorizonAggMetric/","title":"HorizonAggMetric","text":"<p>Same as <code>HorizonMetric</code>, but aggregates the result based on an provided function.</p> <p>This allows, for instance, to measure the average performance of a forecasting model along the horizon.</p>"},{"location":"api/time-series/HorizonAggMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>metric ('metrics.base.RegressionMetric')</p> <p>A regression metric.</p> </li> <li> <p>agg_func ('typing.Callable[[list[float]], float]')</p> <p>A function that takes as input a list of floats and outputs a single float. You may want to <code>min</code>, <code>max</code>, as well as <code>statistics.mean</code> and <code>statistics.median</code>.</p> </li> </ul>"},{"location":"api/time-series/HorizonAggMetric/#examples","title":"Examples","text":"<p>This is used internally by the <code>time_series.evaluate</code> function when you pass an <code>agg_func</code>.</p> <pre><code>&gt;&gt;&gt; import statistics\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import time_series\n\n&gt;&gt;&gt; metric = time_series.evaluate(\n...     dataset=datasets.AirlinePassengers(),\n...     model=time_series.HoltWinters(alpha=0.1),\n...     metric=metrics.MAE(),\n...     agg_func=statistics.mean,\n...     horizon=4\n... )\n\n&gt;&gt;&gt; metric\nmean(MAE): 42.901748\n</code></pre>"},{"location":"api/time-series/HorizonAggMetric/#methods","title":"Methods","text":"get <p>Return the current performance along the horizon.</p> <p>Returns</p> <p>list[float]:     The current performance.</p>   update <p>Update the metric at each step along the horizon.</p> <p>Parameters</p> <ul> <li>y_true     ('list[Number]')    </li> <li>y_pred     ('list[Number]')    </li> </ul> <p>Returns</p> <p>ForecastingMetric:     self</p>"},{"location":"api/time-series/HorizonMetric/","title":"HorizonMetric","text":"<p>Measures performance at each time step ahead.</p> <p>This allows to measure the performance of a model at each time step along the horizon. A copy of the provided regression metric is made for each time step. At each time step ahead, the metric is thus evaluated on each prediction for said time step, and not for the time steps before or after that.</p>"},{"location":"api/time-series/HorizonMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>metric ('metrics.base.RegressionMetric')</p> <p>A regression metric.</p> </li> </ul>"},{"location":"api/time-series/HorizonMetric/#examples","title":"Examples","text":"<p>This is used internally by the <code>time_series.evaluate</code> function.</p> <pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import time_series\n\n&gt;&gt;&gt; metric = time_series.evaluate(\n...     dataset=datasets.AirlinePassengers(),\n...     model=time_series.HoltWinters(alpha=0.1),\n...     metric=metrics.MAE(),\n...     horizon=4\n... )\n\n&gt;&gt;&gt; metric\n+1 MAE: 40.931286\n+2 MAE: 42.667998\n+3 MAE: 44.158092\n+4 MAE: 43.849617\n</code></pre>"},{"location":"api/time-series/HorizonMetric/#methods","title":"Methods","text":"get <p>Return the current performance along the horizon.</p> <p>Returns</p> <p>list[float]:     The current performance.</p>   update <p>Update the metric at each step along the horizon.</p> <p>Parameters</p> <ul> <li>y_true     ('list[Number]')    </li> <li>y_pred     ('list[Number]')    </li> </ul> <p>Returns</p> <p>ForecastingMetric:     self</p>"},{"location":"api/time-series/SNARIMAX/","title":"SNARIMAX","text":"<p>SNARIMAX model.</p> <p>SNARIMAX stands for (S)easonal (N)on-linear (A)uto(R)egressive (I)ntegrated (M)oving-(A)verage with e(X)ogenous inputs model. </p> <p>This model generalizes many established time series models in a single interface that can be trained online. It assumes that the provided training data is ordered in time and is uniformly spaced. It is made up of the following components: </p> <ul> <li>S (Seasonal) - N (Non-linear): Any online regression model can be used, not necessarily a linear regression     as is done in textbooks. - AR (Autoregressive): Lags of the target variable are used as features. - I (Integrated): The model can be fitted on a differenced version of a time series. In this     context, integration is the reverse of differencing. - MA (Moving average): Lags of the errors are used as features. - X (Exogenous): Users can provide additional features. Care has to be taken to include     features that will be available both at training and prediction time. </li> </ul> <p>Each of these components can be switched on and off by specifying the appropriate parameters. Classical time series models such as AR, MA, ARMA, and ARIMA can thus be seen as special parametrizations of the SNARIMAX model. </p> <p>This model is tailored for time series that are homoskedastic. In other words, it might not work well if the variance of the time series varies widely along time.</p>"},{"location":"api/time-series/SNARIMAX/#parameters","title":"Parameters","text":"<ul> <li> <p>p (int)</p> <p>Order of the autoregressive part. This is the number of past target values that will be included as features.</p> </li> <li> <p>d (int)</p> <p>Differencing order.</p> </li> <li> <p>q (int)</p> <p>Order of the moving average part. This is the number of past error terms that will be included as features.</p> </li> <li> <p>m (int) \u2013 defaults to <code>1</code></p> <p>Season length used for extracting seasonal features. If you believe your data has a seasonal pattern, then set this accordingly. For instance, if the data seems to exhibit a yearly seasonality, and that your data is spaced by month, then you should set this to 12. Note that for this parameter to have any impact you should also set at least one of the <code>p</code>, <code>d</code>, and <code>q</code> parameters.</p> </li> <li> <p>sp (int) \u2013 defaults to <code>0</code></p> <p>Seasonal order of the autoregressive part. This is the number of past target values that will be included as features.</p> </li> <li> <p>sd (int) \u2013 defaults to <code>0</code></p> <p>Seasonal differencing order.</p> </li> <li> <p>sq (int) \u2013 defaults to <code>0</code></p> <p>Seasonal order of the moving average part. This is the number of past error terms that will be included as features.</p> </li> <li> <p>regressor (base.Regressor) \u2013 defaults to <code>None</code></p> <p>The online regression model to use. By default, a <code>preprocessing.StandardScaler</code> piped with a <code>linear_model.LinearRegression</code> will be used.</p> </li> </ul>"},{"location":"api/time-series/SNARIMAX/#attributes","title":"Attributes","text":"<ul> <li> <p>differencer (Differencer)</p> </li> <li> <p>y_trues (collections.deque)</p> <p>The <code>p</code> past target values.</p> </li> <li> <p>errors (collections.deque)</p> <p>The <code>q</code> past error values.</p> </li> </ul>"},{"location":"api/time-series/SNARIMAX/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import time_series\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; period = 12\n&gt;&gt;&gt; model = time_series.SNARIMAX(\n...     p=period,\n...     d=1,\n...     q=period,\n...     m=period,\n...     sd=1\n... )\n\n&gt;&gt;&gt; for t, (x, y) in enumerate(datasets.AirlinePassengers()):\n...     model = model.learn_one(y)\n\n&gt;&gt;&gt; horizon = 12\n&gt;&gt;&gt; future = [\n...     {'month': dt.date(year=1961, month=m, day=1)}\n...     for m in range(1, horizon + 1)\n... ]\n&gt;&gt;&gt; forecast = model.forecast(horizon=horizon)\n&gt;&gt;&gt; for x, y_pred in zip(future, forecast):\n...     print(x['month'], f'{y_pred:.3f}')\n1961-01-01 491.988\n1961-02-01 447.593\n1961-03-01 481.405\n1961-04-01 566.278\n1961-05-01 551.561\n1961-06-01 605.414\n1961-07-01 711.140\n1961-08-01 668.204\n1961-09-01 570.517\n1961-10-01 549.589\n1961-11-01 466.344\n1961-12-01 506.945\n</code></pre> <p>Classic ARIMA models learn solely on the time series values. You can also include features built at each step.</p> <pre><code>&gt;&gt;&gt; import calendar\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; def get_month_distances(x):\n...     return {\n...         calendar.month_name[month]: math.exp(-(x['month'].month - month) ** 2)\n...         for month in range(1, 13)\n...     }\n\n&gt;&gt;&gt; def get_ordinal_date(x):\n...     return {'ordinal_date': x['month'].toordinal()}\n\n&gt;&gt;&gt; extract_features = compose.TransformerUnion(\n...     get_ordinal_date,\n...     get_month_distances\n... )\n\n&gt;&gt;&gt; model = (\n...     extract_features |\n...     time_series.SNARIMAX(\n...         p=1,\n...         d=0,\n...         q=0,\n...         m=12,\n...         sp=3,\n...         sq=6,\n...         regressor=(\n...             preprocessing.StandardScaler() |\n...             linear_model.LinearRegression(\n...                 intercept_init=110,\n...                 optimizer=optim.SGD(0.01),\n...                 intercept_lr=0.3\n...             )\n...         )\n...     )\n... )\n\n&gt;&gt;&gt; for x, y in datasets.AirlinePassengers():\n...     model = model.learn_one(x, y)\n\n&gt;&gt;&gt; forecast = model.forecast(horizon=horizon)\n&gt;&gt;&gt; for x, y_pred in zip(future, forecast):\n...     print(x['month'], f'{y_pred:.3f}')\n1961-01-01 446.874\n1961-02-01 423.998\n1961-03-01 439.957\n1961-04-01 457.958\n1961-05-01 457.303\n1961-06-01 496.554\n1961-07-01 553.798\n1961-08-01 551.388\n1961-09-01 479.620\n1961-10-01 440.613\n1961-11-01 409.914\n1961-12-01 433.774\n</code></pre>"},{"location":"api/time-series/SNARIMAX/#methods","title":"Methods","text":"forecast <p>Makes forecast at each step of the given horizon.</p> <p>Parameters</p> <ul> <li>horizon     ('int')    </li> <li>xs     ('list[dict] | None')     \u2013 defaults to <code>None</code> </li> </ul>   learn_one <p>Updates the model.</p> <p>Parameters</p> <ul> <li>y     ('float')    </li> <li>x     ('dict')     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/time-series/SNARIMAX/#references","title":"References","text":"<ol> <li> <p>ARMA - Wikipedia \u21a9</p> </li> <li> <p>NARX - Wikipedia \u21a9</p> </li> <li> <p>ARIMA - Forecasting: Principles and Practice \u21a9</p> </li> <li> <p>Anava, O., Hazan, E., Mannor, S. and Shamir, O., 2013, June. Online learning for time series prediction. In Conference on learning theory (pp. 172-184) \u21a9</p> </li> </ol>"},{"location":"api/time-series/evaluate/","title":"evaluate","text":"<p>Evaluates the performance of a forecaster on a time series dataset.</p> <p>To understand why this method is useful, it's important to understand the difference between nowcasting and forecasting. Nowcasting is about predicting a value at the next time step. This can be seen as a special case of regression, where the value to predict is the value at the next time step. In this case, the <code>evaluate.progressive_val_score</code> function may be used to evaluate a model via progressive validation. </p> <p>Forecasting models can also be evaluated via progressive validation. This is the purpose of this function. At each time step <code>t</code>, the forecaster is asked to predict the values at <code>t + 1</code>, <code>t + 2</code>, ..., <code>t + horizon</code>. The performance at each time step is measured and returned.</p>"},{"location":"api/time-series/evaluate/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset ('base.typing.Dataset')</p> <p>A sequential time series.</p> </li> <li> <p>model ('time_series.base.Forecaster')</p> <p>A forecaster.</p> </li> <li> <p>metric ('metrics.base.RegressionMetric')</p> <p>A regression metric.</p> </li> <li> <p>horizon ('int')</p> </li> <li> <p>agg_func ('typing.Callable[[list[float]], float]') \u2013 defaults to <code>None</code></p> </li> <li> <p>grace_period ('int') \u2013 defaults to <code>None</code></p> <p>Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.</p> </li> </ul>"},{"location":"api/time-series/iter-evaluate/","title":"iter_evaluate","text":"<p>Evaluates the performance of a forecaster on a time series dataset and yields results.</p> <p>This does exactly the same as <code>evaluate.progressive_val_score</code>. The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results.</p>"},{"location":"api/time-series/iter-evaluate/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset ('base.typing.Dataset')</p> <p>A sequential time series.</p> </li> <li> <p>model ('time_series.base.Forecaster')</p> <p>A forecaster.</p> </li> <li> <p>metric ('metrics.base.RegressionMetric')</p> <p>A regression metric.</p> </li> <li> <p>horizon ('int')</p> </li> <li> <p>agg_func ('typing.Callable[[list[float]], float]') \u2013 defaults to <code>None</code></p> </li> <li> <p>grace_period ('int') \u2013 defaults to <code>None</code></p> <p>Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.</p> </li> </ul>"},{"location":"api/time-series/base/Forecaster/","title":"Forecaster","text":""},{"location":"api/time-series/base/Forecaster/#methods","title":"Methods","text":"forecast <p>Makes forecast at each step of the given horizon.</p> <p>Parameters</p> <ul> <li>horizon     ('int')    </li> <li>xs     ('list[dict] | None')     \u2013 defaults to <code>None</code> </li> </ul>   learn_one <p>Updates the model.</p> <p>Parameters</p> <ul> <li>y     ('float')    </li> <li>x     ('dict')     \u2013 defaults to <code>None</code> </li> </ul>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/","title":"ExtremelyFastDecisionTreeClassifier","text":"<p>Extremely Fast Decision Tree classifier.</p> <p>Also referred to as Hoeffding AnyTime Tree (HATT) classifier.</p>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>min_samples_reevaluate (int) \u2013 defaults to <code>20</code></p> <p>Number of instances a node should observe before reevaluating the best split.</p> </li> <li> <p>split_criterion (str) \u2013 defaults to <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold (int) \u2013 defaults to <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>100.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; gen = synth.Agrawal(classification_function=0, seed=42)\n&gt;&gt;&gt; # Take 1000 instances from the infinite data generator\n&gt;&gt;&gt; dataset = iter(gen.take(1000))\n\n&gt;&gt;&gt; model = tree.ExtremelyFastDecisionTreeClassifier(\n...     grace_period=100,\n...     delta=1e-5,\n...     nominal_attributes=['elevel', 'car', 'zipcode'],\n...     min_samples_reevaluate=100\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 87.29%\n</code></pre>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Optional[str]:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p>   draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     (int)     \u2013 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</li> </ul>   learn_one <p>Incrementally train the model</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#notes","title":"Notes","text":"<p>The Extremely Fast Decision Tree (EFDT) 1 constructs a tree incrementally. The EFDT seeks to select and deploy a split as soon as it is confident the split is useful, and then revisits that decision, replacing the split if it subsequently becomes evident that a better split is available. The EFDT learns rapidly from a stationary distribution and eventually it learns the asymptotic batch tree if the distribution from which the data are drawn is stationary.</p>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#references","title":"References","text":"<ol> <li> <p>C. Manapragada, G. Webb, and M. Salehi. Extremely Fast Decision Tree. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining (KDD '18). ACM, New York, NY, USA, 1953-1962. DOI: https://doi.org/10.1145/3219819.3220005\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/","title":"HoeffdingAdaptiveTreeClassifier","text":"<p>Hoeffding Adaptive Tree classifier.</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>split_criterion (str) \u2013 defaults to <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold (int) \u2013 defaults to <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>bootstrap_sampling (bool) \u2013 defaults to <code>True</code></p> <p>If True, perform bootstrap sampling in the leaf nodes.</p> </li> <li> <p>drift_window_threshold (int) \u2013 defaults to <code>300</code></p> <p>Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one.</p> </li> <li> <p>drift_detector (Optional[base.DriftDetector]) \u2013 defaults to <code>None</code></p> <p>The drift detector used to build the tree. If <code>None</code> then <code>drift.ADWIN</code> is used.</p> </li> <li> <p>switch_significance (float) \u2013 defaults to <code>0.05</code></p> <p>The significance level to assess whether alternate subtrees are significantly better than their main subtree counterparts.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>100.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_alternate_trees</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_pruned_alternate_trees</p> </li> <li> <p>n_switch_alternate_trees</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; gen = synth.ConceptDriftStream(stream=synth.SEA(seed=42, variant=0),\n...                                drift_stream=synth.SEA(seed=42, variant=1),\n...                                seed=1, position=500, width=50)\n&gt;&gt;&gt; # Take 1000 instances from the infinite data generator\n&gt;&gt;&gt; dataset = iter(gen.take(1000))\n\n&gt;&gt;&gt; model = tree.HoeffdingAdaptiveTreeClassifier(\n...     grace_period=100,\n...     delta=1e-5,\n...     leaf_prediction='nb',\n...     nb_threshold=10,\n...     seed=0\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 91.49%\n</code></pre>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Optional[str]:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p>   draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     (int)     \u2013 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</li> </ul>   learn_one <p>Train the model on instance x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#notes","title":"Notes","text":"<p>The Hoeffding Adaptive Tree 1 uses a drift detector to monitor performance of branches in the tree and to replace them with new branches when their accuracy decreases.</p> <p>The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance.</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#references","title":"References","text":"<ol> <li> <p>Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\"    In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin,    Heidelberg, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/","title":"HoeffdingAdaptiveTreeRegressor","text":"<p>Hoeffding Adaptive Tree regressor (HATR).</p> <p>This class implements a regression version of the Hoeffding Adaptive Tree Classifier. Hence, it also uses an ADWIN concept-drift detector instance at each decision node to monitor possible changes in the data distribution. If a drift is detected in a node, an alternate tree begins to be induced in the background. When enough information is gathered, HATR swaps the node where the change was detected by its alternate tree.</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>adaptive</code></p> <p>Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model (base.Regressor) \u2013 defaults to <code>None</code></p> <p>The regression model used to provide responses if <code>leaf_prediction='model'</code>. If not provided an instance of <code>river.linear_model.LinearRegression</code> with the default hyperparameters is used.</p> </li> <li> <p>model_selector_decay (float) \u2013 defaults to <code>0.95</code></p> <p>The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split (int) \u2013 defaults to <code>5</code></p> <p>The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>bootstrap_sampling (bool) \u2013 defaults to <code>True</code></p> <p>If True, perform bootstrap sampling in the leaf nodes.</p> </li> <li> <p>drift_window_threshold (int) \u2013 defaults to <code>300</code></p> <p>Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one.</p> </li> <li> <p>drift_detector (Optional[base.DriftDetector]) \u2013 defaults to <code>None</code></p> <p>The drift detector used to build the tree. If <code>None</code> then <code>drift.ADWIN</code> is used. Only detectors that support arbitrarily valued continuous data can be used for regression.</p> </li> <li> <p>switch_significance (float) \u2013 defaults to <code>0.05</code></p> <p>The significance level to assess whether alternate subtrees are significantly better than their main subtree counterparts.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>500.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed (int) \u2013 defaults to <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_alternate_trees</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_pruned_alternate_trees</p> </li> <li> <p>n_switch_alternate_trees</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     tree.HoeffdingAdaptiveTreeRegressor(\n...         grace_period=50,\n...         model_selector_decay=0.3,\n...         seed=0\n...     )\n... )\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 0.809874\n</code></pre>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Optional[str]:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p>   draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     (int)     \u2013 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</li> </ul>   learn_one <p>Train the tree model on sample x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the target value using one of the leaf prediction strategies.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>Predicted target value.</p>   to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#notes","title":"Notes","text":"<p>The Hoeffding Adaptive Tree 1 uses drift detectors to monitor performance of branches in the tree and to replace them with new branches when their accuracy decreases.</p> <p>The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance.</p> <p>To cope with ADWIN's requirements of bounded input data, HATR uses a novel error normalization strategy based on the empiral rule of Gaussian distributions. We assume the deviations of the predictions from the expected values follow a normal distribution. Hence, we subject these errors to a min-max normalization assuming that most of the data lies in the \\(\\left[-3\\sigma, 3\\sigma\\right]\\) range. These normalized errors are passed to the ADWIN instances. This is the same strategy used by Adaptive Random Forest Regressor.</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#references","title":"References","text":"<ol> <li> <p>Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingTreeClassifier/","title":"HoeffdingTreeClassifier","text":"<p>Hoeffding Tree or Very Fast Decision Tree classifier.</p>"},{"location":"api/tree/HoeffdingTreeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>split_criterion (str) \u2013 defaults to <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold (int) \u2013 defaults to <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>100.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.datasets import synth\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; gen = synth.Agrawal(classification_function=0, seed=42)\n&gt;&gt;&gt; # Take 1000 instances from the infinite data generator\n&gt;&gt;&gt; dataset = iter(gen.take(1000))\n\n&gt;&gt;&gt; model = tree.HoeffdingTreeClassifier(\n...     grace_period=100,\n...     delta=1e-5,\n...     nominal_attributes=['elevel', 'car', 'zipcode']\n... )\n\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 84.58%\n</code></pre>"},{"location":"api/tree/HoeffdingTreeClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Optional[str]:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p>   draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     (int)     \u2013 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</li> </ul>   learn_one <p>Train the model on instance x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p>"},{"location":"api/tree/HoeffdingTreeClassifier/#notes","title":"Notes","text":"<p>A Hoeffding Tree 1 is an incremental, anytime decision tree induction algorithm that is capable of learning from massive data streams, assuming that the distribution generating examples does not change over time. Hoeffding trees exploit the fact that a small sample can often be enough to choose an optimal splitting attribute. This idea is supported mathematically by the Hoeffding bound, which quantifies the number of observations (in our case, examples) needed to estimate some statistics within a prescribed precision (in our case, the goodness of an attribute).</p> <p>A theoretically appealing feature of Hoeffding Trees not shared by other incremental decision tree learners is that it has sound guarantees of performance. Using the Hoeffding bound one can show that its output is asymptotically nearly identical to that of a non-incremental learner using infinitely many examples. Implementation based on MOA 2.</p>"},{"location":"api/tree/HoeffdingTreeClassifier/#references","title":"References","text":"<ol> <li> <p>G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams.    In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press.\u00a0\u21a9</p> </li> <li> <p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer.    MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingTreeRegressor/","title":"HoeffdingTreeRegressor","text":"<p>Hoeffding Tree regressor.</p>"},{"location":"api/tree/HoeffdingTreeRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>adaptive</code></p> <p>Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model (base.Regressor) \u2013 defaults to <code>None</code></p> <p>The regression model used to provide responses if <code>leaf_prediction='model'</code>. If not provided an instance of <code>river.linear_model.LinearRegression</code> with the default hyperparameters is used.</p> </li> <li> <p>model_selector_decay (float) \u2013 defaults to <code>0.95</code></p> <p>The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split (int) \u2013 defaults to <code>5</code></p> <p>The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>500.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n&gt;&gt;&gt; from river import preprocessing\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n\n&gt;&gt;&gt; model = (\n...     preprocessing.StandardScaler() |\n...     tree.HoeffdingTreeRegressor(\n...         grace_period=100,\n...         model_selector_decay=0.9\n...     )\n... )\n\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 0.781781\n</code></pre>"},{"location":"api/tree/HoeffdingTreeRegressor/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Optional[str]:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p>   draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     (int)     \u2013 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</li> </ul>   learn_one <p>Train the tree model on sample x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the target value using one of the leaf prediction strategies.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>Predicted target value.</p>   to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p>"},{"location":"api/tree/HoeffdingTreeRegressor/#notes","title":"Notes","text":"<p>The Hoeffding Tree Regressor (HTR) is an adaptation of the incremental tree algorithm of the same name for classification. Similarly to its classification counterpart, HTR uses the Hoeffding bound to control its split decisions. Differently from the classification algorithm, HTR relies on calculating the reduction of variance in the target space to decide among the split candidates. The smallest the variance at its leaf nodes, the more homogeneous the partitions are. At its leaf nodes, HTR fits either linear models or uses the target average as the predictor.</p>"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/","title":"LabelCombinationHoeffdingTreeClassifier","text":"<p>Label Combination Hoeffding Tree for multi-label classification.</p> <p>Label combination transforms the problem from multi-label to multi-class. For each unique combination of labels it assigns a class and proceeds with training the hoeffding tree normally. </p> <p>The transformation is done by changing the label set which could be seen as a binary number to an int which will represent the class, and after the prediction the int is converted back to a binary number which is the predicted label-set.</p>"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>split_criterion (str) \u2013 defaults to <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold (int) \u2013 defaults to <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>100.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = iter(datasets.Music().take(200))\n&gt;&gt;&gt; model = tree.LabelCombinationHoeffdingTreeClassifier(\n...     delta=1e-5,\n...     grace_period=50\n... )\n\n&gt;&gt;&gt; metric = metrics.multioutput.MicroAverage(metrics.Accuracy())\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMicroAverage(Accuracy): 71.11%\n</code></pre>"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Optional[str]:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p>   draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     (int)     \u2013 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</li> </ul>   learn_one <p>Update the Multi-label Hoeffding Tree Classifier.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>sample_weight     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>self</p>   predict_one <p>Predict the labels of an instance.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     Predicted labels.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p>   to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p>"},{"location":"api/tree/SGTClassifier/","title":"SGTClassifier","text":"<p>Stochastic Gradient Tree1 for binary classification.</p> <p>Binary decision tree classifier that minimizes the binary cross-entropy to guide its growth. </p> <p>Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but data impurity-related heuristics.</p>"},{"location":"api/tree/SGTClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Define the significance level of the F-tests performed to decide upon creating splits or updating predictions.</p> </li> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Interval between split attempts or prediction updates.</p> </li> <li> <p>init_pred (float) \u2013 defaults to <code>0.0</code></p> <p>Initial value predicted by the tree.</p> </li> <li> <p>max_depth (Optional[int]) \u2013 defaults to <code>None</code></p> <p>The maximum depth the tree might reach. If set to <code>None</code>, the trees will grow indefinitely.</p> </li> <li> <p>lambda_value (float) \u2013 defaults to <code>0.1</code></p> <p>Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions.</p> </li> <li> <p>gamma (float) \u2013 defaults to <code>1.0</code></p> <p>Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring.</p> </li> <li> <p>nominal_attributes (Optional[List]) \u2013 defaults to <code>None</code></p> <p>List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric.</p> </li> <li> <p>feature_quantizer (river.tree.splitter.base.Quantizer) \u2013 defaults to <code>None</code></p> <p>The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of <code>tree.splitter.StaticQuantizer</code> (with default parameters) is used if this parameter is not set.</p> </li> </ul>"},{"location":"api/tree/SGTClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_node_updates</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_observations</p> </li> <li> <p>n_splits</p> </li> </ul>"},{"location":"api/tree/SGTClassifier/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = datasets.Phishing()\n&gt;&gt;&gt; model = tree.SGTClassifier(\n...     feature_quantizer=tree.splitter.StaticQuantizer(\n...         n_bins=32, warm_start=10\n...     )\n... )\n&gt;&gt;&gt; metric = metrics.Accuracy()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nAccuracy: 82.24%\n</code></pre>"},{"location":"api/tree/SGTClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Union[bool, str, int])    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Classifier:     self</p>   predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Union[bool, str, int, NoneType]:     The predicted label.</p>   predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Union[bool, str, int], float]:     A dictionary that associates a probability which each label.</p>"},{"location":"api/tree/SGTClassifier/#references","title":"References","text":"<ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/SGTRegressor/","title":"SGTRegressor","text":"<p>Stochastic Gradient Tree for regression.</p> <p>Incremental decision tree regressor that minimizes the mean square error to guide its growth. </p> <p>Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but a data impurity-related heuristic.</p>"},{"location":"api/tree/SGTRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Define the significance level of the F-tests performed to decide upon creating splits or updating predictions.</p> </li> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Interval between split attempts or prediction updates.</p> </li> <li> <p>init_pred (float) \u2013 defaults to <code>0.0</code></p> <p>Initial value predicted by the tree.</p> </li> <li> <p>max_depth (Optional[int]) \u2013 defaults to <code>None</code></p> <p>The maximum depth the tree might reach. If set to <code>None</code>, the trees will grow indefinitely.</p> </li> <li> <p>lambda_value (float) \u2013 defaults to <code>0.1</code></p> <p>Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions.</p> </li> <li> <p>gamma (float) \u2013 defaults to <code>1.0</code></p> <p>Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring.</p> </li> <li> <p>nominal_attributes (Optional[List]) \u2013 defaults to <code>None</code></p> <p>List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric.</p> </li> <li> <p>feature_quantizer (river.tree.splitter.base.Quantizer) \u2013 defaults to <code>None</code></p> <p>The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of <code>tree.splitter.StaticQuantizer</code> (with default parameters) is used if this parameter is not set.</p> </li> </ul>"},{"location":"api/tree/SGTRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_node_updates</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_observations</p> </li> <li> <p>n_splits</p> </li> </ul>"},{"location":"api/tree/SGTRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = datasets.TrumpApproval()\n&gt;&gt;&gt; model = tree.SGTRegressor(\n...     delta=0.01,\n...     lambda_value=0.01,\n...     grace_period=20,\n...     feature_quantizer=tree.splitter.DynamicQuantizer(std_prop=0.1)\n... )\n&gt;&gt;&gt; metric = metrics.MAE()\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, model, metric)\nMAE: 1.721818\n</code></pre>"},{"location":"api/tree/SGTRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (numbers.Number)    </li> <li>w     \u2013 defaults to <code>1.0</code> </li> </ul> <p>Returns</p> <p>Regressor:     self</p>   predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>Number:     The prediction.</p>"},{"location":"api/tree/SGTRegressor/#notes","title":"Notes","text":"<p>This implementation enhances the original proposal 1 by using an incremental strategy to discretize numerical features dynamically, rather than relying on a calibration set and parameterized number of bins. The strategy used is an adaptation of the Quantization Observer (QO) 2. Different bin size setting policies are available for selection. They directly related to number of split candidates the tree is going to explore, and thus, how accurate its split decisions are going to be. Besides, the number of stored bins per feature is directly related to the tree's memory usage and runtime.</p>"},{"location":"api/tree/SGTRegressor/#references","title":"References","text":"<ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> <li> <p>Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/iSOUPTreeRegressor/","title":"iSOUPTreeRegressor","text":"<p>Incremental Structured Output Prediction Tree (iSOUP-Tree) for multi-target regression.</p> <p>This is an implementation of the iSOUP-Tree proposed by A. Osojnik, P. Panov, and S. D\u017eeroski 1.</p>"},{"location":"api/tree/iSOUPTreeRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period (int) \u2013 defaults to <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth (int) \u2013 defaults to <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</p> </li> <li> <p>delta (float) \u2013 defaults to <code>1e-07</code></p> <p>Allowed error in split decision, a value closer to 0 takes longer to decide.</p> </li> <li> <p>tau (float) \u2013 defaults to <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction (str) \u2013 defaults to <code>adaptive</code></p> <p>Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model (Union[base.Regressor, Dict]) \u2013 defaults to <code>None</code></p> <p>The regression model(s) used to provide responses if <code>leaf_prediction='model'</code>. It can be either a regressor (in which case it is going to be replicated to all the targets) or a dictionary whose keys are target identifiers, and the values are instances of <code>river.base.Regressor.</code> If not provided, instances of <code>river.linear_model.LinearRegression</code> with the default hyperparameters are used for all the targets. If a dictionary is passed and not all target models are specified, copies from the first model match in the dictionary will be used to the remaining targets.</p> </li> <li> <p>model_selector_decay (float) \u2013 defaults to <code>0.95</code></p> <p>The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes (list) \u2013 defaults to <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter (river.tree.splitter.base.Splitter) \u2013 defaults to <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split (int) \u2013 defaults to <code>5</code></p> <p>The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>binary_split (bool) \u2013 defaults to <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size (float) \u2013 defaults to <code>500.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period (int) \u2013 defaults to <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management (bool) \u2013 defaults to <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs (bool) \u2013 defaults to <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune (bool) \u2013 defaults to <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/iSOUPTreeRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/iSOUPTreeRegressor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import numbers\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import evaluate\n&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import metrics\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import tree\n\n&gt;&gt;&gt; dataset = datasets.SolarFlare()\n\n&gt;&gt;&gt; num = compose.SelectType(numbers.Number) | preprocessing.MinMaxScaler()\n&gt;&gt;&gt; cat = compose.SelectType(str) | preprocessing.OneHotEncoder(sparse=False)\n\n&gt;&gt;&gt; model = tree.iSOUPTreeRegressor(\n...     grace_period=100,\n...     leaf_prediction='model',\n...     leaf_model={\n...         'c-class-flares': linear_model.LinearRegression(l2=0.02),\n...         'm-class-flares': linear_model.PARegressor(),\n...         'x-class-flares': linear_model.LinearRegression(l2=0.1)\n...     }\n... )\n\n&gt;&gt;&gt; pipeline = (num + cat) | model\n&gt;&gt;&gt; metric = metrics.multioutput.MicroAverage(metrics.MAE())\n\n&gt;&gt;&gt; evaluate.progressive_val_score(dataset, pipeline, metric)\nMicroAverage(MAE): 0.426177\n</code></pre>"},{"location":"api/tree/iSOUPTreeRegressor/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Optional[str]:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p>   draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     (int)     \u2013 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow indefinitely.</li> </ul>   learn_one <p>Incrementally train the model with one sample.</p> <p>Training tasks:  * If the tree is empty, create a leaf node as the root. * If the tree is already initialized, find the corresponding leaf for   the instance and update the leaf node statistics. * If growth is allowed and the number of instances that the leaf has   observed between split attempts exceed the grace period then attempt   to split.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> <li>y     (Dict[Hashable, numbers.Number])    </li> <li>sample_weight     (float)     \u2013 defaults to <code>1.0</code> </li> </ul>   predict_one <p>Predict the target values for a given instance.</p> <p>Parameters</p> <ul> <li>x     (dict)    </li> </ul> <p>Returns</p> <p>typing.Dict[typing.Hashable, numbers.Number]:     dict</p>   to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p>"},{"location":"api/tree/iSOUPTreeRegressor/#references","title":"References","text":"<ol> <li> <p>Alja\u017e Osojnik, Pan\u010de Panov, and Sa\u0161o D\u017eeroski. \"Tree-based methods for online multi-target regression.\" Journal of Intelligent Information Systems 50.2 (2018): 315-339.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/base/Branch/","title":"Branch","text":"<p>A generic tree branch.</p>"},{"location":"api/tree/base/Branch/#parameters","title":"Parameters","text":"<ul> <li> <p>children</p> <p>Child branches and/or leaves.</p> </li> </ul>"},{"location":"api/tree/base/Branch/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> <p>Distance to the deepest descendant.</p> </li> <li> <p>n_branches</p> <p>Number of branches, including thyself.</p> </li> <li> <p>n_leaves</p> <p>Number of leaves.</p> </li> <li> <p>n_nodes</p> <p>Number of descendants, including thyself.</p> </li> <li> <p>repr_split</p> <p>String representation of the split.</p> </li> </ul>"},{"location":"api/tree/base/Branch/#methods","title":"Methods","text":"iter_bfs <p>Iterate over nodes in breadth-first order.</p>   iter_branches <p>Iterate over branches in depth-first order.</p>   iter_dfs <p>Iterate over nodes in depth-first order.</p>   iter_edges <p>Iterate over edges in depth-first order.</p>   iter_leaves <p>Iterate over leaves from the left-most one to the right-most one.</p>   most_common_path <p>Return a tuple with the branch index and the child node related to the most traversed path.</p> <p>Used in case the split feature is missing from an instance.</p>   next <p>Move to the next node down the tree.</p> <p>Parameters</p> <ul> <li>x </li> </ul>   to_dataframe <p>Build a DataFrame containing one record for each node.</p>   traverse <p>Return the leaf corresponding to the given input.</p> <p>Parameters</p> <ul> <li>x </li> <li>until_leaf     \u2013 defaults to <code>True</code> </li> </ul>   walk <p>Iterate over the nodes of the path induced by x.</p> <p>Parameters</p> <ul> <li>x </li> <li>until_leaf     \u2013 defaults to <code>True</code> </li> </ul>"},{"location":"api/tree/base/Leaf/","title":"Leaf","text":"<p>A generic tree node.</p>"},{"location":"api/tree/base/Leaf/#parameters","title":"Parameters","text":"<ul> <li> <p>kwargs</p> <p>Each provided keyword argument is stored in the leaf as an attribute.</p> </li> </ul>"},{"location":"api/tree/base/Leaf/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> </ul>"},{"location":"api/tree/base/Leaf/#methods","title":"Methods","text":"iter_branches   iter_dfs   iter_edges   iter_leaves   walk"},{"location":"api/tree/splitter/DynamicQuantizer/","title":"DynamicQuantizer","text":"<p>Adapted version of the Quantizer Observer (QO)1 that is applied to Stochastic Gradient Trees (SGT).</p> <p>This feature quantizer starts by partitioning the inputs using the passed <code>radius</code> value. As more splits are created in the SGTs, new feature quantizers will use <code>std * std_prop</code> as the quantization radius. In the expression, <code>std</code> represents the standard deviation of the input data, which is calculated incrementally.</p>"},{"location":"api/tree/splitter/DynamicQuantizer/#parameters","title":"Parameters","text":"<ul> <li> <p>radius (float) \u2013 defaults to <code>0.5</code></p> <p>The initial quantization radius.</p> </li> <li> <p>std_prop (float) \u2013 defaults to <code>0.25</code></p> <p>The proportion of the standard deviation that is going to be used to define the radius value for new quantizer instances following the initial one.</p> </li> </ul>"},{"location":"api/tree/splitter/DynamicQuantizer/#methods","title":"Methods","text":"update"},{"location":"api/tree/splitter/DynamicQuantizer/#references","title":"References","text":"<ol> <li> <p>Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/EBSTSplitter/","title":"EBSTSplitter","text":"<p>iSOUP-Tree's Extended Binary Search Tree (E-BST).</p> <p>This class implements the Extended Binary Search Tree1 (E-BST) structure, using the variant employed by Osojnik et al.2 in the iSOUP-Tree algorithm. This structure is employed to observe the target space distribution. </p> <p>Proposed along with Fast Incremental Model Tree with Drift Detection1 (FIMT-DD), E-BST was the first attribute observer (AO) proposed for incremental Hoeffding Tree regressors. This AO works by storing all observations between splits in an extended binary search tree structure. E-BST stores the input feature realizations and statistics of the target(s) that enable calculating the split heuristic at any time. To alleviate time and memory costs, E-BST implements a memory management routine, where the worst split candidates are pruned from the binary tree. </p> <p>In this variant, only the left branch statistics are stored and the complete split-enabling statistics are calculated with an in-order traversal of the binary search tree.</p>"},{"location":"api/tree/splitter/EBSTSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/EBSTSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     (river.tree.split_criterion.base.SplitCriterion)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> <li>att_idx     (Hashable)    </li> <li>binary_only     (bool)     \u2013 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p>   cond_proba <p>Not implemented in regression splitters.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int])    </li> </ul>   remove_bad_splits <p>Remove bad splits.</p> <p>Based on FIMT-DD's 1 procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed).  Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound (\\(\\epsilon\\)) are used to decide upon creating a split. A split occurs when \\(r &lt; 1 - \\epsilon\\). A split candidate, with merit \\(m_i\\), is considered badr if \\(m_i / m_1 &lt; r - 2\\epsilon\\). The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\), then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed.  To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in 1.</p> <p>Parameters</p> <ul> <li>criterion </li> <li>last_check_ratio     (float)    </li> <li>last_check_vr     (float)    </li> <li>last_check_e     (float)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> </ul>   update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int, numbers.Number])    </li> <li>sample_weight     (float)    </li> </ul>"},{"location":"api/tree/splitter/EBSTSplitter/#references","title":"References","text":"<ol> <li> <p>Ikonomovska, E., Gama, J., &amp; D\u017eeroski, S. (2011). Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), 128-168.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Osojnik, Alja\u017e. 2017. Structured output prediction on Data Streams (Doctoral Dissertation) \u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/ExhaustiveSplitter/","title":"ExhaustiveSplitter","text":"<p>Numeric attribute observer for classification tasks that is based on a Binary Search Tree.</p> <p>This algorithm1 is also referred to as exhaustive attribute observer, since it ends up storing all the observations between split attempts2. </p> <p>This splitter cannot perform probability density estimations, so it does not work well when coupled with tree leaves using naive bayes models.</p>"},{"location":"api/tree/splitter/ExhaustiveSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/ExhaustiveSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     (river.tree.split_criterion.base.SplitCriterion)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> <li>att_idx     (Hashable)    </li> <li>binary_only     (bool)    </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p>   cond_proba <p>The underlying data structure used to monitor the input does not allow probability density estimations. Hence, it always returns zero for any given input.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int])    </li> </ul>   update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int, numbers.Number])    </li> <li>sample_weight     (float)    </li> </ul>"},{"location":"api/tree/splitter/ExhaustiveSplitter/#references","title":"References","text":"<ol> <li> <p>Domingos, P. and Hulten, G., 2000, August. Mining high-speed data streams. In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 71-80).\u00a0\u21a9</p> </li> <li> <p>Pfahringer, B., Holmes, G. and Kirkby, R., 2008, May. Handling numeric attributes in hoeffding trees. In Pacific-Asia Conference on Knowledge Discovery and Data Mining (pp. 296-307). Springer, Berlin, Heidelberg.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/GaussianSplitter/","title":"GaussianSplitter","text":"<p>Numeric attribute observer for classification tasks that is based on Gaussian estimators.</p> <p>The distribution of each class is approximated using a Gaussian distribution. Hence, the probability density function can be easily calculated.</p>"},{"location":"api/tree/splitter/GaussianSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>n_splits (int) \u2013 defaults to <code>10</code></p> <p>The number of partitions to consider when querying for split candidates.</p> </li> </ul>"},{"location":"api/tree/splitter/GaussianSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/GaussianSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     (river.tree.split_criterion.base.SplitCriterion)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> <li>att_idx     (Hashable)    </li> <li>binary_only     (bool)    </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p>   cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p>   update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int, numbers.Number])    </li> <li>sample_weight     (float)    </li> </ul>"},{"location":"api/tree/splitter/HistogramSplitter/","title":"HistogramSplitter","text":"<p>Numeric attribute observer for classification tasks that discretizes features using histograms.</p>"},{"location":"api/tree/splitter/HistogramSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>n_bins (int) \u2013 defaults to <code>256</code></p> <p>The maximum number of bins in the histogram.</p> </li> <li> <p>n_splits (int) \u2013 defaults to <code>32</code></p> <p>The number of split points to evaluate when querying for the best split candidate.</p> </li> </ul>"},{"location":"api/tree/splitter/HistogramSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/HistogramSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     (river.tree.split_criterion.base.SplitCriterion)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> <li>att_idx     (Hashable)    </li> <li>binary_only     (bool)    </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p>   cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p>   update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int, numbers.Number])    </li> <li>sample_weight     (float)    </li> </ul>"},{"location":"api/tree/splitter/QOSplitter/","title":"QOSplitter","text":"<p>Quantization observer (QO).</p> <p>This splitter utilizes a hash-based quantization algorithm to keep track of the target statistics and evaluate split candidates. QO, relies on the radius parameter to define discretization intervals for each incoming feature. Split candidates are defined as the midpoints between two consecutive hash slots. Both binary splits and multi-way splits can be created by this attribute observer. This class implements the algorithm described in 1. </p> <p>The smaller the quantization radius, the more hash slots will be created to accommodate the discretized data. Hence, both the running time and memory consumption increase, but the resulting splits ought to be closer to the ones obtained by a batch exhaustive approach. On the other hand, if the radius is too large, fewer slots will be created, less memory and running time will be required, but at the cost of coarse split suggestions. </p> <p>QO assumes that all features have the same range. It is always advised to scale the features to apply this splitter. That can be done using the <code>preprocessing</code> module. A good \"rule of thumb\" is to scale data using <code>preprocessing.StandardScaler</code> and define the radius as a proportion of the features' standard deviation. For instance, the default radius value would correspond to one quarter of the normalized features' standard deviation (since the scaled data has zero mean and unit variance). If the features come from normal distributions, by following the empirical rule, roughly <code>32</code> hash slots will be created.</p>"},{"location":"api/tree/splitter/QOSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>radius ('float') \u2013 defaults to <code>0.25</code></p> <p>The quantization radius. QO discretizes the incoming feature in intervals of equal length that are defined by this parameter.</p> </li> <li> <p>allow_multiway_splits \u2013 defaults to <code>False</code></p> <p>Whether or not allow that multiway splits are evaluated. Numeric multi-way splits use the same quantization strategy of QO to create multiple tree branches. The same quantization radius is used, and each stored slot represents the split enabling statistics of one branch.</p> </li> </ul>"},{"location":"api/tree/splitter/QOSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/QOSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     (river.tree.split_criterion.base.SplitCriterion)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> <li>att_idx     (Hashable)    </li> <li>binary_only     (bool)     \u2013 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p>   cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p>   update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int, numbers.Number])    </li> <li>sample_weight     (float)    </li> </ul>"},{"location":"api/tree/splitter/QOSplitter/#references","title":"References","text":"<ol> <li> <p>Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/Quantizer/","title":"Quantizer","text":"<p>Base class for the feature quantizers used in Stochastic Gradient Trees1.</p>"},{"location":"api/tree/splitter/Quantizer/#methods","title":"Methods","text":"update"},{"location":"api/tree/splitter/Quantizer/#references","title":"References","text":"<ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/Splitter/","title":"Splitter","text":"<p>Base class for the tree splitters.</p> <p>Each Attribute Observer (AO) or Splitter monitors one input feature and finds the best split point for this attribute. AOs can also perform other tasks related to the monitored feature, such as estimating its probability density function (classification case). </p> <p>This class should not be instantiated, as none of its methods are implemented.</p>"},{"location":"api/tree/splitter/Splitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/Splitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     (river.tree.split_criterion.base.SplitCriterion)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> <li>att_idx     (Hashable)    </li> <li>binary_only     (bool)    </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p>   cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int])    </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p>   update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int, numbers.Number])    </li> <li>sample_weight     (float)    </li> </ul>"},{"location":"api/tree/splitter/StaticQuantizer/","title":"StaticQuantizer","text":"<p>Quantization strategy originally used in Stochastic Gradient Trees (SGT)1.</p> <p>Firstly, a buffer of size <code>warm_start</code> is stored. The data stored in the buffer is then used to quantize the input feature into <code>n_bins</code> intervals. These intervals will be replicated to every new quantizer. Feature values lying outside of the limits defined by the initial buffer will be mapped to the head or tail of the list of intervals.</p>"},{"location":"api/tree/splitter/StaticQuantizer/#parameters","title":"Parameters","text":"<ul> <li> <p>n_bins (int) \u2013 defaults to <code>64</code></p> <p>The number of bins (intervals) to divide the input feature.</p> </li> <li> <p>warm_start (int) \u2013 defaults to <code>100</code></p> <p>The number of observations used to initialize the quantization intervals.</p> </li> <li> <p>buckets (List) \u2013 defaults to <code>None</code></p> <p>This parameter is only used internally by the quantizer, so it must not be set. Once the intervals are defined, new instances of this quantizer will receive the quantization information via this parameter.</p> </li> </ul>"},{"location":"api/tree/splitter/StaticQuantizer/#methods","title":"Methods","text":"update"},{"location":"api/tree/splitter/StaticQuantizer/#references","title":"References","text":"<ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/TEBSTSplitter/","title":"TEBSTSplitter","text":"<p>Truncated E-BST.</p> <p>Variation of E-BST that rounds the incoming feature values before passing them to the binary search tree (BST). By doing so, the attribute observer might reduce its processing time and memory usage since small variations in the input values will end up being mapped to the same BST node.</p>"},{"location":"api/tree/splitter/TEBSTSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>digits (int) \u2013 defaults to <code>1</code></p> <p>The number of decimal places used to round the input feature values.</p> </li> </ul>"},{"location":"api/tree/splitter/TEBSTSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/TEBSTSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     (river.tree.split_criterion.base.SplitCriterion)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> <li>att_idx     (Hashable)    </li> <li>binary_only     (bool)     \u2013 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p>   cond_proba <p>Not implemented in regression splitters.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int])    </li> </ul>   remove_bad_splits <p>Remove bad splits.</p> <p>Based on FIMT-DD's [^1] procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed).  Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound (\\(\\epsilon\\)) are used to decide upon creating a split. A split occurs when \\(r &lt; 1 - \\epsilon\\). A split candidate, with merit \\(m_i\\), is considered badr if \\(m_i / m_1 &lt; r - 2\\epsilon\\). The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\), then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed.  To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in [^1].</p> <p>Parameters</p> <ul> <li>criterion </li> <li>last_check_ratio     (float)    </li> <li>last_check_vr     (float)    </li> <li>last_check_e     (float)    </li> <li>pre_split_dist     (Union[List, Dict])    </li> </ul>   update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     (Union[bool, str, int, numbers.Number])    </li> <li>sample_weight     (float)    </li> </ul>"},{"location":"api/utils/Rolling/","title":"Rolling","text":"<p>A generic wrapper for performing rolling computations.</p> <p>This can be wrapped around any object which implements both an <code>update</code> and a <code>revert</code> method. Inputs to <code>update</code> are stored in a queue. Elements of the queue are popped when the window is full.</p>"},{"location":"api/utils/Rolling/#parameters","title":"Parameters","text":"<ul> <li> <p>obj (river.utils.rolling.Rollable)</p> <p>An object that implements both an <code>update</code> method and a <code>rolling</code>method.</p> </li> <li> <p>window_size (int)</p> <p>Size of the window.</p> </li> </ul>"},{"location":"api/utils/Rolling/#attributes","title":"Attributes","text":"<ul> <li>window_size</li> </ul>"},{"location":"api/utils/Rolling/#examples","title":"Examples","text":"<p>For instance, here is how you can compute a rolling average over a window of size 3:</p> <pre><code>&gt;&gt;&gt; from river import stats, utils\n\n&gt;&gt;&gt; X = [1, 3, 5, 7]\n&gt;&gt;&gt; rmean = utils.Rolling(stats.Mean(), window_size=3)\n\n&gt;&gt;&gt; for x in X:\n...     print(rmean.update(x).get())\n1.0\n2.0\n3.0\n5.0\n</code></pre>"},{"location":"api/utils/Rolling/#methods","title":"Methods","text":"update"},{"location":"api/utils/SortedWindow/","title":"SortedWindow","text":"<p>Sorted running window data structure.</p>"},{"location":"api/utils/SortedWindow/#parameters","title":"Parameters","text":"<ul> <li> <p>size (int)</p> <p>Size of the window to compute the rolling quantile.</p> </li> </ul>"},{"location":"api/utils/SortedWindow/#attributes","title":"Attributes","text":"<ul> <li>size</li> </ul>"},{"location":"api/utils/SortedWindow/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; window = utils.SortedWindow(size=3)\n\n&gt;&gt;&gt; for i in reversed(range(9)):\n...     print(window.append(i))\n[8]\n[7, 8]\n[6, 7, 8]\n[5, 6, 7]\n[4, 5, 6]\n[3, 4, 5]\n[2, 3, 4]\n[1, 2, 3]\n[0, 1, 2]\n</code></pre>"},{"location":"api/utils/SortedWindow/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>x </li> </ul>   clear <p>S.clear() -&gt; None -- remove all items from S</p>   copy   count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul>   extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul>   index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul>   insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul>   pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2013 defaults to <code>-1</code> </li> </ul>   remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul>   reverse <p>S.reverse() -- reverse IN PLACE</p>   sort"},{"location":"api/utils/SortedWindow/#references","title":"References","text":"<ol> <li> <p>Left sorted inserts in Python \u21a9</p> </li> </ol>"},{"location":"api/utils/TimeRolling/","title":"TimeRolling","text":"<p>A generic wrapper for performing time rolling computations.</p> <p>This can be wrapped around any object which implements both an <code>update</code> and a <code>revert</code> method. Inputs to <code>update</code> are stored in a queue. Elements of the queue are popped when they are too old.</p>"},{"location":"api/utils/TimeRolling/#parameters","title":"Parameters","text":"<ul> <li> <p>obj (river.utils.rolling.Rollable)</p> <p>An object that implements both an <code>update</code> method and a <code>rolling</code>method.</p> </li> <li> <p>period (datetime.timedelta)</p> <p>A duration of time, expressed as a <code>datetime.timedelta</code>.</p> </li> </ul>"},{"location":"api/utils/TimeRolling/#examples","title":"Examples","text":"<p>For instance, here is how you can compute a rolling average over a period of 3 days:</p> <pre><code>&gt;&gt;&gt; from river import stats, utils\n\n&gt;&gt;&gt; X = {\n...     dt.datetime(2019, 1, 1): 1,\n...     dt.datetime(2019, 1, 2): 5,\n...     dt.datetime(2019, 1, 3): 9,\n...     dt.datetime(2019, 1, 4): 13\n... }\n\n&gt;&gt;&gt; rmean = utils.TimeRolling(stats.Mean(), period=dt.timedelta(days=3))\n&gt;&gt;&gt; for t, x in X.items():\n...     print(rmean.update(x, t=t).get())\n1.0\n3.0\n5.0\n9.0\n</code></pre>"},{"location":"api/utils/TimeRolling/#methods","title":"Methods","text":"update"},{"location":"api/utils/VectorDict/","title":"VectorDict","text":""},{"location":"api/utils/VectorDict/#methods","title":"Methods","text":"abs   clear   get <p>Parameters</p> <ul> <li>key </li> <li>args </li> <li>kwargs </li> </ul>   items   keys   max   maximum <p>Parameters</p> <ul> <li>other </li> </ul>   min   minimum <p>Parameters</p> <ul> <li>other </li> </ul>   pop <p>Parameters</p> <ul> <li>args </li> <li>kwargs </li> </ul>   popitem   setdefault <p>Parameters</p> <ul> <li>key </li> <li>args </li> <li>kwargs </li> </ul>   to_dict   to_numpy <p>Parameters</p> <ul> <li>fields </li> </ul>   update <p>Parameters</p> <ul> <li>args </li> <li>kwargs </li> </ul>   values   with_mask <p>Parameters</p> <ul> <li>mask </li> <li>copy </li> </ul>"},{"location":"api/utils/dict2numpy/","title":"dict2numpy","text":"<p>Convert a dictionary containing data to a numpy array.</p> <p>There is not restriction to the type of keys in <code>data</code>, but values must be strictly numeric. To make sure random permutations of the features do not impact on the learning algorithms, keys are first converted to strings and then sorted prior to the conversion.</p>"},{"location":"api/utils/dict2numpy/#parameters","title":"Parameters","text":"<ul> <li> <p>data</p> <p>A dictionary whose keys represent input attributes and the values represent their observed contents.</p> </li> </ul>"},{"location":"api/utils/dict2numpy/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river.utils import dict2numpy\n&gt;&gt;&gt; dict2numpy({'a': 1, 'b': 2, 3: 3})\narray([3, 1, 2])\n</code></pre>"},{"location":"api/utils/expand-param-grid/","title":"expand_param_grid","text":"<p>Expands a grid of parameters.</p> <p>This method can be used to generate a list of model parametrizations from a dictionary where each parameter is associated with a list of possible parameters. In other words, it expands a grid of parameters. </p> <p>Typically, this method can be used to create copies of a given model with different parameter choices. The models can then be used as part of a model selection process, such as a <code>selection.SuccessiveHalvingClassifier</code> or a <code>selection.EWARegressor</code>. </p> <p>The syntax for the parameter grid is quite flexible. It allows nesting parameters and can therefore be used to generate parameters for a pipeline.</p>"},{"location":"api/utils/expand-param-grid/#parameters","title":"Parameters","text":"<ul> <li> <p>model (base.Estimator)</p> </li> <li> <p>grid (dict)</p> <p>The grid of parameters to expand. The provided dictionary can be nested. The only requirement is that the values at the leaves need to be lists.</p> </li> </ul>"},{"location":"api/utils/expand-param-grid/#examples","title":"Examples","text":"<p>As an initial example, we can expand a grid of parameters for a single model.</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n&gt;&gt;&gt; from river import optim\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; model = linear_model.LinearRegression()\n\n&gt;&gt;&gt; grid = {'optimizer': [optim.SGD(.1), optim.SGD(.01), optim.SGD(.001)]}\n&gt;&gt;&gt; models = utils.expand_param_grid(model, grid)\n&gt;&gt;&gt; len(models)\n3\n\n&gt;&gt;&gt; models[0]\nLinearRegression (\n  optimizer=SGD (\n    lr=Constant (\n      learning_rate=0.1\n    )\n  )\n  loss=Squared ()\n  l2=0.\n  l1=0.\n  intercept_init=0.\n  intercept_lr=Constant (\n    learning_rate=0.01\n  )\n  clip_gradient=1e+12\n  initializer=Zeros ()\n)\n</code></pre> <p>You can expand parameters for multiple choices like so:</p> <pre><code>&gt;&gt;&gt; grid = {\n...     'optimizer': [\n...         (optim.SGD, {'lr': [.1, .01, .001]}),\n...         (optim.Adam, {'lr': [.1, .01, .01]})\n...     ]\n... }\n&gt;&gt;&gt; models = utils.expand_param_grid(model, grid)\n&gt;&gt;&gt; len(models)\n6\n</code></pre> <p>You may specify a grid of parameters for a pipeline via nesting:</p> <pre><code>&gt;&gt;&gt; from river import feature_extraction\n\n&gt;&gt;&gt; model = (\n...     feature_extraction.BagOfWords() |\n...     linear_model.LinearRegression()\n... )\n\n&gt;&gt;&gt; grid = {\n...     'BagOfWords': {\n...         'strip_accents': [False, True]\n...     },\n...     'LinearRegression': {\n...         'optimizer': [\n...             (optim.SGD, {'lr': [.1, .01]}),\n...             (optim.Adam, {'lr': [.1, .01]})\n...         ]\n...     }\n... }\n\n&gt;&gt;&gt; models = utils.expand_param_grid(model, grid)\n&gt;&gt;&gt; len(models)\n8\n</code></pre>"},{"location":"api/utils/log-method-calls/","title":"log_method_calls","text":"<p>A context manager to log method calls.</p> <p>All method calls will be logged by default. This behavior can be overriden by passing filtering functions.</p>"},{"location":"api/utils/log-method-calls/#parameters","title":"Parameters","text":"<ul> <li> <p>class_condition (Callable[[Any], bool]) \u2013 defaults to <code>None</code></p> <p>A function which determines if a class should be logged or not.</p> </li> <li> <p>method_condition (Callable[[Any], bool]) \u2013 defaults to <code>None</code></p> <p>A function which determines if a method should be logged or not.</p> </li> </ul>"},{"location":"api/utils/log-method-calls/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; import logging\n&gt;&gt;&gt; from river import anomaly\n&gt;&gt;&gt; from river import compose\n&gt;&gt;&gt; from river import datasets\n&gt;&gt;&gt; from river import preprocessing\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; model = compose.Pipeline(\n...     preprocessing.MinMaxScaler(),\n...     anomaly.HalfSpaceTrees(seed=42)\n... )\n\n&gt;&gt;&gt; class_condition = lambda x: x.__class__.__name__ in ('MinMaxScaler', 'HalfSpaceTrees')\n\n&gt;&gt;&gt; logger = logging.getLogger()\n&gt;&gt;&gt; logger.setLevel(logging.DEBUG)\n\n&gt;&gt;&gt; logs = io.StringIO()\n&gt;&gt;&gt; sh = logging.StreamHandler(logs)\n&gt;&gt;&gt; sh.setLevel(logging.DEBUG)\n&gt;&gt;&gt; logger.addHandler(sh)\n\n&gt;&gt;&gt; with utils.log_method_calls(class_condition):\n...     for x, y in datasets.CreditCard().take(1):\n...         score = model.score_one(x)\n...         model = model.learn_one(x)\n\n&gt;&gt;&gt; print(logs.getvalue())\nMinMaxScaler.learn_one\nMinMaxScaler.transform_one\nHalfSpaceTrees.score_one\nMinMaxScaler.transform_one\nHalfSpaceTrees.learn_one\n\n&gt;&gt;&gt; logs.close()\n</code></pre>"},{"location":"api/utils/numpy2dict/","title":"numpy2dict","text":"<p>Convert a numpy array to a dictionary.</p>"},{"location":"api/utils/numpy2dict/#parameters","title":"Parameters","text":"<ul> <li> <p>data (numpy.ndarray)</p> <p>An one-dimensional numpy.array.</p> </li> </ul>"},{"location":"api/utils/numpy2dict/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from river.utils import numpy2dict\n&gt;&gt;&gt; numpy2dict(np.array([1.0, 2.0, 3.0]))\n{0: 1.0, 1: 2.0, 2: 3.0}\n</code></pre>"},{"location":"api/utils/math/argmax/","title":"argmax","text":"<p>Argmax function.</p>"},{"location":"api/utils/math/argmax/#parameters","title":"Parameters","text":"<ul> <li>lst (list)</li> </ul>"},{"location":"api/utils/math/chain-dot/","title":"chain_dot","text":"<p>Returns the dot product of multiple vectors represented as dicts.</p>"},{"location":"api/utils/math/chain-dot/#parameters","title":"Parameters","text":"<ul> <li>xs</li> </ul>"},{"location":"api/utils/math/chain-dot/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; x = {'x0': 1, 'x1': 2, 'x2': 1}\n&gt;&gt;&gt; y = {'x1': 21, 'x2': 3}\n&gt;&gt;&gt; z = {'x1': 2, 'x2': 1 / 3}\n\n&gt;&gt;&gt; utils.math.chain_dot(x, y, z)\n85.0\n</code></pre>"},{"location":"api/utils/math/clamp/","title":"clamp","text":"<p>Clamp a number.</p> <p>This is a synonym of clipping.</p>"},{"location":"api/utils/math/clamp/#parameters","title":"Parameters","text":"<ul> <li> <p>x (float)</p> </li> <li> <p>minimum \u2013 defaults to <code>0.0</code></p> </li> <li> <p>maximum \u2013 defaults to <code>1.0</code></p> </li> </ul>"},{"location":"api/utils/math/dot/","title":"dot","text":"<p>Returns the dot product of two vectors represented as dicts.</p>"},{"location":"api/utils/math/dot/#parameters","title":"Parameters","text":"<ul> <li> <p>x (dict)</p> </li> <li> <p>y (dict)</p> </li> </ul>"},{"location":"api/utils/math/dot/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; x = {'x0': 1, 'x1': 2}\n&gt;&gt;&gt; y = {'x1': 21, 'x2': 3}\n\n&gt;&gt;&gt; utils.math.dot(x, y)\n42\n</code></pre>"},{"location":"api/utils/math/dotvecmat/","title":"dotvecmat","text":"<p>Vector times matrix from left side, i.e. transpose(x)A.</p>"},{"location":"api/utils/math/dotvecmat/#parameters","title":"Parameters","text":"<ul> <li> <p>x</p> </li> <li> <p>A</p> </li> </ul>"},{"location":"api/utils/math/dotvecmat/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; x = {0: 4, 1: 5}\n\n&gt;&gt;&gt; A = {\n...     (0, 0): 0, (0, 1): 1,\n...     (1, 0): 2, (1, 1): 3\n... }\n\n&gt;&gt;&gt; C = utils.math.dotvecmat(x, A)\n&gt;&gt;&gt; print(C)\n{0: 10.0, 1: 19.0}\n</code></pre>"},{"location":"api/utils/math/matmul2d/","title":"matmul2d","text":"<p>Multiplication for 2D matrices.</p>"},{"location":"api/utils/math/matmul2d/#parameters","title":"Parameters","text":"<ul> <li> <p>A</p> </li> <li> <p>B</p> </li> </ul>"},{"location":"api/utils/math/matmul2d/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; A = {\n...     (0, 0): 2, (0, 1): 0, (0, 2): 4,\n...     (1, 0): 5, (1, 1): 6, (1, 2): 0\n... }\n\n&gt;&gt;&gt; B = {\n...     (0, 0): 1, (0, 1): 1, (0, 2): 0, (0, 3): 0,\n...     (1, 0): 2, (1, 1): 0, (1, 2): 1, (1, 3): 3,\n...     (2, 0): 4, (2, 1): 0, (2, 2): 0, (2, 3): 0\n... }\n\n&gt;&gt;&gt; C = utils.math.matmul2d(A, B)\n&gt;&gt;&gt; pprint.pprint(C)\n{(0, 0): 18.0,\n    (0, 1): 2.0,\n    (0, 2): 0.0,\n    (0, 3): 0.0,\n    (1, 0): 17.0,\n    (1, 1): 5.0,\n    (1, 2): 6.0,\n    (1, 3): 18.0}\n</code></pre>"},{"location":"api/utils/math/minkowski-distance/","title":"minkowski_distance","text":"<p>Minkowski distance.</p>"},{"location":"api/utils/math/minkowski-distance/#parameters","title":"Parameters","text":"<ul> <li> <p>a (dict)</p> </li> <li> <p>b (dict)</p> </li> <li> <p>p (int)</p> <p>Parameter for the Minkowski distance. When <code>p=1</code>, this is equivalent to using the Manhattan distance. When <code>p=2</code>, this is equivalent to using the Euclidean distance.</p> </li> </ul>"},{"location":"api/utils/math/norm/","title":"norm","text":"<p>Compute the norm of a dictionaries values.</p>"},{"location":"api/utils/math/norm/#parameters","title":"Parameters","text":"<ul> <li> <p>x (dict)</p> </li> <li> <p>order \u2013 defaults to <code>None</code></p> </li> </ul>"},{"location":"api/utils/math/outer/","title":"outer","text":"<p>Outer-product between two vectors.</p>"},{"location":"api/utils/math/outer/#parameters","title":"Parameters","text":"<ul> <li> <p>u (dict)</p> </li> <li> <p>v (dict)</p> </li> </ul>"},{"location":"api/utils/math/outer/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; from river import utils\n\n&gt;&gt;&gt; u = dict(enumerate((1, 2, 3)))\n&gt;&gt;&gt; v = dict(enumerate((2, 4, 8)))\n\n&gt;&gt;&gt; uTv = utils.math.outer(u, v)\n&gt;&gt;&gt; pprint.pprint(uTv)\n{(0, 0): 2,\n    (0, 1): 4,\n    (0, 2): 8,\n    (1, 0): 4,\n    (1, 1): 8,\n    (1, 2): 16,\n    (2, 0): 6,\n    (2, 1): 12,\n    (2, 2): 24}\n</code></pre>"},{"location":"api/utils/math/prod/","title":"prod","text":"<p>Product function.</p>"},{"location":"api/utils/math/prod/#parameters","title":"Parameters","text":"<ul> <li>iterable</li> </ul>"},{"location":"api/utils/math/sherman-morrison/","title":"sherman_morrison","text":"<p>Sherman-Morrison formula.</p> <p>This is an inplace function.</p>"},{"location":"api/utils/math/sherman-morrison/#parameters","title":"Parameters","text":"<ul> <li> <p>A (numpy.ndarray)</p> </li> <li> <p>u (numpy.ndarray)</p> </li> <li> <p>v (numpy.ndarray)</p> </li> </ul>"},{"location":"api/utils/math/sherman-morrison/#references","title":"References","text":"<ol> <li> <p>Fast rank-one updates to matrix inverse? \u2014 Tim Vieira \u21a9</p> </li> </ol>"},{"location":"api/utils/math/sigmoid/","title":"sigmoid","text":"<p>Sigmoid function.</p>"},{"location":"api/utils/math/sigmoid/#parameters","title":"Parameters","text":"<ul> <li>x (float)</li> </ul>"},{"location":"api/utils/math/sign/","title":"sign","text":"<p>Sign function.</p>"},{"location":"api/utils/math/sign/#parameters","title":"Parameters","text":"<ul> <li>x (float)</li> </ul>"},{"location":"api/utils/math/softmax/","title":"softmax","text":"<p>Normalizes a dictionary of predicted probabilities, in-place.</p>"},{"location":"api/utils/math/softmax/#parameters","title":"Parameters","text":"<ul> <li>y_pred (dict)</li> </ul>"},{"location":"api/utils/math/woodbury-matrix/","title":"woodbury_matrix","text":"<p>Woodbury matrix identity.</p> <p>This is an inplace function.</p>"},{"location":"api/utils/math/woodbury-matrix/#parameters","title":"Parameters","text":"<ul> <li> <p>A (numpy.ndarray)</p> </li> <li> <p>U (numpy.ndarray)</p> </li> <li> <p>V (numpy.ndarray)</p> </li> </ul>"},{"location":"api/utils/math/woodbury-matrix/#references","title":"References","text":"<ol> <li> <p>Matrix inverse mini-batch updates \u2014 Max Halford \u21a9</p> </li> </ol>"},{"location":"api/utils/norm/normalize-values-in-dict/","title":"normalize_values_in_dict","text":"<p>Normalize the values in a dictionary using the given factor.</p> <p>For each element in the dictionary, applies <code>value/factor</code>.</p>"},{"location":"api/utils/norm/normalize-values-in-dict/#parameters","title":"Parameters","text":"<ul> <li> <p>dictionary</p> <p>Dictionary to normalize.</p> </li> <li> <p>factor \u2013 defaults to <code>None</code></p> <p>Normalization factor value. If not set, use the sum of values.</p> </li> <li> <p>inplace \u2013 defaults to <code>True</code></p> <p>If True, perform operation in-place</p> </li> <li> <p>raise_error \u2013 defaults to <code>False</code></p> <p>In case the normalization factor is either <code>0</code> or <code>None</code>: - <code>True</code>: raise an error. - <code>False</code>: return gracefully (if <code>inplace=False</code>, a copy of) <code>dictionary</code>.</p> </li> </ul>"},{"location":"api/utils/norm/scale-values-in-dict/","title":"scale_values_in_dict","text":"<p>Scale the values in a dictionary.</p> <p>For each element in the dictionary, applies <code>value * multiplier</code>.</p>"},{"location":"api/utils/norm/scale-values-in-dict/#parameters","title":"Parameters","text":"<ul> <li> <p>dictionary</p> <p>Dictionary to scale.</p> </li> <li> <p>multiplier</p> <p>Scaling value.</p> </li> <li> <p>inplace \u2013 defaults to <code>True</code></p> <p>If True, perform operation in-place</p> </li> </ul>"},{"location":"api/utils/pretty/humanize-bytes/","title":"humanize_bytes","text":"<p>Returns a human-friendly byte size.</p>"},{"location":"api/utils/pretty/humanize-bytes/#parameters","title":"Parameters","text":"<ul> <li>n_bytes ('int')</li> </ul>"},{"location":"api/utils/pretty/print-table/","title":"print_table","text":"<p>Pretty-prints a table.</p>"},{"location":"api/utils/pretty/print-table/#parameters","title":"Parameters","text":"<ul> <li> <p>headers ('list[str]')</p> <p>The column names.</p> </li> <li> <p>columns ('list[list[str]]')</p> <p>The column values.</p> </li> <li> <p>order ('list[int]') \u2013 defaults to <code>None</code></p> <p>Order in which to print the column the values. Defaults to the order in which the values are given.</p> </li> </ul>"},{"location":"api/utils/random/poisson/","title":"poisson","text":"<p>Sample a random value from a Poisson distribution.</p>"},{"location":"api/utils/random/poisson/#parameters","title":"Parameters","text":"<ul> <li> <p>rate (float)</p> </li> <li> <p>rng \u2013 defaults to <code>&lt;module 'random' from '/opt/hostedtoolcache/Python/3.11.1/x64/lib/python3.11/random.py'&gt;</code></p> </li> </ul>"},{"location":"api/utils/random/poisson/#references","title":"References","text":"<p>[^1] Wikipedia article</p>"},{"location":"benchmarks/","title":"Benchmark","text":""},{"location":"benchmarks/#binary-classification","title":"Binary classification","text":"<p> {   \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.json\",   \"data\": {     \"url\": \"benchmarks/binary_classification.csv\"   },   \"params\": [     {       \"name\": \"models\",       \"select\": {         \"type\": \"point\",         \"fields\": [           \"model\"         ]       },       \"bind\": \"legend\"     },     {       \"name\": \"Dataset\",       \"value\": \"Bananas\",       \"bind\": {         \"input\": \"select\",         \"options\": [           \"Bananas\",           \"Elec2\",           \"Phishing\",           \"SMTP\"         ]       }     },     {       \"name\": \"grid\",       \"select\": \"interval\",       \"bind\": \"scales\"     }   ],   \"transform\": [     {       \"filter\": {         \"field\": \"dataset\",         \"equal\": {           \"expr\": \"Dataset\"         }       }     }   ],   \"repeat\": {     \"row\": [       \"Accuracy\",       \"F1\",       \"Memory in Mb\",       \"Time in s\"     ]   },   \"spec\": {     \"width\": \"container\",     \"mark\": \"line\",     \"encoding\": {       \"x\": {         \"field\": \"step\",         \"type\": \"quantitative\",         \"axis\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18,           \"title\": \"Instance\"         }       },       \"y\": {         \"field\": {           \"repeat\": \"row\"         },         \"type\": \"quantitative\",         \"axis\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18         }       },       \"color\": {         \"field\": \"model\",         \"type\": \"ordinal\",         \"scale\": {           \"scheme\": \"category20b\"         },         \"title\": \"Models\",         \"legend\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18,           \"labelLimit\": 500         }       },       \"opacity\": {         \"condition\": {           \"param\": \"models\",           \"value\": 1         },         \"value\": 0.2       }     }   } } </p>"},{"location":"benchmarks/#datasets","title":"Datasets","text":"Bananas <pre>Bananas dataset.\n\nAn artificial dataset where instances belongs to several clusters with a banana shape.\nThere are two attributes that correspond to the x and y axis, respectively.\n\n    Name  Bananas                                               \n    Task  Binary classification                                 \n Samples  5,300                                                 \nFeatures  2                                                     \n  Sparse  False                                                 \n    Path  /home/kulbach/projects/river/river/datasets/banana.zip</pre>   Elec2 <pre>Electricity prices in New South Wales.\n\nThis is a binary classification task, where the goal is to predict if the price of electricity\nwill go up or down.\n\nThis data was collected from the Australian New South Wales Electricity Market. In this market,\nprices are not fixed and are affected by demand and supply of the market. They are set every\nfive minutes. Electricity transfers to/from the neighboring state of Victoria were done to\nalleviate fluctuations.\n\n      Name  Elec2                                                      \n      Task  Binary classification                                      \n   Samples  45,312                                                     \n  Features  8                                                          \n    Sparse  False                                                      \n      Path  /home/kulbach/river_data/Elec2/electricity.csv             \n       URL  https://maxhalford.github.io/files/datasets/electricity.zip\n      Size  2.95 MB                                                    \nDownloaded  True                                                       </pre>   Phishing <pre>Phishing websites.\n\nThis dataset contains features from web pages that are classified as phishing or not.\n\n    Name  Phishing                                                   \n    Task  Binary classification                                      \n Samples  1,250                                                      \nFeatures  9                                                          \n  Sparse  False                                                      \n    Path  /home/kulbach/projects/river/river/datasets/phishing.csv.gz</pre>   SMTP <pre>SMTP dataset from the KDD 1999 cup.\n\nThe goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only\ncontains 2,211 (0.4%) positive labels.\n\n      Name  SMTP                                                \n      Task  Binary classification                               \n   Samples  95,156                                              \n  Features  3                                                   \n    Sparse  False                                               \n      Path  /home/kulbach/river_data/SMTP/smtp.csv              \n       URL  https://maxhalford.github.io/files/datasets/smtp.zip\n      Size  5.23 MB                                             \nDownloaded  True                                                </pre>"},{"location":"benchmarks/#models","title":"Models","text":"Logistic regression <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LogisticRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.005\n      )\n    )\n    loss=Log (\n      weight_pos=1.\n      weight_neg=1.\n    )\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre>   ALMA <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  ALMAClassifier (\n    p=2\n    alpha=0.9\n    B=1.111111\n    C=1.414214\n  )\n)</pre>   sklearn SGDClassifier <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SKL2RiverClassifier (\n    estimator=SGDClassifier(eta0=0.005, learning_rate='constant', loss='log', penalty='none')\n    classes=[False, True]\n  )\n)</pre>   Vowpal Wabbit logistic regression <pre>VW2RiverClassifier ()</pre>   Naive Bayes <pre>GaussianNB ()</pre>   Hoeffding Tree <pre>HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)</pre>   Hoeffding Adaptive Tree <pre>HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=True\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=42\n)</pre>   Adaptive Random Forest <pre>[]</pre>   Streaming Random Patches <pre>SRPClassifier (\n  model=HoeffdingTreeClassifier (\n    grace_period=50\n    max_depth=inf\n    split_criterion=\"info_gain\"\n    delta=0.01\n    tau=0.05\n    leaf_prediction=\"nba\"\n    nb_threshold=0\n    nominal_attributes=None\n    splitter=GaussianSplitter (\n      n_splits=10\n    )\n    binary_split=False\n    max_size=100.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n  )\n  n_models=10\n  subspace_size=0.6\n  training_method=\"patches\"\n  lam=6\n  drift_detector=ADWIN (\n    delta=1e-05\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  warning_detector=ADWIN (\n    delta=0.0001\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  disable_detector=\"off\"\n  disable_weighted_vote=False\n  seed=None\n  metric=Accuracy (\n    cm=ConfusionMatrix (\n      classes=[]\n    )\n  )\n)</pre>   k-Nearest Neighbors <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    window_size=100\n    min_distance_keep=0.\n    weighted=True\n    cleanup_every=0\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n    softmax=False\n  )\n)</pre>   ADWIN Bagging <pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre>   AdaBoost <pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre>   Bagging <pre>[HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n)]</pre>   Leveraging Bagging <pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre>   Stacking <pre>[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    window_size=100\n    min_distance_keep=0.\n    weighted=True\n    cleanup_every=0\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n    softmax=False\n  )\n)]</pre>   Voting <pre>VotingClassifier (\n  models=[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    window_size=100\n    min_distance_keep=0.\n    weighted=True\n    cleanup_every=0\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n    softmax=False\n  )\n)]\n  use_probabilities=True\n)</pre>   [baseline] Last Class <pre>NoChangeClassifier ()</pre>"},{"location":"benchmarks/#multiclass-classification","title":"Multiclass classification","text":"<p> {   \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.json\",   \"data\": {     \"url\": \"benchmarks/multiclass_classification.csv\"   },   \"params\": [     {       \"name\": \"models\",       \"select\": {         \"type\": \"point\",         \"fields\": [           \"model\"         ]       },       \"bind\": \"legend\"     },     {       \"name\": \"Dataset\",       \"value\": \"ImageSegments\",       \"bind\": {         \"input\": \"select\",         \"options\": [           \"ImageSegments\",           \"Insects\",           \"Keystroke\"         ]       }     },     {       \"name\": \"grid\",       \"select\": \"interval\",       \"bind\": \"scales\"     }   ],   \"transform\": [     {       \"filter\": {         \"field\": \"dataset\",         \"equal\": {           \"expr\": \"Dataset\"         }       }     }   ],   \"repeat\": {     \"row\": [       \"Accuracy\",       \"MicroF1\",       \"MacroF1\",       \"Memory in Mb\",       \"Time in s\"     ]   },   \"spec\": {     \"width\": \"container\",     \"mark\": \"line\",     \"encoding\": {       \"x\": {         \"field\": \"step\",         \"type\": \"quantitative\",         \"axis\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18,           \"title\": \"Instance\"         }       },       \"y\": {         \"field\": {           \"repeat\": \"row\"         },         \"type\": \"quantitative\",         \"axis\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18         }       },       \"color\": {         \"field\": \"model\",         \"type\": \"ordinal\",         \"scale\": {           \"scheme\": \"category20b\"         },         \"title\": \"Models\",         \"legend\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18,           \"labelLimit\": 500         }       },       \"opacity\": {         \"condition\": {           \"param\": \"models\",           \"value\": 1         },         \"value\": 0.2       }     }   } } </p>"},{"location":"benchmarks/#datasets_1","title":"Datasets","text":"ImageSegments <pre>Image segments classification.\n\nThis dataset contains features that describe image segments into 7 classes: brickface, sky,\nfoliage, cement, window, path, and grass.\n\n    Name  ImageSegments                                              \n    Task  Multi-class classification                                 \n Samples  2,310                                                      \nFeatures  18                                                         \n  Sparse  False                                                      \n    Path  /home/kulbach/projects/river/river/datasets/segment.csv.zip</pre>   Insects <pre>Insects dataset.\n\nThis dataset has different variants, which are:\n\n- abrupt_balanced\n- abrupt_imbalanced\n- gradual_balanced\n- gradual_imbalanced\n- incremental-abrupt_balanced\n- incremental-abrupt_imbalanced\n- incremental-reoccurring_balanced\n- incremental-reoccurring_imbalanced\n- incremental_balanced\n- incremental_imbalanced\n- out-of-control\n\nThe number of samples and the difficulty change from one variant to another. The number of\nclasses is always the same (6), except for the last variant (24).\n\n      Name  Insects                                                                                 \n      Task  Multi-class classification                                                              \n   Samples  52,848                                                                                  \n  Features  33                                                                                      \n   Classes  6                                                                                       \n    Sparse  False                                                                                   \n      Path  /home/kulbach/river_data/Insects/INSECTS-abrupt_balanced_norm.arff                      \n       URL  http://sites.labic.icmc.usp.br/vsouza/repository/creme/INSECTS-abrupt_balanced_norm.arff\n      Size  15.66 MB                                                                                \nDownloaded  True                                                                                    \n   Variant  abrupt_balanced                                                                         \n\nParameters\n----------\n    variant\n        Indicates which variant of the dataset to load.</pre>   Keystroke <pre>CMU keystroke dataset.\n\nUsers are tasked to type in a password. The task is to determine which user is typing in the\npassword.\n\nThe only difference with the original dataset is that the \"sessionIndex\" and \"rep\" attributes\nhave been dropped.\n\n      Name  Keystroke                                                    \n      Task  Multi-class classification                                   \n   Samples  20,400                                                       \n  Features  31                                                           \n    Sparse  False                                                        \n      Path  /home/kulbach/river_data/Keystroke/DSL-StrongPasswordData.csv\n       URL  http://www.cs.cmu.edu/~keystroke/DSL-StrongPasswordData.csv  \n      Size  4.45 MB                                                      \nDownloaded  True                                                         </pre>"},{"location":"benchmarks/#models_1","title":"Models","text":"Naive Bayes <pre>GaussianNB ()</pre>   Hoeffding Tree <pre>HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)</pre>   Hoeffding Adaptive Tree <pre>HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=True\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=42\n)</pre>   Adaptive Random Forest <pre>[]</pre>   Streaming Random Patches <pre>SRPClassifier (\n  model=HoeffdingTreeClassifier (\n    grace_period=50\n    max_depth=inf\n    split_criterion=\"info_gain\"\n    delta=0.01\n    tau=0.05\n    leaf_prediction=\"nba\"\n    nb_threshold=0\n    nominal_attributes=None\n    splitter=GaussianSplitter (\n      n_splits=10\n    )\n    binary_split=False\n    max_size=100.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n  )\n  n_models=10\n  subspace_size=0.6\n  training_method=\"patches\"\n  lam=6\n  drift_detector=ADWIN (\n    delta=1e-05\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  warning_detector=ADWIN (\n    delta=0.0001\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  disable_detector=\"off\"\n  disable_weighted_vote=False\n  seed=None\n  metric=Accuracy (\n    cm=ConfusionMatrix (\n      classes=[]\n    )\n  )\n)</pre>   k-Nearest Neighbors <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    window_size=100\n    min_distance_keep=0.\n    weighted=True\n    cleanup_every=0\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n    softmax=False\n  )\n)</pre>   ADWIN Bagging <pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre>   AdaBoost <pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre>   Bagging <pre>[HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n)]</pre>   Leveraging Bagging <pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre>   Stacking <pre>[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    window_size=100\n    min_distance_keep=0.\n    weighted=True\n    cleanup_every=0\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n    softmax=False\n  )\n)]</pre>   Voting <pre>VotingClassifier (\n  models=[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    window_size=100\n    min_distance_keep=0.\n    weighted=True\n    cleanup_every=0\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n    softmax=False\n  )\n)]\n  use_probabilities=True\n)</pre>   [baseline] Last Class <pre>NoChangeClassifier ()</pre>"},{"location":"benchmarks/#regression","title":"Regression","text":"<p> {   \"$schema\": \"https://vega.github.io/schema/vega-lite/v5.json\",   \"data\": {     \"url\": \"benchmarks/regression.csv\"   },   \"params\": [     {       \"name\": \"models\",       \"select\": {         \"type\": \"point\",         \"fields\": [           \"model\"         ]       },       \"bind\": \"legend\"     },     {       \"name\": \"Dataset\",       \"value\": \"ChickWeights\",       \"bind\": {         \"input\": \"select\",         \"options\": [           \"ChickWeights\",           \"TrumpApproval\"         ]       }     },     {       \"name\": \"grid\",       \"select\": \"interval\",       \"bind\": \"scales\"     }   ],   \"transform\": [     {       \"filter\": {         \"field\": \"dataset\",         \"equal\": {           \"expr\": \"Dataset\"         }       }     }   ],   \"repeat\": {     \"row\": [       \"MAE\",       \"RMSE\",       \"R2\",       \"Memory in Mb\",       \"Time in s\"     ]   },   \"spec\": {     \"width\": \"container\",     \"mark\": \"line\",     \"encoding\": {       \"x\": {         \"field\": \"step\",         \"type\": \"quantitative\",         \"axis\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18,           \"title\": \"Instance\"         }       },       \"y\": {         \"field\": {           \"repeat\": \"row\"         },         \"type\": \"quantitative\",         \"axis\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18         }       },       \"color\": {         \"field\": \"model\",         \"type\": \"ordinal\",         \"scale\": {           \"scheme\": \"category20b\"         },         \"title\": \"Models\",         \"legend\": {           \"titleFontSize\": 18,           \"labelFontSize\": 18,           \"labelLimit\": 500         }       },       \"opacity\": {         \"condition\": {           \"param\": \"models\",           \"value\": 1         },         \"value\": 0.2       }     }   } } </p>"},{"location":"benchmarks/#datasets_2","title":"Datasets","text":"ChickWeights <pre>Chick weights along time.\n\nThe stream contains 578 items and 3 features. The goal is to predict the weight of each chick\nalong time, according to the diet the chick is on. The data is ordered by time and then by\nchick.\n\n    Name  ChickWeights                                                 \n    Task  Regression                                                   \n Samples  578                                                          \nFeatures  3                                                            \n  Sparse  False                                                        \n    Path  /home/kulbach/projects/river/river/datasets/chick-weights.csv</pre>   TrumpApproval <pre>Donald Trump approval ratings.\n\nThis dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald\nTrump's approval ratings. It contains 5 features, which are approval ratings collected by\n5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of\nthis task is to see if we can reproduce FiveThirtyEight's model.\n\n    Name  TrumpApproval                                                    \n    Task  Regression                                                       \n Samples  1,001                                                            \nFeatures  6                                                                \n  Sparse  False                                                            \n    Path  /home/kulbach/projects/river/river/datasets/trump_approval.csv.gz</pre>"},{"location":"benchmarks/#models_2","title":"Models","text":"Linear Regression <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre>   Linear Regression with l1 regularization <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=1.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre>   Linear Regression with l2 regularization <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=1.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre>   Passive-Aggressive Regressor, mode 1 <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  PARegressor (\n    C=1.\n    mode=1\n    eps=0.1\n    learn_intercept=True\n  )\n)</pre>   Passive-Aggressive Regressor, mode 2 <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  PARegressor (\n    C=1.\n    mode=2\n    eps=0.1\n    learn_intercept=True\n  )\n)</pre>   k-Nearest Neighbors <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNRegressor (\n    n_neighbors=5\n    window_size=100\n    aggregation_method=\"mean\"\n    min_distance_keep=0.\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n  )\n)</pre>   Hoeffding Tree <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  HoeffdingTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n  )\n)</pre>   Hoeffding Adaptive Tree <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=True\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=42\n  )\n)</pre>   Stochastic Gradient Tree <pre>SGTRegressor (\n  delta=1e-07\n  grace_period=200\n  init_pred=0.\n  max_depth=inf\n  lambda_value=0.1\n  gamma=1.\n  nominal_attributes=[]\n  feature_quantizer=StaticQuantizer (\n    n_bins=64\n    warm_start=100\n    buckets=None\n  )\n)</pre>   Adaptive Random Forest <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  []\n)</pre>   Adaptive Model Rules <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  AMRules (\n    n_min=200\n    delta=1e-07\n    tau=0.05\n    pred_type=\"adaptive\"\n    pred_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    fading_factor=0.99\n    anomaly_threshold=-0.75\n    m_min=30\n    ordered_rule_set=True\n    min_samples_split=5\n  )\n)</pre>   Streaming Random Patches <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SRPRegressor (\n    model=HoeffdingTreeRegressor (\n      grace_period=50\n      max_depth=inf\n      delta=0.01\n      tau=0.05\n      leaf_prediction=\"adaptive\"\n      leaf_model=LinearRegression (\n        optimizer=SGD (\n          lr=Constant (\n            learning_rate=0.01\n          )\n        )\n        loss=Squared ()\n        l2=0.\n        l1=0.\n        intercept_init=0.\n        intercept_lr=Constant (\n          learning_rate=0.01\n        )\n        clip_gradient=1e+12\n        initializer=Zeros ()\n      )\n      model_selector_decay=0.95\n      nominal_attributes=None\n      splitter=TEBSTSplitter (\n        digits=1\n      )\n      min_samples_split=5\n      binary_split=False\n      max_size=500.\n      memory_estimate_period=1000000\n      stop_mem_management=False\n      remove_poor_attrs=False\n      merit_preprune=True\n    )\n    n_models=10\n    subspace_size=0.6\n    training_method=\"patches\"\n    lam=6\n    drift_detector=ADWIN (\n      delta=1e-05\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    warning_detector=ADWIN (\n      delta=0.0001\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    disable_detector=\"off\"\n    disable_weighted_vote=True\n    drift_detection_criteria=\"error\"\n    aggregation_method=\"mean\"\n    seed=42\n    metric=MAE ()\n  )\n)</pre>   Bagging <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  [HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  )]\n)</pre>   Exponentially Weighted Average <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  [LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=True\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), KNNRegressor (\n    n_neighbors=5\n    window_size=100\n    aggregation_method=\"mean\"\n    min_distance_keep=0.\n    distance_func=functools.partial(&lt;function minkowski_distance at 0x7f2d38a59ea0&gt;, p=2)\n  ), AMRules (\n    n_min=200\n    delta=1e-07\n    tau=0.05\n    pred_type=\"adaptive\"\n    pred_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    fading_factor=0.99\n    anomaly_threshold=-0.75\n    m_min=30\n    ordered_rule_set=True\n    min_samples_split=5\n  )]\n)</pre>   River MLP <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  MLPRegressor (\n    hidden_dims=(5,)\n    activations=(&lt;class 'river.neural_net.activations.ReLU'&gt;, &lt;class 'river.neural_net.activations.ReLU'&gt;, &lt;class 'river.neural_net.activations.Identity'&gt;)\n    loss=Squared ()\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.001\n      )\n    )\n    seed=42\n  )\n)</pre>   [baseline] Mean predictor <pre>StatisticRegressor (\n  statistic=Mean ()\n)</pre>"},{"location":"benchmarks/#environment","title":"Environment","text":"<pre>Python implementation: CPython\nPython version       : 3.11.1\nIPython version      : 8.8.0\n\nriver       : 0.14.0\nnumpy       : 1.24.1\nscikit-learn: 1.2.0\npandas      : 1.5.2\nscipy       : 1.10.0\n\nCompiler    : GCC 11.3.0\nOS          : Linux\nRelease     : 5.15.0-1024-azure\nMachine     : x86_64\nProcessor   : x86_64\nCPU cores   : 2\nArchitecture: 64bit\n</pre>"},{"location":"examples/batch-to-online/","title":"From batch to online/stream","text":""},{"location":"examples/batch-to-online/#a-quick-overview-of-batch-learning","title":"A quick overview of batch learning","text":"<p>If you've already delved into machine learning, then you shouldn't have any difficulty in getting to use incremental learning. If you are somewhat new to machine learning, then do not worry! The point of this notebook in particular is to introduce simple notions. We'll also start to show how <code>river</code> fits in and explain how to use it.</p> <p>The whole point of machine learning is to learn from data. In supervised learning you want to learn how to predict a target \\(y\\) given a set of features \\(X\\). Meanwhile in an unsupervised learning there is no target, and the goal is rather to identify patterns and trends in the features \\(X\\). At this point most people tend to imagine \\(X\\) as a somewhat big table where each row is an observation and each column is a feature, and they would be quite right. Learning from tabular data is part of what's called batch learning, which basically that all of the data is available to our learning algorithm at once. Multiple libraries have been created to handle the batch learning regime, with one of the most prominent being Python's scikit-learn.</p> <p>As a simple example of batch learning let's say we want to learn to predict if a women has breast cancer or not. We'll use the breast cancer dataset available with scikit-learn. We'll learn to map a set of features to a binary decision using a logistic regression. Like many other models based on numerical weights, logistic regression is sensitive to the scale of the features. Rescaling the data so that each feature has mean 0 and variance 1 is generally considered good practice. We can apply the rescaling and fit the logistic regression sequentially in an elegant manner using a Pipeline. To measure the performance of the model we'll evaluate the average ROC AUC score using a 5 fold cross-validation. </p> <pre><code>from sklearn import datasets\nfrom sklearn import linear_model\nfrom sklearn import metrics\nfrom sklearn import model_selection\nfrom sklearn import pipeline\nfrom sklearn import preprocessing\n\n\n# Load the data\ndataset = datasets.load_breast_cancer()\nX, y = dataset.data, dataset.target\n\n# Define the steps of the model\nmodel = pipeline.Pipeline([\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LogisticRegression(solver='lbfgs'))\n])\n\n# Define a determistic cross-validation procedure\ncv = model_selection.KFold(n_splits=5, shuffle=True, random_state=42)\n\n# Compute the MSE values\nscorer = metrics.make_scorer(metrics.roc_auc_score)\nscores = model_selection.cross_val_score(model, X, y, scoring=scorer, cv=cv)\n\n# Display the average score and it's standard deviation\nprint(f'ROC AUC: {scores.mean():.3f} (\u00b1 {scores.std():.3f})')\n</code></pre> <pre>ROC AUC: 0.975 (\u00b1 0.011)\n</pre> <p>This might be a lot to take in if you're not accustomed to scikit-learn, but it probably isn't if you are. Batch learning basically boils down to:</p> <ol> <li>Loading (and preprocessing) the data</li> <li>Fitting a model to the data</li> <li>Computing the performance of the model on unseen data</li> </ol> <p>This is pretty standard and is maybe how most people imagine a machine learning pipeline. However, this way of proceeding has certain downsides. First of all your laptop would crash if the <code>load_boston</code> function returned a dataset who's size exceeds your available amount of RAM. Sometimes you can use some tricks to get around this. For example by optimizing the data types and by using sparse representations when applicable you can potentially save precious gigabytes of RAM. However, like many tricks this only goes so far. If your dataset weighs hundreds of gigabytes then you won't go far without some special hardware. One solution is to do out-of-core learning; that is, algorithms that can learn by being presented the data in chunks or mini-batches. If you want to go down this road then take a look at Dask and Spark's MLlib.</p> <p>Another issue with the batch learning regime is that it can't elegantly learn from new data. Indeed if new data is made available, then the model has to learn from scratch with a new dataset composed of the old data and the new data. This is particularly annoying in a real situation where you might have new incoming data every week, day, hour, minute, or even setting. For example if you're building a recommendation engine for an e-commerce app, then you're probably training your model from 0 every week or so. As your app grows in popularity, so does the dataset you're training on. This will lead to longer and longer training times and might require a hardware upgrade.</p> <p>A final downside that isn't very easy to grasp concerns the manner in which features are extracted. Every time you want to train your model you first have to extract features. The trick is that some features might not be accessible at the particular point in time you are at. For example maybe that some attributes in your data warehouse get overwritten with time. In other words maybe that all the features pertaining to a particular observations are not available, whereas they were a week ago. This happens more often than not in real scenarios, and apart if you have a sophisticated data engineering pipeline then you will encounter these issues at some point. </p>"},{"location":"examples/batch-to-online/#a-hands-on-introduction-to-incremental-learning","title":"A hands-on introduction to incremental learning","text":"<p>Incremental learning is also often called online learning or stream learning, but if you google online learning a lot of the results will point to educational websites. Hence, the terms \"incremental learning\" and \"stream learning\" (from which <code>river</code> derives it's name) are prefered. The point of incremental learning is to fit a model to a stream of data. In other words, the data isn't available in it's entirety, but rather the observations are provided one by one. As an example let's stream through the dataset used previously.</p> <pre><code>for xi, yi in zip(X, y):\n    # This is where the model learns\n    pass\n</code></pre> <p>In this case we're iterating over a dataset that is already in memory, but we could just as well stream from a CSV file, a Kafka stream, an SQL query, etc. If we look at <code>xi</code> we can notice that it is a <code>numpy.ndarray</code>.</p> <pre><code>xi\n</code></pre> <pre>\narray([7.760e+00, 2.454e+01, 4.792e+01, 1.810e+02, 5.263e-02, 4.362e-02,\n       0.000e+00, 0.000e+00, 1.587e-01, 5.884e-02, 3.857e-01, 1.428e+00,\n       2.548e+00, 1.915e+01, 7.189e-03, 4.660e-03, 0.000e+00, 0.000e+00,\n       2.676e-02, 2.783e-03, 9.456e+00, 3.037e+01, 5.916e+01, 2.686e+02,\n       8.996e-02, 6.444e-02, 0.000e+00, 0.000e+00, 2.871e-01, 7.039e-02])\n</pre> <p><code>river</code> by design works with <code>dict</code>s. We believe that <code>dict</code>s are more enjoyable to program with than <code>numpy.ndarray</code>s, at least for when single observations are concerned. <code>dict</code>'s bring the added benefit that each feature can be accessed by name rather than by position.</p> <pre><code>for xi, yi in zip(X, y):\n    xi = dict(zip(dataset.feature_names, xi))\n    pass\n\nxi\n</code></pre> <pre>\n{\n    'mean radius': 7.76,\n    'mean texture': 24.54,\n    'mean perimeter': 47.92,\n    'mean area': 181.0,\n    'mean smoothness': 0.05263,\n    'mean compactness': 0.04362,\n    'mean concavity': 0.0,\n    'mean concave points': 0.0,\n    'mean symmetry': 0.1587,\n    'mean fractal dimension': 0.05884,\n    'radius error': 0.3857,\n    'texture error': 1.428,\n    'perimeter error': 2.548,\n    'area error': 19.15,\n    'smoothness error': 0.007189,\n    'compactness error': 0.00466,\n    'concavity error': 0.0,\n    'concave points error': 0.0,\n    'symmetry error': 0.02676,\n    'fractal dimension error': 0.002783,\n    'worst radius': 9.456,\n    'worst texture': 30.37,\n    'worst perimeter': 59.16,\n    'worst area': 268.6,\n    'worst smoothness': 0.08996,\n    'worst compactness': 0.06444,\n    'worst concavity': 0.0,\n    'worst concave points': 0.0,\n    'worst symmetry': 0.2871,\n    'worst fractal dimension': 0.07039\n}\n</pre> <p>Conveniently, <code>river</code>'s <code>stream</code> module has an <code>iter_sklearn_dataset</code> method that we can use instead.</p> <pre><code>from river import stream\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer()):\n    pass\n</code></pre> <p>The simple fact that we are getting the data as a stream means that we can't do a lot of things the same way as in a batch setting. For example let's say we want to scale the data so that it has mean 0 and variance 1, as we did earlier. To do so we simply have to subtract the mean of each feature to each value and then divide the result by the standard deviation of the feature. The problem is that we can't possible known the values of the mean and the standard deviation before actually going through all the data! One way to proceed would be to do a first pass over the data to compute the necessary values and then scale the values during a second pass. The problem is that this defeats our purpose, which is to learn by only looking at the data once. Although this might seem rather restrictive, it reaps sizable benefits down the road.</p> <p>The way we do feature scaling in <code>river</code> involves computing running statistics (also know as moving statistics). The idea is that we use a data structure that estimates the mean and updates itself when it is provided with a value. The same goes for the variance (and thus the standard deviation). For example, if we denote \\(\\mu_t\\) the mean and \\(n_t\\) the count at any moment \\(t\\), then updating the mean can be done as so:</p> \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\end{cases} \\] <p>Likewise, the running variance can be computed as so:</p> \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\\\ s_{t+1} = s_t + (x - \\mu_t) \\times (x - \\mu_{t+1}) \\\\ \\sigma_{t+1} = \\frac{s_{t+1}}{n_{t+1}} \\end{cases} \\] <p>where \\(s_t\\) is a running sum of squares and \\(\\sigma_t\\) is the running variance at time \\(t\\). This might seem a tad more involved than the batch algorithms you learn in school, but it is rather elegant. Implementing this in Python is not too difficult. For example let's compute the running mean and variance of the <code>'mean area'</code> variable.</p> <pre><code>n, mean, sum_of_squares, variance = 0, 0, 0, 0\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer()):\n    n += 1\n    old_mean = mean\n    mean += (xi['mean area'] - mean) / n\n    sum_of_squares += (xi['mean area'] - old_mean) * (xi['mean area'] - mean)\n    variance = sum_of_squares / n\n\nprint(f'Running mean: {mean:.3f}')\nprint(f'Running variance: {variance:.3f}')\n</code></pre> <pre>Running mean: 654.889\n</pre> <pre>Running variance: 123625.903\n</pre> <p>Let's compare this with <code>numpy</code>. But remember, <code>numpy</code> requires access to \"all\" the data.</p> <pre><code>import numpy as np\n\ni = list(dataset.feature_names).index('mean area')\nprint(f'True mean: {np.mean(X[:, i]):.3f}')\nprint(f'True variance: {np.var(X[:, i]):.3f}')\n</code></pre> <pre>True mean: 654.889\n</pre> <pre>True variance: 123625.903\n</pre> <p>The results seem to be exactly the same! The twist is that the running statistics won't be very accurate for the first few observations. In general though this doesn't matter too much. Some would even go as far as to say that this descrepancy is beneficial and acts as some sort of regularization...</p> <p>Now the idea is that we can compute the running statistics of each feature and scale them as they come along. The way to do this with <code>river</code> is to use the <code>StandardScaler</code> class from the <code>preprocessing</code> module, as so:</p> <pre><code>from river import preprocessing\n\nscaler = preprocessing.StandardScaler()\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer()):\n    scaler = scaler.learn_one(xi)\n</code></pre> <p>Now that we are scaling the data, we can start doing some actual machine learning. We're going to implement an online linear regression task. Because all the data isn't available at once, we are obliged to do what is called stochastic gradient descent, which is a popular research topic and has a lot of variants. SGD is commonly used to train neural networks. The idea is that at each step we compute the loss between the target prediction and the truth. We then calculate the gradient, which is simply a set of derivatives with respect to each weight from the linear regression. Once we have obtained the gradient, we can update the weights by moving them in the opposite direction of the gradient. The amount by which the weights are moved typically depends on a learning rate, which is typically set by the user. Different optimizers have different ways of managing the weight update, and some handle the learning rate implicitly. Online linear regression can be done in <code>river</code> with the <code>LinearRegression</code> class from the <code>linear_model</code> module. We'll be using plain and simple SGD using the <code>SGD</code> optimizer from the <code>optim</code> module. During training we'll measure the squared error between the truth and the predictions.</p> <pre><code>from river import linear_model\nfrom river import optim\n\nscaler = preprocessing.StandardScaler()\noptimizer = optim.SGD(lr=0.01)\nlog_reg = linear_model.LogisticRegression(optimizer)\n\ny_true = []\ny_pred = []\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer(), shuffle=True, seed=42):\n\n    # Scale the features\n    xi_scaled = scaler.learn_one(xi).transform_one(xi)\n\n    # Test the current model on the new \"unobserved\" sample\n    yi_pred = log_reg.predict_proba_one(xi_scaled)\n    # Train the model with the new sample\n    log_reg.learn_one(xi_scaled, yi)\n\n    # Store the truth and the prediction\n    y_true.append(yi)\n    y_pred.append(yi_pred[True])\n\nprint(f'ROC AUC: {metrics.roc_auc_score(y_true, y_pred):.3f}')\n</code></pre> <pre>ROC AUC: 0.990\n</pre> <p>The ROC AUC is significantly better than the one obtained from the cross-validation of scikit-learn's logisitic regression. However to make things really comparable it would be nice to compare with the same cross-validation procedure. <code>river</code> has a <code>compat</code> module that contains utilities for making <code>river</code> compatible with other Python libraries. Because we're doing regression we'll be using the <code>SKLRegressorWrapper</code>. We'll also be using <code>Pipeline</code> to encapsulate the logic of the <code>StandardScaler</code> and the <code>LogisticRegression</code> in one single object.</p> <pre><code>from river import compat\nfrom river import compose\n\n# We define a Pipeline, exactly like we did earlier for sklearn \nmodel = compose.Pipeline(\n    ('scale', preprocessing.StandardScaler()),\n    ('log_reg', linear_model.LogisticRegression())\n)\n\n# We make the Pipeline compatible with sklearn\nmodel = compat.convert_river_to_sklearn(model)\n\n# We compute the CV scores using the same CV scheme and the same scoring\nscores = model_selection.cross_val_score(model, X, y, scoring=scorer, cv=cv)\n\n# Display the average score and it's standard deviation\nprint(f'ROC AUC: {scores.mean():.3f} (\u00b1 {scores.std():.3f})')\n</code></pre> <pre>ROC AUC: 0.964 (\u00b1 0.016)\n</pre> <p>This time the ROC AUC score is lower, which is what we would expect. Indeed online learning isn't as accurate as batch learning. However it all depends in what you're interested in. If you're only interested in predicting the next observation then the online learning regime would be better. That's why it's a bit hard to compare both approaches: they're both suited to different scenarios.</p>"},{"location":"examples/batch-to-online/#going-further","title":"Going further","text":"<p>Here a few resources if you want to do some reading:</p> <ul> <li>Online learning -- Wikipedia</li> <li>What is online machine learning? -- Max Pagels</li> <li>Introduction to Online Learning -- USC course</li> <li>Online Methods in Machine Learning -- MIT course</li> <li>Online Learning: A Comprehensive Survey</li> <li>Streaming 101: The world beyond batch</li> <li>Machine learning for data streams</li> <li>Data Stream Mining: A Practical Approach</li> </ul>"},{"location":"examples/bike-sharing-forecasting/","title":"Bike-sharing forecasting","text":"<p>In this tutorial we're going to forecast the number of bikes in 5 bike stations from the city of Toulouse. We'll do so by building a simple model step by step. The dataset contains 182,470 observations. Let's first take a peak at the data.</p> <pre><code>from pprint import pprint\nfrom river import datasets\n\ndataset = datasets.Bikes()\n\nfor x, y in dataset:\n    pprint(x)\n    print(f'Number of available bikes: {y}')\n    break\n</code></pre> <pre><code>{'clouds': 75,\n 'description': 'light rain',\n 'humidity': 81,\n 'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n 'pressure': 1017.0,\n 'station': 'metro-canal-du-midi',\n 'temperature': 6.54,\n 'wind': 9.3}\n</code></pre> <pre>Number of available bikes: 1\n</pre> <p>Let's start by using a simple linear regression on the numeric features. We can select the numeric features and discard the rest of the features using a <code>Select</code>. Linear regression is very likely to go haywire if we don't scale the data, so we'll use a <code>StandardScaler</code> to do just that. We'll evaluate the model by measuring the mean absolute error. Finally we'll print the score every 20,000 observations. </p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import metrics\nfrom river import evaluate\nfrom river import preprocessing\nfrom river import optim\n\nmodel = compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind')\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression(optimizer=optim.SGD(0.001))\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric, print_every=20_000)\n</code></pre> <pre><code>[20,000] MAE: 4.912727\n[40,000] MAE: 5.333554\n[60,000] MAE: 5.330948\n[80,000] MAE: 5.392313\n[100,000] MAE: 5.423059\n[120,000] MAE: 5.541223\n[140,000] MAE: 5.613023\n[160,000] MAE: 5.622428\n[180,000] MAE: 5.567824\n</code></pre> <pre>MAE: 5.563893\n</pre> <p>The model doesn't seem to be doing that well, but then again we didn't provide a lot of features. Generally, a good idea for this kind of problem is to look at an average of the previous values. For example, for each station we can look at the average number of bikes per hour. To do so we first have to extract the hour from the  <code>moment</code> field. We can then use a <code>TargetAgg</code> to aggregate the values of the target.</p> <pre><code>from river import feature_extraction\nfrom river import stats\n\ndef get_hour(x):\n    x['hour'] = x['moment'].hour\n    return x\n\nmodel = compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind')\nmodel += (\n    get_hour |\n    feature_extraction.TargetAgg(by=['station', 'hour'], how=stats.Mean())\n)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression(optimizer=optim.SGD(0.001))\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric, print_every=20_000)\n</code></pre> <pre><code>[20,000] MAE: 3.721246\n[40,000] MAE: 3.829972\n[60,000] MAE: 3.845068\n[80,000] MAE: 3.910259\n[100,000] MAE: 3.888652\n[120,000] MAE: 3.923727\n[140,000] MAE: 3.980953\n[160,000] MAE: 3.950034\n[180,000] MAE: 3.934545\n</code></pre> <pre>MAE: 3.933498\n</pre> <p>By adding a single feature, we've managed to significantly reduce the mean absolute error. At this point you might think that the model is getting slightly complex, and is difficult to understand and test. Pipelines have the advantage of being terse, but they aren't always to debug. Thankfully <code>river</code> has some ways to relieve the pain.</p> <p>The first thing we can do it to visualize the pipeline, to get an idea of how the data flows through it.</p> <pre><code>model\n</code></pre> <pre>['clouds', 'humidity', 'pressure', 'temperature', 'wind']</pre><code>(   clouds   humidity   pressure   temperature   wind )  </code><pre>get_hour</pre><code> def get_hour(x):     x['hour'] = x['moment'].hour     return x  </code><pre>y_mean_by_station_and_hour</pre><code>(   by=['station', 'hour']   how=Mean ()   target_name=\"y\" )  </code><pre>StandardScaler</pre><code>(   with_std=True )  </code><pre>LinearRegression</pre><code>(   optimizer=SGD (     lr=Constant (       learning_rate=0.001     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () )  </code> <p>We can also use the <code>debug_one</code> method to see what happens to one particular instance. Let's train the model on the first 10,000 observations and then call <code>debug_one</code> on the next one. To do this, we will turn the <code>Bike</code> object into a Python generator with <code>iter()</code> function. The Pythonic way to read the first 10,000 elements of a generator is to use <code>itertools.islice</code>.</p> <pre><code>import itertools\n\nmodel = compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind')\nmodel += (\n    get_hour |\n    feature_extraction.TargetAgg(by=['station', 'hour'], how=stats.Mean())\n)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression()\n\nfor x, y in itertools.islice(dataset, 10000):\n    y_pred = model.predict_one(x)\n    model.learn_one(x, y)\n\nx, y = next(iter(dataset))\nprint(model.debug_one(x))\n</code></pre> <pre>0. Input\n--------\nclouds: 75 (int)\ndescription: light rain (str)\nhumidity: 81 (int)\nmoment: 2016-04-01 00:00:07 (datetime)\npressure: 1,017.00000 (float)\nstation: metro-canal-du-midi (str)\ntemperature: 6.54000 (float)\nwind: 9.30000 (float)\n\n1. Transformer union\n--------------------\n    1.0 Select\n    ----------\n    clouds: 75 (int)\n    humidity: 81 (int)\n    pressure: 1,017.00000 (float)\n    temperature: 6.54000 (float)\n    wind: 9.30000 (float)\n\n    1.1 get_hour | y_mean_by_station_and_hour\n    -----------------------------------------\n    y_mean_by_station_and_hour: 4.43243 (float)\n\nclouds: 75 (int)\nhumidity: 81 (int)\npressure: 1,017.00000 (float)\ntemperature: 6.54000 (float)\nwind: 9.30000 (float)\ny_mean_by_station_and_hour: 4.43243 (float)\n\n2. StandardScaler\n-----------------\nclouds: 0.47566 (float)\nhumidity: 0.42247 (float)\npressure: 1.05314 (float)\ntemperature: -1.22098 (float)\nwind: 2.21104 (float)\ny_mean_by_station_and_hour: -0.59098 (float)\n\n3. LinearRegression\n-------------------\nName                         Value      Weight     Contribution  \n                 Intercept    1.00000    6.58252        6.58252  \n                  pressure    1.05314    3.78529        3.98646  \n                  humidity    0.42247    1.44921        0.61225  \ny_mean_by_station_and_hour   -0.59098    0.54167       -0.32011  \n                    clouds    0.47566   -1.92255       -0.91448  \n                      wind    2.21104   -0.77720       -1.71843  \n               temperature   -1.22098    2.47030       -3.01619  \n\nPrediction: 5.21201\n</pre> <p>The <code>debug_one</code> method shows what happens to an input set of features, step by step.</p> <p>And now comes the catch. Up until now we've been using the <code>progressive_val_score</code> method from the <code>evaluate</code> module. What this does it that it sequentially predicts the output of an observation and updates the model immediately afterwards. This way of proceeding is often used for evaluating online learning models. But in some cases it is the wrong approach.</p> <p>When evaluating a machine learning model, the goal is to simulate production conditions in order to get a trust-worthy assessment of the performance of the model. In our case, we typically want to forecast the number of bikes available in a station, say, 30 minutes ahead. Then, once the 30 minutes have passed, the true number of available bikes will be available and we will be able to update the model using the features available 30 minutes ago.</p> <p>What we really want is to evaluate the model by forecasting 30 minutes ahead and only updating the model once the true values are available. This can be done using the <code>moment</code> and <code>delay</code> parameters in the  <code>progressive_val_score</code> method. The idea is that each observation in the stream of the data is shown twice to the model: once for making a prediction, and once for updating the model when the true value is revealed. The <code>moment</code> parameter determines which variable should be used as a timestamp, while the <code>delay</code> parameter controls the duration to wait before revealing the true values to the model.</p> <pre><code>import datetime as dt\n\nevaluate.progressive_val_score(\n    dataset=dataset,\n    model=model.clone(),\n    metric=metrics.MAE(),\n    moment='moment',\n    delay=dt.timedelta(minutes=30),\n    print_every=20_000\n)\n</code></pre> <pre><code>[20,000] MAE: 4.203433\n[40,000] MAE: 4.195404\n[60,000] MAE: 4.130316\n[80,000] MAE: 4.122796\n[100,000] MAE: 4.069826\n[120,000] MAE: 4.066034\n[140,000] MAE: 4.088604\n[160,000] MAE: 4.059282\n[180,000] MAE: 4.026821\n</code></pre> <pre>MAE: 4.024939\n</pre> <p>The performance is a bit worse, which is to be expected. Indeed, the task is more difficult: the model is only shown the ground truth 30 minutes after making a prediction.</p> <p>The takeaway of this notebook is that the <code>progressive_val_score</code> method can be used to simulate a production scenario, and is thus extremely valuable.</p>"},{"location":"examples/building-a-simple-nowcasting-model/","title":"Building a simple nowcasting model","text":"<pre><code>%matplotlib inline\n</code></pre> <p>Nowcasting is a special case of forecasting. It simply consists in predicting the next value in a time series.</p> <p>We'll be using the international airline passenger data available from here. This particular dataset is included with <code>river</code> in the <code>datasets</code> module.</p> <pre><code>from river import datasets\n\nfor x, y in datasets.AirlinePassengers():\n    print(x, y)\n    break\n</code></pre> <pre>{'month': datetime.datetime(1949, 1, 1, 0, 0)}\n112\n</pre> <p>The data is as simple as can be: it consists of a sequence of months and values representing the total number of international airline passengers per month. Our goal is going to be to predict the number of passengers for the next month at each step. Notice that because the dataset is small  -- which is usually the case for time series -- we could just fit a model from scratch each month. However for the sake of example we're going to train a single model online. Although the overall performance might be potentially weaker, training a time series model online has the benefit of being scalable if, say, you have have thousands of time series to manage.</p> <p>We'll start with a very simple model where the only feature will be the ordinal date of each month. This should be able to capture some of the underlying trend. </p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import preprocessing\n\n\ndef get_ordinal_date(x):\n    return {'ordinal_date': x['month'].toordinal()}\n\n\nmodel = compose.Pipeline(\n    ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression())\n)\n</code></pre> <p>We'll write down a function to evaluate the model. This will go through each observation in the dataset and update the model as it goes on. The prior predictions will be stored along with the true values and will be plotted together. </p> <pre><code>from river import metrics\nfrom river import utils\nimport matplotlib.pyplot as plt\n\n\ndef evaluate_model(model): \n\n    metric = utils.Rolling(metrics.MAE(), 12)\n\n    dates = []\n    y_trues = []\n    y_preds = []\n\n    for x, y in datasets.AirlinePassengers():\n\n        # Obtain the prior prediction and update the model in one go\n        y_pred = model.predict_one(x)\n        model.learn_one(x, y)\n\n        # Update the error metric\n        metric.update(y, y_pred)\n\n        # Store the true value and the prediction\n        dates.append(x['month'])\n        y_trues.append(y)\n        y_preds.append(y_pred)\n\n    # Plot the results\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.grid(alpha=0.75)\n    ax.plot(dates, y_trues, lw=3, color='#2ecc71', alpha=0.8, label='Ground truth')\n    ax.plot(dates, y_preds, lw=3, color='#e74c3c', alpha=0.8, label='Prediction')\n    ax.legend()\n    ax.set_title(metric)\n</code></pre> <p>Let's evaluate our first model.</p> <pre><code>evaluate_model(model)\n</code></pre> <pre>&lt;Figure size 720x432 with 1 Axes&gt;\n</pre>  <p>The model has captured a trend but not the right one. Indeed it thinks the trend is linear whereas we can visually see that the growth of the data increases with time. In other words the second derivative of the series is positive. This is a well know problem in time series forecasting and there are thus many ways to handle it; for example by using a Box-Cox transform. However we are going to do something a bit different, and instead linearly detrend the series using a <code>TargetStandardScaler</code>.</p> <pre><code>from river import stats\n\n\nmodel = compose.Pipeline(\n    ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(intercept_lr=0)),\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <pre>&lt;Figure size 720x432 with 1 Axes&gt;\n</pre>  <p>Now let's try and capture the monthly trend by one-hot encoding the month name.</p> <pre><code>import calendar\n\n\ndef get_month(x):\n    return {\n        calendar.month_name[month]: month == x['month'].month\n        for month in range(1, 13)\n    }\n\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n        ('month', compose.FuncTransformer(get_month)),\n    )),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(intercept_lr=0))\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <pre>&lt;Figure size 720x432 with 1 Axes&gt;\n</pre>  <p>This seems pretty decent. We can take a look at the weights of the linear regression to get an idea of the importance of each feature.</p> <pre><code>model.regressor['lin_reg'].weights\n</code></pre> <pre>\n{\n    'January': -0.13808091575141299,\n    'February': -0.18716063793638954,\n    'March': -0.026469206216021102,\n    'April': -0.03500685108350436,\n    'May': -0.013638742192777328,\n    'June': 0.16194267303548826,\n    'July': 0.31995865445067634,\n    'August': 0.2810396556938982,\n    'September': 0.03834350518076595,\n    'October': -0.11655850082390988,\n    'November': -0.2663497734491209,\n    'December': -0.15396048501165746,\n    'ordinal_date': 1.0234863735122575\n}\n</pre> <p>As could be expected the months of July and August have the highest weights because these are the months where people typically go on holiday abroad. The month of December has a low weight because this is a month of festivities in most of the Western world where people usually stay at home.</p> <p>Our model seems to understand which months are important, but it fails to see that the importance of each month grows multiplicatively as the years go on. In other words our model is too shy. We can fix this by increasing the learning rate of the <code>LinearRegression</code>'s optimizer.</p> <pre><code>from river import optim\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n        ('month', compose.FuncTransformer(get_month)),\n    )),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(\n        intercept_lr=0,\n        optimizer=optim.SGD(0.03)\n    ))\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <pre>&lt;Figure size 720x432 with 1 Axes&gt;\n</pre>  <p>This is starting to look good! Naturally in production we would tune the learning rate, ideally in real-time.</p> <p>Before finishing, we're going to introduce a cool feature extraction trick based on radial basis function kernels. The one-hot encoding we did on the month is a good idea but if you think about it is a bit rigid. Indeed the value of each feature is going to be 0 or 1, depending on the month of each observation. We're basically saying that the month of September is as distant to the month of August as it is to the month of March. Of course this isn't true, and it would be nice if our features would reflect this. To do so we can simply calculate the distance between the month of each observation and all the months in the calendar. Instead of simply computing the distance linearly, we're going to use a so-called Gaussian radial basic function kernel. This is a bit of a mouthful but for us it boils down to a simple formula, which is:</p> \\[d(i, j) = exp(-\\frac{(i - j)^2}{2\\sigma^2})\\] <p>Intuitively this computes a similarity between two months -- denoted by \\(i\\) and \\(j\\) -- which decreases the further apart they are from each other. The \\(sigma\\) parameter can be seen as a hyperparameter than can be tuned -- in the following snippet we'll simply ignore it. The thing to take away is that this results in smoother predictions than when using a one-hot encoding scheme, which is often a desirable property. You can also see trick in action in this nice presentation.</p> <pre><code>import math\n\ndef get_month_distances(x):\n    return {\n        calendar.month_name[month]: math.exp(-(x['month'].month - month) ** 2)\n        for month in range(1, 13)\n    }\n\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n        ('month_distances', compose.FuncTransformer(get_month_distances)),\n    )),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(\n        intercept_lr=0,\n        optimizer=optim.SGD(0.03)\n    ))\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <pre>&lt;Figure size 720x432 with 1 Axes&gt;\n</pre>  <p>We've managed to get a good looking prediction curve with a reasonably simple model. What's more our model has the advantage of being interpretable and easy to debug. There surely are more rocks to squeeze (e.g. tune the hyperparameters, use an ensemble model, etc.) but we'll leave that as an exercice to the reader.</p> <p>As a finishing touch we'll rewrite our pipeline using the <code>|</code> operator, which is called a \"pipe\".</p> <pre><code>extract_features = compose.TransformerUnion(get_ordinal_date, get_month_distances)\n\nscale = preprocessing.StandardScaler()\n\nlearn = linear_model.LinearRegression(\n    intercept_lr=0,\n    optimizer=optim.SGD(0.03)\n)\n\nmodel = extract_features | scale | learn\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <pre>&lt;Figure size 720x432 with 1 Axes&gt;\n</pre>"},{"location":"examples/content-personalization/","title":"Content personalization","text":""},{"location":"examples/content-personalization/#without-context","title":"Without context","text":"<p>This example takes inspiration from Vowpal Wabbit's excellent tutorial.</p> <p>Content personalization is about taking into account user preferences. It's a special case of recommender systems. Ideally, side-information should be taken into account in addition to the user. But we'll start with something simpler. We'll assume that each user has stable preferences that are independent of the context. We capture this by implementing a \"reward\" function.</p> <pre><code>users = ['Tom', 'Anna']\nitems = {'politics', 'sports', 'music', 'food', 'finance', 'health', 'camping'}\n\ndef get_reward(user, item) -&gt; bool:\n    if user == 'Tom':\n        return item in {'music', 'politics'}\n    if user == 'Anna':\n        return item in {'politics', 'sports'}\n</code></pre> <p>Measuring the performance of a recommendation is not straightforward, mostly because of the interactive aspect of recommender systems. In a real situation, recommendations are presented to a user, and the user gives feedback indicating whether they like what they have been recommended or not. This feedback loop can't be captured entirely by a historical dataset. Some kind of simulator is required to generate recommendations and capture feedback. We already have a reward function. Now let's implement a simulation function.</p> <pre><code>import random\nimport matplotlib.pyplot as plt\n\ndef plot_ctr(ctr):\n    plt.plot(range(1, len(ctr) + 1), ctr)\n    plt.xlabel('n_iterations', fontsize=14)\n    plt.ylabel('CTR', fontsize=14)\n    plt.ylim([0, 1])\n    plt.title(f'final CTR: {ctr[-1]:.2%}', fontsize=14)\n    plt.grid()\n\ndef simulate(n, reward_func, model, seed):\n\n    rng = random.Random(seed)\n    n_clicks = 0\n    ctr = []  # click-through rate along time\n\n    for i in range(n):\n\n        # Pick a user at random\n        user = rng.choice(users)\n\n        # Make a single recommendation\n        item = model.rank(user, items=items)[0]\n\n        # Measure the reward\n        clicked = reward_func(user, item)\n        n_clicks += clicked\n        ctr.append(n_clicks / (i + 1))\n\n        # Update the model\n        model.learn_one(user, item, clicked)\n\n    plot_ctr(ctr)\n</code></pre> <p>This simulation function does quite a few things. It can be seen as a simple reinforcement learning simulation. It samples a user, and then ask the model to provide a single recommendation. The user then gives as to whether they liked the recommendation or not. Crucially, the user doesn't tell us what item they would have liked. We could model this as a multi-class classification problem if that were the case.</p> <p>The strategy parameter determines the mechanism used to generate the recommendations. The <code>'best'</code> strategy means that the items are each scored by the model, and are then ranked from the most preferred to the least preferred. Here the most preferred item is the one which gets recommended. But you could imagine all sorts of alternative ways to proceed.</p> <p>We can first evaluate a recommended which acts completely at random. It assigns a random preference to each item, regardless of the user.</p> <pre><code>from river import reco\n\nmodel = reco.RandomNormal(seed=10)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>  <p>We can see that the click-through rate (CTR) oscillates around 28.74%. In fact, this model is expected to be correct <code>100 * (2 / 7)% = 28.57%</code> of the time. Indeed, each user likes two items, and there are seven items in total.</p> <p>Let's now use the <code>Baseline</code> recommended. This one models each preference as the following sum:</p> \\[preference = \\bar{y} + b_{u} + b_{i}\\] <p>where</p> <ul> <li>\\(\\bar{y}\\) is the average CTR overall</li> <li>\\(b_{u}\\) is the average CTR per user minus \\(\\bar{y}\\) -- it's therefore called a bias</li> <li>\\(b_{i}\\) is the average CTR per item minus \\(\\bar{y}\\)</li> </ul> <p>This model is considered to be a baseline because it doesn't actually learn what items are preferred by each user. Instead it models each user and item separately. We shouldn't expect it to be a strong model. It should however do better than the random model used above.</p> <pre><code>model = reco.Baseline(seed=10)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>  <p>This baseline model seems perfect, which is surprising. The reason why it works so well is because both users have in common that they both like politics. The model therefore learns that the <code>'politics'</code> is a good item to recommend.</p> <pre><code>model.i_biases\n</code></pre> <pre>\ndefaultdict(Zeros (), {\n    'politics': 0.0,\n    'music': 0.0,\n    'finance': 0.0,\n    'sports': 0.0,\n    'camping': 0.0,\n    'food': 0.0,\n    'health': 0.0\n})\n</pre> <p>The model is not as performant if we use a reward function where both users have different preferences.</p> <pre><code>simulate(\n    5_000,\n    reward_func=lambda user, item: (\n        item in {'music', 'politics'} if user == \"Tom\" else\n        item in {'food', 'sports'}\n    ),\n    model=model,\n    seed=42\n)\n</code></pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>  <p>A good recommender model should at the very least understand what kind of items each user prefers. One of the simplest and yet performant way to do this is Simon Funk's SGD method he developped for the Netflix challenge and wrote about here. It models each user and each item as latent vectors. The dot product of these two vectors is the expected preference of the user for the item.</p> <pre><code>model = reco.FunkMF(seed=10)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>  <p>We can see that this model learns what items each user enjoys very well. Of course, there are some caveats. In our simulation, we ask the model to recommend the item most likely to be preferred for each user. Indeed, we rank all the items and pick the item at the top of the list. We do this many times for only two users.</p> <p>This is of course not realistic. Users will get fed up with recommendations if they're always shown the same item. It's important to include diversity into recommendations, and to let the model explore other options instead of always focusing on the item with the highest score. This is where evaluating recommender systems gets tricky: the reward function itself is difficult to model.</p> <p>We will keep ignoring these caveats in this notebook. Instead we will focus on a different concern: making recommendations when context is involved.</p>"},{"location":"examples/content-personalization/#with-context","title":"With context","text":"<p>We'll add some context by making it so that user preferences change depending on the time the day. Very simply, preferences might change from morning to afternoon. This is captured by the following reward function.</p> <pre><code>times_of_day = ['morning', 'afternoon']\n\ndef get_reward(user, item, context):\n    if user == 'Tom':\n        if context['time_of_day'] == 'morning':\n            return item == 'politics'\n        if context['time_of_day'] == 'afternoon':\n            return item == 'music'\n    if user == 'Anna':\n        if context['time_of_day'] == 'morning':\n            return item == 'sports'\n        if context['time_of_day'] == 'afternoon':\n            return item == 'politics'\n</code></pre> <p>We have to update our simulation function to generate a random context at each step. We also want our model to use it for recommending items as well as learning.</p> <pre><code>def simulate(n, reward_func, model, seed):\n\n    rng = random.Random(seed)\n    n_clicks = 0\n    ctr = []\n\n    for i in range(n):\n\n        user = rng.choice(users)\n\n        # New: pass a context\n        context = {'time_of_day': rng.choice(times_of_day)}\n        item = model.rank(user, items, context)[0]\n\n        clicked = reward_func(user, item, context)\n        n_clicks += clicked\n        ctr.append(n_clicks / (i + 1))\n\n        # New: pass a context\n        model.learn_one(user, item, clicked, context)\n\n    plot_ctr(ctr)\n</code></pre> <p>Not all models are capable of taking into account context. For instance, the <code>FunkMF</code> model only models users and items. It completely ignores the context, even when we provide one. All recommender models inherit from the base <code>Recommender</code> class. They also have a property which indicates whether or not they are able to handle context:</p> <pre><code>model = reco.FunkMF(seed=10)\nmodel.is_contextual\n</code></pre> <pre>False\n</pre> <p>Let's see well it performs.</p> <pre><code>simulate(5_000, get_reward, model, seed=42)\n</code></pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>  <p>The performance has roughly been divided by half. This is most likely because there are now two times of day, and if the model has learnt preferences for one time of the day, then it's expected to be wrong half of the time.</p> <p>Before delving into recsys models that can handle context, a simple hack is to notice that we can append the time of day to the user. This effectively results in new users which our model can distinguish between. We could apply this trick during the simulation, but we can also override the behavior of the <code>learn_one</code> and <code>rank</code> methods of our model.</p> <pre><code>class FunkMFWithHack(reco.FunkMF):\n\n    def learn_one(self, user, item, reward, context):\n        user = f\"{user}@{context['time_of_day']}\"\n        return super().learn_one(user, item, reward, context)\n\n    def rank(self, user, items, context):\n        user = f\"{user}@{context['time_of_day']}\"\n        return super().rank(user, items, context)\n\nmodel = FunkMFWithHack(seed=29)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>  <p>We can verify that the model has learnt the correct preferences by looking at the expected preference for each <code>(user, item)</code> pair.</p> <pre><code>import pandas as pd\n\n(\n    pd.DataFrame(\n        {\n            'user': user,\n            'item': item,\n            'preference': model.predict_one(user, item)\n        }\n        for user in model.u_latents\n        for item in model.i_latents\n    )\n    .pivot('user', 'item')\n    .style.highlight_max(color='lightgreen', axis='columns')\n)\n</code></pre>       preference   item camping finance food health music politics sports   user                   Anna@afternoon 0.069222 -0.018105 0.035563 0.109751 0.168885 1.000000 -0.059041   Anna@morning -0.011807 -0.050296 0.000000 0.000000 -0.007567 -0.038986 -0.045754   Tom@afternoon -0.074328 0.060644 -0.026601 0.070561 1.000000 0.164659 -0.229550   Tom@morning 0.061163 -0.028562 -0.000407 0.090628 0.065313 1.000000 -0.050107"},{"location":"examples/debugging-a-pipeline/","title":"Debugging a pipeline","text":"<p><code>river</code> encourages users to make use of pipelines. The biggest pain point of pipelines is that it can be hard to understand what's happening to the data, especially when the pipeline is complex. Fortunately the <code>Pipeline</code> class has a <code>debug_one</code> method that can help out.</p> <p>Let's look at a fairly complex pipeline for predicting the number of bikes in 5 bike stations from the city of Toulouse. It doesn't matter if you understand the pipeline or not; the point of this notebook is to learn how to introspect a pipeline.</p> <pre><code>import datetime as dt\nfrom river import compose\nfrom river import datasets\nfrom river import feature_extraction\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\nfrom river import stats\nfrom river import stream\n\n\nX_y = datasets.Bikes()\nX_y = stream.simulate_qa(X_y, moment='moment', delay=dt.timedelta(minutes=30))\n\ndef add_time_features(x):\n    return {\n        **x,\n        'hour': x['moment'].hour,\n        'day': x['moment'].weekday()\n    }\n\nmodel = add_time_features\nmodel |= (\n    compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind') +\n    feature_extraction.TargetAgg(by=['station', 'hour'], how=stats.Mean()) +\n    feature_extraction.TargetAgg(by='station', how=stats.EWMean())\n)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression()\n\nmetric = metrics.MAE()\n\nquestions = {}\n\nfor i, x, y in X_y:\n    # Question\n    is_question = y is None\n    if is_question:\n        y_pred = model.predict_one(x)\n        questions[i] = y_pred\n\n    # Answer\n    else:\n        metric.update(y, questions[i])\n        model = model.learn_one(x, y)\n\n        if i &gt;= 30000 and i % 30000 == 0:\n            print(i, metric)\n</code></pre> <pre>30000 MAE: 2.220942\n</pre> <pre>60000 MAE: 2.270271\n</pre> <pre>90000 MAE: 2.301302\n</pre> <pre>120000 MAE: 2.275876\n</pre> <pre>150000 MAE: 2.275224\n</pre> <pre>180000 MAE: 2.289347\n</pre> <p>Let's start by looking at the pipeline. You can click each cell to display the current state for each step of the pipeline.</p> <pre><code>model\n</code></pre> <pre>add_time_features</pre><code> def add_time_features(x):     return {         **x,         'hour': x['moment'].hour,         'day': x['moment'].weekday()     }  </code><pre>['clouds', 'humidity', 'pressure', 'temperature', 'wind']</pre><code>(   clouds   humidity   pressure   temperature   wind )  </code><pre>y_mean_by_station_and_hour</pre><code>(   by=['station', 'hour']   how=Mean ()   target_name=\"y\" )  </code><pre>y_ewm_0.5_by_station</pre><code>(   by=['station']   how=EWMean (     alpha=0.5   )   target_name=\"y\" )  </code><pre>StandardScaler</pre><code>(   with_std=True )  </code><pre>LinearRegression</pre><code>(   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () )  </code> <p>As mentioned above the <code>Pipeline</code> class has a <code>debug_one</code> method. You can use this at any point you want to visualize what happen to an input <code>x</code>. For example, let's see what happens to the last seen <code>x</code>.</p> <pre><code>print(model.debug_one(x))\n</code></pre> <pre>0. Input\n--------\nclouds: 88 (int)\ndescription: overcast clouds (str)\nhumidity: 84 (int)\nmoment: 2016-10-05 09:57:18 (datetime)\npressure: 1,017.34000 (float)\nstation: pomme (str)\ntemperature: 17.45000 (float)\nwind: 1.95000 (float)\n\n1. add_time_features\n--------------------\nclouds: 88 (int)\nday: 2 (int)\ndescription: overcast clouds (str)\nhour: 9 (int)\nhumidity: 84 (int)\nmoment: 2016-10-05 09:57:18 (datetime)\npressure: 1,017.34000 (float)\nstation: pomme (str)\ntemperature: 17.45000 (float)\nwind: 1.95000 (float)\n\n2. Transformer union\n--------------------\n    2.0 Select\n    ----------\n    clouds: 88 (int)\n    humidity: 84 (int)\n    pressure: 1,017.34000 (float)\n    temperature: 17.45000 (float)\n    wind: 1.95000 (float)\n\n    2.1 TargetAgg\n    -------------\n    y_mean_by_station_and_hour: 7.89396 (float)\n\n    2.2 TargetAgg1\n    --------------\n    y_ewm_0.5_by_station: 11.80372 (float)\n\nclouds: 88 (int)\nhumidity: 84 (int)\npressure: 1,017.34000 (float)\ntemperature: 17.45000 (float)\nwind: 1.95000 (float)\ny_ewm_0.5_by_station: 11.80372 (float)\ny_mean_by_station_and_hour: 7.89396 (float)\n\n3. StandardScaler\n-----------------\nclouds: 1.54778 (float)\nhumidity: 1.16366 (float)\npressure: 0.04916 (float)\ntemperature: -0.51938 (float)\nwind: -0.69426 (float)\ny_ewm_0.5_by_station: 0.19214 (float)\ny_mean_by_station_and_hour: -0.26013 (float)\n\n4. LinearRegression\n-------------------\nName                         Value      Weight     Contribution  \n                 Intercept    1.00000    9.22316        9.22316  \n      y_ewm_0.5_by_station    0.19214    9.26418        1.78000  \n                  humidity    1.16366    1.01252        1.17823  \n               temperature   -0.51938   -0.42112        0.21872  \n                      wind   -0.69426   -0.04088        0.02838  \n                  pressure    0.04916    0.18137        0.00892  \ny_mean_by_station_and_hour   -0.26013    0.19801       -0.05151  \n                    clouds    1.54778   -0.32697       -0.50608  \n\nPrediction: 11.87982\n</pre> <p>The pipeline does quite a few things, but using <code>debug_one</code> shows what happens step by step. This is really useful for checking that the pipeline is behaving as you're expecting it too. Remember that you can <code>debug_one</code> whenever you wish, be it before, during, or after training a model.</p>"},{"location":"examples/imbalanced-learning/","title":"Working with imbalanced data","text":"<p>In machine learning it is quite usual to have to deal with imbalanced dataset. This is particularly true in online learning for tasks such as fraud detection and spam classification. In these two cases, which are binary classification problems, there are usually many more 0s than 1s, which generally hinders the performance of the classifiers we thrown at them.</p> <p>As an example we'll use the credit card dataset available in <code>river</code>. We'll first use a <code>collections.Counter</code> to count the number of 0s and 1s in order to get an idea of the class balance.</p> <pre><code>import collections\nfrom river import datasets\n\nX_y = datasets.CreditCard()\n\ncounts = collections.Counter(y for _, y in X_y)\n\nfor c, count in counts.items():\n    print(f'{c}: {count} ({count / sum(counts.values()):.5%})')\n</code></pre> <pre>0: 284315 (99.82725%)\n</pre> <pre>1: 492 (0.17275%)\n</pre>"},{"location":"examples/imbalanced-learning/#baseline","title":"Baseline","text":"<p>The dataset is quite unbalanced. For each 1 there are about 578 0s. Let's now train a logistic regression with default parameters and see how well it does. We'll measure the ROC AUC score.</p> <pre><code>from river import linear_model\nfrom river import metrics\nfrom river import evaluate\nfrom river import preprocessing\n\n\nX_y = datasets.CreditCard()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression()\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre>ROCAUC: 89.11%\n</pre>"},{"location":"examples/imbalanced-learning/#importance-weighting","title":"Importance weighting","text":"<p>The performance is already quite acceptable, but as we will now see we can do even better. The first thing we can do is to add weight to the 1s by using the <code>weight_pos</code> argument of the <code>Log</code> loss function.</p> <pre><code>from river import optim\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(\n        loss=optim.losses.Log(weight_pos=5)\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre>ROCAUC: 91.43%\n</pre>"},{"location":"examples/imbalanced-learning/#focal-loss","title":"Focal loss","text":"<p>The deep learning for object detection community has produced a special loss function for imbalanced learning called focal loss. We are doing binary classification, so we can plug the binary version of focal loss into our logistic regression and see how well it fairs.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(loss=optim.losses.BinaryFocalLoss(2, 1))\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre>ROCAUC: 91.31%\n</pre>"},{"location":"examples/imbalanced-learning/#under-sampling-the-majority-class","title":"Under-sampling the majority class","text":"<p>Adding importance weights only works with gradient-based models (which includes neural networks). A more generic, and potentially more effective approach, is to use undersamplig and oversampling. As an example, we'll under-sample the stream so that our logistic regression encounter 20% of 1s and 80% of 0s. Under-sampling has the additional benefit of requiring less training steps, and thus reduces the total training time.</p> <pre><code>from river import imblearn\n\nmodel = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomUnderSampler(\n        classifier=linear_model.LogisticRegression(),\n        desired_dist={0: .8, 1: .2},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre>ROCAUC: 94.75%\n</pre> <p>The <code>RandomUnderSampler</code> class is a wrapper for classifiers. This is represented by a rectangle around the logistic regression bubble when we visualize the model.</p> <pre><code>model\n</code></pre> <pre>StandardScaler</pre><code>(   with_std=True )  </code><pre>RandomUnderSampler</pre><code>(   classifier=LogisticRegression (     optimizer=SGD (       lr=Constant (         learning_rate=0.01       )     )     loss=Log (       weight_pos=1.       weight_neg=1.     )     l2=0.     l1=0.     intercept_init=0.     intercept_lr=Constant (       learning_rate=0.01     )     clip_gradient=1e+12     initializer=Zeros ()   )   desired_dist={0: 0.8, 1: 0.2}   seed=42 )  </code><pre>LogisticRegression</pre><code>(   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Log (     weight_pos=1.     weight_neg=1.   )   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () )  </code>"},{"location":"examples/imbalanced-learning/#over-sampling-the-minority-class","title":"Over-sampling the minority class","text":"<p>We can also attain the same class distribution by over-sampling the minority class. This will come at cost of having to train with more samples.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomOverSampler(\n        classifier=linear_model.LogisticRegression(),\n        desired_dist={0: .8, 1: .2},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre>ROCAUC: 91.71%\n</pre>"},{"location":"examples/imbalanced-learning/#sampling-with-a-desired-sample-size","title":"Sampling with a desired sample size","text":"<p>The downside of both <code>RandomUnderSampler</code> and <code>RandomOverSampler</code> is that you don't have any control on the amount of data the classifier trains on. The number of samples is adjusted so that the target distribution can be attained, either by under-sampling or over-sampling. However, you can do both at the same time and choose how much data the classifier will see. To do so, we can use the <code>RandomSampler</code> class. In addition to the desired class distribution, we can specify how much data to train on. The samples will both be under-sampled and over-sampled in order to fit your constraints. This is powerful because it allows you to control both the class distribution and the size of the training data (and thus the training time). In the following example we'll set it so that the model will train with 1 percent of the data.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomSampler(\n        classifier=linear_model.LogisticRegression(),\n        desired_dist={0: .8, 1: .2},\n        sampling_rate=.01,\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre>ROCAUC: 94.71%\n</pre>"},{"location":"examples/imbalanced-learning/#hybrid-approach","title":"Hybrid approach","text":"<p>As you might have guessed by now, nothing is stopping you from mixing imbalanced learning methods together. As an example, let's combine <code>sampling.RandomUnderSampler</code> and the <code>weight_pos</code> parameter from the <code>optim.losses.Log</code> loss function.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomUnderSampler(\n        classifier=linear_model.LogisticRegression(\n            loss=optim.losses.Log(weight_pos=5)\n        ),\n        desired_dist={0: .8, 1: .2},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre>ROCAUC: 96.52%\n</pre>"},{"location":"examples/quantile-regression-uncertainty/","title":"Handling uncertainty with quantile regression","text":"<pre><code>%matplotlib inline\n</code></pre> <p>Quantile regression is useful when you're not so much interested in the accuracy of your model, but rather you want your model to be good at ranking observations correctly. The typical way to perform quantile regression is to use a special loss function, namely the quantile loss. The quantile loss takes a parameter, \\(\\alpha\\) (alpha), which indicates which quantile the model should be targeting. In the case of \\(\\alpha = 0.5\\), then this is equivalent to asking the model to predict the median value of the target, and not the most likely value which would be the mean. </p> <p>A nice thing we can do with quantile regression is to produce a prediction interval for each prediction. Indeed, if we predict the lower and upper quantiles of the target then we will be able to obtain a \"trust region\" in between which the true value is likely to belong. Of course, the likeliness will depend on the chosen quantiles. For a slightly more detailed explanation see this blog post.</p> <p>As an example, let us take the simple nowcasting model we built in another notebook. Instead of predicting the mean value of the target distribution, we will predict the 5th, 50th, 95th quantiles. This will require training three separate models, so we will encapsulate the model building logic in a function called <code>make_model</code>. We also have to slightly adapt the training loop, but not by much. Finally, we will draw the prediction interval along with the predictions from for 50th quantile (i.e. the median) and the true values.</p> <pre><code>import calendar\nimport math\nimport matplotlib.pyplot as plt\nfrom river import compose\nfrom river import datasets\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\nfrom river import stats\n\n\ndef get_ordinal_date(x):\n    return {'ordinal_date': x['month'].toordinal()}    \n\n\ndef get_month_distances(x):\n    return {\n        calendar.month_name[month]: math.exp(-(x['month'].month - month) ** 2)\n        for month in range(1, 13)\n    }\n\n\ndef make_model(alpha):\n\n    extract_features = compose.TransformerUnion(get_ordinal_date, get_month_distances)\n\n    scale = preprocessing.StandardScaler()\n\n    learn = linear_model.LinearRegression(\n        intercept_lr=0,\n        optimizer=optim.SGD(0.03),\n        loss=optim.losses.Quantile(alpha=alpha)\n    )\n\n    model = extract_features | scale | learn\n    model = preprocessing.TargetStandardScaler(regressor=model)\n\n    return model\n\nmetric = metrics.MAE()\n\nmodels = {\n    'lower': make_model(alpha=0.05),\n    'center': make_model(alpha=0.5),\n    'upper': make_model(alpha=0.95)\n}\n\ndates = []\ny_trues = []\ny_preds = {\n    'lower': [],\n    'center': [],\n    'upper': []\n}\n\nfor x, y in datasets.AirlinePassengers():\n    y_trues.append(y)\n    dates.append(x['month'])\n\n    for name, model in models.items():\n        y_preds[name].append(model.predict_one(x))\n        model.learn_one(x, y)\n\n    # Update the error metric\n    metric.update(y, y_preds['center'][-1])\n\n# Plot the results\nfig, ax = plt.subplots(figsize=(10, 6))\nax.grid(alpha=0.75)\nax.plot(dates, y_trues, lw=3, color='#2ecc71', alpha=0.8, label='Truth')\nax.plot(dates, y_preds['center'], lw=3, color='#e74c3c', alpha=0.8, label='Prediction')\nax.fill_between(dates, y_preds['lower'], y_preds['upper'], color='#e74c3c', alpha=0.3, label='Prediction interval')\nax.legend()\nax.set_title(metric);\n</code></pre> <pre>&lt;Figure size 720x432 with 1 Axes&gt;\n</pre>  <p>An important thing to note is that the prediction interval we obtained should not be confused with a confidence interval. Simply put, a prediction interval represents uncertainty for where the true value lies, whereas a confidence interval encapsulates the uncertainty on the prediction. You can find out more by reading this CrossValidated post.</p>"},{"location":"examples/the-art-of-using-pipelines/","title":"The art of using pipelines","text":"<p>Pipelines are a natural way to think about a machine learning system. Indeed with some practice a data scientist can visualise data \"flowing\" through a series of steps. The input is typically some raw data which has to be processed in some manner. The goal is to represent the data in such a way that is can be ingested by a machine learning algorithm. Along the way some steps will extract features, while others will normalize the data and remove undesirable elements. Pipelines are simple, and yet they are a powerful way of designing sophisticated machine learning systems.</p> <p>Both scikit-learn and pandas make it possible to use pipelines. However it's quite rare to see pipelines being used in practice (at least on Kaggle). Sometimes you get to see people using scikit-learn's <code>pipeline</code> module, however the <code>pipe</code> method from <code>pandas</code> is sadly underappreciated. A big reason why pipelines are not given much love is that it's easier to think of batch learning in terms of a script or a notebook. Indeed many people doing data science seem to prefer a procedural style to a declarative style. Moreover in practice pipelines can be a bit rigid if one wishes to do non-orthodox operations.</p> <p>Although pipelines may be a bit of an odd fit for batch learning, they make complete sense when they are used for online learning. Indeed the UNIX philosophy has advocated the use of pipelines for data processing for many decades. If you can visualise data as a stream of observations then using pipelines should make a lot of sense to you. We'll attempt to convince you by writing a machine learning algorithm in a procedural way and then converting it to a declarative pipeline in small steps. Hopefully by the end you'll be convinced, or not!</p> <p>In this notebook we'll manipulate data from the Kaggle Recruit Restaurants Visitor Forecasting competition. The data is directly available through <code>river</code>'s <code>datasets</code> module.</p> <pre><code>from pprint import pprint\nfrom river import datasets\n\nfor x, y in datasets.Restaurants():\n    pprint(x)\n    pprint(y)\n    break\n</code></pre> <pre><code>{'area_name': 'T\u014dky\u014d-to Nerima-ku Toyotamakita',\n 'date': datetime.datetime(2016, 1, 1, 0, 0),\n 'genre_name': 'Izakaya',\n 'is_holiday': True,\n 'latitude': 35.7356234,\n 'longitude': 139.6516577,\n 'store_id': 'air_04341b588bde96cd'}\n10\n</code></pre> <p>We'll start by building and running a model using a procedural coding style. The performance of the model doesn't matter, we're simply interested in the design of the model.</p> <pre><code>from river import feature_extraction\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\nfrom river import stats\nfrom river import utils\n\nmeans = (\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)),\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)),\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21))\n)\n\nscaler = preprocessing.StandardScaler()\nlin_reg = linear_model.LinearRegression()\nmetric = metrics.MAE()\n\nfor x, y in datasets.Restaurants():\n\n    # Derive date features\n    x['weekday'] = x['date'].weekday()\n    x['is_weekend'] = x['date'].weekday() in (5, 6)\n\n    # Process the rolling means of the target  \n    for mean in means:\n        x = {**x, **mean.transform_one(x)}\n        mean.learn_one(x, y)\n\n    # Remove the key/value pairs that aren't features\n    for key in ['store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude']:\n        x.pop(key)\n\n    # Rescale the data\n    x = scaler.learn_one(x).transform_one(x)\n\n    # Fit the linear regression\n    y_pred = lin_reg.predict_one(x)\n    lin_reg.learn_one(x, y)\n\n    # Update the metric using the out-of-fold prediction\n    metric.update(y, y_pred)\n\nprint(metric)\n</code></pre> <pre>MAE: 8.316538\n</pre> <p>We're not using many features. We can print the last <code>x</code> to get an idea of the features (don't forget they've been scaled!)</p> <pre><code>pprint(x)\n</code></pre> <pre><code>{'is_holiday': -0.23103573677646685,\n 'is_weekend': 1.6249280076334165,\n 'weekday': 1.0292832579142892,\n 'y_mean_by_store_id': -1.3980979075298516}\n</code></pre> <p>The above chunk of code is quite explicit but it's a bit verbose. The whole point of libraries such as <code>river</code> is to make life easier for users. Moreover there's too much space for users to mess up the order in which things are done, which increases the chance of there being target leakage. We'll now rewrite our model in a declarative fashion using a pipeline \u00e0 la sklearn.  </p> <pre><code>from river import compose\n\n\ndef get_date_features(x):\n    weekday =  x['date'].weekday()\n    return {'weekday': weekday, 'is_weekend': weekday in (5, 6)}\n\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('date_features', compose.FuncTransformer(get_date_features)),\n        ('last_7_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7))),\n        ('last_14_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14))),\n        ('last_21_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21)))\n    )),\n    ('drop_non_features', compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude')),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression())\n)\n\nmetric = metrics.MAE()\n\nfor x, y in datasets.Restaurants():\n\n    # Make a prediction without using the target\n    y_pred = model.predict_one(x)\n\n    # Update the model using the target\n    model.learn_one(x, y)\n\n    # Update the metric using the out-of-fold prediction\n    metric.update(y, y_pred)\n\nprint(metric)\n</code></pre> <pre>MAE: 8.41379\n</pre> <p>We use a <code>Pipeline</code> to arrange each step in a sequential order. A <code>TransformerUnion</code> is used to merge multiple feature extractors into a single transformer. The <code>for</code> loop is now much shorter and is thus easier to grok: we get the out-of-fold prediction, we fit the model, and finally we update the metric. This way of evaluating a model is typical of online learning, and so we put it wrapped it inside a function called <code>progressive_val_score</code> part of the <code>evaluate</code> module. We can use it to replace the <code>for</code> loop.</p> <pre><code>from river import evaluate\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('date_features', compose.FuncTransformer(get_date_features)),\n        ('last_7_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7))),\n        ('last_14_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14))),\n        ('last_21_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21)))\n    )),\n    ('drop_non_features', compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude')),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression())\n)\n\nevaluate.progressive_val_score(dataset=datasets.Restaurants(), model=model, metric=metrics.MAE())\n</code></pre> <pre>MAE: 8.41379\n</pre> <p>Notice that you couldn't have used the <code>progressive_val_score</code> method if you wrote the model in a procedural manner.</p> <p>Our code is getting shorter, but it's still a bit difficult on the eyes. Indeed there is a lot of boilerplate code associated with pipelines that can get tedious to write. However <code>river</code> has some special tricks up it's sleeve to save you from a lot of pain.</p> <p>The first trick is that the name of each step in the pipeline can be omitted. If no name is given for a step then <code>river</code> automatically infers one.</p> <pre><code>model = compose.Pipeline(\n    compose.TransformerUnion(\n        compose.FuncTransformer(get_date_features),\n        feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)),\n        feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)),\n        feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21))\n    ),\n    compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude'),\n    preprocessing.StandardScaler(),\n    linear_model.LinearRegression()\n)\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre>MAE: 8.41379\n</pre> <p>Under the hood a <code>Pipeline</code> inherits from <code>collections.OrderedDict</code>. Indeed this makes sense because if you think about it a <code>Pipeline</code> is simply a sequence of steps where each step has a name. The reason we mention this is because it means you can manipulate a <code>Pipeline</code> the same way you would manipulate an ordinary <code>dict</code>. For instance we can print the name of each step by using the <code>keys</code> method.</p> <pre><code>for name in model.steps:\n    print(name)\n</code></pre> <pre>TransformerUnion\n</pre> <pre>Discard\n</pre> <pre>StandardScaler\n</pre> <pre>LinearRegression\n</pre> <p>The first step is a <code>FeatureUnion</code> and it's string representation contains the string representation of each of it's elements. Not having to write names saves up some time and space and is certainly less tedious.</p> <p>The next trick is that we can use mathematical operators to compose our pipeline. For example we can use the <code>+</code> operator to merge <code>Transformer</code>s into a <code>TransformerUnion</code>. </p> <pre><code>model = compose.Pipeline(\n    compose.FuncTransformer(get_date_features) + \\\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)) + \\\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)) + \\\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21)),\n\n    compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude'),\n    preprocessing.StandardScaler(),\n    linear_model.LinearRegression()\n)\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre>MAE: 8.41379\n</pre> <p>Likewhise we can use the <code>|</code> operator to assemble steps into a <code>Pipeline</code>. </p> <pre><code>model = (\n    compose.FuncTransformer(get_date_features) +\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)) +\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)) +\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21))\n)\n\nto_discard = ['store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude']\n\nmodel = model | compose.Discard(*to_discard) | preprocessing.StandardScaler()\n\nmodel |= linear_model.LinearRegression()\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre>MAE: 8.41379\n</pre> <p>Hopefully you'll agree that this is a powerful way to express machine learning pipelines. For some people this should be quite remeniscent of the UNIX pipe operator. One final trick we want to mention is that functions are automatically wrapped with a <code>FuncTransformer</code>, which can be quite handy.</p> <pre><code>model = get_date_features\n\nfor n in [7, 14, 21]:\n    model += feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), n))\n\nmodel |= compose.Discard(*to_discard)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression()\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre>MAE: 8.41379\n</pre> <p>Naturally some may prefer the procedural style we first used because they find it easier to work with. It all depends on your style and you should use what you feel comfortable with. However we encourage you to use operators because we believe that this will increase the readability of your code, which is very important. To each their own!</p> <p>Before finishing we can take an interactive look at our pipeline.</p> <pre><code>model\n</code></pre> <pre>get_date_features</pre><code> def get_date_features(x):     weekday =  x['date'].weekday()     return {'weekday': weekday, 'is_weekend': weekday in (5, 6)}  </code><pre>y_mean_by_store_id</pre><code>(   by=['store_id']   how=Rolling (     obj=Mean ()     window_size=7   )   target_name=\"y\" )  </code><pre>y_mean_by_store_id</pre><code>(   by=['store_id']   how=Rolling (     obj=Mean ()     window_size=14   )   target_name=\"y\" )  </code><pre>y_mean_by_store_id</pre><code>(   by=['store_id']   how=Rolling (     obj=Mean ()     window_size=21   )   target_name=\"y\" )  </code><pre>~['area_name', 'date', 'genre_name', 'latitude', 'longitude', 'store_id']</pre><code>(   area_name   date   genre_name   latitude   longitude   store_id )  </code><pre>StandardScaler</pre><code>(   with_std=True )  </code><pre>LinearRegression</pre><code>(   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () )  </code>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/","title":"Part 1","text":"<p>Table of contents of this tutorial series on matrix factorization for recommender systems:</p> <ul> <li>Part 1 - Traditional Matrix Factorization methods for Recommender Systems</li> <li>Part 2 - Factorization Machines and Field-aware Factorization Machines</li> <li>Part 3 - Large scale learning and better predictive power with multiple pass learning</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#introduction","title":"Introduction","text":"<p>A recommender system is a software tool designed to generate and suggest items or entities to the users. Popular large scale examples include:</p> <ul> <li>Amazon (suggesting products)</li> <li>Facebook (suggesting posts in users' news feeds)</li> <li>Spotify (suggesting music)</li> </ul> <p>Social recommendation from graph (mostly used by social networks) are not covered in <code>river</code>. We focus on the general case, item recommendation. This problem can be represented with the user-item matrix:</p> \\[ \\normalsize \\begin{matrix}     &amp; \\begin{matrix} _1 &amp; _\\cdots &amp; _\\cdots &amp; _\\cdots &amp; _I \\end{matrix} \\\\     \\begin{matrix} _1 \\\\ _\\vdots \\\\ _\\vdots \\\\ _\\vdots \\\\ _U \\end{matrix} &amp;         \\begin{bmatrix}             {\\color{Red} ?} &amp; 2 &amp; \\cdots &amp; {\\color{Red} ?} &amp; {\\color{Red} ?} \\\\             {\\color{Red} ?} &amp; {\\color{Red} ?} &amp; \\cdots &amp; {\\color{Red} ?} &amp; 4.5 \\\\             \\vdots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\             3 &amp; {\\color{Red} ?} &amp; \\cdots &amp; {\\color{Red} ?} &amp; {\\color{Red} ?} \\\\             {\\color{Red} ?} &amp; {\\color{Red} ?} &amp; \\cdots &amp; 5 &amp; {\\color{Red} ?}         \\end{bmatrix} \\end{matrix} \\] <p>Where \\(U\\) and \\(I\\) are the number of user and item of the system, respectively. A matrix entry represents a user's preference for an item, it can be a rating, a like or dislike, etc. Because of the huge number of users and items compared to the number of observed entries, those matrices are very sparsed (usually less than 1% filled).</p> <p>Matrix Factorization (MF) is a class of collaborative filtering algorithms derived from Singular Value Decomposition (SVD). MF strength lies in its capacity to able to model high cardinality categorical variables interactions. This subfield boomed during the famous Netflix Prize contest in 2006, when numerous novel variants has been invented and became popular thanks to their attractive accuracy and scalability.</p> <p>MF approach seeks to fill the user-item matrix considering the problem as a matrix completion one. MF core idea assume a latent model learning its own representation of the users and the items in a lower latent dimensional space by factorizing the observed parts of the matrix.</p> <p>A factorized user or item is represented as a vector \\(\\mathbf{v}_u\\) or \\(\\mathbf{v}_i\\) composed of \\(k\\) latent factors, with \\(k &lt;&lt; U, I\\). Those learnt latent variables represent, for an item the various aspects describing it, and for a user its interests in terms of those aspects. The model then assume a user's choice or fondness is composed of a sum of preferences about the various aspects of the concerned item. This sum being the dot product between the latent vectors of a given user-item pair:</p> \\[ \\normalsize \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f} \\] <p>MF models weights are learnt in an online fashion, often with stochastic gradient descent as it provides relatively fast running time and good accuracy. There is a great and widely popular library named surprise that implements MF models (and others) but in contrast with <code>river</code> doesn't follow a pure online philosophy (all the data have to be loaded in memory and the API doesn't allow you to update your model with new data).</p> <p>Notes:</p> <ul> <li>In recent years, proposed deep learning techniques for recommendation tasks claim state of the art results. However, recent work (August 2019) showed that those promises can't be taken for granted and traditional MF methods are still relevant today.</li> <li>For more information about how the business value of recommender systems is measured and why they are one of the main success stories of machine learning, see the following literature survey (December 2019).</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#lets-start","title":"Let's start","text":"<p>In this tutorial, we are going to explore MF algorithms available in <code>river</code> and test them on a movie recommendation problem with the MovieLens 100K dataset. This latter is a collection of movie ratings (from 1 to 5) that includes various information about both the items and the users. We can access it from the river.datasets module:</p> <pre><code>import json\n\nfrom river import datasets\n\nfor x, y in datasets.MovieLens100K():\n    print(f'x = {json.dumps(x, indent=4)}')\n    print(f'y = {y}')\n    break\n</code></pre> <pre><code>x = {\n    \"user\": 259,\n    \"item\": 255,\n    \"timestamp\": 874731910000000000,\n    \"title\": \"My Best Friend's Wedding (1997)\",\n    \"release_date\": 866764800000000000,\n    \"genres\": \"comedy, romance\",\n    \"age\": 21.0,\n    \"gender\": \"M\",\n    \"occupation\": \"student\",\n    \"zip_code\": \"48823\"\n}\ny = 4.0\n</code></pre> <p>Let's define a routine to evaluate our different models on MovieLens 100K. Mean Absolute Error and Root Mean Squared Error will be our metrics printed alongside model's computation time and memory usage:</p> <pre><code>from river import metrics\nfrom river.evaluate import progressive_val_score\n\ndef evaluate(model, unpack_user_and_item=True):\n    X_y = datasets.MovieLens100K(unpack_user_and_item)\n    metric = metrics.MAE() + metrics.RMSE()\n    _ = progressive_val_score(X_y, model, metric, print_every=25_000, show_time=True, show_memory=True)\n</code></pre>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#naive-prediction","title":"Naive prediction","text":"<p>It's good practice in machine learning to start with a naive baseline and then iterate from simple things to complex ones observing progress incrementally. Let's start by predicting the target running mean as a first shot:</p> <pre><code>from river import dummy\nfrom river import stats\n\nmodel = dummy.StatisticRegressor(stats.Mean())\nevaluate(model, unpack_user_and_item=False)\n</code></pre> <pre><code>[25,000] MAE: 0.934259, RMSE: 1.124469 \u2013 00:00:00 \u2013 514 B\n[50,000] MAE: 0.923893, RMSE: 1.105 \u2013 00:00:01 \u2013 514 B\n[75,000] MAE: 0.937359, RMSE: 1.123696 \u2013 00:00:01 \u2013 514 B\n[100,000] MAE: 0.942162, RMSE: 1.125783 \u2013 00:00:02 \u2013 514 B\n</code></pre>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#baseline-model","title":"Baseline model","text":"<p>Now we can do machine learning and explore available models in river.reco module starting with the baseline model. It extends our naive prediction by adding to the global running mean two bias terms characterizing the user and the item discrepancy from the general tendency. The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} \\] <p>This baseline model can be viewed as a linear regression where the intercept is replaced by the target running mean with the users and the items one hot encoded.</p> <p>All machine learning models in <code>river</code> expect dicts as input with feature names as keys and feature values as values. Specifically, models from <code>river.reco</code> expect a <code>'user'</code> and an <code>'item'</code> entries without any type constraint on their values (i.e. can be strings or numbers), e.g.:</p> <pre><code>x = {\n    'user': 'Guido',\n    'item': \"Monty Python's Flying Circus\"\n}\n</code></pre> <p>Other entries, if exist, are simply ignored. This is quite useful as we don't need to spend time and storage doing one hot encoding.</p> <pre><code>from river import preprocessing\nfrom river import optim\nfrom river import reco\n\nbaseline_params = {\n    'optimizer': optim.SGD(0.025),\n    'l2': 0.,\n    'initializer': optim.initializers.Zeros()\n}\n\nmodel = preprocessing.PredClipper(\n    regressor=reco.Baseline(**baseline_params),\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761844, RMSE: 0.960972 \u2013 0:00:00.864336 \u2013 132.26 KB\n[50,000] MAE: 0.753292, RMSE: 0.951223 \u2013 0:00:01.737809 \u2013 191.78 KB\n[75,000] MAE: 0.754177, RMSE: 0.953376 \u2013 0:00:02.598330 \u2013 225.88 KB\n[100,000] MAE: 0.754651, RMSE: 0.954148 \u2013 0:00:03.464756 \u2013 240.29 KB\n</code></pre> <p>We won two tenth of MAE compared to our naive prediction (0.7546 vs 0.9421) meaning that significant information has been learnt by the model.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#funk-matrix-factorization-funkmf","title":"Funk Matrix Factorization (FunkMF)","text":"<p>It's the pure form of matrix factorization consisting of only learning the users and items latent representations as discussed in introduction. Simon Funk popularized its stochastic gradient descent optimization in 2006 during the Netflix Prize. The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] <p>Note: FunkMF is sometimes referred as Probabilistic Matrix Factorization which is an extended probabilistic version.</p> <pre><code>funk_mf_params = {\n    'n_factors': 10,\n    'optimizer': optim.SGD(0.05),\n    'l2': 0.1,\n    'initializer': optim.initializers.Normal(mu=0., sigma=0.1, seed=73)\n}\n\nmodel = preprocessing.PredClipper(\n    regressor=reco.FunkMF(**funk_mf_params),\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 1.070136, RMSE: 1.397014 \u2013 0:00:01.705144 \u2013 938.07 KB\n[50,000] MAE: 0.99174, RMSE: 1.290666 \u2013 0:00:03.466905 \u2013 1.13 MB\n[75,000] MAE: 0.961072, RMSE: 1.250842 \u2013 0:00:05.205363 \u2013 1.33 MB\n[100,000] MAE: 0.944883, RMSE: 1.227688 \u2013 0:00:06.934770 \u2013 1.5 MB\n</code></pre> <p>Results are equivalent to our naive prediction (0.9448 vs 0.9421). By only focusing on the users preferences and the items characteristics, the model is limited in his ability to capture different views of the problem. Despite its poor performance alone, this algorithm is quite useful combined in other models or when we need to build dense representations for other tasks.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#biased-matrix-factorization-biasedmf","title":"Biased Matrix Factorization (BiasedMF)","text":"<p>It's the combination of the Baseline model and FunkMF. The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] <p>Note: Biased Matrix Factorization name is used by some people but some others refer to it by SVD or Funk SVD. It's the case of Yehuda Koren and Robert Bell in Recommender Systems Handbook (Chapter 5 Advances in Collaborative Filtering) and of <code>surprise</code> library. Nevertheless, SVD could be confused with the original Singular Value Decomposition from which it's derived from, and Funk SVD could also be misleading because of the biased part of the model equation which doesn't come from Simon Funk's work. For those reasons, we chose to side with Biased Matrix Factorization which fits more naturally to it.</p> <pre><code>biased_mf_params = {\n    'n_factors': 10,\n    'bias_optimizer': optim.SGD(0.025),\n    'latent_optimizer': optim.SGD(0.05),\n    'weight_initializer': optim.initializers.Zeros(),\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.1, seed=73),\n    'l2_bias': 0.,\n    'l2_latent': 0.\n}\n\nmodel = preprocessing.PredClipper(\n    regressor=reco.BiasedMF(**biased_mf_params),\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761818, RMSE: 0.961057 \u2013 0:00:01.917323 \u2013 1.01 MB\n[50,000] MAE: 0.751667, RMSE: 0.949443 \u2013 0:00:03.825794 \u2013 1.28 MB\n[75,000] MAE: 0.749653, RMSE: 0.948723 \u2013 0:00:05.737369 \u2013 1.51 MB\n[100,000] MAE: 0.748559, RMSE: 0.947854 \u2013 0:00:07.666314 \u2013 1.69 MB\n</code></pre> <p>Results improved (0.7485 vs 0.7546) demonstrating that users and items latent representations bring additional information.</p> <p>To conclude this first tutorial about factorization models, let's review the important parameters to tune when dealing with this family of methods:</p> <ul> <li><code>n_factors</code>: the number of latent factors. The more you set, the more items aspects and users preferences you are going to learn. Too many will cause overfitting, <code>l2</code> regularization could help.</li> <li><code>*_optimizer</code>: the optimizers. Classic stochastic gradient descent performs well, finding the good learning rate will make the difference.</li> <li><code>initializer</code>: the latent weights initialization. Latent vectors have to be initialized with non-constant values. We generally sample them from a zero-mean normal distribution with small standard deviation.</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/","title":"Part 2","text":"<p>As seen in Part 1, strength of Matrix Factorization (MF) lies in its ability to deal with sparse and high cardinality categorical variables. In this second tutorial we will have a look at Factorization Machines (FM) algorithm and study how it generalizes the power of MF.</p> <p>Table of contents of this tutorial series on matrix factorization for recommender systems:</p> <ul> <li>Part 1 - Traditional Matrix Factorization methods for Recommender Systems</li> <li>Part 2 - Factorization Machines and Field-aware Factorization Machines</li> <li>Part 3 - Large scale learning and better predictive power with multiple pass learning</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#factorization-machines","title":"Factorization Machines","text":"<p>Steffen Rendel came up in 2010 with Factorization Machines, an algorithm able to handle any real valued feature vector, combining the advantages of general predictors with factorization models. It became quite popular in the field of online advertising, notably after winning several Kaggle competitions. The modeling technique starts with a linear regression to capture the effects of each variable individually:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} \\] <p>Then are added interaction terms to learn features relations. Instead of learning a single and specific weight per interaction (as in polynomial regression), a set of latent factors is learnt per feature (as in MF). An interaction is calculated by multiplying involved features product with their latent vectors dot product. The degree of factorization \u2014 or model order \u2014 represents the maximum number of features per interaction considered. The model equation for a factorization machine of degree \\(d\\) = 2 is defined as:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] <p>Where \\(\\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle\\) is the dot product of \\(j\\) and \\(j'\\) latent vectors:</p> \\[ \\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{j, f} \\cdot \\mathbf{v}_{j', f} \\] <p>Higher-order FM will be covered in a following section, just note that factorization models express their power in sparse settings, which is also where higher-order interactions are hard to estimate.</p> <p>Strong emphasis must be placed on feature engineering as it allows FM to mimic most factorization models and significantly impact its performance. High cardinality categorical variables one hot encoding is the most frequent step before feeding the model with data. For more efficiency, <code>river</code> FM implementation considers string values as categorical variables and automatically one hot encode them. FM models have their own module river.facto.</p> <p>## Mimic Biased Matrix Factorization (BiasedMF)</p> <p>Let's start with a simple example where we want to reproduce the Biased Matrix Factorization model we trained in the previous tutorial. For a fair comparison with Part 1 example, let's set the same evaluation framework:</p> <pre><code>from river import datasets\nfrom river import metrics\nfrom river.evaluate import progressive_val_score\n\ndef evaluate(model):\n    X_y = datasets.MovieLens100K()\n    metric = metrics.MAE() + metrics.RMSE()\n    _ = progressive_val_score(X_y, model, metric, print_every=25_000, show_time=True, show_memory=True)\n</code></pre> <p>In order to build an equivalent model we need to use the same hyper-parameters. As we can't replace FM intercept by the global running mean we won't be able to build the exact same model:</p> <pre><code>from river import compose\nfrom river import facto\nfrom river import preprocessing\nfrom river import optim\nfrom river import stats\n\nfm_params = {\n    'n_factors': 10,\n    'weight_optimizer': optim.SGD(0.025),\n    'latent_optimizer': optim.SGD(0.05),\n    'sample_normalization': False,\n    'l1_weight': 0.,\n    'l2_weight': 0.,\n    'l1_latent': 0.,\n    'l2_latent': 0.,\n    'intercept': 3,\n    'intercept_lr': .01,\n    'weight_initializer': optim.initializers.Zeros(),\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.1, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor |= facto.FMRegressor(**fm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: nan, RMSE: nan \u2013 00:00:04 \u2013 6.55 KB\n[50,000] MAE: nan, RMSE: nan \u2013 00:00:08 \u2013 6.55 KB\n[75,000] MAE: nan, RMSE: nan \u2013 00:00:12 \u2013 6.55 KB\n[100,000] MAE: nan, RMSE: nan \u2013 00:00:16 \u2013 6.55 KB\n</code></pre> <p>Both MAE are very close to each other (0.7486 vs 0.7485) showing that we almost reproduced reco.BiasedMF algorithm. The cost is a naturally slower running time as FM implementation offers more flexibility.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#feature-engineering-for-fm-models","title":"Feature engineering for FM models","text":"<p>Let's study the basics of how to properly encode data for FM models. We are going to keep using MovieLens 100K as it provides various feature types:</p> <pre><code>import json\n\nfor x, y in datasets.MovieLens100K():\n    print(f'x = {json.dumps(x, indent=4)}\\ny = {y}')\n    break\n</code></pre> <pre><code>x = {\n    \"user\": 259,\n    \"item\": 255,\n    \"timestamp\": 874731910000000000,\n    \"title\": \"My Best Friend's Wedding (1997)\",\n    \"release_date\": 866764800000000000,\n    \"genres\": \"comedy, romance\",\n    \"age\": 21.0,\n    \"gender\": \"M\",\n    \"occupation\": \"student\",\n    \"zip_code\": \"48823\"\n}\ny = 4.0\n</code></pre> <p>The features we are going to add to our model don't improve its predictive power. Nevertheless, they are useful to illustrate different methods of data encoding:</p> <ol> <li>Set-categorical variables</li> </ol> <p>We have seen that categorical variables are one hot encoded automatically if set to strings, in the other hand, set-categorical variables must be encoded explicitly by the user. A good way of doing so is to assign them a value of \\(1/m\\), where \\(m\\) is the number of elements of the sample set. It gives the feature a constant \"weight\" across all samples preserving model's stability. Let's create a routine to encode movies genres this way:</p> <pre><code>def split_genres(x):\n    genres = x['genres'].split(', ')\n    return {f'genre_{genre}': 1 / len(genres) for genre in genres}\n</code></pre> <ol> <li>Numerical variables</li> </ol> <p>In practice, transforming numerical features into categorical ones works better in most cases. Feature binning is the natural way, but finding good bins is sometimes more an art than a science. Let's encode users age with something simple:</p> <pre><code>def bin_age(x):\n    if x['age'] &lt;= 18:\n        return {'age_0-18': 1}\n    elif x['age'] &lt;= 32:\n        return {'age_19-32': 1}\n    elif x['age'] &lt; 55:\n        return {'age_33-54': 1}\n    else:\n        return {'age_55-100': 1}\n</code></pre> <p>Let's put everything together:</p> <pre><code>fm_params = {\n    'n_factors': 14,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.05, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.FMRegressor(**fm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: nan, RMSE: nan \u2013 00:00:10 \u2013 30.31 KB\n\n\n\n---------------------------------------------------------------------------\n\nKeyboardInterrupt                         Traceback (most recent call last)\n\n/var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_36090/4267340742.py in &lt;module&gt;\n     24 )\n     25\n---&gt; 26 evaluate(model)\n\n\n/var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_36090/2127757032.py in evaluate(model)\n      6     X_y = datasets.MovieLens100K(unpack_user_and_item=False)\n      7     metric = metrics.MAE() + metrics.RMSE()\n----&gt; 8     _ = progressive_val_score(X_y, model, metric, print_every=25_000, show_time=True, show_memory=True)\n\n\n~/projects/river/river/evaluate/progressive_validation.py in progressive_val_score(dataset, model, metric, moment, delay, print_every, show_time, show_memory, **print_kwargs)\n    238     )\n    239\n--&gt; 240     for checkpoint in checkpoints:\n    241\n    242         msg = f\"[{checkpoint['Step']:,d}] {metric}\"\n\n\n~/projects/river/river/evaluate/progressive_validation.py in _progressive_validation(dataset, model, metric, checkpoints, moment, delay, measure_time, measure_memory)\n     55             metric.update(y_true=y, y_pred=y_pred)\n     56         if model._supervised:\n---&gt; 57             model.learn_one(x=x, y=y, **kwargs)\n     58         else:\n     59             model.learn_one(x=x, **kwargs)\n\n\n~/projects/river/river/preprocessing/pred_clipper.py in learn_one(self, x, y, **kwargs)\n     54\n     55     def learn_one(self, x, y, **kwargs):\n---&gt; 56         self.regressor.learn_one(x=x, y=y, **kwargs)\n     57         return self\n     58\n\n\n~/projects/river/river/compose/pipeline.py in learn_one(self, x, y, **params)\n    502         last_step = next(steps)\n    503         if last_step._supervised:\n--&gt; 504             last_step.learn_one(x=x, y=y, **params)\n    505         else:\n    506             last_step.learn_one(x, **params)\n\n\n~/projects/river/river/facto/base.py in learn_one(self, x, y, sample_weight)\n     75             x = {j: xj / x_l2_norm for j, xj in x.items()}\n     76\n---&gt; 77         return self._learn_one(x, y, sample_weight=sample_weight)\n     78\n     79     def _ohe_cat_features(self, x):\n\n\n~/projects/river/river/facto/base.py in _learn_one(self, x, y, sample_weight)\n    105\n    106         # Update the latent weights\n--&gt; 107         self._update_latents(x, g_loss)\n    108\n    109         return self\n\n\n~/projects/river/river/facto/fm.py in _update_latents(self, x, g_loss)\n     91         gradients = {}\n     92         for j, xj in x.items():\n---&gt; 93             gradients[j] = {\n     94                 f: g_loss * (xj * precomputed_sum[f] - v[j][f] * xj ** 2)\n     95                 + l1 * sign(v[j][f])\n\n\n~/projects/river/river/facto/fm.py in &lt;dictcomp&gt;(.0)\n     91         gradients = {}\n     92         for j, xj in x.items():\n---&gt; 93             gradients[j] = {\n     94                 f: g_loss * (xj * precomputed_sum[f] - v[j][f] * xj ** 2)\n     95                 + l1 * sign(v[j][f])\n\n\nKeyboardInterrupt:\n</code></pre> <p>Note that using more variables involves factorizing a larger latent space, then increasing the number of latent factors \\(k\\) often helps capturing more information.</p> <p>Some other feature engineering tips from 3 idiots' winning solution for Kaggle Criteo display ads competition in 2014:</p> <ul> <li>Infrequent modalities often bring noise and little information, transforming them into a special tag can help</li> <li>In some cases, sample-wise normalization seems to make the optimization problem easier to be solved</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#higher-order-factorization-machines-hofm","title":"Higher-Order Factorization Machines (HOFM)","text":"<p>The model equation generalized to any order \\(d \\geq 2\\) is defined as:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right) \\] <pre><code>hofm_params = {\n    'degree': 3,\n    'n_factors': 12,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.05, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.HOFMRegressor(**hofm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761297, RMSE: 0.962054 \u2013 0:00:51.632190 \u2013 2.61 MB\n[50,000] MAE: 0.751865, RMSE: 0.951499 \u2013 0:01:42.890329 \u2013 3.08 MB\n[75,000] MAE: 0.750853, RMSE: 0.951526 \u2013 0:02:34.207244 \u2013 3.6 MB\n[100,000] MAE: 0.750607, RMSE: 0.951982 \u2013 0:03:25.248686 \u2013 4.07 MB\n</code></pre> <p>As said previously, high-order interactions are often hard to estimate due to too much sparsity, that's why we won't spend too much time here.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#field-aware-factorization-machines-ffm","title":"Field-aware Factorization Machines (FFM)","text":"<p>Field-aware variant of FM (FFM) improved the original method by adding the notion of \"fields\". A \"field\" is a group of features that belong to a specific domain (e.g. the \"users\" field, the \"items\" field, or the \"movie genres\" field).</p> <p>FFM restricts itself to pairwise interactions and factorizes separated latent spaces \u2014 one per combination of fields (e.g. users/items, users/movie genres, or items/movie genres) \u2014 instead of a common one shared by all fields. Therefore, each feature has one latent vector per field it can interact with \u2014 so that it can learn the specific effect with each different field.</p> <p>The model equation is defined by:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_{j}} \\rangle x_{j} x_{j'} \\] <p>Where \\(f_j\\) and \\(f_{j'}\\) are the fields corresponding to \\(j\\) and \\(j'\\) features, respectively.</p> <pre><code>ffm_params = {\n    'n_factors': 8,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.05, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.FFMRegressor(**ffm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.757718, RMSE: 0.958158 \u2013 0:00:15.781740 \u2013 3.04 MB\n[50,000] MAE: 0.749502, RMSE: 0.948065 \u2013 0:00:31.431484 \u2013 3.59 MB\n[75,000] MAE: 0.749275, RMSE: 0.948918 \u2013 0:00:47.079510 \u2013 4.19 MB\n[100,000] MAE: 0.749542, RMSE: 0.949769 \u2013 0:01:02.776969 \u2013 4.75 MB\n</code></pre> <p>Note that FFM usually needs to learn smaller number of latent factors \\(k\\) than FM as each latent vector only deals with one field.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#field-weighted-factorization-machines-fwfm","title":"Field-weighted Factorization Machines (FwFM)","text":"<p>Field-weighted Factorization Machines (FwFM) address FFM memory issues caused by its large number of parameters, which is in the order of feature number times field number. As FFM, FwFM is an extension of FM restricted to pairwise interactions, but instead of factorizing separated latent spaces, it learns a specific weight \\(r_{f_j, f_{j'}}\\) for each field combination modelling the interaction strength.</p> <p>The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] <pre><code>fwfm_params = {\n    'n_factors': 10,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'seed': 73,\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.FwFMRegressor(**fwfm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761539, RMSE: 0.962241 \u2013 0:00:20.963815 \u2013 1.18 MB\n[50,000] MAE: 0.754089, RMSE: 0.953181 \u2013 0:00:42.057991 \u2013 1.38 MB\n[75,000] MAE: 0.754806, RMSE: 0.954979 \u2013 0:01:04.051777 \u2013 1.6 MB\n[100,000] MAE: 0.755404, RMSE: 0.95604 \u2013 0:01:25.823651 \u2013 1.79 MB\n</code></pre>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-3/","title":"Part 3","text":"<p>To do.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#do-all-classifiers-support-multi-class-classification","title":"Do all classifiers support multi-class classification?","text":"<p>No, they don't. Although binary classification can be seen as a special case of multi-class classification, there are many optimizations that can be performed if we know that there are only two classes. It would be annoying to have to check whether this is the case in an online setting. All in all we find that separating both cases leads to much cleaner code. Note that the <code>multiclass</code> module contains wrapper models that enable you to perform multi-class classification with binary classifiers.</p>"},{"location":"faq/#how-do-i-know-if-a-classifier-supports-multi-class-classification","title":"How do I know if a classifier supports multi-class classification?","text":"<p>Each classifier in <code>river</code> inherits from the <code>base.Classifier</code> class. Each classifier therefore has a <code>_multiclass</code> property which indicates whether or not it can process a non-boolean target value.</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n\n&gt;&gt;&gt; classifier = linear_model.LogisticRegression()\n&gt;&gt;&gt; classifier._multiclass\nFalse\n</code></pre>"},{"location":"faq/#why-doesnt-river-do-any-input-validation","title":"Why doesn't river do any input validation?","text":"<p>Python encourages a coding style called EAFP, which stands for \"Easier to Ask for Forgiveness than Permission\". The idea is to assume that runtime errors don't occur, and instead use try/expects to catch errors. The great benefit is that we don't have to drown our code with <code>if</code> statements, which is symptomatic of the LBYL style, which stands for \"look before you leap\". This makes our implementations much more readable than, say, scikit-learn, which does a lot of input validation. The catch is that users have to be careful to use sane inputs. As always, there is no free lunch!</p>"},{"location":"faq/#what-about-reinforcement-learning","title":"What about reinforcement learning?","text":"<p>Reinforcement learning works in an online manner because of the nature of the task. Reinforcement learning can be therefore be seen as a subcase of online machine learning. However, we prefer not to support it because there are already many existing opensource libraries dedicated to it.</p>"},{"location":"faq/#what-are-the-differences-between-scikit-learns-online-learning-algorithm-which-have-a-partial_fit-method-and-their-equivalents-in-river","title":"What are the differences between scikit-learn's online learning algorithm which have a partial_fit method and their equivalents in river?","text":"<p>The algorithms from <code>sklearn</code> that support incremental learning are mostly meant for mini-batch learning. In a pure streaming context where the observations arrive one by one, then <code>river</code> is much faster than <code>sklearn</code>. This is mostly because <code>sklearn</code> incurs a lot of overhead by performing data checks. Also, sklearn assumes that you're always using the same number of features. This is not the case with <code>river</code> because it use dictionaries which allows you to drop and add features as you wish.</p>"},{"location":"faq/#how-do-i-save-and-load-models","title":"How do I save and load models?","text":"<pre><code>&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; import pickle\n\n&gt;&gt;&gt; model = ensemble.AdaptiveRandomForestClassifier()\n\n# save\n&gt;&gt;&gt; with open('model.pkl', 'wb') as f:\n...     pickle.dump(model, f)\n\n# load\n&gt;&gt;&gt; with open('model.pkl', 'rb') as f:\n...     model = pickle.load(f)\n</code></pre> <p>We also encourage you to try out dill and cloudpickle.</p>"},{"location":"faq/#what-about-neural-networks","title":"What about neural networks?","text":"<p>There are many great open-source libraries for building neural network models. We don't feel that we can bring anything of value to the existing Python ecosystem. However, we are open to implementing compatibility wrappers for popular libraries such as PyTorch and Keras.</p>"},{"location":"faq/#who-are-the-authors-of-this-library","title":"Who are the authors of this library?","text":"<p>We are research engineers, graduate students, PhDs and machine learning researchers. The members of the develompent team are mainly located in France, Brazil and New Zealand.</p>"},{"location":"introduction/basic-concepts/","title":"Basic concepts","text":"<p>Here are some concepts to give you a feel for what problems River addresses.</p>"},{"location":"introduction/basic-concepts/#data-streams","title":"Data streams","text":"<p>River is a library to build online machine learning models. Such models operate on data streams. But a data stream is a bit of a vague concept.</p> <p>In general, a data stream is a sequence of individual elements. In the case of machine learning, each element is a bunch of features. We call these samples, or observations. Each sample might follow a fixed structure and always contain the same features. But features can also appear and disappear over time. That depends on the use case.</p>"},{"location":"introduction/basic-concepts/#reactive-and-proactive-data-streams","title":"Reactive and proactive data streams","text":"<p>The origin of a data stream can vary, and usually it doesn't matter. You should be able to use River regardless of where your data comes from. It is however important to keep in mind the difference between reactive and proactive data streams.</p> <p>Reactive data streams are ones where the data comes to you. For instance, when a user visits your website, that's out of your control. You have no influence on the event. It just happens and you have to react to it.</p> <p>Proactive data streams are ones where you have control on the data stream. For example, you might be reading the data from a file. You decide at which speed you want to read the data, in what order, etc.</p> <p>If you consider data analysis as a whole, you're realize that the general approach is to turn reactive streams into proactive datasets. Events are usually logged into a database and are processed offline. Be it for building KPIs or training models.</p> <p>The challenge for machine learning is to ensure models you train offline on proactive datasets will perform correctly in production on reactive data streams.</p>"},{"location":"introduction/basic-concepts/#online-processing","title":"Online processing","text":"<p>Online processing is the act of processing a data stream one element at a time. In the case of machine learning, that means training a model by teaching it one sample at a time. This is completely opposite to the traditional way of doing machine learning, which is to train a model on a whole batch data at a time.</p> <p>An online model is therefore a stateful, dynamic object. It keeps learning and doesn't have to revisit past data. It's a different way of doing things, and therefore has its own set of pros and cons.</p>"},{"location":"introduction/basic-concepts/#tasks","title":"Tasks","text":"<p>Machine learning encompasses many different tasks: classification, regression, anomaly detection, time series forecasting, etc. The ideology behind River is to be a generic machine learning which allows to perform these tasks in a streaming manner. Indeed, many batch machine learning algorithms have online equivalents.</p> <p>Note that River also supports some more basic tasks. For instance, you might just want to calculate a running average of a data stream. These are usually smaller parts of a whole stream processing pipeline.</p>"},{"location":"introduction/basic-concepts/#dictionaries-everywhere","title":"Dictionaries everywhere","text":"<p>River a Python library. It is composed of a bunch of classes which implement various online processing algorithms. Most of these classes are machine learning models which can process a single sample, be it for learning or for inference.</p> <p>We made the choice to use dictionaries as the basic building block. First of all, online processing is different to batch processing, in that vectorization doesn't bring any speedup. Therefore numeric processing libraries such as numpy and PyTorch actually bring too much overhead. Using native Python data structures is faster.</p> <p>Dictionaries are therefore a perfect fit. They're native to Python and have excellent support in the standard library. They allow naming each feature. They can hold any kind of data type. They allow transparent support of JSON payloads, allowing seemless integration with web apps.</p>"},{"location":"introduction/basic-concepts/#datasets","title":"Datasets","text":"<p>In production, you're almost always going to face data streams which you have to react to. Such as users visiting your website. The advantage of online machine learning is that you can design models which make predictions as well as learn from this data stream as it flows.</p> <p>But of course, when you're developping a model, you don't usually have access to a real-time feed on which to evaluate your model. You usually have an offline dataset which you want to evaluate your model on. River provides some datasets which can be read in online manner, one sample at a time. It is however crucial to keep in mind that the goal is to reproduce a production scenario as closely as possible, in order to ensure your model will perform just as well in production.</p>"},{"location":"introduction/basic-concepts/#model-evaluation","title":"Model evaluation","text":"<p>Online model evaluation differs from its traditional batch counterpart. In the latter, you usually perform cross-validation, whereby your training dataset is split into a learning and an evaluation dataset. This is fine, but it doesn't exactly reflect the data generation process that occurs in production.</p> <p>Online model evaluation involves learning and inference in the same order as what would happen in production. Indeed, if you know the order in which your data arrives, then you can process it the exact same order. This allows you to replay a production scenario and evaluate your model with higher fidelity than cross-validation.</p> <p>This is what makes online machine learning powerful. By replaying datasets in the correct order, you ensure you are designing models which will perform as expected in production.</p>"},{"location":"introduction/basic-concepts/#concept-drift","title":"Concept drift","text":"<p>The main reason why an online model might not perform as expected in production is because of concept drift. But this is true for all machine learning models, be they offline or online.</p> <p>The advantage of online models over offline models is that they can cope with drift. Indeed, because they can keep learning, they usually adapt to concept drift in a seemless manner. As opposed to batch models which have to be retrained from scratch.</p>"},{"location":"introduction/installation/","title":"Installation","text":"<p>River is meant to work with Python 3.8 and above. Installation can be done via <code>pip</code>:</p> <pre><code>pip install river\n</code></pre> <p>You can install the latest development version from GitHub, as so:</p> <pre><code>pip install git+https://github.com/online-ml/river --upgrade\n</code></pre> <p>Or, through SSH:</p> <pre><code>pip install git+ssh://git@github.com/online-ml/river.git --upgrade\n</code></pre> <p>Feel welcome to open an issue on GitHub if you are having any trouble.</p>"},{"location":"introduction/next-steps/","title":"Next steps","text":"<p>The Recipes \ud83c\udf71 section is made up of small tutorials. Each one explains how to perform mundane tasks, such as measuring the performance of a model, selecting hyperparameters, etc.</p> <p>The Examples \ud83c\udf36\ufe0f section contains more involved notebooks with less explanations. Each notebook addresses a particular machine learning problem.</p> <p>The API \ud83d\udcda section references all the modules, classes, and functions in River. It is automatically generated from the codebase's Python docstrings.</p> <p>Feel welcome to open a discussion if you have a question. Before that you can check out the FAQ \ud83d\ude4b, which has answers to recurring questions.</p> <p>The released versions are listed in the Releases \ud83c\udfd7 section. Changes that will be part of the next release are listed in the unreleased section of the documentation's development version, which you may find here.</p> <p>We recommend checking out Awesome Online Machine Learning if you want to go deeper. There you will find online machine learning related content: research papers, alternative and complementary software, blog posts, etc.</p>"},{"location":"introduction/related-projects/","title":"Related projects","text":"<p>Here is a list of projects which are more or less coupled with River:</p> <ul> <li>deep-river interfaces PyTorch models with River.</li> <li>light-river implements fast algorithms in rust. </li> <li>river-extra regroups experimental features which have yet to prove themselves to make it into the main River repository. Between us we call this \"the arena\".</li> <li>Beaver is an MLOps tool for covering the whole lifecycle of online machine learning models.</li> </ul>"},{"location":"introduction/why-use-river/","title":"Why use River?","text":""},{"location":"introduction/why-use-river/#processing-one-sample-at-a-time","title":"Processing one sample at a time","text":"<p>All the tools in the library can be updated with a single observation at a time. They can therefore be used to process streaming data. Depending on your use case, this might be more convenient than using a batch model.</p>"},{"location":"introduction/why-use-river/#adapting-to-drift","title":"Adapting to drift","text":"<p>In the streaming setting, data can evolve. Adaptive methods are specifically designed to be robust against concept drift in dynamic environments. Many of River's models can cope with concept drift.</p>"},{"location":"introduction/why-use-river/#general-purpose","title":"General purpose","text":"<p>River supports different machine learning tasks, including regression, classification, and unsupervised learning. It can also be used for adhoc tasks, such as computing online metrics, as well as concept drift detection.</p>"},{"location":"introduction/why-use-river/#user-experience","title":"User experience","text":"<p>River is not the only library allowing you to do online machine learning. But it might just the simplest one to use in the Python ecosystem. River plays nicely with Python dictionaries, therefore making it easy to use in the context of web applications where JSON payloads are aplenty.</p>"},{"location":"introduction/getting-started/binary-classification/","title":"Binary classification","text":"<p>Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome.</p> <p>A labeled classification sample is made up of a bunch of features and a class. The class is a boolean in the case of binary classification. We'll use the phishing dataset as an example.</p> <pre><code>from river import datasets\n\ndataset = datasets.Phishing()\ndataset\n</code></pre> <pre>\nPhishing websites.\n\nThis dataset contains features from web pages that are classified as phishing or not.\n\n    Name  Phishing                                                        \n    Task  Binary classification                                           \n Samples  1,250                                                           \nFeatures  9                                                               \n  Sparse  False                                                           \n    Path  /Users/max.halford/projects/river/river/datasets/phishing.csv.gz\n</pre> <p>This dataset is a streaming dataset which can be looped over.</p> <pre><code>for x, y in dataset:\n    pass\n</code></pre> <p>Let's take a look at the first sample.</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre>\n{\n    'empty_server_form_handler': 0.0,\n    'popup_window': 0.0,\n    'https': 0.0,\n    'request_from_other_domain': 0.0,\n    'anchor_from_other_domain': 0.0,\n    'is_popular': 0.5,\n    'long_url': 1.0,\n    'age_of_domain': 1,\n    'ip_in_url': 1\n}\n</pre> <pre><code>y\n</code></pre> <pre>True\n</pre> <p>A binary classifier's goal is to learn to predict a binary target <code>y</code> from some given features <code>x</code>. We'll try to do this with a logistic regression.</p> <pre><code>from river import linear_model\n\nmodel = linear_model.LogisticRegression()\nmodel.predict_proba_one(x)\n</code></pre> <pre>{False: 0.5, True: 0.5}\n</pre> <p>The model hasn't been trained on any data, and therefore outputs a default probability of 50% for each class.</p> <p>The model can be trained on the sample, which will update the model's state.</p> <pre><code>model = model.learn_one(x, y)\n</code></pre> <p>If we try to make a prediction on the same sample, we can see that the probabilities are different, because the model has learned something.</p> <pre><code>model.predict_proba_one(x)\n</code></pre> <pre>{False: 0.494687699901455, True: 0.505312300098545}\n</pre> <p>Note that there is also a <code>predict_one</code> if you're only interested in the most likely class rather than the probability distribution.</p> <pre><code>model.predict_one(x)\n</code></pre> <pre>True\n</pre> <p>Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation.</p> <pre><code>from river import metrics\n\nmodel = linear_model.LogisticRegression()\n\nmetric = metrics.ROCAUC()\n\nfor x, y in dataset:\n    y_pred = model.predict_proba_one(x)\n    model.learn_one(x, y)\n    metric.update(y, y_pred)\n\nmetric\n</code></pre> <pre>ROCAUC: 89.36%\n</pre> <p>This is a common way to evaluate an online model. In fact, there is a dedicated <code>evaluate.progressive_val_score</code> function that does this for you.</p> <pre><code>from river import evaluate\n\nmodel = linear_model.LogisticRegression()\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre>ROCAUC: 89.36%\n</pre> <p>A common way to improve the performance of a logistic regression is to scale the data. This can be done by using a <code>preprocessing.StandardScaler</code>. In particular, we can define a pipeline to organise our model into a sequence of steps:</p> <pre><code>from river import compose\nfrom river import preprocessing\n\nmodel = compose.Pipeline(\n    preprocessing.StandardScaler(),\n    linear_model.LogisticRegression()\n)\n\nmodel\n</code></pre> <pre>StandardScaler</pre><code>(   with_std=True )  </code><pre>LogisticRegression</pre><code>(   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Log (     weight_pos=1.     weight_neg=1.   )   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () )  </code> <pre><code>metric = metrics.ROCAUC()\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre>ROCAUC: 95.04%\n</pre> <p>That concludes the getting started introduction to binary classification! You can now move on to the next steps.</p>"},{"location":"introduction/getting-started/concept-drift-detection/","title":"Concept drift","text":"<p>In online machine learning, it is assumed that data can change over time. When building machine learning models, we assume data has a probability distribution, which is usually fixed, i.e., stationary. Changes in the data distribution give rise to the phenomenon called Concept drift. Such drifts can be either virtual or real. In virtual drifts, only the distribution of the features, \\(P(X)\\), changes, whereas the relationship between \\(X\\) (features) and the target, \\(y\\), remains unchanged. The joint probability of \\(P(X, y)\\) changes in real concept drifts. Consequently, non-supervised online machine learning problems might face only virtual concept drifts.</p> <p>Real concept drits can be further divided in abrupt (happen instantly at a given point) or gradual (one \"concept\" changes to another gradually). There are other possible divisions, but they can be fit into abrupt or gradual drifts.</p>"},{"location":"introduction/getting-started/concept-drift-detection/#examples-of-concept-drift","title":"Examples of concept drift","text":"<p>Concept drifts might happen in the electricity demand across the year, in the stock market, in buying preferences, and in the likelihood of a new movie's success, among others.</p> <p>Let us consider the movie example: two movies made at different epochs can have similar features such as famous actors/directors, storyline, production budget, marketing campaigns, etc., yet it is not certain that both will be similarly successful. What the target audience considers is worth watching (and their money) is constantly changing, and production companies must adapt accordingly to avoid \"box office flops\".</p> <p>Prior to the pandemics, the usage of hand sanitizers and facial masks was not widespread. When the cases of COVID-19 started increasing, there was a lack of such products for the final consumer. Imagine a batch-learning model deciding how much of each product a supermarket should stock during those times. What a mess!</p>"},{"location":"introduction/getting-started/concept-drift-detection/#impact-of-drift-on-learning","title":"Impact of drift on learning","text":"<p>Concept drift can have a significant impact on predictive performance if not handled properly. Most batch learning models will fail in the presence of concept drift as they are essentially trained on different data. On the other hand, stream learning methods continuously update themselves and adapt to new concepts. Furthermore, drift-aware methods use change detection methods (a.k.a. drift detectors) to trigger mitigation mechanisms if a change in performance is detected.</p>"},{"location":"introduction/getting-started/concept-drift-detection/#detecting-concept-drift","title":"Detecting concept drift","text":"<p>Multiple drift detection methods have been proposed. The goal of a drift detector is to signal an alarm in the presence of drift. A good drift detector maximizes the number of true positives while keeping the number of false positives to a minimum. It must also be resource-wise efficient to work in the context of infinite data streams.</p> <p>For this example, we will generate a synthetic data stream by concatenating 3 distributions of 1000 samples each:</p> <ul> <li>\\(dist_a\\): \\(\\mu=0.8\\), \\(\\sigma=0.05\\)</li> <li>\\(dist_b\\): \\(\\mu=0.4\\), \\(\\sigma=0.02\\)</li> <li>\\(dist_c\\): \\(\\mu=0.6\\), \\(\\sigma=0.1\\).</li> </ul> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\n\n# Generate data for 3 distributions\nrandom_state = np.random.RandomState(seed=42)\ndist_a = random_state.normal(0.8, 0.05, 1000)\ndist_b = random_state.normal(0.4, 0.02, 1000)\ndist_c = random_state.normal(0.6, 0.1, 1000)\n\n# Concatenate data to simulate a data stream with 2 drifts\nstream = np.concatenate((dist_a, dist_b, dist_c))\n\n# Auxiliary function to plot the data\ndef plot_data(dist_a, dist_b, dist_c, drifts=None):\n    fig = plt.figure(figsize=(7,3), tight_layout=True)\n    gs = gridspec.GridSpec(1, 2, width_ratios=[3, 1])\n    ax1, ax2 = plt.subplot(gs[0]), plt.subplot(gs[1])\n    ax1.grid()\n    ax1.plot(stream, label='Stream')\n    ax2.grid(axis='y')\n    ax2.hist(dist_a, label=r'$dist_a$')\n    ax2.hist(dist_b, label=r'$dist_b$')\n    ax2.hist(dist_c, label=r'$dist_c$')\n    if drifts is not None:\n        for drift_detected in drifts:\n            ax1.axvline(drift_detected, color='red')\n    plt.show()\n\nplot_data(dist_a, dist_b, dist_c)\n</code></pre>"},{"location":"introduction/getting-started/concept-drift-detection/#drift-detection-test","title":"Drift detection test","text":"<p>We will use the ADaptive WINdowing (<code>ADWIN</code>) drift detection method. Remember that the goal is to indicate that drift has occurred after samples 1000 and 2000 in the synthetic data stream.</p> <pre><code>from river import drift\n\ndrift_detector = drift.ADWIN()\ndrifts = []\n\nfor i, val in enumerate(stream):\n    drift_detector.update(val)   # Data is processed one sample at a time\n    if drift_detector.drift_detected:\n        # The drift detector indicates after each sample if there is a drift in the data\n        print(f'Change detected at index {i}')\n        drifts.append(i)\n\nplot_data(dist_a, dist_b, dist_c, drifts)\n</code></pre> <pre><code>Change detected at index 1055\nChange detected at index 2079\n</code></pre>  <p>We see that <code>ADWIN</code> successfully indicates the presence of drift (red vertical lines) close to the begining of a new data distribution.</p>  <p>We conclude this example with some remarks regarding concept drift detectors and their usage:</p> <ul> <li>In practice, drift detectors provide stream learning methods with robustness against concept drift. Drift detectors monitor the model usually through a performance metric.</li> <li>Drift detectors work on univariate data. This is why they are used to monitor a model's performance and not the data itself. Remember that concept drift is defined as a change in the relationship between data and the target to learn (in supervised learning).</li> <li>Drift detectors define their expectations regarding input data. It is important to know these expectations to feed a given drift detector with the correct data.</li> </ul>"},{"location":"introduction/getting-started/multiclass-classification/","title":"Multi-class classification","text":"<p>Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome.</p> <p>A labeled classification sample is made up of a bunch of features and a class. The class is a usually a string or a number in the case of multiclass classification. We'll use the image segments dataset as an example.</p> <pre><code>from river import datasets\n\ndataset = datasets.ImageSegments()\ndataset\n</code></pre> <pre><code>Image segments classification.\n\nThis dataset contains features that describe image segments into 7 classes: brickface, sky,\nfoliage, cement, window, path, and grass.\n\n    Name  ImageSegments                                                   \n    Task  Multi-class classification                                      \n Samples  2,310                                                           \nFeatures  18                                                              \n  Sparse  False                                                           \n    Path  /Users/max.halford/projects/river/river/datasets/segment.csv.zip\n</code></pre> <p>This dataset is a streaming dataset which can be looped over.</p> <pre><code>for x, y in dataset:\n    pass\n</code></pre> <p>Let's take a look at the first sample.</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre><code>{'region-centroid-col': 218,\n 'region-centroid-row': 178,\n 'short-line-density-5': 0.11111111,\n 'short-line-density-2': 0.0,\n 'vedge-mean': 0.8333326999999999,\n 'vegde-sd': 0.54772234,\n 'hedge-mean': 1.1111094,\n 'hedge-sd': 0.5443307,\n 'intensity-mean': 59.629630000000006,\n 'rawred-mean': 52.44444300000001,\n 'rawblue-mean': 75.22222,\n 'rawgreen-mean': 51.22222,\n 'exred-mean': -21.555555,\n 'exblue-mean': 46.77778,\n 'exgreen-mean': -25.222220999999998,\n 'value-mean': 75.22222,\n 'saturation-mean': 0.31899637,\n 'hue-mean': -2.0405545}\n</code></pre> <pre><code>y\n</code></pre> <pre><code>'path'\n</code></pre> <p>A multiclass classifier's goal is to learn how to predict a class <code>y</code> from a bunch of features <code>x</code>. We'll attempt to do this with a decision tree.</p> <pre><code>from river import tree\n\nmodel = tree.HoeffdingTreeClassifier()\nmodel.predict_proba_one(x)\n</code></pre> <pre><code>{}\n</code></pre> <p>The reason why the output dictionary is empty is because the model hasn't seen any data yet. It isn't aware of the dataset whatsoever. If this were a binary classifier, then it would output a probability of 50% for <code>True</code> and <code>False</code> because the classes are implicit. But in this case we're doing multiclass classification.</p> <p>Likewise, the <code>predict_one</code> method initially returns <code>None</code> because the model hasn't seen any labeled data yet.</p> <pre><code>print(model.predict_one(x))\n</code></pre> <pre><code>None\n</code></pre> <p>If we update the model and try again, then we see that a probability of 100% is assigned to the <code>'path'</code> class because that's the only one the model is aware of.</p> <pre><code>model.learn_one(x, y)\nmodel.predict_proba_one(x)\n</code></pre> <pre><code>{'path': 1.0}\n</code></pre> <p>This is a strength of online classifiers: they're able to deal with new classes appearing in the data stream.</p> <p>Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation.</p> <pre><code>from river import metrics\n\nmodel = tree.HoeffdingTreeClassifier()\n\nmetric = metrics.ClassificationReport()\n\nfor x, y in dataset:\n    y_pred = model.predict_one(x)\n    model.learn_one(x, y)\n    if y_pred is not None:\n        metric.update(y, y_pred)\n\nmetric\n</code></pre> <pre><code>            Precision   Recall   F1       Support\n\nbrickface      77.13%   84.85%   80.81%        33  \n   cement      78.92%   83.94%   81.35%        33  \n  foliage      67.00%   20.30%   31.16%        33  \n    grass     100.00%   96.97%   98.46%        33  \n     path      90.39%   91.49%   90.94%       329  \n      sky      99.08%   98.18%   98.63%        33  \n   window      43.50%   67.88%   53.02%        33\n\n    Macro      79.43%   77.66%   76.34%            \n    Micro      77.65%   77.65%   77.65%            \n Weighted      79.43%   77.65%   76.33%\n\n                  77.65% accuracy\n</code></pre> <p>This is a common way to evaluate an online model. In fact, there is a dedicated <code>evaluate.progressive_val_score</code> function that does this for you.</p> <pre><code>from river import evaluate\n\nmodel = tree.HoeffdingTreeClassifier()\nmetric = metrics.ClassificationReport()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>            Precision   Recall   F1       Support\n\nbrickface      77.13%   84.85%   80.81%        33  \n   cement      78.92%   83.94%   81.35%        33  \n  foliage      67.00%   20.30%   31.16%        33  \n    grass     100.00%   96.97%   98.46%        33  \n     path      90.39%   91.49%   90.94%       329  \n      sky      99.08%   98.18%   98.63%        33  \n   window      43.50%   67.88%   53.02%        33\n\n    Macro      79.43%   77.66%   76.34%            \n    Micro      77.65%   77.65%   77.65%            \n Weighted      79.43%   77.65%   76.33%\n\n                  77.65% accuracy\n</code></pre> <p>That concludes the getting started introduction to multiclass classification! You can now move on to the next steps.</p>"},{"location":"introduction/getting-started/regression/","title":"Regression","text":"<p>Regression is about predicting a numeric output for a given sample. A labeled regression sample is made up of a bunch of features and a number. The number is usually continuous, but it may also be discrete. We'll use the Trump approval rating dataset as an example.</p> <pre><code>from river import datasets\n\ndataset = datasets.TrumpApproval()\ndataset\n</code></pre> <pre><code>Donald Trump approval ratings.\n\nThis dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald\nTrump's approval ratings. It contains 5 features, which are approval ratings collected by\n5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of\nthis task is to see if we can reproduce FiveThirtyEight's model.\n\n    Name  TrumpApproval                                                         \n    Task  Regression                                                            \n Samples  1,001                                                                 \nFeatures  6                                                                     \n  Sparse  False                                                                 \n    Path  /Users/max.halford/projects/river/river/datasets/trump_approval.csv.gz\n</code></pre> <p>This dataset is a streaming dataset which can be looped over.</p> <pre><code>for x, y in dataset:\n    pass\n</code></pre> <p>Let's take a look at the first sample.</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre><code>{'ordinal_date': 736389,\n 'gallup': 43.843213,\n 'ipsos': 46.19925042857143,\n 'morning_consult': 48.318749,\n 'rasmussen': 44.104692,\n 'you_gov': 43.636914000000004}\n</code></pre> <p>A regression model's goal is to learn to predict a numeric target <code>y</code> from a bunch of features <code>x</code>. We'll attempt to do this with a nearest neighbors model.</p> <pre><code>from river import neighbors\n\nmodel = neighbors.KNNRegressor()\nmodel.predict_one(x)\n</code></pre> <pre><code>0.0\n</code></pre> <p>The model hasn't been trained on any data, and therefore outputs a default value of 0.</p> <p>The model can be trained on the sample, which will update the model's state.</p> <pre><code>model = model.learn_one(x, y)\n</code></pre> <p>If we try to make a prediction on the same sample, we can see that the output is different, because the model has learned something.</p> <pre><code>model.predict_one(x)\n</code></pre> <pre><code>43.75505\n</code></pre> <p>Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation.</p> <pre><code>from river import metrics\n\nmodel = neighbors.KNNRegressor()\n\nmetric = metrics.MAE()\n\nfor x, y in dataset:\n    y_pred = model.predict_one(x)\n    model.learn_one(x, y)\n    metric.update(y, y_pred)\n\nmetric\n</code></pre> <pre><code>MAE: 0.31039\n</code></pre> <p>This is a common way to evaluate an online model. In fact, there is a dedicated <code>evaluate.progressive_val_score</code> function that does this for you.</p> <pre><code>from river import evaluate\n\nmodel = neighbors.KNNRegressor()\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.31039\n</code></pre> <p>That concludes the getting started introduction to regression! You can now move on to the next steps.</p>"},{"location":"recipes/bandits-101/","title":"Multi-armed bandits","text":"<p>River has a <code>bandit</code> module. It contains several multi-armed bandit policies, bandit environments, and utilities to benchmark policies on bandit problems.</p> <p>Bandit environments in River implement the Gym interface. You can thus load them with <code>gym.make</code>. Note that Gym is intended for reinforcement learning algorithms, while bandit policies are the simplest form of reinforcement learing. Bandit policies learn by receiving a reward after each step, while reinforcement learning algorithms have to learn from feedback that may arrive at the end of a (long) sequence of steps.</p> <pre><code>import gym\n\nfor k in gym.envs.registry:\n    if k.startswith('river_bandits'):\n        print(k)\n</code></pre> <p>River's bandit module offers the <code>bandit.evaluate</code> function to benchmark several policies on a given environment. It takes as input a list of bandit policies, a bandit environment (the problem to solve), and a reward object. There is a also a <code>pull_func</code> parameter that is necessary to define how a policy is supposed to pull an arm from a given environment.</p> <pre><code>import gym\nfrom river import bandit\nimport pandas as pd\nfrom tqdm import tqdm\nfrom river import stats\n\ndef pull_func(policy, env):\n    return next(policy.pull(range(env.action_space.n)))\n\npolicies=[\n    bandit.EpsilonGreedy(epsilon=0.1),\n    bandit.EpsilonGreedy(epsilon=0.01),\n    bandit.EpsilonGreedy(epsilon=0),\n]\n\nenv = gym.make(\n    'river_bandits/KArmedTestbed-v0',\n    max_episode_steps=1000\n)\n\ntrace = bandit.evaluate(\n    policies=policies,\n    env=env,\n    reward_stat=stats.Mean(),\n    pull_func=pull_func,\n    n_episodes=(n_episodes := 2000),\n)\n</code></pre> <p>The <code>bandit.evaluate</code> function returns a generator containing the results at each step of the benchmark. This can be wrapped with a <code>pandas.DataFrame</code> to gather all the results.</p> <pre><code>trace_df = pd.DataFrame(tqdm(\n    trace, position=0, total=(\n        n_episodes *\n        len(policies) *\n        env._max_episode_steps\n    )\n))\ntrace_df.sample(5, random_state=42)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000000/6000000 [01:26&lt;00:00, 69579.00it/s]\n</code></pre>       episode step policy_idx action reward reward_stat     1324896 441 632 0 1 1.173982 1.410379   3566176 1188 725 1 3 -0.361536 0.904599   1109043 369 681 0 7 1.794703 0.899742   4286042 1428 680 2 3 1.677845 0.680013   5395174 1798 391 1 3 1.501662 1.062698     <p>It is then straightforward to plot the average reward each policy obtains at each step, by averaging over episodes.</p> <pre><code>policy_names = {\n    0: '\u03b5 = 0.1',\n    1: '\u03b5 = 0.01',\n    2: '\u03b5 = 0 (greedy)'\n}\n\ncolors = {\n    '\u03b5 = 0.1': 'tab:blue',\n    '\u03b5 = 0.01': 'tab:red',\n    '\u03b5 = 0 (greedy)': 'tab:green'\n}\n\n(\n    trace_df\n    .assign(policy=trace_df.policy_idx.map(policy_names))\n    .groupby(['step', 'policy'])\n    ['reward'].mean()\n    .unstack()\n    .plot(color=colors)\n)\n</code></pre> <pre>&lt;AxesSubplot:xlabel='step'&gt;\n</pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>"},{"location":"recipes/bandits-101/#controlling-the-evaluation-loop","title":"Controlling the evaluation loop","text":"<p>The <code>bandit.evaluate</code> function is useful for benchmarking. But in practice, you'll want to have control over your bandit policy. Indeed you'll want the freedom to pull arms (with the <code>pull</code> method) and update the policy (with the <code>update</code> method) at your discretion.</p> <p>As an example, the following is a possible reimplementation of the <code>bandit.evaluate</code> function. Here we'll be measuring the rate at which each policy selects the optimal arm.</p> <p>Note how the <code>pull</code> and <code>update</code> methods are used.</p> <pre><code>import copy\n\npolicies=[\n    bandit.EpsilonGreedy(epsilon=0.1),\n    bandit.EpsilonGreedy(epsilon=0.01),\n    bandit.EpsilonGreedy(epsilon=0),\n]\n\nenv = gym.make(\n    'river_bandits/KArmedTestbed-v0',\n    max_episode_steps=1000\n)\nn_episodes = 2000\n\ntrace = []\n\nwith tqdm(total=len(policies) * n_episodes * env._max_episode_steps, position=0) as progress:\n    for policy in policies:\n        for episode in range(n_episodes):\n            episode_policy = policy.clone()\n            episode_env = copy.deepcopy(env)\n            episode_env.reset()\n            step = 0\n            while True:\n                action = next(episode_policy.pull(range(episode_env.action_space.n)))\n                observation, reward, terminated, truncated, info = episode_env.step(action)\n                best_action = observation\n                episode_policy.update(action, reward)\n\n                trace.append({\n                    \"episode\": episode,\n                    \"step\": step,\n                    \"policy\": f\"\u03b5 = {policy.epsilon}\",\n                    \"is_action_optimal\": action == best_action\n                })\n                step += 1\n                progress.update()\n\n                if terminated or truncated:\n                    break\n\ntrace_df = pd.DataFrame(trace)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000000/6000000 [01:25&lt;00:00, 70039.23it/s]\n</code></pre> <pre><code>colors = {\n    '\u03b5 = 0.1': 'tab:blue',\n    '\u03b5 = 0.01': 'tab:red',\n    '\u03b5 = 0': 'tab:green'\n}\n\n(\n    trace_df\n    .groupby(['step', 'policy'])\n    ['is_action_optimal'].mean()\n    .unstack()\n    .plot(color=colors)\n)\n</code></pre> <pre>&lt;AxesSubplot:xlabel='step'&gt;\n</pre> <pre>&lt;Figure size 432x288 with 1 Axes&gt;\n</pre>"},{"location":"recipes/bandits-101/#handling-drift","title":"Handling drift","text":"<p>The environment used above is a toy situation used for introducing bandits. It is stationary, meaning that the expected reward of each arm does not change over time.</p> <p>In practice, arms are dynamic, and their performance can vary over time. A simple example of this is the Candy Cane Contest that was hosted on Kaggle in 2020. The expected reward of each arm diminishes each time it is pulled.</p> <p>The way bandit policies in River deal with drift depends on the method. For the <code>bandit.EpsilonGreedy</code> policy, it makes sense to use a rolling average as the reward object. What this means is that the empirical reward the policy calculates for each arm is a rolling average, rather than a global one.</p> <pre><code>from river import proba, utils\n\npolicies=[\n    bandit.EpsilonGreedy(\n        epsilon=0.1,\n        seed=42\n    ),\n    bandit.EpsilonGreedy(\n        epsilon=0.3,\n        reward_obj=utils.Rolling(stats.Mean(), window_size=50),\n        seed=42\n    ),\n    bandit.ThompsonSampling(\n        dist=proba.Beta(),\n        seed=42\n    )\n]\n\nenv = gym.make('river_bandits/CandyCaneContest-v0')\n\ntrace = bandit.evaluate(\n    policies=policies,\n    env=env,\n    pull_func=pull_func,\n    n_episodes=(n_episodes := 30),\n    seed=42\n)\n\ntrace_df = pd.DataFrame(tqdm(\n    trace, position=0, total=(\n        n_episodes *\n        len(policies) *\n        env._max_episode_steps\n    )\n))\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 180000/180000 [00:27&lt;00:00, 6442.28it/s]\n</code></pre> <p>We can compare the performance of each policy by checking the average reward at the end of each episode.</p> <pre><code>(\n    trace_df\n    .groupby(['policy_idx', 'episode'])\n    .last()\n    .groupby('policy_idx')\n    .reward_stat.mean()\n)\n</code></pre> <pre>\npolicy_idx\n0    736.1\n1    817.0\n2    854.0\nName: reward_stat, dtype: float64\n</pre> <p>We see that using a rolling average gives a boost to the epsilon greedy strategy. However, we see that the <code>bandit.ThompsonSampling</code> policy performs even better, even though no particular care was given to drift. A natural next step would thus be to see how it could be improved to handle drift. For instance, its <code>dist</code> parameter could be wrapped with a <code>utils.Rolling</code>:</p> <pre><code>policy = bandit.ThompsonSampling(\n    dist=utils.Rolling(proba.Beta(), window_size=50),\n    seed=42\n)\n</code></pre> <p>Bandits can be used for several tasks. They can be used for content personalization, as well as online model selection (see <code>model_selection.BanditRegressor</code>). The policies in River are therefore designed to be flexible, so that they can be used in conjunction with other River modules. For instance, the <code>reward_obj</code> in <code>bandit.EpsilonGreedy</code> can be a metric, a probability distribution, or a statistic. This works because objects in River adher to a coherent get/update interface.</p>"},{"location":"recipes/cloning-and-mutating/","title":"Cloning and mutating","text":"<p>Sometimes you might want to reset a model, or edit (what we call mutate) its attributes. This can be useful in an online environment. Indeed, if you detect a drift, then you might want to mutate a model's attributes. Or if you see that a performance's model is plummeting, then you might to reset it to its \"factory settings\".</p> <p>Anyway, this is not to convince you, but rather to say that a model's attributes don't have be to set in stone throughout its lifetime. In particular, if you're developping your own model, then you might want to have good tools to do this. This is what this recipe is about.</p>"},{"location":"recipes/cloning-and-mutating/#cloning","title":"Cloning","text":"<p>The first thing you can do is clone a model. This creates a deep copy of the model. The resulting model is entirely independent of the original model. The clone is fresh, in the sense that it is as if it hasn't seen any data.</p> <p>For instance, say you have a linear regression model which you have trained on some data.</p> <pre><code>from river import datasets, linear_model, optim, preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LinearRegression(\n        optimizer=optim.SGD(3e-2)\n    )\n)\n\nfor x, y in datasets.TrumpApproval():\n    model.predict_one(x)\n    model.learn_one(x, y)\n\nmodel[-1].weights\n</code></pre> <pre>\n{\n    'ordinal_date': 20.59955380229643,\n    'gallup': 0.39114944304212645,\n    'ipsos': 0.4101918314868111,\n    'morning_consult': 0.12042970179504908,\n    'rasmussen': 0.18951231512561392,\n    'you_gov': 0.04991712783831687\n}\n</pre> <p>For whatever reason, we may want to clone this model. This can be done with the <code>clone</code> method.</p> <pre><code>clone = model.clone()\nclone[-1].weights\n</code></pre> <pre>{}\n</pre> <p>As we can see, there are no weights because the clone is fresh copy that has not seen any data. However, the learning rate we specified is preserved.</p> <pre><code>clone[-1].optimizer.learning_rate\n</code></pre> <pre>0.03\n</pre> <p>You may also specify parameters you want changed. For instance, let's say we want to clone the model, but we want to change the optimizer:</p> <pre><code>clone = model.clone({\"LinearRegression\": {\"optimizer\": optim.Adam()}})\nclone[-1].optimizer\n</code></pre> <pre>Adam({'lr': Constant({'learning_rate': 0.1}), 'n_iterations': 0, 'beta_1': 0.9, 'beta_2': 0.999, 'eps': 1e-08, 'm': None, 'v': None})\n</pre> <p>The first key indicates that we want to specify a different parameter for the <code>LinearRegression</code> part of the pipeline. Then the second key accesses the linear regression's <code>optimizer</code> parameter.</p> <p>Finally, note that the <code>clone</code> method isn't reserved to models. Indeed, every object in River has it. That's because they all inherit from the <code>Base</code> class in the <code>base</code> module.</p>"},{"location":"recipes/cloning-and-mutating/#mutating-attributes","title":"Mutating attributes","text":"<p>Cloning a model can be useful, but the fact that it essentially resets the model may not be desired. Instead, you might want to change a attribute while preserving the model's state. For example, let's change the <code>l2</code> attribute, and the optimizer's <code>lr</code> attribute.</p> <pre><code>model.mutate({\n    \"LinearRegression\": {\n        \"l2\": 0.1,\n        \"optimizer\": {\n            \"lr\": optim.schedulers.Constant(25e-3)\n        }\n    }\n})\n\nprint(repr(model))\n</code></pre> <pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.025\n      )\n    )\n    loss=Squared ()\n    l2=0.1\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</pre> <p>We can see the attributes we specified have changed. However, the model's state is preserved:</p> <pre><code>model[-1].weights\n</code></pre> <pre>\n{\n    'ordinal_date': 20.59955380229643,\n    'gallup': 0.39114944304212645,\n    'ipsos': 0.4101918314868111,\n    'morning_consult': 0.12042970179504908,\n    'rasmussen': 0.18951231512561392,\n    'you_gov': 0.04991712783831687\n}\n</pre> <p>In other words, the <code>mutate</code> method does not create a deep copy of the model. It just sets attributes. At this point you may ask:</p>  <p>Why can't I just change the attribute directly, without calling <code>mutate</code>?</p>  <p>The answer is that you're free to do proceed as such, but it's not the way we recommend. The <code>mutate</code> method is safer, in that it prevents you from mutating attributes you shouldn't be touching. We call these immutable attributes. For instance, there's no reason you should be modifying the weights.</p> <pre><code>try:\n    model.mutate({\n        \"LinearRegression\": {\n            \"weights\": \"this makes no sense\"\n        }\n    })\nexcept ValueError as e:\n    print(e)\n</code></pre> <pre>'weights' is not a mutable attribute of LinearRegression\n</pre> <p>All attributes are immutable by default. Under the hood, each model can specify a set of mutable attributes via the <code>_mutable_attributes</code> property. In theory this can be overriden. But the general idea is that we will progressively add more and more mutable attributes with time.</p> <p>And that concludes this recipe. Arguably, this recipe caters to advanced users, and in particular users who are developping their own models. And yet, one could also argue that modifying parameters of a model on-the-fly is a great tool to have at your disposal when you're doing online machine learning.</p>"},{"location":"recipes/feature-extraction/","title":"Feature extraction","text":"<p>To do.</p>"},{"location":"recipes/hyperparameter-tuning/","title":"Hyperparameter tuning","text":"<p>To do.</p>"},{"location":"recipes/mini-batching/","title":"Mini-batching","text":"<p>In its purest form, online machine learning encompasses models which learn with one sample at a time. This is the design which is used in <code>river</code>.</p> <p>The main downside of single-instance processing is that it doesn't scale to big data, at least not in the sense of traditional batch learning. Indeed, processing one sample at a time means that we are unable to fully take advantage of vectorisation and other computational tools that are taken for granted in batch learning. On top of this, processing a large dataset in <code>river</code> essentially involves a Python <code>for</code> loop, which might be too slow for some usecases. However, this doesn't mean that <code>river</code> is slow. In fact, for processing a single instance, <code>river</code> is actually a couple of orders of magnitude faster than libraries such as scikit-learn, PyTorch, and Tensorflow. The reason why is because <code>river</code> is designed from the ground up to process a single instance, whereas the majority of other libraries choose to care about batches of data. Both approaches offer different compromises, and the best choice depends on your usecase.</p> <p>In order to propose the best of both worlds, <code>river</code> offers some limited support for mini-batch learning. Some of <code>river</code>'s estimators implement <code>*_many</code> methods on top of their <code>*_one</code> counterparts. For instance, <code>preprocessing.StandardScaler</code> has a <code>learn_many</code> method as well as a <code>transform_many</code> method, in addition to <code>learn_one</code> and <code>transform_one</code>. Each mini-batch method takes as input a <code>pandas.DataFrame</code>. Supervised estimators also take as input a <code>pandas.Series</code> of target values. We choose to use <code>pandas.DataFrames</code> over <code>numpy.ndarrays</code> because of the simple fact that the former allows us to name each feature. This in turn allows us to offer a uniform interface for both single instance and mini-batch learning.</p> <p>As an example, we will build a simple pipeline that scales the data and trains a logistic regression. Indeed, the <code>compose.Pipeline</code> class can be applied to mini-batches, as long as each step is able to do so.</p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import preprocessing\n\nmodel = compose.Pipeline(\n    preprocessing.StandardScaler(),\n    linear_model.LogisticRegression()\n)\n</code></pre> <p>For this example, we will use <code>datasets.Higgs</code>.</p> <pre><code>from river import datasets\n\ndataset = datasets.Higgs()\nif not dataset.is_downloaded:\n    dataset.download()\ndataset\n</code></pre> <pre><code>Downloading https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz (2.62 GB)\n</code></pre> <pre>\nHiggs dataset.\n\nThe data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22)\nare kinematic properties measured by the particle detectors in the accelerator. The last seven\nfeatures are functions of the first 21 features; these are high-level features derived by\nphysicists to help discriminate between the two classes.\n\n      Name  Higgs                                                                       \n      Task  Binary classification                                                       \n   Samples  11,000,000                                                                  \n  Features  28                                                                          \n    Sparse  False                                                                       \n      Path  /Users/max.halford/river_data/Higgs/HIGGS.csv.gz                            \n       URL  https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz\n      Size  2.62 GB                                                                     \nDownloaded  True                                                                        \n</pre> <p>The easiest way to read the data in a mini-batch fashion is to use the <code>read_csv</code> from <code>pandas</code>.</p> <pre><code>import pandas as pd\n\nnames = [\n    'target', 'lepton pT', 'lepton eta', 'lepton phi',\n    'missing energy magnitude', 'missing energy phi',\n    'jet 1 pt', 'jet 1 eta', 'jet 1 phi', 'jet 1 b-tag',\n    'jet 2 pt', 'jet 2 eta', 'jet 2 phi', 'jet 2 b-tag',\n    'jet 3 pt', 'jet 3 eta', 'jet 3 phi', 'jet 3 b-tag',\n    'jet 4 pt', 'jet 4 eta', 'jet 4 phi', 'jet 4 b-tag',\n    'm_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb'\n]\n\nfor x in pd.read_csv(dataset.path, names=names, chunksize=8096, nrows=3e5):\n    y = x.pop('target')\n    y_pred = model.predict_proba_many(x)\n    model.learn_many(x, y)\n</code></pre> <p>If you are familiar with scikit-learn, you might be aware that some of their estimators have a <code>partial_fit</code> method, which is similar to river's <code>learn_many</code> method. Here are some advantages that river has over scikit-learn:</p> <ul> <li>We guarantee that river's is just as fast, if not faster than scikit-learn. The differences are negligeable, but are slightly in favor of river.</li> <li>We take as input dataframes, which allows us to name each feature. The benefit is that you can add/remove/permute features between batches and everything will keep working.</li> <li>Estimators that support mini-batches also support single instance learning. This means that you can enjoy the best of both worlds. For instance, you can train with mini-batches and use <code>predict_one</code> to make predictions.</li> </ul> <p>Note that you can check which estimators can process mini-batches programmatically:</p> <pre><code>import importlib\nimport inspect\n\ndef can_mini_batch(obj):\n    return hasattr(obj, 'learn_many')\n\nfor module in importlib.import_module('river.api').__all__:\n    if module in ['datasets', 'synth']:\n        continue\n    for name, obj in inspect.getmembers(importlib.import_module(f'river.{module}'), can_mini_batch):\n        print(name)\n</code></pre> <pre>OneClassSVM\n</pre> <pre>MiniBatchClassifier\n</pre> <pre>MiniBatchRegressor\n</pre> <pre>MiniBatchSupervisedTransformer\n</pre> <pre>MiniBatchTransformer\n</pre> <pre>SKL2RiverClassifier\n</pre> <pre>SKL2RiverRegressor\n</pre> <pre>Pipeline\n</pre> <pre>Select\n</pre> <pre>TransformerProduct\n</pre> <pre>TransformerUnion\n</pre> <pre>BagOfWords\n</pre> <pre>TFIDF\n</pre> <pre>LinearRegression\n</pre> <pre>LogisticRegression\n</pre> <pre>Perceptron\n</pre> <pre>OneVsRestClassifier\n</pre> <pre>BernoulliNB\n</pre> <pre>ComplementNB\n</pre> <pre>MultinomialNB\n</pre> <pre>MLPRegressor\n</pre> <pre>OneHotEncoder\n</pre> <pre>StandardScaler\n</pre> <p>Because mini-batch learning isn't treated as a first-class citizen, some of the river's functionalities require some work in order to play nicely with mini-batches. For instance, the objects from the <code>metrics</code> module have an <code>update</code> method that take as input a single pair <code>(y_true, y_pred)</code>. This might change in the future, depending on the demand.</p> <p>We plan to promote more models to the mini-batch regime. However, we will only be doing so for the methods that benefit the most from it, as well as those that are most popular. Indeed, <code>river</code>'s core philosophy will remain to cater to single instance learning.</p>"},{"location":"recipes/model-evaluation/","title":"Model evaluation","text":"<p>To do.</p>"},{"location":"recipes/on-hoeffding-trees/","title":"Incremental decision trees in river: the Hoeffding Tree case","text":"<p>Decision trees (DT) are popular learning models due to their inherently simplicity, flexibility and self-explainable structure. Moreover, when aggregated in ensembles, high predictive power might be achieved. Bagging and gradient boosting-based tree ensembles are very popular solutions in competition platforms such as Kaggle, and also among researchers.</p> <p>Although fairly lightweight, traditional batch DTs cannot cope with data stream mining/online learning requirements, as they do multiple passes over the data and have to be retrained from scratch every time a new observation appears.</p> <p>The data stream literature has plenty of incremental DT (iDT) families that are better suited to online learning. Nonetheless, Hoeffding Trees (HT) are historically the most popular family of iDTs to date. In fact, HTs have some nice properties:</p> <ul> <li>one-pass learning regime;</li> <li>theoretical guarantees to converge to the batch DT model given enough observations and a stationary data distribution;</li> <li>small memory and running time footprint (in most cases);</li> <li>some of their variations can deal with non-stationary distributions.</li> </ul> <p>And the previous list goes on and on. Besides that, HTs also have the same advantages as batch DTs (<code>C4.5</code>/<code>J48</code>, <code>CART</code>, <code>M5</code>, etc.) do. We can inspect the structure of a HT to understand how decisions were made, which is a nice feature to have in online learning tasks.</p> <p>In <code>river</code>, HTs are first-class citizens, so we have multiple realizations of this framework that are suited to different learning tasks and scenarios.</p> <p>This brief introduction to HT does not aims at being extensive nor delving into algorithmic or implementation details of the HTs. Instead, we intend to provide a high-level overview of the HTs as they are envisioned in <code>river</code>, as well as their shared properties and important hyperparameters.</p> <p>In this guide, we are going to:</p> <ol> <li>summarize the differences accross the multiple HT versions available;</li> <li>learn how to inspect tree models;</li> <li>learn how to manage the memory usage of HTs;</li> <li>compare numerical tree splitters and understand their impact on the iDT induction process.</li> </ol> <p>Well, without further ado, let's go! </p> <p>First things first, we are going to start with some imports.</p> <pre><code>import matplotlib.pyplot as plt\nimport datetime as dt\n\nfrom river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import preprocessing  # we are going to use that later\nfrom river.datasets import synth  # we are going to use some synthetic datasets too\nfrom river import tree\n</code></pre>"},{"location":"recipes/on-hoeffding-trees/#1-trees-trees-everywhere-gardening-101-with-river","title":"1. Trees, trees everywhere: gardening 101 with river","text":"<p>At first glance, the amount of iDT algorithms in <code>river</code> might seem too much to handle, but in reality the distinction among them is easy to grasp. To facilitate our lives, here's a neat table listing the available HT models and summarizing their differences:</p>    Name Acronym Task Non-stationary? Comments Source     Hoeffding Tree Classifier HTC Classification No Basic HT for classification tasks [1]   Hoeffding Adaptive Tree Classifier HATC Classification Yes Modifies HTC by adding an instance of ADWIN to each node to detect and react to drift detection [2]   Extremely Fast Decision Tree Classifier EFDT Classification No Deploys split decisions as soon as possible and periodically revisit decisions and redo them if necessary. Not as fast in practice as the name implies, but it tends to converge faster than HTC to the model generated by a batch DT [3]   Hoeffding Tree Regressor HTR Regression No Basic HT for regression tasks. It is an adaptation of the FIRT/FIMT algorithm that bears some semblance to HTC [4]   Hoeffding Adaptive Tree Regressor HATR Regression Yes Modifies HTR by adding an instance of ADWIN to each node to detect and react to drift detection -   incremental Structured-Output Prediction Tree Regressor iSOUPT Multi-target regression No Multi-target version of HTR [5]   Label Combination Hoeffding Tree Classifier LCHTC Multi-label classification No Creates a numerical code for each combination of the binary labels and uses HTC to learn from this encoded representation. At prediction time, decodes the modified representation to obtain the original label set -    <p>As we can see, although their application fields might overlap sometimes, the HT variations have specific situations in which they are better suited to work. Moreover, in <code>river</code> we provide a standardized API access to all the HT variants since they share many properties in common.</p>"},{"location":"recipes/on-hoeffding-trees/#2-how-to-inspect-tree-models","title":"2. How to inspect tree models?","text":"<p>We provide a handful of tools to inspect trained HTs in <code>river</code>. Here, we will provide some examples of how to access their inner structures, get useful information, and plot the iDT structure.</p> <p>Firstly, let's pick a toy dataset from which our tree will learn from. Here we are going to focus on the classification case, but the same operations apply to other learning tasks. We will select the <code>Phishing</code> dataset from the <code>datasets</code> module to exemplify the HTs' capabilities.</p> <pre><code>dataset = datasets.Phishing()\ndataset\n</code></pre> <pre>\nPhishing websites.\n\nThis dataset contains features from web pages that are classified as phishing or not.\n\n    Name  Phishing                                                        \n    Task  Binary classification                                           \n Samples  1,250                                                           \nFeatures  9                                                               \n  Sparse  False                                                           \n    Path  /Users/max.halford/projects/river/river/datasets/phishing.csv.gz\n</pre> <p>We are going to train an instance of <code>HoeffdingTreeClassifier</code> using this dataset. As everything else in <code>river</code>, training an iDT is a piece of cake!</p> <pre><code>%%time\n\nmodel = tree.HoeffdingTreeClassifier(grace_period=50)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel\n</code></pre> <pre><code>CPU times: user 174 ms, sys: 5.16 ms, total: 180 ms\nWall time: 192 ms\n</code></pre> <pre>\nHoeffdingTreeClassifier (\n  grace_period=50\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)\n</pre> <p>That's it! We are not going to enter into details about some of the available parameters of HTC here. The user can refer to the documentation page for more information about that. Let's talk about model inspection :D</p> <p>At any time, we can easily get some statistics about our trained model by using the <code>summary</code> property:</p> <pre><code>model.summary\n</code></pre> <pre>\n{\n    'n_nodes': 5,\n    'n_branches': 2,\n    'n_leaves': 3,\n    'n_active_leaves': 3,\n    'n_inactive_leaves': 0,\n    'height': 3,\n    'total_observed_weight': 1250.0\n}\n</pre> <p>This property show us the internal structure of the tree, including data concerning the memory-management routines that we are going to check later in this guide. We can also get a representation of the tree model as a <code>pandas.DataFrame</code> object:</p> <pre><code>model.to_dataframe().iloc[:5, :5]\n</code></pre>       parent is_leaf depth stats feature   node          0 &lt;NA&gt; False 0 {True: 260.0, False: 390.0} empty_server_form_handler   1 0 True 1 {True: 443.4163997711022, False: 59.8769131081... NaN   2 0 False 1 {True: 71.58360022889781, False: 404.123086891... popup_window   3 2 True 2 {False: 31.426538522574834, True: 33.0} NaN   4 2 True 2 {False: 250.57346147742516, True: 6.0} NaN     <p>Hmm, maybe not the clearest of the representations. What about drawing the tree structure instead?</p> <pre><code>model.draw()\n</code></pre>  <p>Much better, huh?</p> <p>Lastly, we can check how the tree predicts one specific instance by using the <code>debug_one</code> method:</p> <pre><code>x, y = next(iter(dataset))  # Let's select the first example in the stream\nx, y\n</code></pre> <pre>\n(\n    {\n        'empty_server_form_handler': 0.0,\n        'popup_window': 0.0,\n        'https': 0.0,\n        'request_from_other_domain': 0.0,\n        'anchor_from_other_domain': 0.0,\n        'is_popular': 0.5,\n        'long_url': 1.0,\n        'age_of_domain': 1,\n        'ip_in_url': 1\n    },\n    True\n)\n</pre> <pre><code>print(model.debug_one(x))\n</code></pre> <pre>empty_server_form_handler \u2264 0.5454545454545454\nClass True:\n        P(False) = 0.1\n        P(True) = 0.9\n\n</pre> <p>Our tree got this one right! The method <code>debug_one</code> is especially useful when we are dealing with a big tree model where drawing might not be the wisest of the choices (we will end up with a tree chart that has too much information to visually understand).</p> <p>Some additional hints:</p> <ul> <li>the <code>max_depth</code> parameter is our friend when building HTs that need to be constantly inspected. This parameter, which is available for every HT variant, triggers a pre-pruning mechanism that stops tree growth when the given depth is reached.</li> <li>we can also limit the depth when using the <code>draw</code> method.</li> <li>in the case of tree ensembles, individual trees can be accessed using the <code>[index]</code> operator. Then, the same set of inspection tools are available to play with!</li> </ul>"},{"location":"recipes/on-hoeffding-trees/#3-advanced-gardening-with-river-grab-your-pruning-shears-and-lets-limit-memory-usage","title":"3. Advanced gardening with river: grab your pruning shears and let's limit memory usage","text":"<p>Online learning is well-suited to highly scalable processing centers with petabytes of data arriving intermittently, but it can also work with Internet of Things (IoT) devices operating at low power and with limited processing capability. Hence, making sure our trees are not going to use too much memory is a nice feature that can impact on both energy usage and the running time. HTs have memory-management routines that put the user in the control of computational resources that are available.</p> <p>In this brief guide, we are going to use a regression tree, since this kind of iDT typically spends more memory than the classification counterparts. However, the user can control the memory usage in the exact same way in <code>river</code>, regardless of the HT variant!</p> <p>We will rely on the <code>Friedman</code> synthetic dataset (data generator) from the <code>synth</code> module in our evaluation. Since data generators can produce instances indefinitely, we will select a sample of size 10K for our tests.</p> <p>We are almost ready to go. Let's first define a simple function that plots the results obtained from a given dataset, metric and </p> <pre><code>def plot_performance(dataset, metric, models):\n    metric_name = metric.__class__.__name__\n\n    # To make the generated data reusable\n    dataset = list(dataset)\n    fig, ax = plt.subplots(figsize=(10, 5), nrows=3, dpi=300)\n    for model_name, model in models.items():\n        step = []\n        error = []\n        r_time = []\n        memory = []\n\n        for checkpoint in evaluate.iter_progressive_val_score(\n            dataset, model, metric, measure_time=True, measure_memory=True, step=100\n        ):\n            step.append(checkpoint[\"Step\"])\n            error.append(checkpoint[metric_name].get())\n\n            # Convert timedelta object into seconds\n            r_time.append(checkpoint[\"Time\"].total_seconds())\n            # Make sure the memory measurements are in MB\n            raw_memory = checkpoint[\"Memory\"]\n            memory.append(raw_memory * 2**-20)\n\n        ax[0].plot(step, error, label=model_name)\n        ax[1].plot(step, r_time, label=model_name)\n        ax[2].plot(step, memory, label=model_name)\n\n    ax[0].set_ylabel(metric_name)\n    ax[1].set_ylabel('Time (seconds)')\n    ax[2].set_ylabel('Memory (MB)')\n    ax[2].set_xlabel('Instances')\n\n    ax[0].grid(True)\n    ax[1].grid(True)\n    ax[2].grid(True)\n\n    ax[0].legend(\n        loc='upper center', bbox_to_anchor=(0.5, 1.25),\n        ncol=3, fancybox=True, shadow=True\n    )\n    plt.tight_layout()\n    plt.close()\n\n    return fig\n</code></pre> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"Unbounded HTR\": (\n            preprocessing.StandardScaler() |\n            tree.HoeffdingTreeRegressor(splitter=tree.splitter.EBSTSplitter())\n        )\n    }\n)\n</code></pre> <pre>&lt;Figure size 3000x1500 with 3 Axes&gt;\n</pre>  <p>In our example we use the <code>EBSTSplitter</code>, which is going to discussed later. For now, is enough to know that it is a mechanism to evaluate split candidates in the trees.</p> <p>As we can see, our tree uses almost 10 MB to keep its structure. Let's say we wanted to limit our memory usage to 5 MB. How could we do that?</p> <p>Note that we are using a illustration case here. In real applications, data may be unbounded, so the trees might grow indefinitely.</p> <p>HTs expose some parameters related to memory management. The user can refer to the documentation for more details on that matter. Here, we are going to focus on two parameters:</p> <ul> <li><code>max_size</code>: determines the maximum amount of memory (in MB) that the HT can use.</li> <li><code>memory_estimate_period</code>: intervals after which the memory-management is triggered.</li> </ul> <p>We are going to limit our HTR to 5 MB and perform memory checks at intervals of 500 instances.</p> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"Restricted HTR\": (\n            preprocessing.StandardScaler()\n            | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.EBSTSplitter(),\n                max_size=5,\n                memory_estimate_period=500\n            )\n        )\n    }\n)\n</code></pre> <pre>&lt;Figure size 3000x1500 with 3 Axes&gt;\n</pre>  <p>Note that as soon the memory usage reaches the limit that we determined (at the memory check intervals), HTR starts managing its resource usage to reduce the size. As a consequence, the running time also decreases. For more accurate management, the intervals between memory checks should be decreased. This action, however, has costs since the tree stops the learning process to estimate its size and alter its own structure. Too frequent memory checks might end up result in a slow learning process. Besides, by using fewer resources, the predictive performance can be negatively impacted. So, use this tool with caution!</p> <p>But how that works at all?</p> <p>HTs monitor the incoming feature values to perform split attempts. To do so, they rely on a class of algorithms called Attribute Observers (AO) or Splitters (spoiler alert!). Each leaf node in an HT keeps one AO per incoming feature. After pre-determined intervals (<code>grace_period</code> parameter), leaves query their AOs for split candidates. Well, there are costs to monitor input features (mainly the numerical ones). In fact, AOs correspond to one of the most time and memory-consuming portions of the HTs. To manage memory usage, an HT firstly determines its least promising leaves, w.r.t. how likely they will be split. Then, these leaves' AOs are removed, and the tree nodes are said to be \"deactivated.\" That's it! The deactivated leaves do not perform split attempts anymore, but they continue to be updated to provide responses. They will be kept as leaves as long as there are not available resources to enable tree growth. These leaves can be activated again (meaning that new AOs will be created for them) if there is available memory, so don't worry!</p> <p>Hint: another indirect way to bound memory usage is to limit the tree depth. By default, the trees can grow indefinitely, but the <code>max_depth</code> parameter can control this behavior.</p> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"HTR with at most 5 levels\": (\n            preprocessing.StandardScaler()\n            | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.EBSTSplitter(),\n                max_depth=5\n            )\n        )\n    }\n)\n</code></pre> <pre>&lt;Figure size 3000x1500 with 3 Axes&gt;\n</pre>"},{"location":"recipes/on-hoeffding-trees/#4-branching-and-growth-splitters-the-heart-of-the-trees","title":"4. Branching and growth: splitters, the heart of the trees","text":"<p>As previously stated, one of the core operations of iDT is, well, to grow. Plants and gardening-related jokes apart, growth in HTs is guided by their AOs or splitters, as mentioned in the end of Section 3. </p> <p>Nominal features can be easily monitored, since the feature partitions are well-defined beforehand. Numerical features, on the other hand, do not have an explicit best cut point. Still, numerical features are typically split by using a binary test: \\(\\le\\) or \\(&gt;\\). Therefore, numerical splitters must somehow summarize the incoming feature values and be able to evaluate the merit of split point candidates.</p> <p>There are diverse strategies to monitor numerical features and choices related to them, including which data structure will be used to keep a summary of the incoming feature and also how many split points are going to be evaluated during split attempts. Again, this guide does not intend to be an exhaustive delve into the iDT subject. In fact, each of the following aspects of the iDTs could be considered a separate research area: AOs, intervals between split attempts, split heuristics (e.g., info gain, variance reduction, and so on), tree depth and max size, and much more!</p> <p>Let's focus a bit into the AO matter. River provides a handful of splitters for classification and regression trees, which can be chosen using the parameter <code>splitter</code>. We will list the available tree splitters in the following sections and compare some of their chacteristics.</p> <p>Some notation:</p> <ul> <li>\\(n\\): Number of observations seen so far.</li> <li>\\(c\\): the number of classes.</li> <li>\\(s\\): the number of split points to evaluate (which means that this is a user-given parameter).</li> <li>\\(h\\): the number of histogram bins or hash slots. Tipically, \\(h \\ll n\\).</li> </ul>"},{"location":"recipes/on-hoeffding-trees/#41-classification-tree-splitters","title":"4.1. Classification tree splitters","text":"<p>The following table summarizes the available classification splitters. The user might refer to the documentation of each splitter for more details about their functioning.</p>    Splitter Description Insertion Memory Split candidate query Works with Naive Bayes leaves?     Exhaustive Keeps all the observed input values and class counts in a Binary Search Tree (BST) \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\) No   Histogram Builds a histogram for each class in order to discretize the input feature \\(O(\\log h)\\) \\(O(c h)\\) \\(O(c h)\\) Yes   Gaussian Approximates the class distributions using Gaussian distributions \\(O(1)\\) \\(O(c)\\) \\(O(cs)\\) Yes    <p>Note that some of the splitters have configurable parameters that directly impact not only on their time and memory costs, but also on the final predictive performance. Examples:</p> <ul> <li>The number of split points can be configured in the Gaussian splitter. Increasing this number makes this splitter slower, but it also potentially increases the quality of the obtained query points, implying enhanced tree accuracy. </li> <li>The number of stored bins can be selected in the Histogram splitter. Increasing this number increases the memory footprint and running time of this splitter, but it also potentially makes its split candidates more accurate and positively impacts on the tree's final predictive performance.</li> </ul> <p>Next, we provide a brief comparison of the classification splitters using 10K instances of the Random RBF synthetic dataset. Note that the tree equiped with the Exhaustive splitter does not use Naive Bayes leaves.</p> <pre><code>plot_performance(\n    synth.RandomRBF(seed_model=7, seed_sample=42).take(10_000),\n    metrics.Accuracy(),\n    {\n        \"HTC + Exhaustive splitter\": tree.HoeffdingTreeClassifier(\n            splitter=tree.splitter.ExhaustiveSplitter(),\n            leaf_prediction=\"mc\"\n        ),\n        \"HTC + Histogram splitter\": tree.HoeffdingTreeClassifier(\n            splitter=tree.splitter.HistogramSplitter()\n        ),\n        \"HTC + Gaussian splitter\": tree.HoeffdingTreeClassifier(\n            splitter=tree.splitter.GaussianSplitter()\n        )\n    }\n)\n</code></pre> <pre>&lt;Figure size 3000x1500 with 3 Axes&gt;\n</pre>"},{"location":"recipes/on-hoeffding-trees/#42-regression-tree-splitters","title":"4.2 Regression tree splitters","text":"<p>The available regression tree splitters are summarized in the next table. The TE-BST costs are expressed in terms of \\(n^*\\) because the number of stored elements can be smaller than or equal to \\(n\\).</p>    Splitter Description Insertion Memory Split candidate query     Extended Binary Search Tree (E-BST) Stores all the observations and target statistics in a BST \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\)   Truncated E-BST (TE-BST) Rounds the incoming data before passing it to the BST \\(O(\\log n^*)\\) (average) or \\(O(n^*)\\) (worst case) \\(O(n^*)\\) \\(O(n^*)\\)   Quantization Observer (QO) Uses a hash-like structure to quantize the incoming data \\(O(1)\\) \\(O(h)\\) \\(O(h \\log h)\\)    <p>E-BST is an exhaustive algorithm, i.e., it works as batch solutions usually do, which might be prohibitive in real-world online scenarios. TE-BST and QO apply approximations to alleviate the costs involved in monitoring numerical data and performing split attempts. The number of desired decimal places to round the data (TE-BST) and the quantization radius (QO) are directly related to the running time, memory footprint, and error of the resulting tree model.</p> <p>We present a brief comparison of the available regression tree splitters using the 10K instances of the Friedman synthetic dataset.</p> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"HTR + E-BST\": (\n            preprocessing.StandardScaler() | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.EBSTSplitter()\n            )\n        ),\n        \"HTR + TE-BST\": (\n            preprocessing.StandardScaler() | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.TEBSTSplitter()\n            )\n        ),\n        \"HTR + QO\": (\n            preprocessing.StandardScaler() | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.QOSplitter()\n            )\n        ),\n\n    }\n)\n</code></pre> <pre>&lt;Figure size 3000x1500 with 3 Axes&gt;\n</pre>"},{"location":"recipes/on-hoeffding-trees/#wrapping-up","title":"Wrapping up","text":"<p>This guide provides a walkthrough in the HTs available in <code>river</code>. We discussed about model inspection, memory management, and feature splits. Keep in mind that each HT variant has specific details and capabilities that are out-of-the-scope of this introductory material. The user is advised to check the documentation page of the tree models for detailed information.</p>"},{"location":"recipes/pipelines/","title":"Pipelines","text":"<p>Pipelines are an integral part of River. We encourage their usage and apply them in many of their examples.</p> <p>The <code>compose.Pipeline</code> contains all the logic for building and applying pipelines. A pipeline is essentially a list of estimators that are applied in sequence. The only requirement is that the first <code>n - 1</code> steps be transformers. The last step can be a regressor, a classifier, a clusterer, a transformer, etc. Here is an example:</p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import preprocessing\nfrom river import feature_extraction\n\nmodel = compose.Pipeline(\n    preprocessing.StandardScaler(),\n    feature_extraction.PolynomialExtender(),\n    linear_model.LinearRegression()\n)\n</code></pre> <p>You can also use the <code>|</code> operator, as so:</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    feature_extraction.PolynomialExtender() |\n    linear_model.LinearRegression()\n)\n</code></pre> <p>Or, equally:</p> <pre><code>model = preprocessing.StandardScaler() \nmodel |= feature_extraction.PolynomialExtender()\nmodel |= linear_model.LinearRegression()\n</code></pre> <p>A pipeline has a <code>draw</code> method that can be used to visualize it:</p> <pre><code>model\n</code></pre> <pre>StandardScaler</pre><code>(   with_std=True )  </code><pre>PolynomialExtender</pre><code>(   degree=2   interaction_only=False   include_bias=False   bias_name=\"bias\" )  </code><pre>LinearRegression</pre><code>(   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () )  </code> <p><code>compose.Pipeline</code> inherits from <code>base.Estimator</code>, which means that it has a <code>learn_one</code> method. You would expect <code>learn_one</code> to update each estimator, but that's not actually what happens. Instead, the transformers are updated when <code>predict_one</code> (or <code>predict_proba_one</code> for that matter) is called. Indeed, in online machine learning, we can update the unsupervised parts of our model when a sample arrives. We don't have to wait for the ground truth to arrive in order to update unsupervised estimators that don't depend on it. In other words, in a pipeline, <code>learn_one</code> updates the supervised parts, whilst <code>predict_one</code> updates the unsupervised parts. It's important to be aware of this behavior, as it is quite different to what is done in other libraries that rely on batch machine learning.</p> <p>Here is a small example to illustrate the previous point:</p> <pre><code>from river import datasets\n\ndataset = datasets.TrumpApproval()\nx, y = next(iter(dataset))\nx, y\n</code></pre> <pre>\n(\n    {\n        'ordinal_date': 736389,\n        'gallup': 43.843213,\n        'ipsos': 46.19925042857143,\n        'morning_consult': 48.318749,\n        'rasmussen': 44.104692,\n        'you_gov': 43.636914000000004\n    },\n    43.75505\n)\n</pre> <p>Let us call <code>predict_one</code>, which will update each transformer, but won't update the linear regression.</p> <pre><code>model.predict_one(x)\n</code></pre> <pre>0.0\n</pre> <p>The prediction is nil because each weight of the linear regression is equal to 0.</p> <pre><code>model['StandardScaler'].means\n</code></pre> <pre>\ndefaultdict(&lt;class 'float'&gt;, {\n    'ordinal_date': 736389.0,\n    'gallup': 43.843213,\n    'ipsos': 46.19925042857143,\n    'morning_consult': 48.318749,\n    'rasmussen': 44.104692,\n    'you_gov': 43.636914000000004\n})\n</pre> <p>As we can see, the means of each feature have been updated, even though we called <code>predict_one</code> and not <code>learn_one</code>.</p> <p>Note that if you call <code>transform_one</code> with a pipeline who's last step is not a transformer, then the output from the last transformer (which is thus the penultimate step) will be returned:</p> <pre><code>model.transform_one(x)\n</code></pre> <pre>\n{\n    'ordinal_date': 0.0,\n    'gallup': 0.0,\n    'ipsos': 0.0,\n    'morning_consult': 0.0,\n    'rasmussen': 0.0,\n    'you_gov': 0.0,\n    'ordinal_date*ordinal_date': 0.0,\n    'gallup*ordinal_date': 0.0,\n    'ipsos*ordinal_date': 0.0,\n    'morning_consult*ordinal_date': 0.0,\n    'ordinal_date*rasmussen': 0.0,\n    'ordinal_date*you_gov': 0.0,\n    'gallup*gallup': 0.0,\n    'gallup*ipsos': 0.0,\n    'gallup*morning_consult': 0.0,\n    'gallup*rasmussen': 0.0,\n    'gallup*you_gov': 0.0,\n    'ipsos*ipsos': 0.0,\n    'ipsos*morning_consult': 0.0,\n    'ipsos*rasmussen': 0.0,\n    'ipsos*you_gov': 0.0,\n    'morning_consult*morning_consult': 0.0,\n    'morning_consult*rasmussen': 0.0,\n    'morning_consult*you_gov': 0.0,\n    'rasmussen*rasmussen': 0.0,\n    'rasmussen*you_gov': 0.0,\n    'you_gov*you_gov': 0.0\n}\n</pre> <p>In many cases, you might want to connect a step to multiple steps. For instance, you might to extract different kinds of features from a single input. An elegant way to do this is to use a <code>compose.TransformerUnion</code>. Essentially, the latter is a list of transformers who's results will be merged into a single <code>dict</code> when <code>transform_one</code> is called. As an example let's say that we want to apply a <code>feature_extraction.RBFSampler</code> as well as the <code>feature_extraction.PolynomialExtender</code>. This may be done as so:</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    (feature_extraction.PolynomialExtender() + feature_extraction.RBFSampler()) |\n    linear_model.LinearRegression()\n)\n\nmodel\n</code></pre> <pre>StandardScaler</pre><code>(   with_std=True )  </code><pre>PolynomialExtender</pre><code>(   degree=2   interaction_only=False   include_bias=False   bias_name=\"bias\" )  </code><pre>RBFSampler</pre><code>(   gamma=1.   n_components=100   seed=None )  </code><pre>LinearRegression</pre><code>(   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () )  </code> .river-estimator {     padding: 1em;     border-style: solid;     background: white; }  .river-pipeline {     display: flex;     flex-direction: column;     align-items: center;     background: linear-gradient(#000, #000) no-repeat center / 3px 100%; }  .river-union {     display: flex;     flex-direction: row;     align-items: center;     justify-content: center;     padding: 1em;     border-style: solid;     background: white; }  .river-wrapper {     display: flex;     flex-direction: column;     align-items: center;     justify-content: center;     padding: 1em;     border-style: solid;     background: white; }  .river-wrapper &gt; .river-estimator {     margin-top: 1em; }  /* Vertical spacing between steps */  .river-component + .river-component {     margin-top: 2em; }  .river-union &gt; .river-estimator {     margin-top: 0; }  .river-union &gt; .pipeline {     margin-top: 0; }  /* Spacing within a union of estimators */  .river-union &gt; .river-component + .river-component {     margin-left: 1em; }  /* Typography */  .river-estimator-params {     display: block;     white-space: pre-wrap;     font-size: 120%;     margin-bottom: -1em; }  .river-estimator &gt; .river-estimator-params, .river-wrapper &gt; .river-details &gt; river-estimator-params {     background-color: white !important; }  .river-estimator-name {     display: inline;     margin: 0;     font-size: 130%; }  /* Toggle */  .river-summary {     display: flex;     align-items:center;     cursor: pointer; }  .river-summary &gt; div {     width: 100%; }  <p>Note that the <code>+</code> symbol acts as a shorthand notation for creating a <code>compose.TransformerUnion</code>, which means that we could have declared the above pipeline as so:</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    compose.TransformerUnion(\n        feature_extraction.PolynomialExtender(),\n        feature_extraction.RBFSampler()\n    ) |\n    linear_model.LinearRegression()\n)\n</code></pre> <p>Pipelines provide the benefit of removing a lot of cruft by taking care of tedious details for you. They also enable to clearly define what steps your model is made of. Finally, having your model in a single object means that you can move it around more easily. Note that you can include user-defined functions in a pipeline by using a <code>compose.FuncTransformer</code>.</p>"},{"location":"recipes/reading-data/","title":"Reading data","text":"<p>In <code>river</code>, the features of a sample are stored inside a dictionary, which in Python is called a <code>dict</code> and is a native data structure. In other words, we don't use any sophisticated data structure, such as a <code>numpy.ndarray</code> or a <code>pandas.DataFrame</code>.</p> <p>The main advantage of using plain <code>dict</code>s is that it removes the overhead that comes with using the aforementioned data structures. This is important in a streaming context because we want to be able to process many individual samples in rapid succession. Another advantage is that <code>dict</code>s allow us to give names to our features. Finally, <code>dict</code>s are not typed, and can therefore store heterogeneous data.</p> <p>Another advantage which we haven't mentioned is that <code>dict</code>s play nicely with Python's standard library. Indeed, Python contains many tools that allow manipulating <code>dict</code>s. For instance, the <code>csv.DictReader</code> can be used to read a CSV file and convert each row to a <code>dict</code>. In fact, the <code>stream.iter_csv</code> method from <code>river</code> is just a wrapper on top of <code>csv.DictReader</code> that adds a few bells and whistles.</p> <p><code>river</code> provides some out-of-the-box datasets to get you started.</p> <pre><code>from river import datasets\n\ndataset = datasets.Bikes()\ndataset\n</code></pre> <pre>\nBike sharing station information from the city of Toulouse.\n\nThe goal is to predict the number of bikes in 5 different bike stations from the city of\nToulouse.\n\n      Name  Bikes                                                         \n      Task  Regression                                                    \n   Samples  182,470                                                       \n  Features  8                                                             \n    Sparse  False                                                         \n      Path  /Users/max.halford/river_data/Bikes/toulouse_bikes.csv        \n       URL  https://maxhalford.github.io/files/datasets/toulouse_bikes.zip\n      Size  12.52 MB                                                      \nDownloaded  True                                                          \n</pre> <p>Note that when we say \"loaded\", we don't mean that the actual data is read from the disk. On the contrary, the dataset is a streaming data that can be iterated over one sample at a time. In Python lingo, it's a generator.</p> <p>Let's take a look at the first sample:</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre>\n{\n    'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n    'station': 'metro-canal-du-midi',\n    'clouds': 75,\n    'description': 'light rain',\n    'humidity': 81,\n    'pressure': 1017.0,\n    'temperature': 6.54,\n    'wind': 9.3\n}\n</pre> <p>Each dataset is iterable, which means we can also do:</p> <pre><code>for x, y in dataset:\n    break\nx\n</code></pre> <pre>\n{\n    'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n    'station': 'metro-canal-du-midi',\n    'clouds': 75,\n    'description': 'light rain',\n    'humidity': 81,\n    'pressure': 1017.0,\n    'temperature': 6.54,\n    'wind': 9.3\n}\n</pre> <p>As we can see, the values have different types.</p> <p>Under the hood, calling <code>for x, y in dataset</code> simply iterates over a file and parses each value appropriately. We can do this ourselves by using <code>stream.iter_csv</code>:</p> <pre><code>from river import stream\n\nX_y = stream.iter_csv(dataset.path)\nx, y = next(X_y)\nx, y\n</code></pre> <pre>\n(\n    {\n        'moment': '2016-04-01 00:00:07',\n        'bikes': '1',\n        'station': 'metro-canal-du-midi',\n        'clouds': '75',\n        'description': 'light rain',\n        'humidity': '81',\n        'pressure': '1017.0',\n        'temperature': '6.54',\n        'wind': '9.3'\n    },\n    None\n)\n</pre> <p>There are a couple things that are wrong. First of all, the numeric features have not been casted into numbers. Indeed, by default, <code>stream.iter_csv</code> assumes that everything is a string. A related issue is that the <code>moment</code> field hasn't been parsed into a <code>datetime</code>. Finally, the target field, which is <code>bikes</code>, hasn't been separated from the rest of the features. We can remedy to these issues by setting a few parameters:</p> <pre><code>X_y = stream.iter_csv(\n    dataset.path,\n    converters={\n        'bikes': int,\n        'clouds': int,\n        'humidity': int,\n        'pressure': float,\n        'temperature': float,\n        'wind': float\n    },\n    parse_dates={'moment': '%Y-%m-%d %H:%M:%S'},\n    target='bikes'\n)\nx, y = next(X_y)\nx, y\n</code></pre> <pre>\n(\n    {\n        'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n        'station': 'metro-canal-du-midi',\n        'clouds': 75,\n        'description': 'light rain',\n        'humidity': 81,\n        'pressure': 1017.0,\n        'temperature': 6.54,\n        'wind': 9.3\n    },\n    1\n)\n</pre> <p>That's much better. We invite you to take a look at the <code>stream</code> module to see for yourself what other methods are available. Note that <code>river</code> is first and foremost a machine learning library, and therefore isn't as much concerned about reading data as it is about statistical algorithms. We do however believe that the fact that we use dictionary gives you, the user, a lot of freedom and flexibility.</p> <p>The <code>stream</code> module provides helper functions to read data from different formats. For instance, you can use the <code>stream.iter_sklearn_dataset</code> function to turn any scikit-learn dataset into a stream.</p> <pre><code>from sklearn import datasets\n\ndataset = datasets.load_diabetes()\n\nfor x, y in stream.iter_sklearn_dataset(dataset):\n    break\n\nx, y\n</code></pre> <pre>\n(\n    {\n        'age': 0.038075906433423026,\n        'sex': 0.05068011873981862,\n        'bmi': 0.061696206518683294,\n        'bp': 0.0218723855140367,\n        's1': -0.04422349842444599,\n        's2': -0.03482076283769895,\n        's3': -0.04340084565202491,\n        's4': -0.002592261998183278,\n        's5': 0.019907486170462722,\n        's6': -0.01764612515980379\n    },\n    151.0\n)\n</pre> <p>To conclude, let us shortly mention the difference between proactive learning and reactive learning in the specific context of online machine learning. When we loop over a data with a <code>for</code> loop, we have the control over the data and the order in which it arrives. We are proactive in the sense that we, the user, are asking for the data to arrive.</p> <p>In contract, in a reactive situation, we don't have control on the data arrival. A typical example of such a situation is a web server, where web requests arrive in an arbitrary order. This is a situation where <code>river</code> shines. For instance, in a Flask application, you could define a route to make predictions with a <code>river</code> model as so:</p> <pre><code>import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/', methods=['GET'])\ndef predict():\n    payload = flask.request.json\n    river_model = load_model()\n    return river_model.predict_proba_one(payload)\n</code></pre> <p>Likewise, a model can be updated whenever a request arrives as so:</p> <pre><code>@app.route('/', methods=['POST'])\ndef learn():\n    payload = flask.request.json\n    river_model = load_model()\n    river_model.learn_one(payload['features'], payload['target'])\n    return {}, 201\n</code></pre> <p>To summarize, <code>river</code> can be used in many different ways. The fact that it uses dictionaries to represent features provides a lot of flexibility and space for creativity.</p>"},{"location":"recipes/rolling-computations/","title":"Rolling computations","text":"<p>You might wonder which classes in River can be wrapped with a <code>utils.Rolling</code>. This can be answered with a bit of metaprogramming.</p> <pre><code>import importlib\nimport inspect\nfrom river.utils.rolling import Rollable\n\nfor submodule in importlib.import_module(\"river.api\").__all__:\n    for _, obj in inspect.getmembers(\n        importlib.import_module(f\"river.{submodule}\"), lambda x: isinstance(x, Rollable)\n    ):\n        print(f'{submodule}.{obj.__name__}')\n</code></pre> <pre>covariance.EmpiricalCovariance\n</pre> <pre>metrics.Accuracy\n</pre> <pre>metrics.AdjustedMutualInfo\n</pre> <pre>metrics.AdjustedRand\n</pre> <pre>metrics.BalancedAccuracy\n</pre> <pre>metrics.ClassificationReport\n</pre> <pre>metrics.CohenKappa\n</pre> <pre>metrics.Completeness\n</pre> <pre>metrics.ConfusionMatrix\n</pre> <pre>metrics.CrossEntropy\n</pre> <pre>metrics.F1\n</pre> <pre>metrics.FBeta\n</pre> <pre>metrics.FowlkesMallows\n</pre> <pre>metrics.GeometricMean\n</pre> <pre>metrics.Homogeneity\n</pre> <pre>metrics.Jaccard\n</pre> <pre>metrics.LogLoss\n</pre> <pre>metrics.MAE\n</pre> <pre>metrics.MCC\n</pre> <pre>metrics.MSE\n</pre> <pre>metrics.MacroF1\n</pre> <pre>metrics.MacroFBeta\n</pre> <pre>metrics.MacroJaccard\n</pre> <pre>metrics.MacroPrecision\n</pre> <pre>metrics.MacroRecall\n</pre> <pre>metrics.MicroF1\n</pre> <pre>metrics.MicroFBeta\n</pre> <pre>metrics.MicroJaccard\n</pre> <pre>metrics.MicroPrecision\n</pre> <pre>metrics.MicroRecall\n</pre> <pre>metrics.MultiFBeta\n</pre> <pre>metrics.MutualInfo\n</pre> <pre>metrics.NormalizedMutualInfo\n</pre> <pre>metrics.Precision\n</pre> <pre>metrics.R2\n</pre> <pre>metrics.RMSE\n</pre> <pre>metrics.RMSLE\n</pre> <pre>metrics.ROCAUC\n</pre> <pre>metrics.Rand\n</pre> <pre>metrics.Recall\n</pre> <pre>metrics.SMAPE\n</pre> <pre>metrics.Silhouette\n</pre> <pre>metrics.VBeta\n</pre> <pre>metrics.WeightedF1\n</pre> <pre>metrics.WeightedFBeta\n</pre> <pre>metrics.WeightedJaccard\n</pre> <pre>metrics.WeightedPrecision\n</pre> <pre>metrics.WeightedRecall\n</pre> <pre>proba.Beta\n</pre> <pre>proba.Gaussian\n</pre> <pre>proba.Multinomial\n</pre> <pre>stats.BayesianMean\n</pre> <pre>stats.Cov\n</pre> <pre>stats.Mean\n</pre> <pre>stats.PearsonCorr\n</pre> <pre>stats.SEM\n</pre> <pre>stats.Sum\n</pre> <pre>stats.Var\n</pre>"},{"location":"releases/0.0.2/","title":"0.0.2 - 2019-02-13","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.0.2/#compat","title":"compat","text":"<ul> <li>Added <code>sklearn</code> wrappers.</li> </ul>"},{"location":"releases/0.0.2/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.HedgeClassifier</code>.</li> </ul>"},{"location":"releases/0.0.2/#feature_selection","title":"feature_selection","text":"<ul> <li>Added <code>feature_selection.RandomDiscarder</code>.</li> </ul>"},{"location":"releases/0.0.2/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added <code>feature_extraction.TargetEncoder</code>.</li> </ul>"},{"location":"releases/0.0.2/#impute","title":"impute","text":"<ul> <li>Added <code>impute.NumericImputer</code>.</li> </ul>"},{"location":"releases/0.0.2/#optim","title":"optim","text":"<ul> <li>Added <code>optim.AbsoluteLoss</code>.</li> <li>Added <code>optim.HingeLoss</code>.</li> <li>Added <code>optim.EpsilonInsensitiveHingeLoss</code>.</li> </ul>"},{"location":"releases/0.0.2/#stats","title":"stats","text":"<ul> <li>Added <code>stats.NUnique</code>.</li> <li>Added <code>stats.Min</code>.</li> <li>Added <code>stats.Max</code>.</li> <li>Added <code>stats.PeakToPeak</code>.</li> <li>Added <code>stats.Kurtosis</code>.</li> <li>Added <code>stats.Skew</code>.</li> <li>Added <code>stats.Sum</code>.</li> <li>Added <code>stats.EWMean</code>.</li> <li>Made sure the running statistics produce the same results as <code>pandas.DataFrame.rolling</code> method.</li> </ul>"},{"location":"releases/0.0.3/","title":"0.0.3 - 2019-03-21","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.0.3/#base","title":"base","text":"<ul> <li>Calling <code>fit_one</code> now returns the calling instance, not the out-of-fold prediction/transform; <code>fit_predict_one</code>, <code>fit_predict_proba_one</code>, and <code>fit_transform_one</code> are available to reproduce the previous behavior.</li> <li>Binary classifiers now output a <code>dict</code> with probabilities for <code>False</code> and <code>True</code> when calling <code>predict_proba_one</code>, which solves the interface issues of having multi-class classifiers do binary classification.</li> </ul>"},{"location":"releases/0.0.3/#compat","title":"compat","text":"<ul> <li>Added <code>compat.convert_river_to_sklearn</code>.</li> </ul>"},{"location":"releases/0.0.3/#compose","title":"compose","text":"<ul> <li>Added <code>compose.BoxCoxTransformRegressor</code>.</li> <li>Added <code>compose.TargetModifierRegressor</code>.</li> </ul>"},{"location":"releases/0.0.3/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_restaurants</code>.</li> <li>Added <code>datasets.load_airline</code>.</li> </ul>"},{"location":"releases/0.0.3/#dist","title":"dist","text":"<ul> <li>Added <code>dist.Multinomial</code>.</li> <li>Added <code>dist.Normal</code>.</li> </ul>"},{"location":"releases/0.0.3/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.BaggingRegressor</code>.</li> </ul>"},{"location":"releases/0.0.3/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added <code>feature_extraction.TargetGroupBy</code>.</li> </ul>"},{"location":"releases/0.0.3/#impute","title":"impute","text":"<ul> <li>Added <code>impute.CategoricalImputer</code>.</li> </ul>"},{"location":"releases/0.0.3/#linear_model","title":"linear_model","text":"<ul> <li>Added <code>linear_model.FMRegressor</code>.</li> <li>Removed all the passive-aggressive estimators.</li> </ul>"},{"location":"releases/0.0.3/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.Accuracy</code>.</li> <li>Added <code>metrics.MAE</code>.</li> <li>Added <code>metrics.MSE</code>.</li> <li>Added <code>metrics.RMSE</code>.</li> <li>Added <code>metrics.RMSLE</code>.</li> <li>Added <code>metrics.SMAPE</code>.</li> <li>Added <code>metrics.Precision</code>.</li> <li>Added <code>metrics.Recall</code>.</li> <li>Added <code>metrics.F1</code>.</li> </ul>"},{"location":"releases/0.0.3/#model_selection","title":"model_selection","text":"<ul> <li><code>model_selection.online_score</code> can now be passed a <code>metrics.Metric</code> instead of an <code>sklearn</code> metric; it also checks that the provided metric can be used with the accompanying model.</li> </ul>"},{"location":"releases/0.0.3/#naive_bayes","title":"naive_bayes","text":"<ul> <li>Added <code>naive_bayes.GaussianNB</code>.</li> </ul>"},{"location":"releases/0.0.3/#optim","title":"optim","text":"<ul> <li>Added <code>optim.PassiveAggressiveI</code>.</li> <li>Added <code>optim.PassiveAggressiveII</code>.</li> </ul>"},{"location":"releases/0.0.3/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.Discarder</code>.</li> <li>Added <code>preprocessing.PolynomialExtender</code>.</li> <li>Added <code>preprocessing.FuncTransformer</code>.</li> </ul>"},{"location":"releases/0.0.3/#reco","title":"reco","text":"<ul> <li>Added <code>reco.SVD</code>.</li> </ul>"},{"location":"releases/0.0.3/#stats","title":"stats","text":"<ul> <li>Added <code>stats.Mode</code>.</li> <li>Added <code>stats.Quantile</code>.</li> <li>Added <code>stats.RollingQuantile</code>.</li> <li>Added <code>stats.Entropy</code>.</li> <li>Added <code>stats.RollingMin</code>.</li> <li>Added <code>stats.RollingMax</code>.</li> <li>Added <code>stats.RollingMode</code>.</li> <li>Added <code>stats.RollingSum</code>.</li> <li>Added <code>stats.RollingPeakToPeak</code>.</li> </ul>"},{"location":"releases/0.0.3/#stream","title":"stream","text":"<ul> <li>Added <code>stream.iter_csv</code>.</li> </ul>"},{"location":"releases/0.0.3/#tree","title":"tree","text":"<ul> <li>Added <code>tree.MondrianTreeClassifier</code>.</li> <li>Added <code>tree.MondrianTreeRegressor</code>.</li> </ul>"},{"location":"releases/0.1.0/","title":"0.1.0 - 2019-05-08","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.1.0/#base","title":"base","text":"<ul> <li>Removed the <code>fit_predict_one</code> estimator method.</li> <li>Removed the <code>fit_predict_proba_one</code> estimator method.</li> <li>Removed the <code>fit_transform_one</code> estimator method.</li> </ul>"},{"location":"releases/0.1.0/#compat","title":"compat","text":"<ul> <li>Added <code>compat.convert_sklearn_to_river</code>.</li> <li><code>compat.convert_river_to_sklearn</code> now returns an <code>sklearn.pipeline.Pipeline</code> when provided with a <code>compose.Pipeline</code>.</li> </ul>"},{"location":"releases/0.1.0/#compose","title":"compose","text":"<ul> <li>Added <code>compose.Discard</code>.</li> <li>Added <code>compose.Select</code>.</li> <li>Added <code>compose.SplitRegressor</code>.</li> <li>The <code>draw</code> method of <code>compose.Pipeline</code> now works properly for arbitrary amounts of nesting, including multiple nested <code>compose.FeatureUnion</code>.</li> </ul>"},{"location":"releases/0.1.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_electricity</code>.</li> </ul>"},{"location":"releases/0.1.0/#dummy","title":"dummy","text":"<ul> <li>Added <code>dummy.NoChangeClassifier</code>.</li> <li>Added <code>dummy.PriorClassifier</code>.</li> <li>Added <code>dummy.StatisticRegressor</code>.</li> </ul>"},{"location":"releases/0.1.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added <code>feature_extraction.Differ</code>.</li> <li>Renamed <code>feature_extraction.GroupBy</code> to <code>feature_extraction.Agg</code>.</li> <li>Renamed <code>feature_extraction.TargetGroupBy</code> to <code>feature_extraction.TargetAgg</code>.</li> </ul>"},{"location":"releases/0.1.0/#feature_selection","title":"feature_selection","text":"<ul> <li>Added <code>feature_selection.SelectKBest</code>.</li> <li>Added <code>feature_selection.VarianceThreshold</code>.</li> </ul>"},{"location":"releases/0.1.0/#impute","title":"impute","text":"<ul> <li>Added <code>impute.StatImputer</code>.</li> <li>Removed <code>impute.CategoricalImputer</code>.</li> <li>Removed <code>impute.NumericImputer</code>.</li> </ul>"},{"location":"releases/0.1.0/#linear_model","title":"linear_model","text":"<ul> <li>Added <code>linear_model.PAClassifier</code>.</li> <li>Added <code>linear_model.PARegressor</code>.</li> <li>Added <code>linear_model.SoftmaxRegression</code>.</li> </ul>"},{"location":"releases/0.1.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.ConfusionMatrix</code>.</li> <li>Added <code>metrics.CrossEntropy</code>.</li> <li>Added <code>metrics.MacroF1</code>.</li> <li>Added <code>metrics.MacroPrecision</code>.</li> <li>Added <code>metrics.MacroRecall</code>.</li> <li>Added <code>metrics.MicroF1</code>.</li> <li>Added <code>metrics.MicroPrecision</code>.</li> <li>Added <code>metrics.MicroRecall</code>.</li> <li>Each metric now has a <code>bigger_is_better</code> property to indicate if a high value is better than a low one or not.</li> </ul>"},{"location":"releases/0.1.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.OptimalLR</code>.</li> <li>Added <code>optim.CrossEntropy</code>.</li> <li>Removed <code>optim.PassiveAggressiveI</code>.</li> <li>Removed <code>optim.PassiveAggressiveII</code>.</li> </ul>"},{"location":"releases/0.1.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Removed <code>preprocessing.Discarder</code>.</li> <li>Added <code>on</code> and <code>sparse</code> parameters to <code>preprocessing.OneHotEncoder</code>.</li> </ul>"},{"location":"releases/0.1.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.Covariance</code>.</li> <li>Added <code>stats.PearsonCorrelation</code>.</li> <li>Added <code>stats.SmoothMean</code>.</li> </ul>"},{"location":"releases/0.1.0/#utils","title":"utils","text":"<ul> <li>Added <code>utils.check_estimator</code>.</li> <li>Added <code>utils.Histogram</code>.</li> <li>Added <code>utils.SortedWindow</code>.</li> <li>Added <code>utils.Window</code>.</li> </ul>"},{"location":"releases/0.10.0/","title":"0.10.0 - 2022-02-04","text":""},{"location":"releases/0.10.0/#base","title":"base","text":"<ul> <li>Introduce <code>base.MiniBatchTransformer</code>. Add support for mini-batches to <code>compose.TransformerUnion</code>, <code>compose.Select</code>, and <code>preprocessing.OneHotEncoder</code>.</li> </ul>"},{"location":"releases/0.10.0/#checks","title":"checks","text":"<ul> <li>Created this module to store estimator unit testing, rather than having it in the <code>utils</code> module.</li> </ul>"},{"location":"releases/0.10.0/#compose","title":"compose","text":"<ul> <li>Split <code>compose.Renamer</code> into <code>compose.Prefixer</code> and <code>compose.Suffixer</code> that respectively prepend and append a string to the features' name.</li> <li>Changed <code>compose.Renamer</code> to allow feature renaming following a mapping.</li> </ul>"},{"location":"releases/0.10.0/#evaluate","title":"evaluate","text":"<ul> <li>Refactored <code>evaluate.progressive_validation</code> to work with <code>base.AnomalyDetector</code>s.</li> </ul>"},{"location":"releases/0.10.0/#facto","title":"facto","text":"<ul> <li>Added <code>debug_one</code> method to <code>BaseFM</code>.</li> </ul>"},{"location":"releases/0.10.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Make the <code>by</code> parameter in <code>feature_extraction.Agg</code> and <code>feature_extraction.TargetAgg</code> to be optional, allowing to calculate aggregates over the whole data.</li> <li>Removed <code>feature_extraction.Lagger</code> and <code>feature_extraction.TargetLagger</code>. Their functionality can be reproduced by combining <code>feature_extraction.Agg</code> and <code>stats.Shift</code>.</li> <li><code>feature_extraction.Agg</code> and <code>feature_extraction.Target</code> now have a <code>state</code> property. It returns a <code>pandas.Series</code> representing the current aggregates values within each group.</li> </ul>"},{"location":"releases/0.10.0/#metrics","title":"metrics","text":"<ul> <li><code>metrics.ROCAUC</code> works with <code>base.AnomalyDetectors</code>s.</li> </ul>"},{"location":"releases/0.10.0/#misc","title":"misc","text":"<ul> <li>Created this module to store some stuff that was in the <code>utils</code> module but wasn't necessarily shared between modules.</li> <li>Implement <code>misc.CovMatrix</code>.</li> </ul>"},{"location":"releases/0.10.0/#reco","title":"reco","text":"<ul> <li>Renamed the <code>Recommender</code> base class into <code>Ranker</code>.</li> <li>Added a <code>rank</code> method to each recommender.</li> <li>Removed <code>reco.SurpriseWrapper</code> as it wasn't really useful.</li> <li>Added an <code>is_contextual</code> property to each ranker to indicate if a model makes use of contextual features or not.</li> </ul>"},{"location":"releases/0.10.0/#stats","title":"stats","text":"<ul> <li><code>stats.Mean</code>, <code>stats.Var</code>, and <code>stats.Cov</code> each now have an <code>update_many</code> method which accepts numpy arrays.</li> </ul>"},{"location":"releases/0.10.0/#utils","title":"utils","text":"<ul> <li>Removed <code>utils.Window</code> and use <code>collections.deque</code> instead where necessary.</li> </ul>"},{"location":"releases/0.10.1/","title":"0.10.1 - 2022-02-05","text":""},{"location":"releases/0.10.1/#evaluate","title":"evaluate","text":"<p><code>evaluate.progressive_val_score</code> can now handle models which use <code>**kwargs</code> in their <code>learn_one</code> and <code>predict_one</code> methods. For instance, this is useful for <code>reco.Ranker</code> models which require passing a user and an item.</p>"},{"location":"releases/0.11.0/","title":"0.11.0 - 2022-05-28","text":"<ul> <li>Moved all metrics in <code>metrics.cluster</code> except <code>metrics.Silhouette</code> to river-extra.</li> </ul>"},{"location":"releases/0.11.0/#anomaly","title":"anomaly","text":"<ul> <li>There is now a <code>anomaly.base.SupervisedAnomalyDetector</code> base class for supervised anomaly detection.</li> <li>Added <code>anomaly.GaussianScorer</code>, which is the first supervised anomaly detector.</li> <li>There is now a <code>anomaly.base.AnomalyFilter</code> base class for anomaly filtering methods. These allow to classify anomaly scores. They can also prevent models from learning on anomalous data, for instance by putting them as an initial step of a pipeline.</li> <li>Added <code>anomaly.ConstantFilter</code> and <code>QuantileFilter</code>, which are the first anomaly filters.</li> <li>Removed <code>anomaly.ConstantThresholder</code> and <code>anomaly.QuantileThresholder</code>, as they overlap with the new anomaly filtering mechanism.</li> </ul>"},{"location":"releases/0.11.0/#base","title":"base","text":"<ul> <li>Fixed an issue where the <code>_raw_memory_usage</code> property would spin into an infinite loop if a model's property was an <code>itertools.count</code>.</li> </ul>"},{"location":"releases/0.11.0/#dataset","title":"dataset","text":"<ul> <li>Added the <code>datasets.WaterFlow</code> dataset.</li> </ul>"},{"location":"releases/0.11.0/#dist","title":"dist","text":"<ul> <li>A <code>revert</code> method has been added to <code>stats.Gaussian</code>.</li> <li>A <code>revert</code> method has been added to <code>stats.Multinomial</code>.</li> <li>Added <code>dist.TimeRolling</code> to measure probability distributions over windows of time.</li> </ul>"},{"location":"releases/0.11.0/#drift","title":"drift","text":"<ul> <li>Add the <code>PeriodicTrigger</code> detector, a baseline capable of producing drift signals in regular or random intervals.</li> <li>The numpy usage was removed in <code>drift.KSWIN</code> in favor of <code>collections.deque</code>. Appending or deleting elements to numpy arrays imply creating another object.</li> <li>Added the seed parameter to <code>drift.KSWIN</code> to control reproducibility.</li> <li>The Kolmogorov-Smirnov test mode was changed to the default (<code>\"auto\"</code>) to suppress warnings (<code>drift.KSWIN</code>).</li> <li>Unnecessary usage of numpy was also removed in other concept drift detectors.</li> </ul>"},{"location":"releases/0.11.0/#ensemble","title":"ensemble","text":"<ul> <li>Streamline <code>SRP{Classifier,Regressor}</code>, remove unneeded numpy usage, make SRP variants robust against missing features, and fix bugs.</li> <li>Remove unneeded numpy usage <code>AdaptiveRandomForest{Classifier,Regressor}</code>.</li> </ul>"},{"location":"releases/0.11.0/#evaluate","title":"evaluate","text":"<ul> <li>Added a <code>iter_progressive_val_score</code> function, which does the same as <code>progressive_val_score</code>, except that it yields rather than prints results at each step, which give more control to the user.</li> </ul>"},{"location":"releases/0.11.0/#imblearn","title":"imblearn","text":"<ul> <li>Added <code>imblearn.ChebyshevUnderSampler</code> and <code>imblearn.ChebyshevOverSampler</code> for imbalanced regression.</li> </ul>"},{"location":"releases/0.11.0/#linear_model","title":"linear_model","text":"<ul> <li><code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code> now correctly apply the <code>l2</code> regularization when their <code>learn_many</code> method is used.</li> <li>Added <code>l1</code> regularization (implementation with cumulative penalty, see paper) for <code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code></li> </ul>"},{"location":"releases/0.11.0/#neighbors","title":"neighbors","text":"<ul> <li><code>neighbors.KNNADWINClassifier</code> and <code>neighbors.SAMKNNClassifier</code> have been deprecated.</li> <li>Introduced <code>neighbors.NearestNeighbors</code> for searching nearest neighbors.</li> <li>Vastly refactored and simplified the nearest neighbors logic.</li> </ul>"},{"location":"releases/0.11.0/#proba","title":"proba","text":"<ul> <li>Added <code>proba.Rolling</code> to measure a probability distribution over a window.</li> </ul>"},{"location":"releases/0.11.0/#rules","title":"rules","text":"<ul> <li>AMRules's <code>debug_one</code> explicitly indicates the prediction strategy used by each rule.</li> <li>Fix bug in <code>debug_one</code> (AMRules) where prediction explanations were incorrectly displayed when <code>ordered_rule_set=True</code>.</li> </ul>"},{"location":"releases/0.11.0/#time_series","title":"time_series","text":"<ul> <li>Added an <code>iter_evaluate</code> function to trace the evaluation at each sample in a dataset.</li> </ul>"},{"location":"releases/0.11.0/#tree","title":"tree","text":"<ul> <li>Fix bug in Naive Bayes-based leaf prediction.</li> <li>Remove unneeded numpy usage in <code>HoeffdingAdaptiveTree{Classifier,Regressor}</code>.</li> </ul>"},{"location":"releases/0.11.0/#stats","title":"stats","text":"<ul> <li>A <code>revert</code> method has been added to <code>stats.Var</code>.</li> </ul>"},{"location":"releases/0.11.1/","title":"0.11.1 - 2022-06-06","text":"<p>A small release to introduce benchmarks.</p>"},{"location":"releases/0.11.1/#anomaly","title":"anomaly","text":"<ul> <li>Fixed a bug where anomaly filters were never updated.</li> </ul>"},{"location":"releases/0.12.0/","title":"0.12.0 - 2022-09-02","text":"<ul> <li>Moved all the public modules imports from <code>river/__init__.py</code> to <code>river/api.py</code> and removed unnecessary dependencies between modules enabling faster cherry-picked import times (~3x).</li> <li>Adding wheels for Python 3.11.</li> </ul>"},{"location":"releases/0.12.0/#base","title":"base","text":"<ul> <li>Introduced an <code>mutate</code> method to the <code>base.Base</code> class. This allows setting attributes in a controlled manner, which paves the way for online AutoML. See the recipe for more information.</li> </ul>"},{"location":"releases/0.12.0/#compat","title":"compat","text":"<ul> <li>Moved the PyTorch wrappers to river-extra.</li> </ul>"},{"location":"releases/0.12.0/#covariance","title":"covariance","text":"<ul> <li>Created a new <code>covariance</code> module to hold everything related to covariance and inversion covariance matrix estimation.</li> <li>Moved <code>misc.CovarianceMatrix</code> to <code>covariance.EmpiricalCovariance</code>.</li> <li>Added <code>covariance.EmpiricalPrecision</code> to estimate the inverse covariance matrix.</li> </ul>"},{"location":"releases/0.12.0/#compose","title":"compose","text":"<ul> <li>Moved <code>utils.pure_inference_mode</code> to <code>compose.pure_inference_mode</code> and <code>utils.warm_up_mode</code> to <code>compose.warm_up_mode</code>.</li> <li>Pipeline parts can now be accessed by integer positions as well as by name.</li> </ul>"},{"location":"releases/0.12.0/#datasets","title":"datasets","text":"<ul> <li>Imports <code>synth</code>, enabling <code>from river import datasets; datasets.synth</code>.</li> </ul>"},{"location":"releases/0.12.0/#drift","title":"drift","text":"<ul> <li>Refactor the concept drift detectors to match the remaining of River's API. Warnings are only issued by detectors that support this feature.</li> <li>Drifts can be assessed via the property <code>drift_detected</code>. Warning signals can be acessed by the property <code>warning_detected</code>. The <code>update</code> now returns <code>self</code>.</li> <li>Ensure all detectors automatically reset their inner states after a concept drift detection.</li> <li>Streamline <code>DDM</code>, <code>EDDM</code>, <code>HDDM_A</code>, and <code>HDDM_W</code>. Make the configurable parameters names match their respective papers.</li> <li>Fix bugs in <code>EDDM</code> and <code>HDDM_W</code>.</li> <li>Enable two-sided tests in <code>PageHinkley</code>.</li> <li>Improve documentation and update tests.</li> </ul>"},{"location":"releases/0.12.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added a <code>tokenizer_pattern</code> parameter to <code>feature_extraction.BagOfWords</code> and <code>feature_extraction.TFIDF</code> to override the default pattern used for tokenizing text.</li> <li>Added a <code>stop_words</code> parameter to <code>feature_extraction.BagOfWords</code> and <code>feature_extraction.TFIDF</code> for removing stop words once the text has been tokenized.</li> </ul>"},{"location":"releases/0.12.0/#linear_model","title":"linear_model","text":"<ul> <li>After long ado, we've finally implemented <code>linear_model.BayesianLinearRegression</code>.</li> </ul>"},{"location":"releases/0.12.0/#metrics","title":"metrics","text":"<ul> <li>Removed dependency to <code>optim</code>.</li> <li>Removed <code>metrics.Rolling</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>metrics.TimeRolling</code>, due to the addition of <code>utils.Rolling</code>.</li> </ul>"},{"location":"releases/0.12.0/#proba","title":"proba","text":"<ul> <li>Removed <code>proba.Rolling</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>proba.TimeRolling</code>, due to the addition of <code>utils.Rolling</code>.</li> </ul>"},{"location":"releases/0.12.0/#rule","title":"rule","text":"<ul> <li>The default <code>splitter</code> was changed to <code>tree.splitter.TEBST</code> for memory and running time efficiency.</li> </ul>"},{"location":"releases/0.12.0/#stats","title":"stats","text":"<ul> <li>Removed <code>stats.RollingMean</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>stats.RollingVar</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>stats.RollingCov</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>stats.RollingPearsonCorr</code>, due to the addition of <code>utils.Rolling</code>.</li> </ul>"},{"location":"releases/0.12.0/#stream","title":"stream","text":"<ul> <li><code>stream.iter_array</code> now handles text data.</li> <li>Added <code>stream.TwitterLiveStream</code>, to listen to a filtered live stream of Tweets.</li> </ul>"},{"location":"releases/0.12.0/#time_series","title":"time_series","text":"<ul> <li>Added <code>time_series.HorizonAggMetric</code>.</li> <li>Fixed a bug in <code>time_series.SNARIMAX</code> where the number of seasonal components was not correct when <code>sp</code> or <code>sq</code> were specified.</li> <li>Fixed the differencing logic in <code>time_series.SNARIMAX</code> when <code>d</code> or <code>sd</code> were specified.</li> </ul>"},{"location":"releases/0.12.0/#tree","title":"tree","text":"<ul> <li>Rename <code>split_confidence</code> and <code>tie_threshold</code> to <code>delta</code> and <code>tau</code>, respectively. This way, the parameters are not misleading and match what the research papers have used for decades.</li> <li>Refactor <code>HoeffdingAdaptiveTree{Classifier,Regressor}</code> to allow the usage of any drift detector. Expose the significance level of the test used to switch between subtrees as a user-defined parameter.</li> <li>Correct test used to switch between foreground and background subtrees in <code>HoeffdingAdaptiveTreeRegressor</code>. Due to the continuous and unbounded nature of the monitored errors, a z-test is now performed to decide which subtree to keep.</li> <li>The default <code>leaf_prediction</code> value was changed to <code>\"adaptive\"</code>, as this often results in the smallest errors in practice.</li> <li>The default <code>splitter</code> was changed to <code>tree.splitter.TEBST</code> for memory and running time efficiency.</li> </ul>"},{"location":"releases/0.12.0/#utils","title":"utils","text":"<ul> <li>Removed dependencies to <code>anomaly</code> and <code>compose</code>.</li> <li>Added <code>utils.Rolling</code> and <code>utils.TimeRolling</code>, which are generic wrappers for computing over a window (of time).</li> <li>Use binary search to speed-up element removal in <code>utils.SortedWindow</code>.</li> </ul>"},{"location":"releases/0.12.1/","title":"0.12.1 - 2022-09-02","text":""},{"location":"releases/0.12.1/#base","title":"base","text":"<ul> <li>Fix the way the <code>clone</code> method handles positional arguments.</li> </ul>"},{"location":"releases/0.13.0/","title":"0.13.0 - 2022-09-15","text":""},{"location":"releases/0.13.0/#compose","title":"compose","text":"<ul> <li><code>compose.TransformerUnion</code> parts can now be accessed by index as well as by name.</li> </ul>"},{"location":"releases/0.13.0/#stats","title":"stats","text":"<ul> <li>Added the <code>LossyCount</code> for tracking frequent itemsets. This implementation also supports a forgetting factor to reduce the influence of old elements.</li> <li>The following statistics are now implemented in Rust:</li> <li><code>Quantile</code></li> <li><code>EWMean</code></li> <li><code>EWVar</code></li> <li><code>IQR</code></li> <li><code>Kurtosis</code></li> <li><code>PeaktoPeak</code></li> <li><code>Skew</code></li> <li><code>RollingQuantile</code></li> <li><code>RollingIQR</code></li> </ul>"},{"location":"releases/0.13.0/#stream","title":"stream","text":"<ul> <li>Implemented <code>stream.TwitchChatStream</code>.</li> </ul>"},{"location":"releases/0.14.0/","title":"0.14.0 - 2022-10-26","text":"<ul> <li>Introducing the <code>bandit</code> module for running multi-armed bandits</li> <li>Introducing the <code>sketch</code> module with summarization tools and data sketches working in a streaming fashion!</li> </ul>"},{"location":"releases/0.14.0/#bandit","title":"bandit","text":"<ul> <li>Added <code>bandit.EpsilonGreedy</code>.</li> <li>Added <code>bandit.UCB</code>.</li> <li>Added <code>bandit.ThomsonSampling</code>.</li> <li>Added a <code>bandit.base</code> module.</li> <li>Added <code>bandit.envs.CandyCaneContest</code>, which implements the Gym interface.</li> <li>Added <code>bandit.envs.KArmedTestbed</code>, which implements the Gym interface.</li> <li>Added <code>bandit.evaluate</code> for basic benchmarking of bandit policies on a Gym environment.</li> </ul>"},{"location":"releases/0.14.0/#drift","title":"drift","text":"<ul> <li>Exposed more parameters in ADWIN: <code>clock</code>, <code>max_buckets</code>, <code>min_window_length</code>, and <code>grace_period</code>.</li> </ul>"},{"location":"releases/0.14.0/#model_selection","title":"model_selection","text":"<ul> <li>Added <code>model_selection.BanditRegressor</code>, which is a generic model selection method that works with any bandit policy.</li> <li>Removed <code>model_selection.EpsilonGreedyRegressor</code> due to the addition of <code>model_selection.BanditRegressor</code>.</li> <li>Removed <code>model_selection.UCBRegressor</code> due to the addition of <code>model_selection.BanditRegressor</code>.</li> </ul>"},{"location":"releases/0.14.0/#proba","title":"proba","text":"<ul> <li>Added <code>proba.Beta</code>.</li> <li>Added a <code>sample</code> method to each distribution.</li> <li>Added a <code>mode</code> property to each distribution.</li> <li>Replaced the <code>pmf</code> and <code>pdf</code> methods with a <code>__call__</code> method.</li> </ul>"},{"location":"releases/0.14.0/#sketch","title":"sketch","text":"<ul> <li>Moved <code>misc.Histogram</code> to <code>sketch.Histogram</code>.</li> <li>Moved <code>stats.LossyCount</code> to <code>sketch.HeavyHitters</code> and update its API to better match <code>collections.Counter</code>.</li> <li>Added missing return <code>self</code> in <code>HeavyHitters</code>.</li> <li>Added the Count-Min Sketch (<code>sketch.Counter</code>) algorithm for approximate element counting.</li> <li>Added an implementation of Bloom filter (<code>sketch.Set</code>) to provide approximate set-like operations.</li> </ul>"},{"location":"releases/0.2.0/","title":"0.2.0 - 2019-05-27","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.2.0/#compose","title":"compose","text":"<ul> <li><code>compose.Pipeline</code> now has a <code>debug_one</code>.</li> <li><code>compose.Discard</code> and <code>compose.Select</code> now take variadic inputs, which means you don't have to provide a list of features to exclude/include.</li> </ul>"},{"location":"releases/0.2.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_bikes</code></li> </ul>"},{"location":"releases/0.2.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Classes that inherit from <code>feature_extraction.VectorizerMixin</code> can now directly be passed <code>str</code> instances instead of <code>dict</code> instances.</li> <li><code>feature_extraction.Agg</code> and <code>feature_extraction.TargetAgg</code> can now aggregate on multiple attributes.</li> </ul>"},{"location":"releases/0.2.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>RollingAccuracy</code></li> <li>Added <code>RollingCrossEntropy</code></li> <li>Added <code>RollingF1</code></li> <li>Added <code>RollingLogLoss</code></li> <li>Added <code>RollingMacroF1</code></li> <li>Added <code>RollingMacroPrecision</code></li> <li>Added <code>RollingMacroRecall</code></li> <li>Added <code>RollingMAE</code></li> <li>Added <code>RollingMicroF1</code></li> <li>Added <code>RollingMicroPrecision</code></li> <li>Added <code>RollingMicroRecall</code></li> <li>Added <code>RollingMSE</code></li> <li>Added <code>RollingPrecision</code></li> <li>Added <code>RollingRecall</code></li> <li>Added <code>RollingRMSE</code></li> <li>Added <code>RollingRMSLE</code></li> <li>Added <code>RollingSMAPE</code></li> </ul>"},{"location":"releases/0.2.0/#model_selection","title":"model_selection","text":"<ul> <li>Added <code>model_selection.online_qa_score</code>.</li> </ul>"},{"location":"releases/0.2.0/#proba","title":"proba","text":"<p>The <code>dist</code> module has been renamed to <code>proba</code> and is now public, for the moment it contains a single distribution called <code>proba.Gaussian</code>.</p>"},{"location":"releases/0.2.0/#naive_bayes","title":"naive_bayes","text":"<ul> <li>Added <code>naive_bayes.BernoulliNB</code>.</li> <li>Added <code>naive_bayes.ComplementNB</code>.</li> </ul>"},{"location":"releases/0.2.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.AdaBound</code>.</li> </ul>"},{"location":"releases/0.2.0/#tree","title":"tree","text":"<ul> <li>Added <code>tree.DecisionTreeClassifier</code>.</li> <li>Removed <code>tree.MondrianTreeClassifier</code> and <code>tree.MondrianTreeRegressor</code> because their performance wasn't good enough.</li> </ul>"},{"location":"releases/0.2.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.AutoCorrelation</code>.</li> <li>Added <code>stats.EWVar</code>.</li> <li>Rename <code>stats.Variance</code> to <code>stats.Var</code> and <code>stats.RollingVariance</code> to <code>stats.RollingVar</code>.</li> </ul>"},{"location":"releases/0.2.0/#stream","title":"stream","text":"<ul> <li>Added <code>stream.simulate_qa</code>.</li> </ul>"},{"location":"releases/0.2.0/#utils","title":"utils","text":"<ul> <li>Added <code>utils.SDFT</code>.</li> <li>Added <code>utils.Skyline</code>.</li> <li>Renamed the <code>window_size</code> parameter to <code>size</code> in <code>utils.Window</code> and <code>utils.SortedWindow</code>.</li> </ul>"},{"location":"releases/0.3.0/","title":"0.3.0 - 2019-06-23","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.3.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.load_chick_weights</code>.</li> </ul>"},{"location":"releases/0.3.0/#decomposition","title":"decomposition","text":"<ul> <li>Added <code>decomposition.LDA</code>.</li> </ul>"},{"location":"releases/0.3.0/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.HedgeRegressor</code>.</li> <li>Added <code>ensemble.StackingBinaryClassifier</code>.</li> </ul>"},{"location":"releases/0.3.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.FBeta</code></li> <li>Added <code>metrics.MacroFBeta</code></li> <li>Added <code>metrics.MicroFBeta</code></li> <li>Added <code>metrics.MultiFBeta</code></li> <li>Added <code>metrics.RollingFBeta</code></li> <li>Added <code>metrics.RollingMacroFBeta</code></li> <li>Added <code>metrics.RollingMicroFBeta</code></li> <li>Added <code>metrics.RollingMultiFBeta</code></li> <li>Added <code>metrics.Jaccard</code></li> <li>Added <code>metrics.RollingConfusionMatrix</code></li> <li>Added <code>metrics.RegressionMultiOutput</code></li> <li>Added <code>metrics.MCC</code></li> <li>Added <code>metrics.RollingMCC</code></li> <li>Added <code>metrics.ROCAUC</code></li> <li>Renamed <code>metrics.F1Score</code> to <code>metrics.F1</code>.</li> </ul>"},{"location":"releases/0.3.0/#multioutput","title":"multioutput","text":"<ul> <li>Added <code>multioutput.ClassifierChain</code>.</li> <li>Added <code>multioutput.RegressorChain</code>.</li> </ul>"},{"location":"releases/0.3.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.QuantileLoss</code></li> <li>Added <code>optim.MiniBatcher</code>.</li> </ul>"},{"location":"releases/0.3.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.Normalizer</code>.</li> </ul>"},{"location":"releases/0.3.0/#proba","title":"proba","text":"<ul> <li>Added <code>proba.Multinomial</code>.</li> </ul>"},{"location":"releases/0.4.1/","title":"0.4.1 - 2019-10-23","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.4.1/#base","title":"base","text":"<ul> <li>Tests are now much more extensive, thanks mostly to the newly added estimator tags.</li> </ul>"},{"location":"releases/0.4.1/#compose","title":"compose","text":"<ul> <li>Added <code>compose.Renamer</code>.</li> </ul>"},{"location":"releases/0.4.1/#datasets","title":"datasets","text":"<ul> <li>Added <code>fetch_kdd99_http</code>.</li> <li>Added <code>fetch_sms</code>.</li> <li>Added <code>fetch_trec07p</code>.</li> </ul>"},{"location":"releases/0.4.1/#ensemble","title":"ensemble","text":"<ul> <li>Removed <code>ensemble.HedgeBinaryClassifier</code> because it's performance was subpar.</li> <li>Removed <code>ensemble.GroupRegressor</code>, as this should be a special case of <code>ensemble.StackingRegressor</code>.</li> </ul>"},{"location":"releases/0.4.1/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Fixed a bug where <code>feature_extraction.CountVectorizer</code> and <code>feature_extraction.TFIDFVectorizer</code> couldn't be pickled.</li> </ul>"},{"location":"releases/0.4.1/#linear_model","title":"linear_model","text":"<ul> <li><code>linear_model.LogisticRegression</code> and <code>linear_model.LinearRegression</code> now have an <code>intercept_lr</code> parameter.</li> </ul>"},{"location":"releases/0.4.1/#metrics","title":"metrics","text":"<ul> <li>Metrics can now be composed using the <code>+</code> operator, which is useful for evaluating multiple metrics at the same time.</li> <li>Added <code>metrics.Rolling</code>, which eliminates the need for a specific rolling implementation for each metric.</li> <li>Each metric can now be passed a <code>sample_weight</code> argument.</li> <li>Added <code>metrics.WeightedF1</code>.</li> <li>Added <code>metrics.WeightedFBeta</code>.</li> <li>Added <code>metrics.WeightedPrecision</code>.</li> <li>Added <code>metrics.WeightedRecall</code>.</li> </ul>"},{"location":"releases/0.4.1/#neighbors","title":"neighbors","text":"<ul> <li>Added <code>neighbors.KNeighborsRegressor</code>.</li> <li>Added <code>neighbors.KNeighborsClassifier</code>.</li> </ul>"},{"location":"releases/0.4.1/#optim","title":"optim","text":"<ul> <li>Added <code>optim.AdaMax</code>.</li> <li>The <code>optim</code> module has been reorganized into submodules; namely <code>optim.schedulers</code>, <code>optim.initializers</code>, and <code>optim.losses</code>. The top-level now only contains optimizers. Some classes have been renamed accordingly. See the documentation for details.</li> <li>Renamed <code>optim.VanillaSGD</code> to <code>optim.SGD</code>.</li> </ul>"},{"location":"releases/0.4.1/#stats","title":"stats","text":"<ul> <li>Added <code>stats.IQR</code>.</li> <li>Added <code>stats.RollingIQR</code>.</li> <li>Cythonized <code>stats.Mean</code> and <code>stats.Var</code>.</li> </ul>"},{"location":"releases/0.4.1/#stream","title":"stream","text":"<ul> <li>Added <code>stream.shuffle</code>.</li> <li><code>stream.iter_csv</code> now has <code>fraction</code> and <code>seed</code> parameters to sample rows, deterministically or not.</li> <li>Renamed <code>stream.iter_numpy</code> to <code>stream.iter_array</code>.</li> <li><code>stream.iter_csv</code> can now read from gzipped files.</li> </ul>"},{"location":"releases/0.4.1/#time_series","title":"time_series","text":"<ul> <li><code>time_series.Detrender</code> now has a <code>window_size</code> parameter for detrending with a rolling mean.</li> </ul>"},{"location":"releases/0.4.1/#tree","title":"tree","text":"<ul> <li>Added <code>tree.RandomForestClassifier</code>.</li> </ul>"},{"location":"releases/0.4.1/#utils","title":"utils","text":"<ul> <li>Fixed a bug where <code>utils.dot</code> could take longer than necessary.</li> </ul>"},{"location":"releases/0.4.3/","title":"0.4.3 - 2019-10-27","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.4.3/#base","title":"base","text":"<ul> <li>Model that inherit from <code>base.Wrapper</code> (e.g. <code>tree.RandomForestClassifier</code>) can now be pickled.</li> </ul>"},{"location":"releases/0.4.3/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_credit_card</code>.</li> </ul>"},{"location":"releases/0.4.3/#utils","title":"utils","text":"<ul> <li>Added the <code>utils.math</code> sub-module.</li> </ul>"},{"location":"releases/0.4.3/#tree","title":"tree","text":"<ul> <li>Fixed the <code>debug_one</code> method of <code>tree.DecisionTreeClassifier</code>.</li> </ul>"},{"location":"releases/0.4.4/","title":"0.4.4 - 2019-11-11","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul> <p>This release was mainly made to provide access to <code>wheels &lt;https://pythonwheels.com/&gt;</code>_ for Windows and MacOS.</p>"},{"location":"releases/0.4.4/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.AdaBoostClassifier</code>.</li> </ul>"},{"location":"releases/0.4.4/#linear_model","title":"linear_model","text":"<ul> <li>Added a <code>clip_gradient</code> parameter to <code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code>. Gradient clipping was already implemented, but the maximum absolute value can now be set by the user.</li> <li>The <code>intercept_lr</code> parameter of <code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code> can now be passed an instance of <code>optim.schedulers.Scheduler</code> as well as a <code>float</code>.</li> </ul>"},{"location":"releases/0.4.4/#metrics","title":"metrics","text":"<ul> <li>Fixed <code>metrics.SMAPE</code>, the implementation was missing a multiplication by 2.</li> </ul>"},{"location":"releases/0.4.4/#optim","title":"optim","text":"<ul> <li>Added <code>optim.schedulers.Optimal</code> produces results that are identical to <code>sklearn.linear_model.SGDRegressor</code> and <code>sklearn.linear_model.SGDClassifier</code> when setting their <code>learning_rate</code> parameter to <code>'optimal'</code>.</li> </ul>"},{"location":"releases/0.4.4/#time_series","title":"time_series","text":"<ul> <li>Added <code>time_series.SNARIMAX</code>, a generic model which encompasses well-known time series models such as ARIMA and NARX.</li> </ul>"},{"location":"releases/0.5.0/","title":"0.5.0 - 2020-03-13","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.5.0/#compat","title":"compat","text":"<ul> <li>Added <code>compat.PyTorch2CremeRegressor</code>.</li> <li><code>compat.SKL2CremeRegressor</code> and <code>compat.SKL2CremeClassifier</code> now have an optional <code>batch_size</code> parameter in order to perform mini-batching.</li> </ul>"},{"location":"releases/0.5.0/#compose","title":"compose","text":"<ul> <li>Renamed <code>compose.Whitelister</code> to <code>compose.Select</code>.</li> <li>Renamed <code>compose.Blacklister</code> to <code>compose.Discard</code>.</li> </ul>"},{"location":"releases/0.5.0/#facto","title":"facto","text":"<ul> <li>Added <code>facto.FFMClassifier</code>.</li> <li>Added <code>facto.FFMRegressor</code>.</li> <li>Added <code>facto.FwFMClassifier</code>.</li> <li>Added <code>facto.FwFMRegressor</code>.</li> <li>Added <code>facto.HOFMClassifier</code>.</li> <li>Added <code>facto.HOFMRegressor</code>.</li> <li>Refactored <code>facto.FMClassifier</code>.</li> <li>Refactored <code>facto.FMRegressor</code>.</li> </ul>"},{"location":"releases/0.5.0/#feature_selection","title":"feature_selection","text":"<ul> <li>Added <code>feature_selection.PoissonInclusion</code>.</li> <li>Removed <code>feature_selection.RandomDiscarder</code> as it didn't make much sense.</li> </ul>"},{"location":"releases/0.5.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Renamed <code>feature_extraction.CountVectorizer</code> to <code>feature_extraction.BagOfWords</code>.</li> <li>Renamed <code>feature_extraction.TFIDFVectorizer</code> to <code>feature_extraction.TFIDF</code>.</li> <li>Added <code>preprocessor</code> and <code>ngram_range</code> parameters to <code>feature_extraction.BagOfWords</code>.</li> <li>Added <code>preprocessor</code> and <code>ngram_range</code> parameters to <code>feature_extraction.TFIDF</code>.</li> </ul>"},{"location":"releases/0.5.0/#datasets","title":"datasets","text":"<ul> <li>The <code>datasets</code> module has been overhauled. Each dataset is now a class (e.g. <code>fetch_electricity</code> has become <code>datasets.Elec2</code>).</li> <li>Added <code>datasets.TrumpApproval</code>.</li> <li>Added <code>datasets.MaliciousURL</code>.</li> <li>Added <code>datasets.gen.SEA</code>.</li> <li>Added <code>datasets.Higgs</code>.</li> <li>Added <code>datasets.MovieLens100K</code>.</li> <li>Added <code>datasets.Bananas</code>.</li> <li>Added <code>datasets.Taxis</code>.</li> <li>Added <code>datasets.ImageSegments</code>.</li> <li>Added <code>datasets.SMTP</code></li> </ul>"},{"location":"releases/0.5.0/#impute","title":"impute","text":"<ul> <li>Added <code>impute.PreviousImputer</code>.</li> </ul>"},{"location":"releases/0.5.0/#linear_model","title":"linear_model","text":"<ul> <li><code>linear_model.FMClassifier</code> has been moved to the <code>facto</code> module.</li> <li><code>linear_model.FMRegressor</code> has been  moved to the <code>facto</code> module.</li> <li>Added <code>linear_model.ALMAClassifier</code>.</li> </ul>"},{"location":"releases/0.5.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.ClassificationReport</code>.</li> <li>Added <code>metrics.TimeRolling</code>.</li> <li>The implementation of <code>metrics.ROCAUC</code> was incorrect. Using the trapezoidal rule instead of Simpson's rule seems to be more robust.</li> <li><code>metrics.PerClass</code> has been removed; it is recommended that you use <code>metrics.ClassificationReport</code> instead as it gives a better overview.</li> </ul>"},{"location":"releases/0.5.0/#meta","title":"meta","text":"<ul> <li>Moved <code>meta.TransformedTargetRegressor</code> and <code>meta.BoxCoxRegressor</code> to this module (they were previously in the <code>compose</code> module).</li> <li>Added <code>meta.PredClipper</code></li> </ul>"},{"location":"releases/0.5.0/#model_selection","title":"model_selection","text":"<ul> <li>Added <code>model_selection.expand_param_grid</code> to generate a list of models from a grid of parameters.</li> <li>Added the <code>model_selection.successive_halving</code> method for selecting hyperparameters.</li> <li>The <code>online_score</code> and <code>online_qa_score</code> methods have been merged into a single method named <code>model_selection.progressive_val_score</code>.</li> </ul>"},{"location":"releases/0.5.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.RBFSampler</code>.</li> <li>Added <code>preprocessing.MaxAbsScaler</code>.</li> <li>Added <code>preprocessing.RobustScaler</code>.</li> <li>Added <code>preprocessing.Binarizer</code>.</li> <li>Added <code>with_mean</code> and <code>with_std</code> parameters to <code>preprocessing.StandardScaler</code>.</li> </ul>"},{"location":"releases/0.5.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.losses.BinaryFocalLoss</code>.</li> <li>Added the <code>optim.AMSGrad</code> optimizer.</li> <li>Added the <code>optim.Nadam</code> optimizer.</li> <li>Added <code>optim.losses.Poisson</code>.</li> <li>Fixed a performance bug in <code>optim.NesterovMomentum</code>.</li> </ul>"},{"location":"releases/0.5.0/#reco","title":"reco","text":"<ul> <li>Added <code>reco.FunkMF</code>.</li> <li>Renamed <code>reco.SVD</code> to <code>reco.BiasedMF</code>.</li> <li>Renamed <code>reco.SGDBaseline</code> to <code>reco.Baseline</code>.</li> <li>Models now expect a <code>dict</code> input with <code>user</code> and <code>item</code> fields.</li> </ul>"},{"location":"releases/0.5.0/#sampling","title":"sampling","text":"<ul> <li>Added <code>sampling.RandomUnderSampler</code>.</li> <li>Added <code>sampling.RandomOverSampler</code>.</li> <li>Added <code>sampling.RandomSampler</code>.</li> <li>Added <code>sampling.HardSamplingClassifier</code>.</li> <li>Added <code>sampling.HardSamplingRegressor</code>.</li> </ul>"},{"location":"releases/0.5.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.AbsMax</code>.</li> <li>Added <code>stats.RollingAbsMax</code>.</li> </ul>"},{"location":"releases/0.5.0/#stream","title":"stream","text":"<ul> <li>Added <code>stream.iter_libsvm</code>.</li> <li><code>stream.iter_csv</code> now supports reading from '.zip' files.</li> <li>Added <code>stream.Cache</code>.</li> <li>Added a <code>drop</code> parameter to <code>stream.iter_csv</code> to discard fields.</li> </ul>"},{"location":"releases/0.5.1/","title":"0.5.1 - 2020-03-29","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.5.1/#compose","title":"compose","text":"<ul> <li><code>compose.Pipeline</code> and <code>compose.TransformerUnion</code> now variadic arguments as input instead of a list. This doesn't change anything when using the shorthand operators <code>|</code> and <code>+</code>.</li> </ul>"},{"location":"releases/0.5.1/#model_selection","title":"model_selection","text":"<ul> <li>Removed <code>model_selection.successive_halving</code></li> <li>Added <code>model_selection.SuccessiveHalvingRegressor</code> and <code>model_selection.SuccessiveHalvingClassifier</code></li> </ul>"},{"location":"releases/0.5.1/#stream","title":"stream","text":"<ul> <li>Added a <code>copy</code> parameter to <code>stream.simulate_qa</code> in order to handle unwanted feature modifications.</li> </ul>"},{"location":"releases/0.5.1/#tree","title":"tree","text":"<ul> <li>Added a <code>curtail_under</code> parameter to <code>tree.DecisionTreeClassifier</code>.</li> <li>The speed and accuracy of both <code>tree.DecisionTreeClassifier</code> and <code>tree.RandomForestClassifier</code> has been slightly improved for numerical attributes.</li> <li>The esthetics of the <code>tree.DecisionTreeClassifier.draw</code> method have been improved.</li> </ul>"},{"location":"releases/0.6.0/","title":"0.6.0 - 2020-06-09","text":""},{"location":"releases/0.6.0/#base","title":"base","text":"<ul> <li>Added a new base class called <code>SupervisedTransformer</code> from which supervised transformers inherit from. Before this, supervised transformers has a <code>is_supervised</code> property.</li> </ul>"},{"location":"releases/0.6.0/#compose","title":"compose","text":"<ul> <li>Added <code>compose.SelectType</code>, which allows selecting feature subsets based on their type.</li> <li>Added a <code>score_one</code> method to <code>compose.Pipeline</code> so that estimators from the <code>anomaly</code> module can be pipelined.</li> <li>Added <code>compose.Grouper</code>, which allows applying transformers within different subgroups.</li> </ul>"},{"location":"releases/0.6.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.Music</code>, which is a dataset for multi-output binary classification.</li> <li>Added <code>datasets.synth.Friedman</code>, which is synthetic regression dataset.</li> <li>The <code>datasets.gen</code> module has been renamed to <code>datasets.synth</code></li> <li>Each dataset now has a <code>__repr__</code> method which displays some descriptive information.</li> <li>Added <code>datasets.Insects</code>, which has 10 variants.</li> </ul>"},{"location":"releases/0.6.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li><code>feature_extraction.Differ</code> has been deprecated. We might put it back in a future if we find a better design.</li> </ul>"},{"location":"releases/0.6.0/#impute","title":"impute","text":"<ul> <li><code>impute.StatImputer</code> has been completely refactored.</li> </ul>"},{"location":"releases/0.6.0/#metrics","title":"metrics","text":"<ul> <li>In <code>metrics.SMAPE</code>, instead of raising a <code>ZeroDivisionError</code>, the convention is now to use 0 when both <code>y_true</code> and <code>y_pred</code> are equal to 0.</li> </ul>"},{"location":"releases/0.6.0/#model_selection","title":"model_selection","text":"<ul> <li>Added the possibility to configure how the progress is printed in <code>model_selection.progressive_val_score</code>. For instance, the progress can now be printed to a file by providing the <code>file</code> argument.</li> </ul>"},{"location":"releases/0.6.0/#multiclass","title":"multiclass","text":"<ul> <li>Added <code>multiclass.OutputCodeClassifier</code>.</li> <li>Added <code>multiclass.OneVsOneClassifier</code>.</li> </ul>"},{"location":"releases/0.6.0/#multioutput","title":"multioutput","text":"<ul> <li>Fixed a bug where <code>multioutput.ClassifierChain</code> and <code>multioutput.RegressorChain</code> could not be pickled.</li> </ul>"},{"location":"releases/0.6.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.Shift</code>, which can be used to compute statistics over a shifted version of a variable.</li> <li>Added <code>stats.Link</code>, which can be used to compose univariate statistics. Univariate statistics can now be composed via the <code>|</code> operator.</li> <li>Renamed <code>stats.Covariance</code> to <code>stats.Cov</code>.</li> <li>Renamed <code>stats.PearsonCorrelation</code> to <code>stats.PearsonCorr</code>.</li> <li>Renamed <code>stats.AutoCorrelation</code> to <code>stats.AutoCorr</code>.</li> <li>Added <code>stats.RollingCov</code>, which computes covariance between two variables over a window.</li> <li>Added <code>stats.RollingPearsonCorr</code>, which computes the Pearson correlation over a window.</li> </ul>"},{"location":"releases/0.6.0/#stream","title":"stream","text":"<ul> <li>Added a <code>stream.iter_sql</code> utility method to work with SQLAlchemy.</li> <li>The <code>target_name</code> parameter of <code>stream.iter_csv</code> has been renamed to <code>target</code>. It can now be passed a list of values in order to support multi-output scenarios.</li> <li>Added <code>stream.iter_arff</code> for handling ARFF files.</li> </ul>"},{"location":"releases/0.6.0/#tree","title":"tree","text":"<ul> <li>Cancelled the behavior where <code>tree.DecisionTreeRegressor</code> would raise an exception when no split was found.</li> </ul>"},{"location":"releases/0.6.1/","title":"0.6.1 - 2020-06-10","text":""},{"location":"releases/0.6.1/#compose","title":"compose","text":"<ul> <li>Fixed a bug that occurred when part of a <code>compose.Transformer</code> was a <code>compose.Pipeline</code> and wasn't properly handled.</li> </ul>"},{"location":"releases/0.7.0/","title":"0.7.0 - 2021-04-16","text":"<p>Alas, no release notes for this one.</p>"},{"location":"releases/0.7.1/","title":"0.7.1 - 2021-06-13","text":"<p>Fixed an issue where scikit-learn was imported in <code>sam_knn.py</code> but wasn't specified as a dependency.</p>"},{"location":"releases/0.7.1/#stream","title":"stream","text":"<ul> <li>Added <code>drop_nones</code> parameter to <code>stream.iter_csv</code>.</li> </ul>"},{"location":"releases/0.7.2/","title":"0.7.2","text":""},{"location":"releases/0.7.2/#expert","title":"expert","text":"<ul> <li>Each expert model will now raise a <code>NotEnoughModels</code> exception if only a single model is passed.</li> </ul>"},{"location":"releases/0.8.0/","title":"0.8.0 - 2021-08-31","text":""},{"location":"releases/0.8.0/#base","title":"base","text":"<ul> <li>The <code>predict_many</code> and <code>predict_proba_many</code> methods have been removed from <code>base.Classifier</code>. They're part of <code>base.MiniBatchClassifier</code>.</li> </ul>"},{"location":"releases/0.8.0/#ensemble","title":"ensemble","text":"<ul> <li>Implemented <code>ensemble.VotingClassifier</code>.</li> <li>Implemented <code>ensemble.SRPRegressor</code>.</li> </ul>"},{"location":"releases/0.8.0/#meta","title":"meta","text":"<ul> <li>Renamed <code>meta.TransformedTargetRegressor</code> to <code>meta.TargetTransformRegressor</code>.</li> <li>Added <code>meta.TargetStandardScaler</code>.</li> </ul>"},{"location":"releases/0.8.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added a <code>with_std</code> parameter to <code>StandardScaler</code>.</li> </ul>"},{"location":"releases/0.8.0/#rules","title":"rules","text":"<ul> <li>Added <code>rules.AMRules</code></li> </ul>"},{"location":"releases/0.8.0/#stats","title":"stats","text":"<ul> <li>Make <code>stats.RollingQuantile</code> match the default behavior of Numpy's <code>quantile</code> function.</li> </ul>"},{"location":"releases/0.8.0/#tree","title":"tree","text":"<ul> <li>Unifed base class structure applied to all tree models.</li> <li>Bug fixes.</li> <li>Added <code>tree.SGTClassifier</code> and <code>tree.SGTRegressor</code>.</li> </ul>"},{"location":"releases/0.9.0/","title":"0.9.0 - 2021-11-30","text":"<ul> <li>Wheels for Python 3.6 have been dropped.</li> <li>Wheels for Python 3.9 have been added.</li> </ul>"},{"location":"releases/0.9.0/#anomaly","title":"anomaly","text":"<ul> <li>Moved <code>base.AnomalyDetector</code> to <code>anomaly.AnomalyDetector</code>.</li> <li>Implemented <code>anomaly.ConstantThresholder</code>.</li> <li>Implemented <code>anomaly.QuantileThresholder</code>.</li> <li>Implemented <code>anomaly.OneClassSVM</code>.</li> </ul>"},{"location":"releases/0.9.0/#base","title":"base","text":"<ul> <li>Renamed <code>base.WrapperMixin</code> to <code>base.Wrapper</code>.</li> <li>Introduced <code>base.WrapperEnsemble</code>.</li> <li>Clarified the difference between a <code>base.typing.Dataset</code> and a <code>base.typing.Stream</code>. A <code>Stream</code> is an instance of a <code>Dataset</code> and is stateful. A <code>Dataset</code> is stateless. It's essentially the same difference between an <code>Iterable</code> and an <code>Iterator</code> in the Python standard library.</li> </ul>"},{"location":"releases/0.9.0/#compat","title":"compat","text":"<ul> <li>Added <code>compat.PyTorch2RiverClassifier</code></li> <li>Implemented median absolute deviation in <code>stats.MAD</code>.</li> <li>Refactored <code>compat.PyTorch2RiverRegressor</code></li> <li>Fixed an issue where some statistics could not be printed if they had not seen any data yet.</li> </ul>"},{"location":"releases/0.9.0/#compose","title":"compose","text":"<ul> <li>You can now use a <code>list</code> as a shorthand to build a <code>TransformerUnion</code>.</li> <li>Fixed a visualization issue when using a pipeline with multiple feature unions.</li> <li>The prejudiced terms <code>blacklist</code> and <code>whitelist</code> have both been renamed to <code>keys</code>.</li> <li>Removed <code>learn_unsupervised</code> parameter from pipeline methods.</li> <li>Implemented <code>compose.TransformerProduct</code>.</li> </ul>"},{"location":"releases/0.9.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.Keystroke</code>.</li> </ul>"},{"location":"releases/0.9.0/#ensemble","title":"ensemble","text":"<ul> <li>Bug fixes in <code>ensemble.SRPClassifier</code> and <code>ensemble.SRPRegressor</code>.</li> <li>Some estimators have been moved into the <code>ensemble</code> module.</li> </ul>"},{"location":"releases/0.9.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Implemented <code>feature_extraction.Lagger</code>.</li> <li>Implemented <code>feature_extraction.TargetLagger</code>.</li> </ul>"},{"location":"releases/0.9.0/#meta","title":"meta","text":"<p>This module has been deleted.</p> <ul> <li>Move <code>meta.PredClipper</code> to the <code>preprocessing</code> module.</li> <li>Removed <code>meta.BoxCoxRegressor</code>.</li> <li>Moved <code>meta.TargetTransformRegressor</code> to <code>compose.TargetTransformRegressor</code>.</li> <li>Moved <code>meta.TargetStandardScaler</code> to <code>preprocessing.TargetStandardScaler</code>.</li> </ul>"},{"location":"releases/0.9.0/#model_selection","title":"model_selection","text":"<ul> <li>This new module replaces the <code>expert</code> module.</li> <li>Implemented <code>model_selection.GreedyRegressor</code>.</li> <li>Added <code>ModelSelector</code> base class.</li> </ul>"},{"location":"releases/0.9.0/#optim","title":"optim","text":"<ul> <li><code>optim.Adam</code> and <code>optim.RMSProp</code> now work with <code>utils.VectorDict</code>s as well as <code>numpy.ndarray</code>s.</li> <li>Added <code>optim.losses.Huber</code>.</li> </ul>"},{"location":"releases/0.9.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Enabled <code>preprocessing.OneHotEncoder</code> to one-hot encode values that are list or sets.</li> </ul>"},{"location":"releases/0.9.0/#reco","title":"reco","text":"<ul> <li>Added a <code>debug_one</code> method to <code>reco.FMRegressor</code>.</li> </ul>"},{"location":"releases/0.9.0/#selection","title":"selection","text":"<ul> <li>This new module replaces the <code>expert</code> module.</li> <li>Implemented <code>selection.GreedyExpertRegressor</code>.</li> </ul>"},{"location":"releases/0.9.0/#stats","title":"stats","text":"<ul> <li>Fixed an issue where some statistics could not be printed if they had not seen any data yet.</li> <li>Implemented median absolute deviation in <code>stats.MAD</code>.</li> <li>The <code>stats.Mean</code> and <code>stats.Var</code> implementations have been made more numerically stable.</li> </ul>"},{"location":"releases/0.9.0/#time_series","title":"time_series","text":"<ul> <li><code>time_series.Detrender</code> and <code>time_series.GroupDetrender</code> have been removed as they overlap with <code>preprocessing.TargetStandardScaler</code>.</li> <li>Implemented a <code>time_series.evaluate</code> method, which performs progressive validation for time series scenarios.</li> <li>Implemented <code>time_series.HorizonMetric</code> class to evaluate the performance of a forecasting model at each time step along a horizon.</li> <li>Implemented <code>time_series.HoltWinters</code>.</li> </ul>"},{"location":"releases/0.9.0/#utils","title":"utils","text":"<ul> <li>Moved <code>model_selection.expand_param_grid</code> to <code>utils.expand_param_grid</code>.</li> <li>Added <code>utils.poisson</code>.</li> <li>Added the <code>utils.log_method_calls</code> context manager.</li> <li>Added the <code>utils.warm_up_mode</code> context manager.</li> <li>Added the <code>utils.pure_inference_model</code> context manager.</li> </ul>"},{"location":"releases/unreleased/","title":"Unreleased","text":""},{"location":"releases/unreleased/#base","title":"base","text":"<ul> <li>Fixed an issue where an estimator that has attribute a pipeline could not be cloned.</li> <li>Added a <code>base.DriftAndWarningDetector</code> to clarify the difference between drift detectors that have a <code>warning_detected</code> property and those that don't.</li> </ul>"},{"location":"releases/unreleased/#conf","title":"conf","text":"<ul> <li>Introduced this new module to perform conformal predictions.</li> <li>Added a <code>conf.Interval</code> dataclass to represent predictive intervals.</li> <li>Added <code>conf.RegressionJackknife</code>.</li> </ul>"},{"location":"releases/unreleased/#datasets","title":"datasets","text":"<ul> <li>Removed unnecessary Numpy usage in the <code>synth</code> submodule.</li> <li>Changed <code>np.random.RandomState</code> to <code>np.random.default_rng</code> where necessary.</li> </ul>"},{"location":"releases/unreleased/#drift","title":"drift","text":"<ul> <li>Added <code>drift.DriftRetrainingClassifier</code>.</li> </ul>"},{"location":"releases/unreleased/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.ADWINBoostingClassifier</code>.</li> <li>Added <code>ensemble.BOLEClassifier</code>.</li> </ul>"},{"location":"releases/unreleased/#linear_model","title":"linear_model","text":"<ul> <li>Renamed <code>use_dist</code> to <code>with_dist</code> in <code>linear_model.BayesianLinearRegression</code>'s <code>predict_one</code> method.</li> </ul>"},{"location":"releases/unreleased/#multiclass","title":"multiclass","text":"<ul> <li>Added a <code>coding_method</code> method to <code>multiclass.OCC</code> to control how the codes are randomly generated.</li> </ul>"},{"location":"releases/unreleased/#preprocessing","title":"preprocessing","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>preprocessing.AdaptiveStandardScaler</code>.</li> </ul>"},{"location":"releases/unreleased/#rules","title":"rules","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>rules.AMRules</code>.</li> </ul>"},{"location":"releases/unreleased/#sketch","title":"sketch","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>sketch.HeavyHitters</code>.</li> </ul>"},{"location":"releases/unreleased/#stats","title":"stats","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>stats.Entropy</code>.</li> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>stats.EWMean</code>.</li> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>stats.EWVar</code>.</li> </ul>"},{"location":"releases/unreleased/#utils","title":"utils","text":"<ul> <li>Removed artifacts from the merger.</li> </ul>"}]}