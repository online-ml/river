{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"river"},{"location":"api/overview/","text":"Overview \u00b6 anomaly \u00b6 Anomaly detection. Estimators in the anomaly module have a bespoke API. Each anomaly detector has a score_one method instead of a predict_one method. This method returns an anomaly score. Normal observations should have a low score, whereas anomalous observations should have a high score. The range of the scores is relative to each estimator. Anomaly detectors are usually unsupervised, in that they analyze the distribution of the features they are shown. But River also has a notion of supervised anomaly detectors. These analyze the distribution of a target variable, and optionally include the distribution of the features as well. They are useful for detecting labelling anomalies, which can be detrimental if they learned by a model. GaussianScorer HalfSpaceTrees OneClassSVM QuantileFilter ThresholdFilter base \u00b6 AnomalyDetector base \u00b6 Base interfaces. Every estimator in river is a class, and as such inherits from at least one base interface. These are used to categorize, organize, and standardize the many estimators that river contains. This module contains mixin classes, which are all suffixed by Mixin . Their purpose is to provide additional functionality to an estimator, and thus need to be used in conjunction with a non-mixin base class. This module also contains utilities for type hinting and tagging estimators. Base Classifier Clusterer DriftDetector Ensemble Estimator MiniBatchClassifier MiniBatchRegressor MiniBatchTransformer MultiOutputMixin Regressor SupervisedTransformer Transformer Wrapper WrapperEnsemble cluster \u00b6 Unsupervised clustering. CluStream DBSTREAM DenStream KMeans STREAMKMeans compat \u00b6 Compatibility tools. This module contains adapters for making river estimators compatible with other libraries, and vice-versa whenever possible. The relevant adapters will only be usable if you have installed the necessary library. For instance, you have to install scikit-learn in order to use the compat.convert_sklearn_to_river function. Classes River2SKLClassifier River2SKLClusterer River2SKLRegressor River2SKLTransformer SKL2RiverClassifier SKL2RiverRegressor Functions convert_river_to_sklearn convert_sklearn_to_river compose \u00b6 Model composition. This module contains utilities for merging multiple modeling steps into a single pipeline. Although pipelines are not the only way to process a stream of data, we highly encourage you to use them. Discard FuncTransformer Grouper Pipeline Prefixer Renamer Select SelectType Suffixer TargetTransformRegressor TransformerProduct TransformerUnion datasets \u00b6 Datasets. This module contains a collection of datasets for multiple tasks: classification, regression, etc. The data corresponds to popular datasets and are conveniently wrapped to easily iterate over the data in a stream fashion. All datasets have fixed size. Please refer to river.synth if you are interested in infinite synthetic data generators. AirlinePassengers Bananas Bikes ChickWeights CreditCard Elec2 HTTP Higgs ImageSegments Insects Keystroke MaliciousURL MovieLens100K Music Phishing Restaurants SMSSpam SMTP SolarFlare TREC07 Taxis TrumpApproval WaterFlow base \u00b6 Dataset FileDataset RemoteDataset SyntheticDataset drift \u00b6 Concept Drift Detection. This module contains concept drift detection methods. The purpose of a drift detector is to raise an alarm if the data distribution changes. A good drift detector method is the one that maximizes the true positives while keeping the number of false positives to a minimum. ADWIN DDM EDDM HDDM_A HDDM_W KSWIN PageHinkley PeriodicTrigger dummy \u00b6 Dummy estimators. This module is here for testing purposes, as well as providing baseline performances. NoChangeClassifier PriorClassifier StatisticRegressor ensemble \u00b6 Ensemble learning. Broadly speaking, there are two kinds of ensemble approaches. There are those that copy a single model several times and aggregate the predictions of said copies. This includes bagging as well as boosting. Then there are those that are composed of an arbitrary list of models, and can therefore aggregate predictions from different kinds of models. ADWINBaggingClassifier AdaBoostClassifier AdaptiveRandomForestClassifier AdaptiveRandomForestRegressor BaggingClassifier BaggingRegressor EWARegressor LeveragingBaggingClassifier SRPClassifier SRPRegressor StackingClassifier VotingClassifier evaluate \u00b6 Model evaluation. This module provides utilities to evaluate an online model. The goal is to reproduce a real-world scenario with high fidelity. The core function of this module is progressive_val_score , which allows to evaluate a model via progressive validation. This module also exposes \"tracks\". A track is a predefined combination of a dataset and one or more metrics. This allows a principled manner to compare models with each other. For instance, the load_binary_clf_tracks returns tracks that are to be used to evaluate the performance of a binary classification model. The benchmarks directory at the root of the River repository uses these tracks. Classes Track Functions iter_progressive_val_score load_binary_clf_tracks progressive_val_score facto \u00b6 Factorization machines. FFMClassifier FFMRegressor FMClassifier FMRegressor FwFMClassifier FwFMRegressor HOFMClassifier HOFMRegressor feature_extraction \u00b6 Feature extraction. This module can be used to extract information from raw features. This includes encoding categorical data as well as looking at interactions between existing features. This differs from the processing module in that the latter's purpose is rather to clean the data so that it may be processed by a particular machine learning algorithm. Agg BagOfWords PolynomialExtender RBFSampler TFIDF TargetAgg feature_selection \u00b6 Feature selection. PoissonInclusion SelectKBest VarianceThreshold imblearn \u00b6 Sampling methods. ChebyshevOverSampler ChebyshevUnderSampler HardSamplingClassifier HardSamplingRegressor RandomOverSampler RandomSampler RandomUnderSampler linear_model \u00b6 Linear models. ALMAClassifier LinearRegression LogisticRegression PAClassifier PARegressor Perceptron SoftmaxRegression base \u00b6 GLM metrics \u00b6 Evaluation metrics. All the metrics are updated one sample at a time. This way we can track performance of predictive methods over time. Accuracy AdjustedMutualInfo AdjustedRand BalancedAccuracy ClassificationReport CohenKappa Completeness ConfusionMatrix CrossEntropy F1 FBeta FowlkesMallows GeometricMean Homogeneity Jaccard LogLoss MAE MCC MSE MacroF1 MacroFBeta MacroJaccard MacroPrecision MacroRecall MicroF1 MicroFBeta MicroJaccard MicroPrecision MicroRecall MultiFBeta MutualInfo NormalizedMutualInfo Precision R2 RMSE RMSLE ROCAUC Rand Recall Rolling SMAPE Silhouette TimeRolling VBeta WeightedF1 WeightedFBeta WeightedJaccard WeightedPrecision WeightedRecall base \u00b6 BinaryMetric ClassificationMetric Metric Metrics MultiClassMetric RegressionMetric WrapperMetric multioutput \u00b6 Metrics for multi-output learning. ExactMatch MacroAverage MicroAverage MultiLabelConfusionMatrix PerOutput base \u00b6 MultiOutputClassificationMetric MultiOutputRegressionMetric misc \u00b6 Miscellaneous. This module essentially regroups some implementations that have nowhere else to go. CovMatrix Histogram SDFT Skyline model_selection \u00b6 Model selection. This module regroups a variety of methods that may be used for performing model selection. An model selector is provided with a list of models. These are called \"experts\" in the expert learning literature. The model selector's goal is to perform at least as well as the best model. Indeed, initially, the best model is not known. The performance of each model becomes more apparent as time goes by. Different strategies are possible, each one offering a different tradeoff in terms of accuracy and computational performance. Model selection can be used for tuning the hyperparameters of a model. This may be done by creating a copy of the model for each set of hyperparameters, and treating each copy as a separate model. The utils.expand_param_grid function can be used for this purpose. EpsilonGreedyRegressor GreedyRegressor SuccessiveHalvingClassifier SuccessiveHalvingRegressor UCBRegressor base \u00b6 ModelSelectionClassifier ModelSelectionRegressor multiclass \u00b6 Multi-class classification. OneVsOneClassifier OneVsRestClassifier OutputCodeClassifier multioutput \u00b6 Multi-output models. ClassifierChain MonteCarloClassifierChain ProbabilisticClassifierChain RegressorChain naive_bayes \u00b6 Naive Bayes algorithms. BernoulliNB ComplementNB GaussianNB MultinomialNB neighbors \u00b6 Neighbors-based learning. Also known as lazy methods. In these methods, generalisation of the training data is delayed until a query is received. KNNClassifier KNNRegressor NearestNeighbors neural_net \u00b6 Neural networks. MLPRegressor activations \u00b6 Identity ReLU Sigmoid optim \u00b6 Stochastic optimization. AMSGrad AdaBound AdaDelta AdaGrad AdaMax Adam Averager FTRLProximal Momentum Nadam NesterovMomentum RMSProp SGD base \u00b6 Initializer Loss Optimizer Scheduler initializers \u00b6 Weight initializers. Constant Normal Zeros losses \u00b6 Loss functions. Each loss function is intended to work with both single values as well as numpy vectors. Absolute BinaryFocalLoss BinaryLoss Cauchy CrossEntropy EpsilonInsensitiveHinge Hinge Huber Log MultiClassLoss Poisson Quantile RegressionLoss Squared schedulers \u00b6 Learning rate schedulers. Constant InverseScaling Optimal preprocessing \u00b6 Feature preprocessing. The purpose of this module is to modify an existing set of features so that they can be processed by a machine learning algorithm. This may be done by scaling numeric parts of the data or by one-hot encoding categorical features. The difference with the feature_extraction module is that the latter extracts new information from the data AdaptiveStandardScaler Binarizer FeatureHasher LDA MaxAbsScaler MinMaxScaler Normalizer OneHotEncoder PredClipper PreviousImputer RobustScaler StandardScaler StatImputer TargetStandardScaler proba \u00b6 Probability distributions. Gaussian Multinomial Rolling TimeRolling base \u00b6 ContinuousDistribution DiscreteDistribution reco \u00b6 Recommender systems module. Recommender systems (recsys for short) is a large topic. This module is far from comprehensive. It simply provides models which can contribute towards building a recommender system. A typical recommender system is made up of a retrieval phase, followed by a ranking phase. The output of the retrieval phase is a shortlist of the catalogue of items. The items in the shortlist are then usually ranked according to the expected preference the user will have for each item. This module focuses on the ranking phase. Models which inherit from the Ranker class have a rank method. This allows sorting a set of items for a given user. Each model also has a learn_one(user, item, y, context) which allows learning user preferences. The y parameter is a reward value, the nature of which depends is specific to each and every recommendation task. Typically the reward is a number or a boolean value. It is up to the user to determine how to translate a user session into training data. Baseline BiasedMF FunkMF RandomNormal base \u00b6 Ranker rules \u00b6 Decision rules-based algorithms. AMRules stats \u00b6 Running statistics AbsMax AutoCorr BayesianMean Count Cov EWMean EWVar Entropy IQR Kurtosis Link MAD Max Mean Min Mode NUnique PeakToPeak PearsonCorr Quantile RollingAbsMax RollingCov RollingIQR RollingMax RollingMean RollingMin RollingMode RollingPeakToPeak RollingPearsonCorr RollingQuantile RollingSEM RollingSum RollingVar SEM Shift Skew Sum Var base \u00b6 Bivariate Univariate stream \u00b6 Streaming utilities. The module includes tools to iterate over data streams. Classes Cache Functions iter_arff iter_array iter_csv iter_libsvm iter_pandas iter_sklearn_dataset iter_sql shuffle simulate_qa synth \u00b6 Synthetic datasets. Each synthetic dataset is a stream generator. The benefit of using a generator is that they do not store the data and each data sample is generated on the fly. Except for a couple of methods, the majority of these methods are infinite data generators. Agrawal AnomalySine ConceptDriftStream Friedman FriedmanDrift Hyperplane LED LEDDrift Logical Mixed Mv Planes2D RandomRBF RandomRBFDrift RandomTree SEA STAGGER Sine Waveform time_series \u00b6 Time series forecasting. Classes ForecastingMetric HoltWinters HorizonMetric SNARIMAX Functions evaluate iter_evaluate base \u00b6 Forecaster tree \u00b6 This module implements incremental Decision Tree (iDT) algorithms for handling classification and regression tasks. Each family of iDT will be presented in a dedicated section. At any moment, iDT might face situations where an input feature previously used to make a split decision is missing in an incoming sample. In this case, the most traversed path is selected to pass down the instance. Moreover, in the case of nominal features, if a new category arises and the feature is used in a decision node, a new branch is created to accommodate the new value. 1. Hoeffding Trees This family of iDT algorithms use the Hoeffding Bound to determine whether or not the incrementally computed best split candidates would be equivalent to the ones obtained in a batch-processing fashion. All the available Hoeffding Tree (HT) implementation share some common functionalities: Set the maximum tree depth allowed ( max_depth ). Handle Active and Inactive nodes: Active learning nodes update their own internal state to improve predictions and monitor input features to perform split attempts. Inactive learning nodes do not update their internal state and only keep the predictors; they are used to save memory in the tree ( max_size ). Enable/disable memory management. Define strategies to sort leaves according to how likely they are going to be split. This enables deactivating non-promising leaves to save memory. Disabling \u2018poor\u2019 attributes to save memory and speed up tree construction. A poor attribute is an input feature whose split merit is much smaller than the current best candidate. Once a feature is disabled, the tree stops saving statistics necessary to split such a feature. Define properties to access leaf prediction strategies, split criteria, and other relevant characteristics. 2. Stochastic Gradient Trees Stochastic Gradient Trees (SGT) directly optimize a loss function, rather than relying on split heuristics to guide the tree growth. F-tests are performed do decide whether a leaf should be expanded or its prediction value should be updated. SGTs can deal with binary classification and single-target regression. They also support dynamic and static feature quantizers to deal with numerical inputs. ExtremelyFastDecisionTreeClassifier HoeffdingAdaptiveTreeClassifier HoeffdingAdaptiveTreeRegressor HoeffdingTreeClassifier HoeffdingTreeRegressor LabelCombinationHoeffdingTreeClassifier SGTClassifier SGTRegressor iSOUPTreeRegressor base \u00b6 This module defines generic branch and leaf implementations. These should be used in River by each tree-based model. Using these classes makes the code more DRY. The only exception for not doing so would be for performance, whereby a tree-based model uses a bespoke implementation. This module defines a bunch of methods to ease the manipulation and diagnostic of trees. Its intention is to provide utilities for walking over a tree and visualizing it. Branch Leaf splitter \u00b6 This module implements the Attribute Observers (AO) (or tree splitters) that are used by the Hoeffding Trees (HT). It also implements the feature quantizers (FQ) used by Stochastic Gradient Trees (SGT). AOs are a core aspect of the HTs construction, and might represent one of the major bottlenecks when building the trees. The same holds for SGTs and FQs. The correct choice and setup of a splitter might result in significant differences in the running time and memory usage of the incremental decision trees. AOs for classification and regression trees can be differentiated by using the property is_target_class ( True for splitters designed to classification tasks). An error will be raised if one tries to use a classification splitter in a regression tree and vice-versa. Lastly, AOs cannot be used in SGT and FQs cannot be used in Hoeffding Trees. So, care must be taken when choosing the correct feature splitter. DynamicQuantizer EBSTSplitter ExhaustiveSplitter GaussianSplitter HistogramSplitter QOSplitter Quantizer Splitter StaticQuantizer TEBSTSplitter utils \u00b6 Shared utility classes and functions Classes SortedWindow VectorDict Functions dict2numpy expand_param_grid log_method_calls numpy2dict pure_inference_mode warm_up_mode math \u00b6 Mathematical utility functions (intended for internal purposes). A lot of this is experimental and has a high probability of changing in the future. argmax chain_dot clamp dot dotvecmat matmul2d minkowski_distance norm outer prod sherman_morrison sigmoid sign softmax pretty \u00b6 Helper functions for making things readable by humans. humanize_bytes print_table random \u00b6 poisson","title":"Overview"},{"location":"api/overview/#overview","text":"","title":"Overview"},{"location":"api/overview/#anomaly","text":"Anomaly detection. Estimators in the anomaly module have a bespoke API. Each anomaly detector has a score_one method instead of a predict_one method. This method returns an anomaly score. Normal observations should have a low score, whereas anomalous observations should have a high score. The range of the scores is relative to each estimator. Anomaly detectors are usually unsupervised, in that they analyze the distribution of the features they are shown. But River also has a notion of supervised anomaly detectors. These analyze the distribution of a target variable, and optionally include the distribution of the features as well. They are useful for detecting labelling anomalies, which can be detrimental if they learned by a model. GaussianScorer HalfSpaceTrees OneClassSVM QuantileFilter ThresholdFilter","title":"anomaly"},{"location":"api/overview/#base","text":"AnomalyDetector","title":"base"},{"location":"api/overview/#base_1","text":"Base interfaces. Every estimator in river is a class, and as such inherits from at least one base interface. These are used to categorize, organize, and standardize the many estimators that river contains. This module contains mixin classes, which are all suffixed by Mixin . Their purpose is to provide additional functionality to an estimator, and thus need to be used in conjunction with a non-mixin base class. This module also contains utilities for type hinting and tagging estimators. Base Classifier Clusterer DriftDetector Ensemble Estimator MiniBatchClassifier MiniBatchRegressor MiniBatchTransformer MultiOutputMixin Regressor SupervisedTransformer Transformer Wrapper WrapperEnsemble","title":"base"},{"location":"api/overview/#cluster","text":"Unsupervised clustering. CluStream DBSTREAM DenStream KMeans STREAMKMeans","title":"cluster"},{"location":"api/overview/#compat","text":"Compatibility tools. This module contains adapters for making river estimators compatible with other libraries, and vice-versa whenever possible. The relevant adapters will only be usable if you have installed the necessary library. For instance, you have to install scikit-learn in order to use the compat.convert_sklearn_to_river function. Classes River2SKLClassifier River2SKLClusterer River2SKLRegressor River2SKLTransformer SKL2RiverClassifier SKL2RiverRegressor Functions convert_river_to_sklearn convert_sklearn_to_river","title":"compat"},{"location":"api/overview/#compose","text":"Model composition. This module contains utilities for merging multiple modeling steps into a single pipeline. Although pipelines are not the only way to process a stream of data, we highly encourage you to use them. Discard FuncTransformer Grouper Pipeline Prefixer Renamer Select SelectType Suffixer TargetTransformRegressor TransformerProduct TransformerUnion","title":"compose"},{"location":"api/overview/#datasets","text":"Datasets. This module contains a collection of datasets for multiple tasks: classification, regression, etc. The data corresponds to popular datasets and are conveniently wrapped to easily iterate over the data in a stream fashion. All datasets have fixed size. Please refer to river.synth if you are interested in infinite synthetic data generators. AirlinePassengers Bananas Bikes ChickWeights CreditCard Elec2 HTTP Higgs ImageSegments Insects Keystroke MaliciousURL MovieLens100K Music Phishing Restaurants SMSSpam SMTP SolarFlare TREC07 Taxis TrumpApproval WaterFlow","title":"datasets"},{"location":"api/overview/#base_2","text":"Dataset FileDataset RemoteDataset SyntheticDataset","title":"base"},{"location":"api/overview/#drift","text":"Concept Drift Detection. This module contains concept drift detection methods. The purpose of a drift detector is to raise an alarm if the data distribution changes. A good drift detector method is the one that maximizes the true positives while keeping the number of false positives to a minimum. ADWIN DDM EDDM HDDM_A HDDM_W KSWIN PageHinkley PeriodicTrigger","title":"drift"},{"location":"api/overview/#dummy","text":"Dummy estimators. This module is here for testing purposes, as well as providing baseline performances. NoChangeClassifier PriorClassifier StatisticRegressor","title":"dummy"},{"location":"api/overview/#ensemble","text":"Ensemble learning. Broadly speaking, there are two kinds of ensemble approaches. There are those that copy a single model several times and aggregate the predictions of said copies. This includes bagging as well as boosting. Then there are those that are composed of an arbitrary list of models, and can therefore aggregate predictions from different kinds of models. ADWINBaggingClassifier AdaBoostClassifier AdaptiveRandomForestClassifier AdaptiveRandomForestRegressor BaggingClassifier BaggingRegressor EWARegressor LeveragingBaggingClassifier SRPClassifier SRPRegressor StackingClassifier VotingClassifier","title":"ensemble"},{"location":"api/overview/#evaluate","text":"Model evaluation. This module provides utilities to evaluate an online model. The goal is to reproduce a real-world scenario with high fidelity. The core function of this module is progressive_val_score , which allows to evaluate a model via progressive validation. This module also exposes \"tracks\". A track is a predefined combination of a dataset and one or more metrics. This allows a principled manner to compare models with each other. For instance, the load_binary_clf_tracks returns tracks that are to be used to evaluate the performance of a binary classification model. The benchmarks directory at the root of the River repository uses these tracks. Classes Track Functions iter_progressive_val_score load_binary_clf_tracks progressive_val_score","title":"evaluate"},{"location":"api/overview/#facto","text":"Factorization machines. FFMClassifier FFMRegressor FMClassifier FMRegressor FwFMClassifier FwFMRegressor HOFMClassifier HOFMRegressor","title":"facto"},{"location":"api/overview/#feature_extraction","text":"Feature extraction. This module can be used to extract information from raw features. This includes encoding categorical data as well as looking at interactions between existing features. This differs from the processing module in that the latter's purpose is rather to clean the data so that it may be processed by a particular machine learning algorithm. Agg BagOfWords PolynomialExtender RBFSampler TFIDF TargetAgg","title":"feature_extraction"},{"location":"api/overview/#feature_selection","text":"Feature selection. PoissonInclusion SelectKBest VarianceThreshold","title":"feature_selection"},{"location":"api/overview/#imblearn","text":"Sampling methods. ChebyshevOverSampler ChebyshevUnderSampler HardSamplingClassifier HardSamplingRegressor RandomOverSampler RandomSampler RandomUnderSampler","title":"imblearn"},{"location":"api/overview/#linear_model","text":"Linear models. ALMAClassifier LinearRegression LogisticRegression PAClassifier PARegressor Perceptron SoftmaxRegression","title":"linear_model"},{"location":"api/overview/#base_3","text":"GLM","title":"base"},{"location":"api/overview/#metrics","text":"Evaluation metrics. All the metrics are updated one sample at a time. This way we can track performance of predictive methods over time. Accuracy AdjustedMutualInfo AdjustedRand BalancedAccuracy ClassificationReport CohenKappa Completeness ConfusionMatrix CrossEntropy F1 FBeta FowlkesMallows GeometricMean Homogeneity Jaccard LogLoss MAE MCC MSE MacroF1 MacroFBeta MacroJaccard MacroPrecision MacroRecall MicroF1 MicroFBeta MicroJaccard MicroPrecision MicroRecall MultiFBeta MutualInfo NormalizedMutualInfo Precision R2 RMSE RMSLE ROCAUC Rand Recall Rolling SMAPE Silhouette TimeRolling VBeta WeightedF1 WeightedFBeta WeightedJaccard WeightedPrecision WeightedRecall","title":"metrics"},{"location":"api/overview/#base_4","text":"BinaryMetric ClassificationMetric Metric Metrics MultiClassMetric RegressionMetric WrapperMetric","title":"base"},{"location":"api/overview/#multioutput","text":"Metrics for multi-output learning. ExactMatch MacroAverage MicroAverage MultiLabelConfusionMatrix PerOutput","title":"multioutput"},{"location":"api/overview/#base_5","text":"MultiOutputClassificationMetric MultiOutputRegressionMetric","title":"base"},{"location":"api/overview/#misc","text":"Miscellaneous. This module essentially regroups some implementations that have nowhere else to go. CovMatrix Histogram SDFT Skyline","title":"misc"},{"location":"api/overview/#model_selection","text":"Model selection. This module regroups a variety of methods that may be used for performing model selection. An model selector is provided with a list of models. These are called \"experts\" in the expert learning literature. The model selector's goal is to perform at least as well as the best model. Indeed, initially, the best model is not known. The performance of each model becomes more apparent as time goes by. Different strategies are possible, each one offering a different tradeoff in terms of accuracy and computational performance. Model selection can be used for tuning the hyperparameters of a model. This may be done by creating a copy of the model for each set of hyperparameters, and treating each copy as a separate model. The utils.expand_param_grid function can be used for this purpose. EpsilonGreedyRegressor GreedyRegressor SuccessiveHalvingClassifier SuccessiveHalvingRegressor UCBRegressor","title":"model_selection"},{"location":"api/overview/#base_6","text":"ModelSelectionClassifier ModelSelectionRegressor","title":"base"},{"location":"api/overview/#multiclass","text":"Multi-class classification. OneVsOneClassifier OneVsRestClassifier OutputCodeClassifier","title":"multiclass"},{"location":"api/overview/#multioutput_1","text":"Multi-output models. ClassifierChain MonteCarloClassifierChain ProbabilisticClassifierChain RegressorChain","title":"multioutput"},{"location":"api/overview/#naive_bayes","text":"Naive Bayes algorithms. BernoulliNB ComplementNB GaussianNB MultinomialNB","title":"naive_bayes"},{"location":"api/overview/#neighbors","text":"Neighbors-based learning. Also known as lazy methods. In these methods, generalisation of the training data is delayed until a query is received. KNNClassifier KNNRegressor NearestNeighbors","title":"neighbors"},{"location":"api/overview/#neural_net","text":"Neural networks. MLPRegressor","title":"neural_net"},{"location":"api/overview/#activations","text":"Identity ReLU Sigmoid","title":"activations"},{"location":"api/overview/#optim","text":"Stochastic optimization. AMSGrad AdaBound AdaDelta AdaGrad AdaMax Adam Averager FTRLProximal Momentum Nadam NesterovMomentum RMSProp SGD","title":"optim"},{"location":"api/overview/#base_7","text":"Initializer Loss Optimizer Scheduler","title":"base"},{"location":"api/overview/#initializers","text":"Weight initializers. Constant Normal Zeros","title":"initializers"},{"location":"api/overview/#losses","text":"Loss functions. Each loss function is intended to work with both single values as well as numpy vectors. Absolute BinaryFocalLoss BinaryLoss Cauchy CrossEntropy EpsilonInsensitiveHinge Hinge Huber Log MultiClassLoss Poisson Quantile RegressionLoss Squared","title":"losses"},{"location":"api/overview/#schedulers","text":"Learning rate schedulers. Constant InverseScaling Optimal","title":"schedulers"},{"location":"api/overview/#preprocessing","text":"Feature preprocessing. The purpose of this module is to modify an existing set of features so that they can be processed by a machine learning algorithm. This may be done by scaling numeric parts of the data or by one-hot encoding categorical features. The difference with the feature_extraction module is that the latter extracts new information from the data AdaptiveStandardScaler Binarizer FeatureHasher LDA MaxAbsScaler MinMaxScaler Normalizer OneHotEncoder PredClipper PreviousImputer RobustScaler StandardScaler StatImputer TargetStandardScaler","title":"preprocessing"},{"location":"api/overview/#proba","text":"Probability distributions. Gaussian Multinomial Rolling TimeRolling","title":"proba"},{"location":"api/overview/#base_8","text":"ContinuousDistribution DiscreteDistribution","title":"base"},{"location":"api/overview/#reco","text":"Recommender systems module. Recommender systems (recsys for short) is a large topic. This module is far from comprehensive. It simply provides models which can contribute towards building a recommender system. A typical recommender system is made up of a retrieval phase, followed by a ranking phase. The output of the retrieval phase is a shortlist of the catalogue of items. The items in the shortlist are then usually ranked according to the expected preference the user will have for each item. This module focuses on the ranking phase. Models which inherit from the Ranker class have a rank method. This allows sorting a set of items for a given user. Each model also has a learn_one(user, item, y, context) which allows learning user preferences. The y parameter is a reward value, the nature of which depends is specific to each and every recommendation task. Typically the reward is a number or a boolean value. It is up to the user to determine how to translate a user session into training data. Baseline BiasedMF FunkMF RandomNormal","title":"reco"},{"location":"api/overview/#base_9","text":"Ranker","title":"base"},{"location":"api/overview/#rules","text":"Decision rules-based algorithms. AMRules","title":"rules"},{"location":"api/overview/#stats","text":"Running statistics AbsMax AutoCorr BayesianMean Count Cov EWMean EWVar Entropy IQR Kurtosis Link MAD Max Mean Min Mode NUnique PeakToPeak PearsonCorr Quantile RollingAbsMax RollingCov RollingIQR RollingMax RollingMean RollingMin RollingMode RollingPeakToPeak RollingPearsonCorr RollingQuantile RollingSEM RollingSum RollingVar SEM Shift Skew Sum Var","title":"stats"},{"location":"api/overview/#base_10","text":"Bivariate Univariate","title":"base"},{"location":"api/overview/#stream","text":"Streaming utilities. The module includes tools to iterate over data streams. Classes Cache Functions iter_arff iter_array iter_csv iter_libsvm iter_pandas iter_sklearn_dataset iter_sql shuffle simulate_qa","title":"stream"},{"location":"api/overview/#synth","text":"Synthetic datasets. Each synthetic dataset is a stream generator. The benefit of using a generator is that they do not store the data and each data sample is generated on the fly. Except for a couple of methods, the majority of these methods are infinite data generators. Agrawal AnomalySine ConceptDriftStream Friedman FriedmanDrift Hyperplane LED LEDDrift Logical Mixed Mv Planes2D RandomRBF RandomRBFDrift RandomTree SEA STAGGER Sine Waveform","title":"synth"},{"location":"api/overview/#time_series","text":"Time series forecasting. Classes ForecastingMetric HoltWinters HorizonMetric SNARIMAX Functions evaluate iter_evaluate","title":"time_series"},{"location":"api/overview/#base_11","text":"Forecaster","title":"base"},{"location":"api/overview/#tree","text":"This module implements incremental Decision Tree (iDT) algorithms for handling classification and regression tasks. Each family of iDT will be presented in a dedicated section. At any moment, iDT might face situations where an input feature previously used to make a split decision is missing in an incoming sample. In this case, the most traversed path is selected to pass down the instance. Moreover, in the case of nominal features, if a new category arises and the feature is used in a decision node, a new branch is created to accommodate the new value. 1. Hoeffding Trees This family of iDT algorithms use the Hoeffding Bound to determine whether or not the incrementally computed best split candidates would be equivalent to the ones obtained in a batch-processing fashion. All the available Hoeffding Tree (HT) implementation share some common functionalities: Set the maximum tree depth allowed ( max_depth ). Handle Active and Inactive nodes: Active learning nodes update their own internal state to improve predictions and monitor input features to perform split attempts. Inactive learning nodes do not update their internal state and only keep the predictors; they are used to save memory in the tree ( max_size ). Enable/disable memory management. Define strategies to sort leaves according to how likely they are going to be split. This enables deactivating non-promising leaves to save memory. Disabling \u2018poor\u2019 attributes to save memory and speed up tree construction. A poor attribute is an input feature whose split merit is much smaller than the current best candidate. Once a feature is disabled, the tree stops saving statistics necessary to split such a feature. Define properties to access leaf prediction strategies, split criteria, and other relevant characteristics. 2. Stochastic Gradient Trees Stochastic Gradient Trees (SGT) directly optimize a loss function, rather than relying on split heuristics to guide the tree growth. F-tests are performed do decide whether a leaf should be expanded or its prediction value should be updated. SGTs can deal with binary classification and single-target regression. They also support dynamic and static feature quantizers to deal with numerical inputs. ExtremelyFastDecisionTreeClassifier HoeffdingAdaptiveTreeClassifier HoeffdingAdaptiveTreeRegressor HoeffdingTreeClassifier HoeffdingTreeRegressor LabelCombinationHoeffdingTreeClassifier SGTClassifier SGTRegressor iSOUPTreeRegressor","title":"tree"},{"location":"api/overview/#base_12","text":"This module defines generic branch and leaf implementations. These should be used in River by each tree-based model. Using these classes makes the code more DRY. The only exception for not doing so would be for performance, whereby a tree-based model uses a bespoke implementation. This module defines a bunch of methods to ease the manipulation and diagnostic of trees. Its intention is to provide utilities for walking over a tree and visualizing it. Branch Leaf","title":"base"},{"location":"api/overview/#splitter","text":"This module implements the Attribute Observers (AO) (or tree splitters) that are used by the Hoeffding Trees (HT). It also implements the feature quantizers (FQ) used by Stochastic Gradient Trees (SGT). AOs are a core aspect of the HTs construction, and might represent one of the major bottlenecks when building the trees. The same holds for SGTs and FQs. The correct choice and setup of a splitter might result in significant differences in the running time and memory usage of the incremental decision trees. AOs for classification and regression trees can be differentiated by using the property is_target_class ( True for splitters designed to classification tasks). An error will be raised if one tries to use a classification splitter in a regression tree and vice-versa. Lastly, AOs cannot be used in SGT and FQs cannot be used in Hoeffding Trees. So, care must be taken when choosing the correct feature splitter. DynamicQuantizer EBSTSplitter ExhaustiveSplitter GaussianSplitter HistogramSplitter QOSplitter Quantizer Splitter StaticQuantizer TEBSTSplitter","title":"splitter"},{"location":"api/overview/#utils","text":"Shared utility classes and functions Classes SortedWindow VectorDict Functions dict2numpy expand_param_grid log_method_calls numpy2dict pure_inference_mode warm_up_mode","title":"utils"},{"location":"api/overview/#math","text":"Mathematical utility functions (intended for internal purposes). A lot of this is experimental and has a high probability of changing in the future. argmax chain_dot clamp dot dotvecmat matmul2d minkowski_distance norm outer prod sherman_morrison sigmoid sign softmax","title":"math"},{"location":"api/overview/#pretty","text":"Helper functions for making things readable by humans. humanize_bytes print_table","title":"pretty"},{"location":"api/overview/#random","text":"poisson","title":"random"},{"location":"api/anomaly/GaussianScorer/","text":"GaussianScorer \u00b6 Univariate Gaussian anomaly detector. This is a supervised anomaly detector. It fits a Gaussian distribution to the target values. The anomaly score is then computed as so: \\[score = 2 * \\mid CDF(y) - 0.5 \\mid\\] This makes it so that the anomaly score is between 0 and 1. Parameters \u00b6 window_size \u2013 defaults to None Set this to fit the Gaussian distribution over a window of recent values. grace_period \u2013 defaults to 100 Number of samples before which a 0 is always returned. This is handy because the Gaussian distribution needs time to stabilize, and will likely produce overly high anomaly score for the first samples. Examples \u00b6 >>> import random >>> from river import anomaly >>> rng = random . Random ( 42 ) >>> detector = anomaly . GaussianScorer () >>> for y in ( rng . gauss ( 0 , 1 ) for _ in range ( 100 )): ... detector = detector . learn_one ( None , y ) >>> detector . score_one ( None , - 3 ) 0.999477 ... >>> detector . score_one ( None , 3 ) 0.999153 ... >>> detector . score_one ( None , 0 ) 0.052665 ... >>> detector . score_one ( None , 0.5 ) 0.383717 ... Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters _ y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedAnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds a normal observation. Parameters _ y ( Union[bool, str, int, numbers.Number] ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"GaussianScorer"},{"location":"api/anomaly/GaussianScorer/#gaussianscorer","text":"Univariate Gaussian anomaly detector. This is a supervised anomaly detector. It fits a Gaussian distribution to the target values. The anomaly score is then computed as so: \\[score = 2 * \\mid CDF(y) - 0.5 \\mid\\] This makes it so that the anomaly score is between 0 and 1.","title":"GaussianScorer"},{"location":"api/anomaly/GaussianScorer/#parameters","text":"window_size \u2013 defaults to None Set this to fit the Gaussian distribution over a window of recent values. grace_period \u2013 defaults to 100 Number of samples before which a 0 is always returned. This is handy because the Gaussian distribution needs time to stabilize, and will likely produce overly high anomaly score for the first samples.","title":"Parameters"},{"location":"api/anomaly/GaussianScorer/#examples","text":">>> import random >>> from river import anomaly >>> rng = random . Random ( 42 ) >>> detector = anomaly . GaussianScorer () >>> for y in ( rng . gauss ( 0 , 1 ) for _ in range ( 100 )): ... detector = detector . learn_one ( None , y ) >>> detector . score_one ( None , - 3 ) 0.999477 ... >>> detector . score_one ( None , 3 ) 0.999153 ... >>> detector . score_one ( None , 0 ) 0.052665 ... >>> detector . score_one ( None , 0.5 ) 0.383717 ...","title":"Examples"},{"location":"api/anomaly/GaussianScorer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters _ y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedAnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds a normal observation. Parameters _ y ( Union[bool, str, int, numbers.Number] ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/anomaly/HalfSpaceTrees/","text":"HalfSpaceTrees \u00b6 Half-Space Trees (HST). Half-space trees are an online variant of isolation forests. They work well when anomalies are spread out. However, they do not work well if anomalies are packed together in windows. By default, this implementation assumes that each feature has values that are comprised between 0 and 1. If this isn't the case, then you can manually specify the limits via the limits argument. If you do not know the limits in advance, then you can use a preprocessing.MinMaxScaler as an initial preprocessing step. The current implementation builds the trees the first time the learn_one method is called. Therefore, the first learn_one call might be slow, whereas subsequent calls will be very fast in comparison. In general, the computation time of both learn_one and score_one scales linearly with the number of trees, and exponentially with the height of each tree. Note that high scores indicate anomalies, whereas low scores indicate normal observations. Parameters \u00b6 n_trees \u2013 defaults to 10 Number of trees to use. height \u2013 defaults to 8 Height of each tree. Note that a tree of height h is made up of h + 1 levels and therefore contains 2 ** (h + 1) - 1 nodes. window_size \u2013 defaults to 250 Number of observations to use for calculating the mass at each node in each tree. limits ( Dict[Hashable, Tuple[float, float]] ) \u2013 defaults to None Specifies the range of each feature. By default each feature is assumed to be in range [0, 1] . seed ( int ) \u2013 defaults to None Random number seed. Attributes \u00b6 size_limit This is the threshold under which the node search stops during the scoring phase. The value .1 is a magic constant indicated in the original paper. Examples \u00b6 >>> from river import anomaly >>> X = [ 0.5 , 0.45 , 0.43 , 0.44 , 0.445 , 0.45 , 0.0 ] >>> hst = anomaly . HalfSpaceTrees ( ... n_trees = 5 , ... height = 3 , ... window_size = 3 , ... seed = 42 ... ) >>> for x in X [: 3 ]: ... hst = hst . learn_one ({ 'x' : x }) # Warming up >>> for x in X : ... features = { 'x' : x } ... hst = hst . learn_one ( features ) ... print ( f 'Anomaly score for x= { x : .3f } : { hst . score_one ( features ) : .3f } ' ) Anomaly score for x = 0.500 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.430 : 0.107 Anomaly score for x = 0.440 : 0.107 Anomaly score for x = 0.445 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.000 : 0.853 The feature values are all comprised between 0 and 1. This is what is assumed by the model by default. In the following example, we construct a pipeline that scales the data online and ensures that the values of each feature are comprised between 0 and 1. >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees ( seed = 42 ) ... ) >>> auc = metrics . ROCAUC () >>> for x , y in datasets . CreditCard () . take ( 2500 ): ... score = model . score_one ( x ) ... model = model . learn_one ( x ) ... auc = auc . update ( y , score ) >>> auc ROCAUC : 93.94 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a References \u00b6 Tan, S.C., Ting, K.M. and Liu, T.F., 2011, June. Fast anomaly detection for streaming data. In Twenty-Second International Joint Conference on Artificial Intelligence. \u21a9","title":"HalfSpaceTrees"},{"location":"api/anomaly/HalfSpaceTrees/#halfspacetrees","text":"Half-Space Trees (HST). Half-space trees are an online variant of isolation forests. They work well when anomalies are spread out. However, they do not work well if anomalies are packed together in windows. By default, this implementation assumes that each feature has values that are comprised between 0 and 1. If this isn't the case, then you can manually specify the limits via the limits argument. If you do not know the limits in advance, then you can use a preprocessing.MinMaxScaler as an initial preprocessing step. The current implementation builds the trees the first time the learn_one method is called. Therefore, the first learn_one call might be slow, whereas subsequent calls will be very fast in comparison. In general, the computation time of both learn_one and score_one scales linearly with the number of trees, and exponentially with the height of each tree. Note that high scores indicate anomalies, whereas low scores indicate normal observations.","title":"HalfSpaceTrees"},{"location":"api/anomaly/HalfSpaceTrees/#parameters","text":"n_trees \u2013 defaults to 10 Number of trees to use. height \u2013 defaults to 8 Height of each tree. Note that a tree of height h is made up of h + 1 levels and therefore contains 2 ** (h + 1) - 1 nodes. window_size \u2013 defaults to 250 Number of observations to use for calculating the mass at each node in each tree. limits ( Dict[Hashable, Tuple[float, float]] ) \u2013 defaults to None Specifies the range of each feature. By default each feature is assumed to be in range [0, 1] . seed ( int ) \u2013 defaults to None Random number seed.","title":"Parameters"},{"location":"api/anomaly/HalfSpaceTrees/#attributes","text":"size_limit This is the threshold under which the node search stops during the scoring phase. The value .1 is a magic constant indicated in the original paper.","title":"Attributes"},{"location":"api/anomaly/HalfSpaceTrees/#examples","text":">>> from river import anomaly >>> X = [ 0.5 , 0.45 , 0.43 , 0.44 , 0.445 , 0.45 , 0.0 ] >>> hst = anomaly . HalfSpaceTrees ( ... n_trees = 5 , ... height = 3 , ... window_size = 3 , ... seed = 42 ... ) >>> for x in X [: 3 ]: ... hst = hst . learn_one ({ 'x' : x }) # Warming up >>> for x in X : ... features = { 'x' : x } ... hst = hst . learn_one ( features ) ... print ( f 'Anomaly score for x= { x : .3f } : { hst . score_one ( features ) : .3f } ' ) Anomaly score for x = 0.500 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.430 : 0.107 Anomaly score for x = 0.440 : 0.107 Anomaly score for x = 0.445 : 0.107 Anomaly score for x = 0.450 : 0.071 Anomaly score for x = 0.000 : 0.853 The feature values are all comprised between 0 and 1. This is what is assumed by the model by default. In the following example, we construct a pipeline that scales the data online and ensures that the values of each feature are comprised between 0 and 1. >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees ( seed = 42 ) ... ) >>> auc = metrics . ROCAUC () >>> for x , y in datasets . CreditCard () . take ( 2500 ): ... score = model . score_one ( x ) ... model = model . learn_one ( x ) ... auc = auc . update ( y , score ) >>> auc ROCAUC : 93.94 %","title":"Examples"},{"location":"api/anomaly/HalfSpaceTrees/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/anomaly/HalfSpaceTrees/#references","text":"Tan, S.C., Ting, K.M. and Liu, T.F., 2011, June. Fast anomaly detection for streaming data. In Twenty-Second International Joint Conference on Artificial Intelligence. \u21a9","title":"References"},{"location":"api/anomaly/OneClassSVM/","text":"OneClassSVM \u00b6 One-class SVM for anomaly detection. This is a stochastic implementation of the one-class SVM algorithm, and will not exactly match its batch formulation. It is encouraged to scale the data upstream with preprocessing.StandardScaler , as well as use feature_extraction.RBFSampler to capture non-linearities. Parameters \u00b6 nu \u2013 defaults to 0.1 An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. You can think of it as the expected fraction of anomalies. optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Attributes \u00b6 weights Examples \u00b6 >>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = anomaly . QuantileFilter ( ... anomaly . OneClassSVM ( nu = 0.2 ), ... q = 0.995 ... ) >>> auc = metrics . ROCAUC () >>> for x , y in datasets . CreditCard () . take ( 2500 ): ... score = model . score_one ( x ) ... is_anomaly = model . classify ( score ) ... model = model . learn_one ( x ) ... auc = auc . update ( y , is_anomaly ) >>> auc ROCAUC : 74.68 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters x Returns An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"OneClassSVM"},{"location":"api/anomaly/OneClassSVM/#oneclasssvm","text":"One-class SVM for anomaly detection. This is a stochastic implementation of the one-class SVM algorithm, and will not exactly match its batch formulation. It is encouraged to scale the data upstream with preprocessing.StandardScaler , as well as use feature_extraction.RBFSampler to capture non-linearities.","title":"OneClassSVM"},{"location":"api/anomaly/OneClassSVM/#parameters","text":"nu \u2013 defaults to 0.1 An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. You can think of it as the expected fraction of anomalies. optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme.","title":"Parameters"},{"location":"api/anomaly/OneClassSVM/#attributes","text":"weights","title":"Attributes"},{"location":"api/anomaly/OneClassSVM/#examples","text":">>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = anomaly . QuantileFilter ( ... anomaly . OneClassSVM ( nu = 0.2 ), ... q = 0.995 ... ) >>> auc = metrics . ROCAUC () >>> for x , y in datasets . CreditCard () . take ( 2500 ): ... score = model . score_one ( x ) ... is_anomaly = model . classify ( score ) ... model = model . learn_one ( x ) ... auc = auc . update ( y , is_anomaly ) >>> auc ROCAUC : 74.68 %","title":"Examples"},{"location":"api/anomaly/OneClassSVM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters x Returns An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/anomaly/QuantileFilter/","text":"QuantileFilter \u00b6 Threshold anomaly filter. Parameters \u00b6 anomaly_detector An anomaly detector. q ( float ) The quantile level above which to classify an anomaly score as anomalous. protect_anomaly_detector \u2013 defaults to True Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift. Attributes \u00b6 q Examples \u00b6 >>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . QuantileFilter ( ... anomaly . HalfSpaceTrees ( seed = 42 ), ... q = 0.95 ... ) ... ) >>> report = metrics . ClassificationReport () >>> for x , y in datasets . CreditCard () . take ( 8000 ): ... score = model . score_one ( x ) ... is_anomaly = model [ 'QuantileFilter' ] . classify ( score ) ... model = model . learn_one ( x ) ... report = report . update ( y , is_anomaly ) >>> report Precision Recall F1 Support < BLANKLINE > 0 99.91 % 97.78 % 98.83 % 7975 1 9.23 % 72.00 % 16.36 % 25 < BLANKLINE > Macro 54.57 % 84.89 % 57.60 % Micro 97.70 % 97.70 % 97.70 % Weighted 99.63 % 97.70 % 98.58 % < BLANKLINE > 97.70 % accuracy Methods \u00b6 classify Classify an anomaly score as anomalous or not. Parameters score ( float ) Returns bool : A boolean value indicating whether the anomaly score is anomalous or not. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the anomaly filter and the underlying anomaly detector. Parameters args Returns self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters args Returns An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"QuantileFilter"},{"location":"api/anomaly/QuantileFilter/#quantilefilter","text":"Threshold anomaly filter.","title":"QuantileFilter"},{"location":"api/anomaly/QuantileFilter/#parameters","text":"anomaly_detector An anomaly detector. q ( float ) The quantile level above which to classify an anomaly score as anomalous. protect_anomaly_detector \u2013 defaults to True Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift.","title":"Parameters"},{"location":"api/anomaly/QuantileFilter/#attributes","text":"q","title":"Attributes"},{"location":"api/anomaly/QuantileFilter/#examples","text":">>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import metrics >>> from river import preprocessing >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . QuantileFilter ( ... anomaly . HalfSpaceTrees ( seed = 42 ), ... q = 0.95 ... ) ... ) >>> report = metrics . ClassificationReport () >>> for x , y in datasets . CreditCard () . take ( 8000 ): ... score = model . score_one ( x ) ... is_anomaly = model [ 'QuantileFilter' ] . classify ( score ) ... model = model . learn_one ( x ) ... report = report . update ( y , is_anomaly ) >>> report Precision Recall F1 Support < BLANKLINE > 0 99.91 % 97.78 % 98.83 % 7975 1 9.23 % 72.00 % 16.36 % 25 < BLANKLINE > Macro 54.57 % 84.89 % 57.60 % Micro 97.70 % 97.70 % 97.70 % Weighted 99.63 % 97.70 % 98.58 % < BLANKLINE > 97.70 % accuracy","title":"Examples"},{"location":"api/anomaly/QuantileFilter/#methods","text":"classify Classify an anomaly score as anomalous or not. Parameters score ( float ) Returns bool : A boolean value indicating whether the anomaly score is anomalous or not. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the anomaly filter and the underlying anomaly detector. Parameters args Returns self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters args Returns An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/anomaly/ThresholdFilter/","text":"ThresholdFilter \u00b6 Threshold anomaly filter. Parameters \u00b6 anomaly_detector An anomaly detector. threshold ( float ) A threshold above which to classify an anomaly score as anomalous. protect_anomaly_detector \u2013 defaults to True Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift. Examples \u00b6 Anomaly filters can be used as part of a pipeline. For instance, we might want to filter out anomalous observations so as not to corrupt a supervised model. As an example, let's take the datasets.WaterFlow dataset. Some of the samples have anomalous target variables because of human interventions. We don't want our model to learn these values. >>> from river import datasets >>> from river import metrics >>> from river import time_series >>> dataset = datasets . WaterFlow () >>> metric = metrics . SMAPE () >>> period = 24 # 24 samples per day >>> model = ( ... anomaly . ThresholdFilter ( ... anomaly . GaussianScorer ( ... window_size = period * 7 , # 7 days ... grace_period = 30 ... ), ... threshold = 0.995 ... ) | ... time_series . HoltWinters ( ... alpha = 0.3 , ... beta = 0.1 , ... multiplicative = False ... ) ... ) >>> time_series . evaluate ( ... dataset , ... model , ... metric , ... horizon = period ... ) + 1 SMAPE : 4.220171 + 2 SMAPE : 4.322648 + 3 SMAPE : 4.418546 + 4 SMAPE : 4.504986 + 5 SMAPE : 4.57924 + 6 SMAPE : 4.64123 + 7 SMAPE : 4.694042 + 8 SMAPE : 4.740753 + 9 SMAPE : 4.777291 + 10 SMAPE : 4.804558 + 11 SMAPE : 4.828114 + 12 SMAPE : 4.849823 + 13 SMAPE : 4.865871 + 14 SMAPE : 4.871972 + 15 SMAPE : 4.866274 + 16 SMAPE : 4.842614 + 17 SMAPE : 4.806214 + 18 SMAPE : 4.763355 + 19 SMAPE : 4.713455 + 20 SMAPE : 4.672062 + 21 SMAPE : 4.659102 + 22 SMAPE : 4.693496 + 23 SMAPE : 4.773707 + 24 SMAPE : 4.880654 Methods \u00b6 classify Classify an anomaly score as anomalous or not. Parameters score ( float ) Returns bool : A boolean value indicating whether the anomaly score is anomalous or not. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the anomaly filter and the underlying anomaly detector. Parameters args Returns self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters args Returns An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"ThresholdFilter"},{"location":"api/anomaly/ThresholdFilter/#thresholdfilter","text":"Threshold anomaly filter.","title":"ThresholdFilter"},{"location":"api/anomaly/ThresholdFilter/#parameters","text":"anomaly_detector An anomaly detector. threshold ( float ) A threshold above which to classify an anomaly score as anomalous. protect_anomaly_detector \u2013 defaults to True Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift.","title":"Parameters"},{"location":"api/anomaly/ThresholdFilter/#examples","text":"Anomaly filters can be used as part of a pipeline. For instance, we might want to filter out anomalous observations so as not to corrupt a supervised model. As an example, let's take the datasets.WaterFlow dataset. Some of the samples have anomalous target variables because of human interventions. We don't want our model to learn these values. >>> from river import datasets >>> from river import metrics >>> from river import time_series >>> dataset = datasets . WaterFlow () >>> metric = metrics . SMAPE () >>> period = 24 # 24 samples per day >>> model = ( ... anomaly . ThresholdFilter ( ... anomaly . GaussianScorer ( ... window_size = period * 7 , # 7 days ... grace_period = 30 ... ), ... threshold = 0.995 ... ) | ... time_series . HoltWinters ( ... alpha = 0.3 , ... beta = 0.1 , ... multiplicative = False ... ) ... ) >>> time_series . evaluate ( ... dataset , ... model , ... metric , ... horizon = period ... ) + 1 SMAPE : 4.220171 + 2 SMAPE : 4.322648 + 3 SMAPE : 4.418546 + 4 SMAPE : 4.504986 + 5 SMAPE : 4.57924 + 6 SMAPE : 4.64123 + 7 SMAPE : 4.694042 + 8 SMAPE : 4.740753 + 9 SMAPE : 4.777291 + 10 SMAPE : 4.804558 + 11 SMAPE : 4.828114 + 12 SMAPE : 4.849823 + 13 SMAPE : 4.865871 + 14 SMAPE : 4.871972 + 15 SMAPE : 4.866274 + 16 SMAPE : 4.842614 + 17 SMAPE : 4.806214 + 18 SMAPE : 4.763355 + 19 SMAPE : 4.713455 + 20 SMAPE : 4.672062 + 21 SMAPE : 4.659102 + 22 SMAPE : 4.693496 + 23 SMAPE : 4.773707 + 24 SMAPE : 4.880654","title":"Examples"},{"location":"api/anomaly/ThresholdFilter/#methods","text":"classify Classify an anomaly score as anomalous or not. Parameters score ( float ) Returns bool : A boolean value indicating whether the anomaly score is anomalous or not. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the anomaly filter and the underlying anomaly detector. Parameters args Returns self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters args Returns An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/anomaly/base/AnomalyDetector/","text":"AnomalyDetector \u00b6 An anomaly detector. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"AnomalyDetector"},{"location":"api/anomaly/base/AnomalyDetector/#anomalydetector","text":"An anomaly detector.","title":"AnomalyDetector"},{"location":"api/anomaly/base/AnomalyDetector/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model. Parameters x ( dict ) Returns AnomalyDetector : self score_one Return an outlier score. A high score is indicative of an anomaly. A low score corresponds to a normal observation. Parameters x ( dict ) Returns float : An anomaly score. A high score is indicative of an anomaly. A low score corresponds a","title":"Methods"},{"location":"api/base/Base/","text":"Base \u00b6 Base class that is inherited by the majority of classes in River. This base class allows us to handle the following tasks in a uniform manner: Getting and setting parameters. - Displaying information. - Cloning. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Base"},{"location":"api/base/Base/#base","text":"Base class that is inherited by the majority of classes in River. This base class allows us to handle the following tasks in a uniform manner: Getting and setting parameters. - Displaying information. - Cloning.","title":"Base"},{"location":"api/base/Base/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/base/Classifier/","text":"Classifier \u00b6 A classifier. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Classifier"},{"location":"api/base/Classifier/#classifier","text":"A classifier.","title":"Classifier"},{"location":"api/base/Classifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/base/Clusterer/","text":"Clusterer \u00b6 A clustering model. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Clusterer"},{"location":"api/base/Clusterer/#clusterer","text":"A clustering model.","title":"Clusterer"},{"location":"api/base/Clusterer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Methods"},{"location":"api/base/DriftDetector/","text":"DriftDetector \u00b6 A drift detector. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"DriftDetector"},{"location":"api/base/DriftDetector/#driftdetector","text":"A drift detector.","title":"DriftDetector"},{"location":"api/base/DriftDetector/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/base/DriftDetector/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/base/Ensemble/","text":"Ensemble \u00b6 An ensemble is a model which is composed of a list of models. Parameters \u00b6 models ( Iterator[ base.Estimator ] ) Attributes \u00b6 models Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Ensemble"},{"location":"api/base/Ensemble/#ensemble","text":"An ensemble is a model which is composed of a list of models.","title":"Ensemble"},{"location":"api/base/Ensemble/#parameters","text":"models ( Iterator[ base.Estimator ] )","title":"Parameters"},{"location":"api/base/Ensemble/#attributes","text":"models","title":"Attributes"},{"location":"api/base/Ensemble/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/base/Estimator/","text":"Estimator \u00b6 An estimator. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Estimator"},{"location":"api/base/Estimator/#estimator","text":"An estimator.","title":"Estimator"},{"location":"api/base/Estimator/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/base/MiniBatchClassifier/","text":"MiniBatchClassifier \u00b6 A classifier that can operate on mini-batches. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"MiniBatchClassifier"},{"location":"api/base/MiniBatchClassifier/#minibatchclassifier","text":"A classifier that can operate on mini-batches.","title":"MiniBatchClassifier"},{"location":"api/base/MiniBatchClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/base/MiniBatchRegressor/","text":"MiniBatchRegressor \u00b6 A regressor that can operate on mini-batches. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"MiniBatchRegressor"},{"location":"api/base/MiniBatchRegressor/#minibatchregressor","text":"A regressor that can operate on mini-batches.","title":"MiniBatchRegressor"},{"location":"api/base/MiniBatchRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) kwargs Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/base/MiniBatchTransformer/","text":"MiniBatchTransformer \u00b6 A transform that can operate on mini-batches. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. A lot of transformers don't actually have to do anything during the learn_many step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_many can override this method. Parameters X ( pandas.core.frame.DataFrame ) kwargs Returns Transformer : self learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_many Transform a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A new DataFrame. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"MiniBatchTransformer"},{"location":"api/base/MiniBatchTransformer/#minibatchtransformer","text":"A transform that can operate on mini-batches.","title":"MiniBatchTransformer"},{"location":"api/base/MiniBatchTransformer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. A lot of transformers don't actually have to do anything during the learn_many step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_many can override this method. Parameters X ( pandas.core.frame.DataFrame ) kwargs Returns Transformer : self learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_many Transform a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A new DataFrame. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/base/MultiOutputMixin/","text":"MultiOutputMixin \u00b6 A multi-output estimator.","title":"MultiOutputMixin"},{"location":"api/base/MultiOutputMixin/#multioutputmixin","text":"A multi-output estimator.","title":"MultiOutputMixin"},{"location":"api/base/Regressor/","text":"Regressor \u00b6 A regressor. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Regressor"},{"location":"api/base/Regressor/#regressor","text":"A regressor.","title":"Regressor"},{"location":"api/base/Regressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/base/SupervisedTransformer/","text":"SupervisedTransformer \u00b6 A supervised transformer. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) kwargs Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"SupervisedTransformer"},{"location":"api/base/SupervisedTransformer/#supervisedtransformer","text":"A supervised transformer.","title":"SupervisedTransformer"},{"location":"api/base/SupervisedTransformer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) kwargs Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/base/Transformer/","text":"Transformer \u00b6 A transformer. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Transformer"},{"location":"api/base/Transformer/#transformer","text":"A transformer.","title":"Transformer"},{"location":"api/base/Transformer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/base/Wrapper/","text":"Wrapper \u00b6 A wrapper model.","title":"Wrapper"},{"location":"api/base/Wrapper/#wrapper","text":"A wrapper model.","title":"Wrapper"},{"location":"api/base/WrapperEnsemble/","text":"WrapperEnsemble \u00b6 A wrapper ensemble is an ensemble composed of multiple copies of the same model. Parameters \u00b6 model The model to copy. n_models The number of copies to make. seed Random number generator seed for reproducibility. Attributes \u00b6 models Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"WrapperEnsemble"},{"location":"api/base/WrapperEnsemble/#wrapperensemble","text":"A wrapper ensemble is an ensemble composed of multiple copies of the same model.","title":"WrapperEnsemble"},{"location":"api/base/WrapperEnsemble/#parameters","text":"model The model to copy. n_models The number of copies to make. seed Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/base/WrapperEnsemble/#attributes","text":"models","title":"Attributes"},{"location":"api/base/WrapperEnsemble/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/cluster/CluStream/","text":"CluStream \u00b6 CluStream The CluStream algorithm 1 maintains statistical information about the data using micro-clusters. These micro-clusters are temporal extensions of cluster feature vectors. The micro-clusters are stored at snapshots in time following a pyramidal pattern. This pattern allows to recall summary statistics from different time horizons. Training with a new point p is performed in two main tasks: Determinate closest micro-cluster to p Check whether p fits (memory) into the closest micro-cluster: if p fits, put into micro-cluster if p does not fit, free some space to insert a new micro-cluster. This is done in two ways, delete an old micro-cluster or merge the two micro-clusters closest to each other. Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions. time_window ( int ) \u2013 defaults to 1000 If the current time is T and the time window is h , we only consider the data that arrived within the period (T-h,T) . max_micro_clusters ( int ) \u2013 defaults to 100 The maximum number of micro-clusters to use. micro_cluster_r_factor ( int ) \u2013 defaults to 2 Multiplier for the micro-cluster radius. When deciding to add a new data point to a micro-cluster, the maximum boundary is defined as a factor of the micro_cluster_r_factor of the RMS deviation of the data points in the micro-cluster from the centroid. n_macro_clusters ( int ) \u2013 defaults to 5 The number of clusters (k) for the k-means algorithm. kwargs Other parameters passed to the incremental kmeans at cluster.KMeans . Attributes \u00b6 centers ( dict ) Central positions of each cluster. Examples \u00b6 In the following example, max_micro_clusters and time_window are set relatively low due to the limited number of training points. Moreover, all points are learnt before any predictions are made. The halflife is set at 0.4, to show that you can pass cluster.KMeans parameters via keyword arguments. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ] ... ] >>> clustream = cluster . CluStream ( time_window = 1 , ... max_micro_clusters = 3 , ... n_macro_clusters = 2 , ... seed = 0 , ... halflife = 0.4 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... clustream = clustream . learn_one ( x ) >>> clustream . predict_one ({ 0 : 1 , 1 : 1 }) 1 >>> clustream . predict_one ({ 0 : 4 , 1 : 3 }) 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number. References \u00b6 Aggarwal, C.C., Philip, S.Y., Han, J. and Wang, J., 2003, A framework for clustering evolving data streams. In Proceedings 2003 VLDB conference (pp. 81-92). Morgan Kaufmann. \u21a9","title":"CluStream"},{"location":"api/cluster/CluStream/#clustream","text":"CluStream The CluStream algorithm 1 maintains statistical information about the data using micro-clusters. These micro-clusters are temporal extensions of cluster feature vectors. The micro-clusters are stored at snapshots in time following a pyramidal pattern. This pattern allows to recall summary statistics from different time horizons. Training with a new point p is performed in two main tasks: Determinate closest micro-cluster to p Check whether p fits (memory) into the closest micro-cluster: if p fits, put into micro-cluster if p does not fit, free some space to insert a new micro-cluster. This is done in two ways, delete an old micro-cluster or merge the two micro-clusters closest to each other.","title":"CluStream"},{"location":"api/cluster/CluStream/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions. time_window ( int ) \u2013 defaults to 1000 If the current time is T and the time window is h , we only consider the data that arrived within the period (T-h,T) . max_micro_clusters ( int ) \u2013 defaults to 100 The maximum number of micro-clusters to use. micro_cluster_r_factor ( int ) \u2013 defaults to 2 Multiplier for the micro-cluster radius. When deciding to add a new data point to a micro-cluster, the maximum boundary is defined as a factor of the micro_cluster_r_factor of the RMS deviation of the data points in the micro-cluster from the centroid. n_macro_clusters ( int ) \u2013 defaults to 5 The number of clusters (k) for the k-means algorithm. kwargs Other parameters passed to the incremental kmeans at cluster.KMeans .","title":"Parameters"},{"location":"api/cluster/CluStream/#attributes","text":"centers ( dict ) Central positions of each cluster.","title":"Attributes"},{"location":"api/cluster/CluStream/#examples","text":"In the following example, max_micro_clusters and time_window are set relatively low due to the limited number of training points. Moreover, all points are learnt before any predictions are made. The halflife is set at 0.4, to show that you can pass cluster.KMeans parameters via keyword arguments. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ] ... ] >>> clustream = cluster . CluStream ( time_window = 1 , ... max_micro_clusters = 3 , ... n_macro_clusters = 2 , ... seed = 0 , ... halflife = 0.4 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... clustream = clustream . learn_one ( x ) >>> clustream . predict_one ({ 0 : 1 , 1 : 1 }) 1 >>> clustream . predict_one ({ 0 : 4 , 1 : 3 }) 0","title":"Examples"},{"location":"api/cluster/CluStream/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/CluStream/#references","text":"Aggarwal, C.C., Philip, S.Y., Han, J. and Wang, J., 2003, A framework for clustering evolving data streams. In Proceedings 2003 VLDB conference (pp. 81-92). Morgan Kaufmann. \u21a9","title":"References"},{"location":"api/cluster/DBSTREAM/","text":"DBSTREAM \u00b6 DBSTREAM DBSTREAM 1 is a clustering algorithm for evolving data streams. It is the first micro-cluster-based online clustering component that explicitely captures the density between micro-clusters via a shared density graph. The density information in the graph is then exploited for reclustering based on actual density between adjacent micro clusters. The algorithm is divided into two parts: Online micro-cluster maintenance (learning) For a new point p : Find all micro clusters for which p falls within the fixed radius (clustering threshold). If no neighbor is found, a new micro cluster with a weight of 1 is created for p . If no neighbor is found, a new micro cluster with a weight of 1 is created for p . If one or more neighbors of p are found, we update the micro clusters by applying the appropriate fading, increasing their weight and then we try to move them closer to p using the Gaussian neighborhood function. Next, the shared density graph is updated. To prevent collapsing micro clusters, we will restrict the movement for micro clusters in case they come closer than \\(r\\) (clustering threshold) to each other. Finishing this process, the time stamp is also increased by 1. Finally, the cleanup will be processed. It is executed every t_gap time steps, removing weak micro clusters and weak entries in the shared density graph to recover memory and improve the clustering algorithm's processing speed. Offline generation of macro clusters (clustering) The offline generation of macro clusters is generated through the two following steps: The connectivity graph C is constructed using shared density entries between strong micro clusters. The edges in this connectivity graph with a connectivity value greater than the intersection threshold ( \\(\\alpha\\) ) are used to find connected components representing the final cluster. After the connectivity graph is generated, a variant of the DBSCAN algorithm proposed by Ester et al. is applied to form all macro clusters from \\(\\alpha\\) -connected micro clusters. Parameters \u00b6 clustering_threshold ( float ) \u2013 defaults to 1.0 DBStream represents each micro cluster by a leader (a data point defining the micro cluster's center) and the density in an area of a user-specified radius \\(r\\) ( clustering_threshold ) around the center. fading_factor ( float ) \u2013 defaults to 0.01 Parameter that controls the importance of historical data to current cluster. Note that fading_factor has to be different from 0 . cleanup_interval ( float ) \u2013 defaults to 2 The time interval between two consecutive time points when the cleanup process is conducted. intersection_factor ( float ) \u2013 defaults to 0.3 The intersection factor related to the area of the overlap of the micro clusters relative to the area cover by micro clusters. This parameter is used to determine whether a micro cluster or a shared density is weak. minimum_weight ( float ) \u2013 defaults to 1.0 The minimum weight for a cluster to be not \"noisy\". Attributes \u00b6 n_clusters Number of clusters generated by the algorithm. clusters A set of final clusters of type DBStreamMicroCluster . However, these are either micro clusters, or macro clusters that are generated by merging all \\(\\alpha\\) -connected micro clusters. This set is generated through the offline phase of the algorithm. centers Final clusters' centers. micro_clusters Micro clusters generated by the algorithm. Instead of updating directly the new instance points into a nearest micro cluster, through each iteration, the weight and center will be modified so that the clusters are closer to the new points, using the Gaussian neighborhood function. Examples \u00b6 >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 0.5 ], [ 1 , 0.625 ], [ 1 , 0.75 ], [ 1 , 1.125 ], [ 1 , 1.5 ], [ 1 , 1.75 ], ... [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ], [ 4 , 3.25 ], [ 4 , 3.5 ] ... ] >>> dbstream = cluster . DBSTREAM ( clustering_threshold = 1.5 , ... fading_factor = 0.05 , ... cleanup_interval = 4 , ... intersection_factor = 0.5 , ... minimum_weight = 1 ) >>> for x , _ in stream . iter_array ( X ): ... dbstream = dbstream . learn_one ( x ) >>> dbstream . predict_one ({ 0 : 1 , 1 : 2 }) 0 >>> dbstream . predict_one ({ 0 : 5 , 1 : 2 }) 1 >>> dbstream . n_clusters 2 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number. References \u00b6 Michael Hahsler and Matthew Bolanos (2016, pp 1449-1461). Clsutering Data Streams Based on Shared Density between Micro-Clusters, IEEE Transactions on Knowledge and Data Engineering 28(6) . In Proceedings of the Sixth SIAM International Conference on Data Mining, April 20\u201322, 2006, Bethesda, MD, USA. \u21a9 Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In KDD-96 Proceedings, AAAI. \u21a9","title":"DBSTREAM"},{"location":"api/cluster/DBSTREAM/#dbstream","text":"DBSTREAM DBSTREAM 1 is a clustering algorithm for evolving data streams. It is the first micro-cluster-based online clustering component that explicitely captures the density between micro-clusters via a shared density graph. The density information in the graph is then exploited for reclustering based on actual density between adjacent micro clusters. The algorithm is divided into two parts: Online micro-cluster maintenance (learning) For a new point p : Find all micro clusters for which p falls within the fixed radius (clustering threshold). If no neighbor is found, a new micro cluster with a weight of 1 is created for p . If no neighbor is found, a new micro cluster with a weight of 1 is created for p . If one or more neighbors of p are found, we update the micro clusters by applying the appropriate fading, increasing their weight and then we try to move them closer to p using the Gaussian neighborhood function. Next, the shared density graph is updated. To prevent collapsing micro clusters, we will restrict the movement for micro clusters in case they come closer than \\(r\\) (clustering threshold) to each other. Finishing this process, the time stamp is also increased by 1. Finally, the cleanup will be processed. It is executed every t_gap time steps, removing weak micro clusters and weak entries in the shared density graph to recover memory and improve the clustering algorithm's processing speed. Offline generation of macro clusters (clustering) The offline generation of macro clusters is generated through the two following steps: The connectivity graph C is constructed using shared density entries between strong micro clusters. The edges in this connectivity graph with a connectivity value greater than the intersection threshold ( \\(\\alpha\\) ) are used to find connected components representing the final cluster. After the connectivity graph is generated, a variant of the DBSCAN algorithm proposed by Ester et al. is applied to form all macro clusters from \\(\\alpha\\) -connected micro clusters.","title":"DBSTREAM"},{"location":"api/cluster/DBSTREAM/#parameters","text":"clustering_threshold ( float ) \u2013 defaults to 1.0 DBStream represents each micro cluster by a leader (a data point defining the micro cluster's center) and the density in an area of a user-specified radius \\(r\\) ( clustering_threshold ) around the center. fading_factor ( float ) \u2013 defaults to 0.01 Parameter that controls the importance of historical data to current cluster. Note that fading_factor has to be different from 0 . cleanup_interval ( float ) \u2013 defaults to 2 The time interval between two consecutive time points when the cleanup process is conducted. intersection_factor ( float ) \u2013 defaults to 0.3 The intersection factor related to the area of the overlap of the micro clusters relative to the area cover by micro clusters. This parameter is used to determine whether a micro cluster or a shared density is weak. minimum_weight ( float ) \u2013 defaults to 1.0 The minimum weight for a cluster to be not \"noisy\".","title":"Parameters"},{"location":"api/cluster/DBSTREAM/#attributes","text":"n_clusters Number of clusters generated by the algorithm. clusters A set of final clusters of type DBStreamMicroCluster . However, these are either micro clusters, or macro clusters that are generated by merging all \\(\\alpha\\) -connected micro clusters. This set is generated through the offline phase of the algorithm. centers Final clusters' centers. micro_clusters Micro clusters generated by the algorithm. Instead of updating directly the new instance points into a nearest micro cluster, through each iteration, the weight and center will be modified so that the clusters are closer to the new points, using the Gaussian neighborhood function.","title":"Attributes"},{"location":"api/cluster/DBSTREAM/#examples","text":">>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 0.5 ], [ 1 , 0.625 ], [ 1 , 0.75 ], [ 1 , 1.125 ], [ 1 , 1.5 ], [ 1 , 1.75 ], ... [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ], [ 4 , 3.25 ], [ 4 , 3.5 ] ... ] >>> dbstream = cluster . DBSTREAM ( clustering_threshold = 1.5 , ... fading_factor = 0.05 , ... cleanup_interval = 4 , ... intersection_factor = 0.5 , ... minimum_weight = 1 ) >>> for x , _ in stream . iter_array ( X ): ... dbstream = dbstream . learn_one ( x ) >>> dbstream . predict_one ({ 0 : 1 , 1 : 2 }) 0 >>> dbstream . predict_one ({ 0 : 5 , 1 : 2 }) 1 >>> dbstream . n_clusters 2","title":"Examples"},{"location":"api/cluster/DBSTREAM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/DBSTREAM/#references","text":"Michael Hahsler and Matthew Bolanos (2016, pp 1449-1461). Clsutering Data Streams Based on Shared Density between Micro-Clusters, IEEE Transactions on Knowledge and Data Engineering 28(6) . In Proceedings of the Sixth SIAM International Conference on Data Mining, April 20\u201322, 2006, Bethesda, MD, USA. \u21a9 Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In KDD-96 Proceedings, AAAI. \u21a9","title":"References"},{"location":"api/cluster/DenStream/","text":"DenStream \u00b6 DenStream DenStream 1 is a clustering algorithm for evolving data streams. DenStream can discover clusters with arbitrary shape and is robust against noise (outliers). \"Dense\" micro-clusters (named core-micro-clusters) summarise the clusters of arbitrary shape. A pruning strategy based on the concepts of potential and outlier micro-clusters guarantees the precision of the weights of the micro-clusters with limited memory. The algorithm is divided into two parts: Online micro-cluster maintenance (learning) For a new point p : Try to merge p into either the nearest p-micro-cluster (potential), o-micro-cluster (outlier), or create a new o-micro-cluster and insert it into the outlier buffer. For each T_p iterations, consider the weights of all potential and outlier micro-clusters. If their weights are smaller than a certain threshold (different for each type of micro-clusters), the micro-cluster is deleted. Offline generation of clusters on-demand (clustering) A variant of the DBSCAN algorithm 2 is used, such that all density-connected p-micro-clusters determine the final clusters. Moreover, in order for the algorithm to always be able to generate clusters, a certain number of points must be passed through the algorithm with a suitable streaming speed (number of points passed through within a unit time), indicated by n_samples_init and stream_speed . Parameters \u00b6 decaying_factor ( float ) \u2013 defaults to 0.25 Parameter that controls the importance of historical data to current cluster. Note that decaying_factor has to be different from 0 . beta ( float ) \u2013 defaults to 0.75 Parameter to determine the threshold of outlier relative to core micro-clusters. The value of beta must be within the range (0,1] . mu ( float ) \u2013 defaults to 2 Parameter to determine the threshold of outliers relative to core micro-cluster. As beta * mu must be greater than 1, mu must be within the range (1/beta, inf) . epsilon ( float ) \u2013 defaults to 0.02 Defines the epsilon neighborhood n_samples_init ( int ) \u2013 defaults to 1000 Number of points to to initiqalize the online process stream_speed ( int ) \u2013 defaults to 100 Number of points arrived in unit time Attributes \u00b6 n_clusters Number of clusters generated by the algorithm. clusters A set of final clusters of type MicroCluster , which means that these cluster include all the required information, including number of points, creation time, weight, (weighted) linear sum, (weighted) square sum, center and radius. p_micro_clusters The potential core-icro-clusters that are generated by the algorithm. When a generate cluster request arrives, these p-micro-clusters will go through a variant of the DBSCAN algorithm to determine the final clusters. o_micro_clusters The outlier micro-clusters. Examples \u00b6 The following example uses the default parameters of the algorithm to test its functionality. The set of evolving points X are designed so that clusters are easily identifiable. >>> from river import cluster >>> from river import stream >>> X = [ ... [ - 1 , - 0.5 ], [ - 1 , - 0.625 ], [ - 1 , - 0.75 ], [ - 1 , - 1 ], [ - 1 , - 1.125 ], ... [ - 1 , - 1.25 ], [ - 1.5 , - 0.5 ], [ - 1.5 , - 0.625 ], [ - 1.5 , - 0.75 ], [ - 1.5 , - 1 ], ... [ - 1.5 , - 1.125 ], [ - 1.5 , - 1.25 ], [ 1 , 1.5 ], [ 1 , 1.75 ], [ 1 , 2 ], ... [ 4 , 1.25 ], [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ], ... [ 4 , 3.25 ], [ 4 , 3.5 ], [ 4 , 3.75 ], [ 4 , 4 ], ... ] >>> denstream = cluster . DenStream ( decaying_factor = 0.01 , ... beta = 0.5 , ... mu = 2.5 , ... epsilon = 0.5 , ... n_samples_init = 10 ) >>> for x , _ in stream . iter_array ( X ): ... denstream = denstream . learn_one ( x ) >>> denstream . predict_one ({ 0 : - 1 , 1 : - 2 }) 1 >>> denstream . predict_one ({ 0 : 5 , 1 : 4 }) 2 >>> denstream . predict_one ({ 0 : 1 , 1 : 1 }) 0 >>> denstream . n_clusters 3 Methods \u00b6 BufferItem clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number. References \u00b6 Feng et al (2006, pp 328-339). Density-Based Clustering over an Evolving Data Stream with Noise. In Proceedings of the Sixth SIAM International Conference on Data Mining, April 20\u201322, 2006, Bethesda, MD, USA. \u21a9 Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In KDD-96 Proceedings, AAAI. \u21a9","title":"DenStream"},{"location":"api/cluster/DenStream/#denstream","text":"DenStream DenStream 1 is a clustering algorithm for evolving data streams. DenStream can discover clusters with arbitrary shape and is robust against noise (outliers). \"Dense\" micro-clusters (named core-micro-clusters) summarise the clusters of arbitrary shape. A pruning strategy based on the concepts of potential and outlier micro-clusters guarantees the precision of the weights of the micro-clusters with limited memory. The algorithm is divided into two parts: Online micro-cluster maintenance (learning) For a new point p : Try to merge p into either the nearest p-micro-cluster (potential), o-micro-cluster (outlier), or create a new o-micro-cluster and insert it into the outlier buffer. For each T_p iterations, consider the weights of all potential and outlier micro-clusters. If their weights are smaller than a certain threshold (different for each type of micro-clusters), the micro-cluster is deleted. Offline generation of clusters on-demand (clustering) A variant of the DBSCAN algorithm 2 is used, such that all density-connected p-micro-clusters determine the final clusters. Moreover, in order for the algorithm to always be able to generate clusters, a certain number of points must be passed through the algorithm with a suitable streaming speed (number of points passed through within a unit time), indicated by n_samples_init and stream_speed .","title":"DenStream"},{"location":"api/cluster/DenStream/#parameters","text":"decaying_factor ( float ) \u2013 defaults to 0.25 Parameter that controls the importance of historical data to current cluster. Note that decaying_factor has to be different from 0 . beta ( float ) \u2013 defaults to 0.75 Parameter to determine the threshold of outlier relative to core micro-clusters. The value of beta must be within the range (0,1] . mu ( float ) \u2013 defaults to 2 Parameter to determine the threshold of outliers relative to core micro-cluster. As beta * mu must be greater than 1, mu must be within the range (1/beta, inf) . epsilon ( float ) \u2013 defaults to 0.02 Defines the epsilon neighborhood n_samples_init ( int ) \u2013 defaults to 1000 Number of points to to initiqalize the online process stream_speed ( int ) \u2013 defaults to 100 Number of points arrived in unit time","title":"Parameters"},{"location":"api/cluster/DenStream/#attributes","text":"n_clusters Number of clusters generated by the algorithm. clusters A set of final clusters of type MicroCluster , which means that these cluster include all the required information, including number of points, creation time, weight, (weighted) linear sum, (weighted) square sum, center and radius. p_micro_clusters The potential core-icro-clusters that are generated by the algorithm. When a generate cluster request arrives, these p-micro-clusters will go through a variant of the DBSCAN algorithm to determine the final clusters. o_micro_clusters The outlier micro-clusters.","title":"Attributes"},{"location":"api/cluster/DenStream/#examples","text":"The following example uses the default parameters of the algorithm to test its functionality. The set of evolving points X are designed so that clusters are easily identifiable. >>> from river import cluster >>> from river import stream >>> X = [ ... [ - 1 , - 0.5 ], [ - 1 , - 0.625 ], [ - 1 , - 0.75 ], [ - 1 , - 1 ], [ - 1 , - 1.125 ], ... [ - 1 , - 1.25 ], [ - 1.5 , - 0.5 ], [ - 1.5 , - 0.625 ], [ - 1.5 , - 0.75 ], [ - 1.5 , - 1 ], ... [ - 1.5 , - 1.125 ], [ - 1.5 , - 1.25 ], [ 1 , 1.5 ], [ 1 , 1.75 ], [ 1 , 2 ], ... [ 4 , 1.25 ], [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ], ... [ 4 , 3.25 ], [ 4 , 3.5 ], [ 4 , 3.75 ], [ 4 , 4 ], ... ] >>> denstream = cluster . DenStream ( decaying_factor = 0.01 , ... beta = 0.5 , ... mu = 2.5 , ... epsilon = 0.5 , ... n_samples_init = 10 ) >>> for x , _ in stream . iter_array ( X ): ... denstream = denstream . learn_one ( x ) >>> denstream . predict_one ({ 0 : - 1 , 1 : - 2 }) 1 >>> denstream . predict_one ({ 0 : 5 , 1 : 4 }) 2 >>> denstream . predict_one ({ 0 : 1 , 1 : 1 }) 0 >>> denstream . n_clusters 3","title":"Examples"},{"location":"api/cluster/DenStream/#methods","text":"BufferItem clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/DenStream/#references","text":"Feng et al (2006, pp 328-339). Density-Based Clustering over an Evolving Data Stream with Noise. In Proceedings of the Sixth SIAM International Conference on Data Mining, April 20\u201322, 2006, Bethesda, MD, USA. \u21a9 Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise. In KDD-96 Proceedings, AAAI. \u21a9","title":"References"},{"location":"api/cluster/KMeans/","text":"KMeans \u00b6 Incremental k-means. The most common way to implement batch k-means is to use Lloyd's algorithm, which consists in assigning all the data points to a set of cluster centers and then moving the centers accordingly. This requires multiple passes over the data and thus isn't applicable in a streaming setting. In this implementation we start by finding the cluster that is closest to the current observation. We then move the cluster's central position towards the new observation. The halflife parameter determines by how much to move the cluster toward the new observation. You will get better results if you scale your data appropriately. Parameters \u00b6 n_clusters \u2013 defaults to 5 Maximum number of clusters to assign. halflife \u2013 defaults to 0.5 Amount by which to move the cluster centers, a reasonable value if between 0 and 1. mu \u2013 defaults to 0 Mean of the normal distribution used to instantiate cluster positions. sigma \u2013 defaults to 1 Standard deviation of the normal distribution used to instantiate cluster positions. p \u2013 defaults to 2 Power parameter for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions. Attributes \u00b6 centers ( dict ) Central positions of each cluster. Examples \u00b6 In the following example the cluster assignments are exactly the same as when using sklearn 's batch implementation. However changing the halflife parameter will produce different outputs. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ - 4 , 2 ], ... [ - 4 , 4 ], ... [ - 4 , 0 ] ... ] >>> k_means = cluster . KMeans ( n_clusters = 2 , halflife = 0.1 , sigma = 3 , seed = 42 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... k_means = k_means . learn_one ( x ) ... print ( f ' { X [ i ] } is assigned to cluster { k_means . predict_one ( x ) } ' ) [ 1 , 2 ] is assigned to cluster 1 [ 1 , 4 ] is assigned to cluster 1 [ 1 , 0 ] is assigned to cluster 0 [ - 4 , 2 ] is assigned to cluster 1 [ - 4 , 4 ] is assigned to cluster 1 [ - 4 , 0 ] is assigned to cluster 0 >>> k_means . predict_one ({ 0 : 0 , 1 : 0 }) 0 >>> k_means . predict_one ({ 0 : 4 , 1 : 4 }) 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) Returns Clusterer : self learn_predict_one Equivalent to k_means.learn_one(x).predict_one(x) , but faster. Parameters x predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number. References \u00b6 Sequential k-Means Clustering \u21a9 Sculley, D., 2010, April. Web-scale k-means clustering. In Proceedings of the 19th international conference on World wide web (pp. 1177-1178 \u21a9","title":"KMeans"},{"location":"api/cluster/KMeans/#kmeans","text":"Incremental k-means. The most common way to implement batch k-means is to use Lloyd's algorithm, which consists in assigning all the data points to a set of cluster centers and then moving the centers accordingly. This requires multiple passes over the data and thus isn't applicable in a streaming setting. In this implementation we start by finding the cluster that is closest to the current observation. We then move the cluster's central position towards the new observation. The halflife parameter determines by how much to move the cluster toward the new observation. You will get better results if you scale your data appropriately.","title":"KMeans"},{"location":"api/cluster/KMeans/#parameters","text":"n_clusters \u2013 defaults to 5 Maximum number of clusters to assign. halflife \u2013 defaults to 0.5 Amount by which to move the cluster centers, a reasonable value if between 0 and 1. mu \u2013 defaults to 0 Mean of the normal distribution used to instantiate cluster positions. sigma \u2013 defaults to 1 Standard deviation of the normal distribution used to instantiate cluster positions. p \u2013 defaults to 2 Power parameter for the Minkowski metric. When p=1 , this corresponds to the Manhattan distance, while p=2 corresponds to the Euclidean distance. seed ( int ) \u2013 defaults to None Random seed used for generating initial centroid positions.","title":"Parameters"},{"location":"api/cluster/KMeans/#attributes","text":"centers ( dict ) Central positions of each cluster.","title":"Attributes"},{"location":"api/cluster/KMeans/#examples","text":"In the following example the cluster assignments are exactly the same as when using sklearn 's batch implementation. However changing the halflife parameter will produce different outputs. >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ - 4 , 2 ], ... [ - 4 , 4 ], ... [ - 4 , 0 ] ... ] >>> k_means = cluster . KMeans ( n_clusters = 2 , halflife = 0.1 , sigma = 3 , seed = 42 ) >>> for i , ( x , _ ) in enumerate ( stream . iter_array ( X )): ... k_means = k_means . learn_one ( x ) ... print ( f ' { X [ i ] } is assigned to cluster { k_means . predict_one ( x ) } ' ) [ 1 , 2 ] is assigned to cluster 1 [ 1 , 4 ] is assigned to cluster 1 [ 1 , 0 ] is assigned to cluster 0 [ - 4 , 2 ] is assigned to cluster 1 [ - 4 , 4 ] is assigned to cluster 1 [ - 4 , 0 ] is assigned to cluster 0 >>> k_means . predict_one ({ 0 : 0 , 1 : 0 }) 0 >>> k_means . predict_one ({ 0 : 4 , 1 : 4 }) 1","title":"Examples"},{"location":"api/cluster/KMeans/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) Returns Clusterer : self learn_predict_one Equivalent to k_means.learn_one(x).predict_one(x) , but faster. Parameters x predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/KMeans/#references","text":"Sequential k-Means Clustering \u21a9 Sculley, D., 2010, April. Web-scale k-means clustering. In Proceedings of the 19th international conference on World wide web (pp. 1177-1178 \u21a9","title":"References"},{"location":"api/cluster/STREAMKMeans/","text":"STREAMKMeans \u00b6 STREAMKMeans STREAMKMeans is an alternative version of the original algorithm STREAMLSEARCH proposed by O'Callaghan et al. 1 by replacing the k-Medians using LSEARCH by the classical KMeans algorithm. However, instead of using the traditional KMeans that requires a total reclustering after each time the temporary chunk of data points is full, the implementation of this algorithm in River uses the increamental KMeans . This allows the algorithm to update KMeans without the need of re-initialization, saving a substantial amount of computing resources. The algorithm is constructed as follows. To begin, the algorithm will be initialized with an incremental KMeans algorithm with the same number of centers as required. For a new point p : If the size of chunk is less than the maximum size allowed, add the new point to the temporary chunk. When the size of chunk reaches the maximum value size allowed A new incremental KMeans algorithm will be initiated. This algorithm will run through all points in the temporary chunk. The centers of this new algorithm will be passed through the originally initialized KMeans to update the centers of the algorithm All points will be deleted from the temporary chunk to continue adding new points later. When a prediction request arrives, the centers of the algorithm will be exactly the same as the centers of the original KMeans at the time of retrieval. Parameters \u00b6 chunk_size \u2013 defaults to 10 Maximum size allowed for the temporary data chunk. n_clusters \u2013 defaults to 2 Number of clusters generated by the algorithm. kwargs Other parameters passed to the incremental kmeans at cluster.KMeans . Attributes \u00b6 centers Cluster centers generated from running the incremental KMeans algorithm through centers of each chunk. Examples \u00b6 >>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 0.5 ], [ 1 , 0.625 ], [ 1 , 0.75 ], [ 1 , 1.125 ], [ 1 , 1.5 ], [ 1 , 1.75 ], ... [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ], [ 4 , 3.25 ], [ 4 , 3.5 ] ... ] >>> streamkmeans = cluster . STREAMKMeans ( chunk_size = 3 , n_clusters = 2 , halflife = 0.5 , sigma = 1.5 , seed = 0 ) >>> for x , _ in stream . iter_array ( X ): ... streamkmeans = streamkmeans . learn_one ( x ) >>> streamkmeans . predict_one ({ 0 : 1 , 1 : 0 }) 0 >>> streamkmeans . predict_one ({ 0 : 5 , 1 : 2 }) 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number. References \u00b6 O'Callaghan et al. (2002). Streaming-data algorithms for high-quality clustering. In Proceedings 18th International Conference on Data Engineering, Feb 26 - March 1, San Jose, CA, USA. DOI: 10.1109/ICDE.2002.994785. \u21a9","title":"STREAMKMeans"},{"location":"api/cluster/STREAMKMeans/#streamkmeans","text":"STREAMKMeans STREAMKMeans is an alternative version of the original algorithm STREAMLSEARCH proposed by O'Callaghan et al. 1 by replacing the k-Medians using LSEARCH by the classical KMeans algorithm. However, instead of using the traditional KMeans that requires a total reclustering after each time the temporary chunk of data points is full, the implementation of this algorithm in River uses the increamental KMeans . This allows the algorithm to update KMeans without the need of re-initialization, saving a substantial amount of computing resources. The algorithm is constructed as follows. To begin, the algorithm will be initialized with an incremental KMeans algorithm with the same number of centers as required. For a new point p : If the size of chunk is less than the maximum size allowed, add the new point to the temporary chunk. When the size of chunk reaches the maximum value size allowed A new incremental KMeans algorithm will be initiated. This algorithm will run through all points in the temporary chunk. The centers of this new algorithm will be passed through the originally initialized KMeans to update the centers of the algorithm All points will be deleted from the temporary chunk to continue adding new points later. When a prediction request arrives, the centers of the algorithm will be exactly the same as the centers of the original KMeans at the time of retrieval.","title":"STREAMKMeans"},{"location":"api/cluster/STREAMKMeans/#parameters","text":"chunk_size \u2013 defaults to 10 Maximum size allowed for the temporary data chunk. n_clusters \u2013 defaults to 2 Number of clusters generated by the algorithm. kwargs Other parameters passed to the incremental kmeans at cluster.KMeans .","title":"Parameters"},{"location":"api/cluster/STREAMKMeans/#attributes","text":"centers Cluster centers generated from running the incremental KMeans algorithm through centers of each chunk.","title":"Attributes"},{"location":"api/cluster/STREAMKMeans/#examples","text":">>> from river import cluster >>> from river import stream >>> X = [ ... [ 1 , 0.5 ], [ 1 , 0.625 ], [ 1 , 0.75 ], [ 1 , 1.125 ], [ 1 , 1.5 ], [ 1 , 1.75 ], ... [ 4 , 1.5 ], [ 4 , 2.25 ], [ 4 , 2.5 ], [ 4 , 3 ], [ 4 , 3.25 ], [ 4 , 3.5 ] ... ] >>> streamkmeans = cluster . STREAMKMeans ( chunk_size = 3 , n_clusters = 2 , halflife = 0.5 , sigma = 1.5 , seed = 0 ) >>> for x , _ in stream . iter_array ( X ): ... streamkmeans = streamkmeans . learn_one ( x ) >>> streamkmeans . predict_one ({ 0 : 1 , 1 : 0 }) 0 >>> streamkmeans . predict_one ({ 0 : 5 , 1 : 2 }) 1","title":"Examples"},{"location":"api/cluster/STREAMKMeans/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x . Parameters x ( dict ) sample_weight ( int ) \u2013 defaults to None Returns Clusterer : self predict_one Predicts the cluster number for a set of features x . Parameters x ( dict ) sample_weight \u2013 defaults to None Returns int : A cluster number.","title":"Methods"},{"location":"api/cluster/STREAMKMeans/#references","text":"O'Callaghan et al. (2002). Streaming-data algorithms for high-quality clustering. In Proceedings 18th International Conference on Data Engineering, Feb 26 - March 1, San Jose, CA, USA. DOI: 10.1109/ICDE.2002.994785. \u21a9","title":"References"},{"location":"api/compat/River2SKLClassifier/","text":"River2SKLClassifier \u00b6 Compatibility layer from River to scikit-learn for classification. Parameters \u00b6 river_estimator ( base.Classifier ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y classes \u2013 defaults to None Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . predict_proba Predicts the target probability of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . score Return the mean accuracy on the given test data and labels. In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"River2SKLClassifier"},{"location":"api/compat/River2SKLClassifier/#river2sklclassifier","text":"Compatibility layer from River to scikit-learn for classification.","title":"River2SKLClassifier"},{"location":"api/compat/River2SKLClassifier/#parameters","text":"river_estimator ( base.Classifier )","title":"Parameters"},{"location":"api/compat/River2SKLClassifier/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y classes \u2013 defaults to None Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . predict_proba Predicts the target probability of an entire dataset contained in memory. Parameters X Returns Predicted target values for each row of X . score Return the mean accuracy on the given test data and labels. In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"Methods"},{"location":"api/compat/River2SKLClusterer/","text":"River2SKLClusterer \u00b6 Compatibility layer from River to scikit-learn for clustering. Parameters \u00b6 river_estimator ( base.Clusterer ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_predict Perform clustering on X and returns cluster labels. Parameters X y \u2013 defaults to None Returns ndarray of shape (n_samples,), dtype=np.int64 get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output. set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"River2SKLClusterer"},{"location":"api/compat/River2SKLClusterer/#river2sklclusterer","text":"Compatibility layer from River to scikit-learn for clustering.","title":"River2SKLClusterer"},{"location":"api/compat/River2SKLClusterer/#parameters","text":"river_estimator ( base.Clusterer )","title":"Parameters"},{"location":"api/compat/River2SKLClusterer/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_predict Perform clustering on X and returns cluster labels. Parameters X y \u2013 defaults to None Returns ndarray of shape (n_samples,), dtype=np.int64 get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output. set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"Methods"},{"location":"api/compat/River2SKLRegressor/","text":"River2SKLRegressor \u00b6 Compatibility layer from River to scikit-learn for regression. Parameters \u00b6 river_estimator ( base.Regressor ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns ndarray : Predicted target values for each row of X . score Return the coefficient of determination of the prediction. The coefficient of determination :math: R^2 is defined as :math: (1 - \\frac{u}{v}) , where :math: u is the residual sum of squares ((y_true - y_pred)** 2).sum() and :math: v is the total sum of squares ((y_true - y_true.mean()) ** 2).sum() . The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y , disregarding the input features, would get a :math: R^2 score of 0.0. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"River2SKLRegressor"},{"location":"api/compat/River2SKLRegressor/#river2sklregressor","text":"Compatibility layer from River to scikit-learn for regression.","title":"River2SKLRegressor"},{"location":"api/compat/River2SKLRegressor/#parameters","text":"river_estimator ( base.Regressor )","title":"Parameters"},{"location":"api/compat/River2SKLRegressor/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y Returns self get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y Returns self predict Predicts the target of an entire dataset contained in memory. Parameters X Returns ndarray : Predicted target values for each row of X . score Return the coefficient of determination of the prediction. The coefficient of determination :math: R^2 is defined as :math: (1 - \\frac{u}{v}) , where :math: u is the residual sum of squares ((y_true - y_pred)** 2).sum() and :math: v is the total sum of squares ((y_true - y_true.mean()) ** 2).sum() . The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y , disregarding the input features, would get a :math: R^2 score of 0.0. Parameters X y sample_weight \u2013 defaults to None Returns float set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance","title":"Methods"},{"location":"api/compat/River2SKLTransformer/","text":"River2SKLTransformer \u00b6 Compatibility layer from River to scikit-learn for transformation. Parameters \u00b6 river_estimator ( base.Transformer ) Methods \u00b6 fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_transform Fit to data, then transform it. Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X . Parameters X y \u2013 defaults to None fit_params Returns ndarray array of shape (n_samples, n_features_new) get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y \u2013 defaults to None Returns self set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance transform Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output.","title":"River2SKLTransformer"},{"location":"api/compat/River2SKLTransformer/#river2skltransformer","text":"Compatibility layer from River to scikit-learn for transformation.","title":"River2SKLTransformer"},{"location":"api/compat/River2SKLTransformer/#parameters","text":"river_estimator ( base.Transformer )","title":"Parameters"},{"location":"api/compat/River2SKLTransformer/#methods","text":"fit Fits to an entire dataset contained in memory. Parameters X y \u2013 defaults to None Returns self fit_transform Fit to data, then transform it. Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X . Parameters X y \u2013 defaults to None fit_params Returns ndarray array of shape (n_samples, n_features_new) get_params Get parameters for this estimator. Parameters deep \u2013 defaults to True Returns dict partial_fit Fits incrementally on a portion of a dataset. Parameters X y \u2013 defaults to None Returns self set_params Set the parameters of this estimator. The method works on simple estimators as well as on nested objects (such as :class: ~sklearn.pipeline.Pipeline ). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object. Parameters params Returns estimator instance transform Predicts the target of an entire dataset contained in memory. Parameters X Returns Transformed output.","title":"Methods"},{"location":"api/compat/SKL2RiverClassifier/","text":"SKL2RiverClassifier \u00b6 Compatibility layer from scikit-learn to River for classification. Parameters \u00b6 estimator ( sklearn.base.ClassifierMixin ) A scikit-learn regressor which has a partial_fit method. classes ( list ) Examples \u00b6 >>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_breast_cancer (), ... shuffle = True , ... seed = 42 ... ) >>> model = preprocessing . StandardScaler () >>> model |= compat . convert_sklearn_to_river ( ... estimator = linear_model . SGDClassifier ( ... loss = 'log_loss' , ... eta0 = 0.01 , ... learning_rate = 'constant' ... ), ... classes = [ False , True ] ... ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.199554 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"SKL2RiverClassifier"},{"location":"api/compat/SKL2RiverClassifier/#skl2riverclassifier","text":"Compatibility layer from scikit-learn to River for classification.","title":"SKL2RiverClassifier"},{"location":"api/compat/SKL2RiverClassifier/#parameters","text":"estimator ( sklearn.base.ClassifierMixin ) A scikit-learn regressor which has a partial_fit method. classes ( list )","title":"Parameters"},{"location":"api/compat/SKL2RiverClassifier/#examples","text":">>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_breast_cancer (), ... shuffle = True , ... seed = 42 ... ) >>> model = preprocessing . StandardScaler () >>> model |= compat . convert_sklearn_to_river ( ... estimator = linear_model . SGDClassifier ( ... loss = 'log_loss' , ... eta0 = 0.01 , ... learning_rate = 'constant' ... ), ... classes = [ False , True ] ... ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.199554","title":"Examples"},{"location":"api/compat/SKL2RiverClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_many predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/compat/SKL2RiverRegressor/","text":"SKL2RiverRegressor \u00b6 Compatibility layer from scikit-learn to River for regression. Parameters \u00b6 estimator ( sklearn.base.BaseEstimator ) A scikit-learn transformer which has a partial_fit method. Examples \u00b6 >>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_diabetes (), ... shuffle = True , ... seed = 42 ... ) >>> scaler = preprocessing . StandardScaler () >>> sgd_reg = compat . convert_sklearn_to_river ( linear_model . SGDRegressor ()) >>> model = scaler | sgd_reg >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 84.519485 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_many predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"SKL2RiverRegressor"},{"location":"api/compat/SKL2RiverRegressor/#skl2riverregressor","text":"Compatibility layer from scikit-learn to River for regression.","title":"SKL2RiverRegressor"},{"location":"api/compat/SKL2RiverRegressor/#parameters","text":"estimator ( sklearn.base.BaseEstimator ) A scikit-learn transformer which has a partial_fit method.","title":"Parameters"},{"location":"api/compat/SKL2RiverRegressor/#examples","text":">>> from river import compat >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import stream >>> from sklearn import linear_model >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_diabetes (), ... shuffle = True , ... seed = 42 ... ) >>> scaler = preprocessing . StandardScaler () >>> sgd_reg = compat . convert_sklearn_to_river ( linear_model . SGDRegressor ()) >>> model = scaler | sgd_reg >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 84.519485","title":"Examples"},{"location":"api/compat/SKL2RiverRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_many predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/compat/convert-river-to-sklearn/","text":"convert_river_to_sklearn \u00b6 Wraps a river estimator to make it compatible with scikit-learn. Parameters \u00b6 estimator ( base.Estimator )","title":"convert_river_to_sklearn"},{"location":"api/compat/convert-river-to-sklearn/#convert_river_to_sklearn","text":"Wraps a river estimator to make it compatible with scikit-learn.","title":"convert_river_to_sklearn"},{"location":"api/compat/convert-river-to-sklearn/#parameters","text":"estimator ( base.Estimator )","title":"Parameters"},{"location":"api/compat/convert-sklearn-to-river/","text":"convert_sklearn_to_river \u00b6 Wraps a scikit-learn estimator to make it compatible with river. Parameters \u00b6 estimator ( sklearn.base.BaseEstimator ) classes ( list ) \u2013 defaults to None Class names necessary for classifiers.","title":"convert_sklearn_to_river"},{"location":"api/compat/convert-sklearn-to-river/#convert_sklearn_to_river","text":"Wraps a scikit-learn estimator to make it compatible with river.","title":"convert_sklearn_to_river"},{"location":"api/compat/convert-sklearn-to-river/#parameters","text":"estimator ( sklearn.base.BaseEstimator ) classes ( list ) \u2013 defaults to None Class names necessary for classifiers.","title":"Parameters"},{"location":"api/compose/Discard/","text":"Discard \u00b6 Removes features. This can be used in a pipeline when you want to remove certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input. Parameters \u00b6 keys ( Tuple[Hashable] ) Key(s) to discard. Examples \u00b6 >>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Discard ( 'a' , 'b' ) . transform_one ( x ) { 'c' : 13 } You can chain a discarder with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Discard ( 'shop' , 'country' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Discard"},{"location":"api/compose/Discard/#discard","text":"Removes features. This can be used in a pipeline when you want to remove certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input.","title":"Discard"},{"location":"api/compose/Discard/#parameters","text":"keys ( Tuple[Hashable] ) Key(s) to discard.","title":"Parameters"},{"location":"api/compose/Discard/#examples","text":">>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Discard ( 'a' , 'b' ) . transform_one ( x ) { 'c' : 13 } You can chain a discarder with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Discard ( 'shop' , 'country' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 }","title":"Examples"},{"location":"api/compose/Discard/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/FuncTransformer/","text":"FuncTransformer \u00b6 Wraps a function to make it usable in a pipeline. There is often a need to apply an arbitrary transformation to a set of features. For instance, this could involve parsing a date and then extracting the hour from said date. If you're processing a stream of data, then you can do this yourself by calling the necessary code at your leisure. On the other hand, if you want to do this as part of a pipeline, then you need to follow a simple convention. To use a function as part of a pipeline, take as input a dict of features and output a dict . Once you have initialized this class with your function, then you can use it like you would use any other (unsupervised) transformer. It is up to you if you want your function to be pure or not. By pure we refer to a function that doesn't modify its input. However, we recommend writing pure functions because this reduces the chances of inserting bugs into your pipeline. Parameters \u00b6 func ( Callable[[dict], dict] ) A function that takes as input a dict and outputs a dict . Examples \u00b6 >>> from pprint import pprint >>> import datetime as dt >>> from river import compose >>> x = { 'date' : '2019-02-14' } >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... x [ 'is_weekend' ] = date . day in ( 5 , 6 ) ... x [ 'hour' ] = date . hour ... return x >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } The above example is not pure because it modifies the input. The following example is pure and produces the same output: >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'hour' : 0 , 'is_weekend' : False } The previous example doesn't include the date feature because it returns a new dict . However, a common usecase is to add a feature to an existing set of features. You can do this in a pure way by unpacking the input dict into the output dict : >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour , ** x } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } You can add FuncTransformer to a pipeline just like you would with any other transformer. >>> from river import naive_bayes >>> pipeline = compose . FuncTransformer ( parse_date ) | naive_bayes . MultinomialNB () >>> pipeline Pipeline ( FuncTransformer ( func = \"parse_date\" ), MultinomialNB ( alpha = 1. ) ) If you provide a function without wrapping it, then the pipeline will do it for you: >>> pipeline = parse_date | naive_bayes . MultinomialNB () Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"FuncTransformer"},{"location":"api/compose/FuncTransformer/#functransformer","text":"Wraps a function to make it usable in a pipeline. There is often a need to apply an arbitrary transformation to a set of features. For instance, this could involve parsing a date and then extracting the hour from said date. If you're processing a stream of data, then you can do this yourself by calling the necessary code at your leisure. On the other hand, if you want to do this as part of a pipeline, then you need to follow a simple convention. To use a function as part of a pipeline, take as input a dict of features and output a dict . Once you have initialized this class with your function, then you can use it like you would use any other (unsupervised) transformer. It is up to you if you want your function to be pure or not. By pure we refer to a function that doesn't modify its input. However, we recommend writing pure functions because this reduces the chances of inserting bugs into your pipeline.","title":"FuncTransformer"},{"location":"api/compose/FuncTransformer/#parameters","text":"func ( Callable[[dict], dict] ) A function that takes as input a dict and outputs a dict .","title":"Parameters"},{"location":"api/compose/FuncTransformer/#examples","text":">>> from pprint import pprint >>> import datetime as dt >>> from river import compose >>> x = { 'date' : '2019-02-14' } >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... x [ 'is_weekend' ] = date . day in ( 5 , 6 ) ... x [ 'hour' ] = date . hour ... return x >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } The above example is not pure because it modifies the input. The following example is pure and produces the same output: >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'hour' : 0 , 'is_weekend' : False } The previous example doesn't include the date feature because it returns a new dict . However, a common usecase is to add a feature to an existing set of features. You can do this in a pure way by unpacking the input dict into the output dict : >>> def parse_date ( x ): ... date = dt . datetime . strptime ( x [ 'date' ], '%Y-%m- %d ' ) ... return { 'is_weekend' : date . day in ( 5 , 6 ), 'hour' : date . hour , ** x } >>> t = compose . FuncTransformer ( parse_date ) >>> pprint ( t . transform_one ( x )) { 'date' : '2019-02-14' , 'hour' : 0 , 'is_weekend' : False } You can add FuncTransformer to a pipeline just like you would with any other transformer. >>> from river import naive_bayes >>> pipeline = compose . FuncTransformer ( parse_date ) | naive_bayes . MultinomialNB () >>> pipeline Pipeline ( FuncTransformer ( func = \"parse_date\" ), MultinomialNB ( alpha = 1. ) ) If you provide a function without wrapping it, then the pipeline will do it for you: >>> pipeline = parse_date | naive_bayes . MultinomialNB ()","title":"Examples"},{"location":"api/compose/FuncTransformer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Grouper/","text":"Grouper \u00b6 Applies a transformer within different groups. This transformer allows you to split your data into groups and apply a transformer within each group. This happens in a streaming manner, which means that the groups are discovered online. A separate copy of the provided transformer is made whenever a new group appears. The groups are defined according to one or more keys. Parameters \u00b6 transformer ( base.Transformer ) by ( Union[Hashable, List[Hashable]] ) The field on which to group the data. This can either by a single value, or a list of values. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Grouper"},{"location":"api/compose/Grouper/#grouper","text":"Applies a transformer within different groups. This transformer allows you to split your data into groups and apply a transformer within each group. This happens in a streaming manner, which means that the groups are discovered online. A separate copy of the provided transformer is made whenever a new group appears. The groups are defined according to one or more keys.","title":"Grouper"},{"location":"api/compose/Grouper/#parameters","text":"transformer ( base.Transformer ) by ( Union[Hashable, List[Hashable]] ) The field on which to group the data. This can either by a single value, or a list of values.","title":"Parameters"},{"location":"api/compose/Grouper/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Pipeline/","text":"Pipeline \u00b6 A pipeline of estimators. Pipelines allow you to chain different steps into a sequence. Typically, when doing supervised learning, a pipeline contains one ore more transformation steps, whilst it's is a regressor or a classifier. It is highly recommended to use pipelines with river . Indeed, in an online learning setting, it is very practical to have a model defined as a single object. Take a look at the user guide for further information and practical examples. One special thing to take notice to is the way transformers are handled. It is usual to predict something for a sample and wait for the ground truth to arrive. In such a scenario, the features are seen before the ground truth arrives. Therefore, the unsupervised parts of the pipeline are updated when predict_one and predict_proba_one are called. Usually the unsupervised parts of the pipeline are all the steps that precede the final step, which is a supervised model. However, some transformers are supervised and are therefore also updated during calls to learn_one . Parameters \u00b6 steps Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided. Examples \u00b6 The recommended way to declare a pipeline is to use the | operator. The latter allows you to chain estimators in a very terse manner: >>> from river import linear_model >>> from river import preprocessing >>> scaler = preprocessing . StandardScaler () >>> log_reg = linear_model . LinearRegression () >>> model = scaler | log_reg This results in a pipeline that stores each step inside a dictionary. >>> model Pipeline ( StandardScaler ( with_std = True ), LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) ) You can access parts of a pipeline in the same manner as a dictionary: >>> model [ 'LinearRegression' ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) Note that you can also declare a pipeline by using the compose.Pipeline constructor method, which is slightly more verbose: >>> from river import compose >>> model = compose . Pipeline ( scaler , log_reg ) By using a compose.TransformerUnion , you can define complex pipelines that apply different steps to different parts of the data. For instance, we can extract word counts from text data, and extract polynomial features from numeric data. >>> from river import feature_extraction as fx >>> tfidf = fx . TFIDF ( 'text' ) >>> counts = fx . BagOfWords ( 'text' ) >>> text_part = compose . Select ( 'text' ) | ( tfidf + counts ) >>> num_part = compose . Select ( 'a' , 'b' ) | fx . PolynomialExtender () >>> model = text_part + num_part >>> model |= preprocessing . StandardScaler () >>> model |= linear_model . LinearRegression () The following shows an example of using debug_one to visualize how the information flows and changes throughout the pipeline. >>> from river import compose >>> from river import naive_bayes >>> dataset = [ ... ( 'A positive comment' , True ), ... ( 'A negative comment' , False ), ... ( 'A happy comment' , True ), ... ( 'A lovely comment' , True ), ... ( 'A harsh comment' , False ) ... ] >>> tfidf = fx . TFIDF () | compose . Prefixer ( 'tfidf_' ) >>> counts = fx . BagOfWords () | compose . Prefixer ( 'count_' ) >>> mnb = naive_bayes . MultinomialNB () >>> model = ( tfidf + counts ) | mnb >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> x = dataset [ 0 ][ 0 ] >>> report = model . debug_one ( dataset [ 0 ][ 0 ]) >>> print ( report ) 0. Input -------- A positive comment 1. Transformer union -------------------- 1.0 TFIDF | Prefixer -------------------- tfidf_comment : 0.47606 ( float ) tfidf_positive : 0.87942 ( float ) 1.1 BagOfWords | Prefixer ------------------------- count_comment : 1 ( int ) count_positive : 1 ( int ) count_comment : 1 ( int ) count_positive : 1 ( int ) tfidf_comment : 0.50854 ( float ) tfidf_positive : 0.86104 ( float ) 2. MultinomialNB ---------------- False : 0.19313 True : 0.80687 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Displays the state of a set of features as it goes through the pipeline. Parameters x ( dict ) show_types \u2013 defaults to True n_decimals \u2013 defaults to 5 forecast Return a forecast. Only works if each estimator has a transform_one method and the final estimator has a forecast method. This is the case of time series models from the time_series module. Parameters horizon ( int ) xs ( List[dict] ) \u2013 defaults to None learn_many Fit to a mini-batch. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None params learn_one Fit to a single instance. Parameters x ( dict ) y \u2013 defaults to None params predict_many predict_one Call transform_one on the first steps and predict_one on the last step. Parameters x ( dict ) params predict_proba_many predict_proba_one Call transform_one on the first steps and predict_proba_one on the last step. Parameters x ( dict ) params score_one Call transform_one on the first steps and score_one on the last step. Parameters x ( dict ) params transform_many Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters X ( pandas.core.frame.DataFrame ) transform_one Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters x ( dict ) params","title":"Pipeline"},{"location":"api/compose/Pipeline/#pipeline","text":"A pipeline of estimators. Pipelines allow you to chain different steps into a sequence. Typically, when doing supervised learning, a pipeline contains one ore more transformation steps, whilst it's is a regressor or a classifier. It is highly recommended to use pipelines with river . Indeed, in an online learning setting, it is very practical to have a model defined as a single object. Take a look at the user guide for further information and practical examples. One special thing to take notice to is the way transformers are handled. It is usual to predict something for a sample and wait for the ground truth to arrive. In such a scenario, the features are seen before the ground truth arrives. Therefore, the unsupervised parts of the pipeline are updated when predict_one and predict_proba_one are called. Usually the unsupervised parts of the pipeline are all the steps that precede the final step, which is a supervised model. However, some transformers are supervised and are therefore also updated during calls to learn_one .","title":"Pipeline"},{"location":"api/compose/Pipeline/#parameters","text":"steps Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.","title":"Parameters"},{"location":"api/compose/Pipeline/#examples","text":"The recommended way to declare a pipeline is to use the | operator. The latter allows you to chain estimators in a very terse manner: >>> from river import linear_model >>> from river import preprocessing >>> scaler = preprocessing . StandardScaler () >>> log_reg = linear_model . LinearRegression () >>> model = scaler | log_reg This results in a pipeline that stores each step inside a dictionary. >>> model Pipeline ( StandardScaler ( with_std = True ), LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) ) You can access parts of a pipeline in the same manner as a dictionary: >>> model [ 'LinearRegression' ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) Note that you can also declare a pipeline by using the compose.Pipeline constructor method, which is slightly more verbose: >>> from river import compose >>> model = compose . Pipeline ( scaler , log_reg ) By using a compose.TransformerUnion , you can define complex pipelines that apply different steps to different parts of the data. For instance, we can extract word counts from text data, and extract polynomial features from numeric data. >>> from river import feature_extraction as fx >>> tfidf = fx . TFIDF ( 'text' ) >>> counts = fx . BagOfWords ( 'text' ) >>> text_part = compose . Select ( 'text' ) | ( tfidf + counts ) >>> num_part = compose . Select ( 'a' , 'b' ) | fx . PolynomialExtender () >>> model = text_part + num_part >>> model |= preprocessing . StandardScaler () >>> model |= linear_model . LinearRegression () The following shows an example of using debug_one to visualize how the information flows and changes throughout the pipeline. >>> from river import compose >>> from river import naive_bayes >>> dataset = [ ... ( 'A positive comment' , True ), ... ( 'A negative comment' , False ), ... ( 'A happy comment' , True ), ... ( 'A lovely comment' , True ), ... ( 'A harsh comment' , False ) ... ] >>> tfidf = fx . TFIDF () | compose . Prefixer ( 'tfidf_' ) >>> counts = fx . BagOfWords () | compose . Prefixer ( 'count_' ) >>> mnb = naive_bayes . MultinomialNB () >>> model = ( tfidf + counts ) | mnb >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> x = dataset [ 0 ][ 0 ] >>> report = model . debug_one ( dataset [ 0 ][ 0 ]) >>> print ( report ) 0. Input -------- A positive comment 1. Transformer union -------------------- 1.0 TFIDF | Prefixer -------------------- tfidf_comment : 0.47606 ( float ) tfidf_positive : 0.87942 ( float ) 1.1 BagOfWords | Prefixer ------------------------- count_comment : 1 ( int ) count_positive : 1 ( int ) count_comment : 1 ( int ) count_positive : 1 ( int ) tfidf_comment : 0.50854 ( float ) tfidf_positive : 0.86104 ( float ) 2. MultinomialNB ---------------- False : 0.19313 True : 0.80687","title":"Examples"},{"location":"api/compose/Pipeline/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Displays the state of a set of features as it goes through the pipeline. Parameters x ( dict ) show_types \u2013 defaults to True n_decimals \u2013 defaults to 5 forecast Return a forecast. Only works if each estimator has a transform_one method and the final estimator has a forecast method. This is the case of time series models from the time_series module. Parameters horizon ( int ) xs ( List[dict] ) \u2013 defaults to None learn_many Fit to a mini-batch. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None params learn_one Fit to a single instance. Parameters x ( dict ) y \u2013 defaults to None params predict_many predict_one Call transform_one on the first steps and predict_one on the last step. Parameters x ( dict ) params predict_proba_many predict_proba_one Call transform_one on the first steps and predict_proba_one on the last step. Parameters x ( dict ) params score_one Call transform_one on the first steps and score_one on the last step. Parameters x ( dict ) params transform_many Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters X ( pandas.core.frame.DataFrame ) transform_one Apply each transformer in the pipeline to some features. The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers. Parameters x ( dict ) params","title":"Methods"},{"location":"api/compose/Prefixer/","text":"Prefixer \u00b6 Prepends a prefix on features names. Parameters \u00b6 prefix ( str ) Examples \u00b6 >>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Prefixer ( 'prefix_' ) . transform_one ( x ) { 'prefix_a' : 42 , 'prefix_b' : 12 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Prefixer"},{"location":"api/compose/Prefixer/#prefixer","text":"Prepends a prefix on features names.","title":"Prefixer"},{"location":"api/compose/Prefixer/#parameters","text":"prefix ( str )","title":"Parameters"},{"location":"api/compose/Prefixer/#examples","text":">>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Prefixer ( 'prefix_' ) . transform_one ( x ) { 'prefix_a' : 42 , 'prefix_b' : 12 }","title":"Examples"},{"location":"api/compose/Prefixer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Renamer/","text":"Renamer \u00b6 Renames features following substitution rules. Parameters \u00b6 mapping ( Dict[str, str] ) Dictionnary describing substitution rules. Keys in mapping that are not a feature's name are silently ignored. Examples \u00b6 >>> from river import compose >>> mapping = { 'a' : 'v' , 'c' : 'o' } >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Renamer ( mapping ) . transform_one ( x ) { 'b' : 12 , 'v' : 42 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Renamer"},{"location":"api/compose/Renamer/#renamer","text":"Renames features following substitution rules.","title":"Renamer"},{"location":"api/compose/Renamer/#parameters","text":"mapping ( Dict[str, str] ) Dictionnary describing substitution rules. Keys in mapping that are not a feature's name are silently ignored.","title":"Parameters"},{"location":"api/compose/Renamer/#examples","text":">>> from river import compose >>> mapping = { 'a' : 'v' , 'c' : 'o' } >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Renamer ( mapping ) . transform_one ( x ) { 'b' : 12 , 'v' : 42 }","title":"Examples"},{"location":"api/compose/Renamer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Select/","text":"Select \u00b6 Selects features. This can be used in a pipeline when you want to select certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of filtering the specified keys from the input. Parameters \u00b6 keys ( Tuple[Hashable] ) Key(s) to keep. Examples \u00b6 >>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Select ( 'c' ) . transform_one ( x ) { 'c' : 13 } You can chain a selector with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Select ( 'sales' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 } This transformer also supports mini-batch processing: >>> import random >>> from river import compose >>> random . seed ( 42 ) >>> X = [{ \"x_1\" : random . uniform ( 8 , 12 ), \"x_2\" : random . uniform ( 8 , 12 )} for _ in range ( 6 )] >>> for x in X : ... print ( x ) { 'x_1' : 10.557707193831535 , 'x_2' : 8.100043020890668 } { 'x_1' : 9.100117273476478 , 'x_2' : 8.892842952595291 } { 'x_1' : 10.94588485665605 , 'x_2' : 10.706797949691644 } { 'x_1' : 11.568718270819382 , 'x_2' : 8.347755330517664 } { 'x_1' : 9.687687278741082 , 'x_2' : 8.119188877752281 } { 'x_1' : 8.874551899214413 , 'x_2' : 10.021421152413449 } >>> import pandas as pd >>> X = pd . DataFrame . from_dict ( X ) You can then call transform_many to transform a mini-batch of features: >>> compose . Select ( 'x_2' ) . transform_many ( X ) x_2 0 8.100043 1 8.892843 2 10.706798 3 8.347755 4 8.119189 5 10.021421 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. A lot of transformers don't actually have to do anything during the learn_many step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_many can override this method. Parameters X ( pandas.core.frame.DataFrame ) kwargs Returns Transformer : self learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_many Transform a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A new DataFrame. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Select"},{"location":"api/compose/Select/#select","text":"Selects features. This can be used in a pipeline when you want to select certain features. The transform_one method is pure, and therefore returns a fresh new dictionary instead of filtering the specified keys from the input.","title":"Select"},{"location":"api/compose/Select/#parameters","text":"keys ( Tuple[Hashable] ) Key(s) to keep.","title":"Parameters"},{"location":"api/compose/Select/#examples","text":">>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 , 'c' : 13 } >>> compose . Select ( 'c' ) . transform_one ( x ) { 'c' : 13 } You can chain a selector with any estimator in order to apply said estimator to the desired features. >>> from river import feature_extraction as fx >>> x = { 'sales' : 10 , 'shop' : 'Ikea' , 'country' : 'Sweden' } >>> pipeline = ( ... compose . Select ( 'sales' ) | ... fx . PolynomialExtender () ... ) >>> pipeline . transform_one ( x ) { 'sales' : 10 , 'sales*sales' : 100 } This transformer also supports mini-batch processing: >>> import random >>> from river import compose >>> random . seed ( 42 ) >>> X = [{ \"x_1\" : random . uniform ( 8 , 12 ), \"x_2\" : random . uniform ( 8 , 12 )} for _ in range ( 6 )] >>> for x in X : ... print ( x ) { 'x_1' : 10.557707193831535 , 'x_2' : 8.100043020890668 } { 'x_1' : 9.100117273476478 , 'x_2' : 8.892842952595291 } { 'x_1' : 10.94588485665605 , 'x_2' : 10.706797949691644 } { 'x_1' : 11.568718270819382 , 'x_2' : 8.347755330517664 } { 'x_1' : 9.687687278741082 , 'x_2' : 8.119188877752281 } { 'x_1' : 8.874551899214413 , 'x_2' : 10.021421152413449 } >>> import pandas as pd >>> X = pd . DataFrame . from_dict ( X ) You can then call transform_many to transform a mini-batch of features: >>> compose . Select ( 'x_2' ) . transform_many ( X ) x_2 0 8.100043 1 8.892843 2 10.706798 3 8.347755 4 8.119189 5 10.021421","title":"Examples"},{"location":"api/compose/Select/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. A lot of transformers don't actually have to do anything during the learn_many step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_many can override this method. Parameters X ( pandas.core.frame.DataFrame ) kwargs Returns Transformer : self learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_many Transform a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A new DataFrame. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/SelectType/","text":"SelectType \u00b6 Selects features based on their type. This is practical when you want to apply different preprocessing steps to different kinds of features. For instance, a common usecase is to apply a preprocessing.StandardScaler to numeric features and a preprocessing.OneHotEncoder to categorical features. Parameters \u00b6 types ( Tuple[type] ) Python types which you want to select. Under the hood, the isinstance method will be used to check if a value is of a given type. Examples \u00b6 >>> import numbers >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> num = compose . SelectType ( numbers . Number ) | preprocessing . StandardScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder () >>> model = ( num + cat ) | linear_model . LogisticRegression () Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"SelectType"},{"location":"api/compose/SelectType/#selecttype","text":"Selects features based on their type. This is practical when you want to apply different preprocessing steps to different kinds of features. For instance, a common usecase is to apply a preprocessing.StandardScaler to numeric features and a preprocessing.OneHotEncoder to categorical features.","title":"SelectType"},{"location":"api/compose/SelectType/#parameters","text":"types ( Tuple[type] ) Python types which you want to select. Under the hood, the isinstance method will be used to check if a value is of a given type.","title":"Parameters"},{"location":"api/compose/SelectType/#examples","text":">>> import numbers >>> from river import compose >>> from river import linear_model >>> from river import preprocessing >>> num = compose . SelectType ( numbers . Number ) | preprocessing . StandardScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder () >>> model = ( num + cat ) | linear_model . LogisticRegression ()","title":"Examples"},{"location":"api/compose/SelectType/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/Suffixer/","text":"Suffixer \u00b6 Appends a suffix on features names. Parameters \u00b6 suffix ( str ) Examples \u00b6 >>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Suffixer ( '_suffix' ) . transform_one ( x ) { 'a_suffix' : 42 , 'b_suffix' : 12 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Suffixer"},{"location":"api/compose/Suffixer/#suffixer","text":"Appends a suffix on features names.","title":"Suffixer"},{"location":"api/compose/Suffixer/#parameters","text":"suffix ( str )","title":"Parameters"},{"location":"api/compose/Suffixer/#examples","text":">>> from river import compose >>> x = { 'a' : 42 , 'b' : 12 } >>> compose . Suffixer ( '_suffix' ) . transform_one ( x ) { 'a_suffix' : 42 , 'b_suffix' : 12 }","title":"Examples"},{"location":"api/compose/Suffixer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/compose/TargetTransformRegressor/","text":"TargetTransformRegressor \u00b6 Modifies the target before training. The user is expected to check that func and inverse_func are coherent with each other. Parameters \u00b6 regressor ( base.Regressor ) Regression model to wrap. func ( ) A function modifying the target before training. inverse_func ( ) A function to return to the target's original space. Examples \u00b6 >>> import math >>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... compose . TargetTransformRegressor ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.15 ), ... func = math . log , ... inverse_func = math . exp ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 8.759624 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"TargetTransformRegressor"},{"location":"api/compose/TargetTransformRegressor/#targettransformregressor","text":"Modifies the target before training. The user is expected to check that func and inverse_func are coherent with each other.","title":"TargetTransformRegressor"},{"location":"api/compose/TargetTransformRegressor/#parameters","text":"regressor ( base.Regressor ) Regression model to wrap. func ( ) A function modifying the target before training. inverse_func ( ) A function to return to the target's original space.","title":"Parameters"},{"location":"api/compose/TargetTransformRegressor/#examples","text":">>> import math >>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... compose . TargetTransformRegressor ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.15 ), ... func = math . log , ... inverse_func = math . exp ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 8.759624","title":"Examples"},{"location":"api/compose/TargetTransformRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/compose/TransformerProduct/","text":"TransformerProduct \u00b6 Computes interactions between the outputs of a set transformers. This is for when you want to add interaction terms between groups of features. It may also be used an alternative to feature_extraction.PolynomialExtender when the latter is overkill. Parameters \u00b6 transformers Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided. Examples \u00b6 Let's say we have a certain set of features with two groups. In practice these may be different namespaces, such one for items and the other for users. >>> x = dict ( ... a = 0 , b = 1 , # group 1 ... x = 2 , y = 3 # group 2 ... ) We might want to add interaction terms between groups ('a', 'b') and ('x', 'y') , as so: >>> from pprint import pprint >>> from river.compose import Select , TransformerProduct >>> product = TransformerProduct ( ... Select ( 'a' , 'b' ), ... Select ( 'x' , 'y' ) ... ) >>> pprint ( product . transform_one ( x )) { 'a*x' : 0 , 'a*y' : 0 , 'b*x' : 2 , 'b*y' : 3 } This can also be done with the following shorthand: >>> product = Select ( 'a' , 'b' ) * Select ( 'x' , 'y' ) >>> pprint ( product . transform_one ( x )) { 'a*x' : 0 , 'a*y' : 0 , 'b*x' : 2 , 'b*y' : 3 } If you want to include the original terms, you can do something like this: >>> group_1 = Select ( 'a' , 'b' ) >>> group_2 = Select ( 'x' , 'y' ) >>> product = group_1 + group_2 + group_1 * group_2 >>> pprint ( product . transform_one ( x )) { 'a' : 0 , 'a*x' : 0 , 'a*y' : 0 , 'b' : 1 , 'b*x' : 2 , 'b*y' : 3 , 'x' : 2 , 'y' : 3 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update each transformer. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None learn_one Update each transformer. Parameters x ( dict ) y \u2013 defaults to None transform_many Passes the data through each transformer and packs the results together. Parameters X ( pandas.core.frame.DataFrame ) transform_one Passes the data through each transformer and packs the results together. Parameters x ( dict )","title":"TransformerProduct"},{"location":"api/compose/TransformerProduct/#transformerproduct","text":"Computes interactions between the outputs of a set transformers. This is for when you want to add interaction terms between groups of features. It may also be used an alternative to feature_extraction.PolynomialExtender when the latter is overkill.","title":"TransformerProduct"},{"location":"api/compose/TransformerProduct/#parameters","text":"transformers Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.","title":"Parameters"},{"location":"api/compose/TransformerProduct/#examples","text":"Let's say we have a certain set of features with two groups. In practice these may be different namespaces, such one for items and the other for users. >>> x = dict ( ... a = 0 , b = 1 , # group 1 ... x = 2 , y = 3 # group 2 ... ) We might want to add interaction terms between groups ('a', 'b') and ('x', 'y') , as so: >>> from pprint import pprint >>> from river.compose import Select , TransformerProduct >>> product = TransformerProduct ( ... Select ( 'a' , 'b' ), ... Select ( 'x' , 'y' ) ... ) >>> pprint ( product . transform_one ( x )) { 'a*x' : 0 , 'a*y' : 0 , 'b*x' : 2 , 'b*y' : 3 } This can also be done with the following shorthand: >>> product = Select ( 'a' , 'b' ) * Select ( 'x' , 'y' ) >>> pprint ( product . transform_one ( x )) { 'a*x' : 0 , 'a*y' : 0 , 'b*x' : 2 , 'b*y' : 3 } If you want to include the original terms, you can do something like this: >>> group_1 = Select ( 'a' , 'b' ) >>> group_2 = Select ( 'x' , 'y' ) >>> product = group_1 + group_2 + group_1 * group_2 >>> pprint ( product . transform_one ( x )) { 'a' : 0 , 'a*x' : 0 , 'a*y' : 0 , 'b' : 1 , 'b*x' : 2 , 'b*y' : 3 , 'x' : 2 , 'y' : 3 }","title":"Examples"},{"location":"api/compose/TransformerProduct/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update each transformer. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None learn_one Update each transformer. Parameters x ( dict ) y \u2013 defaults to None transform_many Passes the data through each transformer and packs the results together. Parameters X ( pandas.core.frame.DataFrame ) transform_one Passes the data through each transformer and packs the results together. Parameters x ( dict )","title":"Methods"},{"location":"api/compose/TransformerUnion/","text":"TransformerUnion \u00b6 Packs multiple transformers into a single one. Pipelines allow you to apply steps sequentially. Therefore, the output of a step becomes the input of the next one. In many cases, you may want to pass the output of a step to multiple steps. This simple transformer allows you to do so. In other words, it enables you to apply particular steps to different parts of an input. A typical example is when you want to scale numeric features and one-hot encode categorical features. This transformer is essentially a list of transformers. Whenever it is updated, it loops through each transformer and updates them. Meanwhile, calling transform_one collects the output of each transformer and merges them into a single dictionary. Parameters \u00b6 transformers Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided. Examples \u00b6 Take the following dataset: >>> X = [ ... { 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'place' : 'Taco Bell' , 'revenue' : 50 } ... ] As an example, let's assume we want to compute two aggregates of a dataset. We therefore define two feature_extraction.Agg s and initialize a TransformerUnion with them: >>> from river import compose >>> from river import feature_extraction >>> from river import stats >>> mean = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Mean () ... ) >>> count = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Count () ... ) >>> agg = compose . TransformerUnion ( mean , count ) We can now update each transformer and obtain their output with a single function call: >>> from pprint import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint ( agg . transform_one ( x )) { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 42.0 } { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 16.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 50.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 50.0 } Note that you can use the + operator as a shorthand notation: agg = mean + count This allows you to build complex pipelines in a very terse manner. For instance, we can create a pipeline that scales each feature and fits a logistic regression as so: >>> from river import linear_model as lm >>> from river import preprocessing as pp >>> model = ( ... ( mean + count ) | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) Whice is equivalent to the following code: >>> model = compose . Pipeline ( ... compose . TransformerUnion ( mean , count ), ... pp . StandardScaler (), ... lm . LogisticRegression () ... ) Note that you access any part of a TransformerUnion by name: >>> model [ 'TransformerUnion' ][ 'Agg' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Mean () ) >>> model [ 'TransformerUnion' ][ 'Agg1' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Count () ) You can also manually provide a name for each step: >>> agg = compose . TransformerUnion ( ... ( 'Mean revenue by place' , mean ), ... ( '# by place' , count ) ... ) Mini-batch example: >>> X = pd . DataFrame ([ ... { \"place\" : 2 , \"revenue\" : 42 }, ... { \"place\" : 3 , \"revenue\" : 16 }, ... { \"place\" : 3 , \"revenue\" : 24 }, ... { \"place\" : 2 , \"revenue\" : 58 }, ... { \"place\" : 3 , \"revenue\" : 20 }, ... { \"place\" : 2 , \"revenue\" : 50 }, ... ]) Since we need a transformer with mini-batch support to demonstrate, we shall use a StandardScaler . >>> from river import compose >>> from river import preprocessing >>> agg = ( ... compose . Select ( \"place\" ) + ... ( compose . Select ( \"revenue\" ) | preprocessing . StandardScaler ()) ... ) >>> _ = agg . learn_many ( X ) >>> agg . transform_many ( X ) place revenue 0 2 0.441250 1 3 - 1.197680 2 3 - 0.693394 3 2 1.449823 4 3 - 0.945537 5 2 0.945537 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update each transformer. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None learn_one Update each transformer. Parameters x ( dict ) y \u2013 defaults to None transform_many Passes the data through each transformer and packs the results together. Parameters X ( pandas.core.frame.DataFrame ) transform_one Passes the data through each transformer and packs the results together. Parameters x ( dict )","title":"TransformerUnion"},{"location":"api/compose/TransformerUnion/#transformerunion","text":"Packs multiple transformers into a single one. Pipelines allow you to apply steps sequentially. Therefore, the output of a step becomes the input of the next one. In many cases, you may want to pass the output of a step to multiple steps. This simple transformer allows you to do so. In other words, it enables you to apply particular steps to different parts of an input. A typical example is when you want to scale numeric features and one-hot encode categorical features. This transformer is essentially a list of transformers. Whenever it is updated, it loops through each transformer and updates them. Meanwhile, calling transform_one collects the output of each transformer and merges them into a single dictionary.","title":"TransformerUnion"},{"location":"api/compose/TransformerUnion/#parameters","text":"transformers Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.","title":"Parameters"},{"location":"api/compose/TransformerUnion/#examples","text":"Take the following dataset: >>> X = [ ... { 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'place' : 'Taco Bell' , 'revenue' : 50 } ... ] As an example, let's assume we want to compute two aggregates of a dataset. We therefore define two feature_extraction.Agg s and initialize a TransformerUnion with them: >>> from river import compose >>> from river import feature_extraction >>> from river import stats >>> mean = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Mean () ... ) >>> count = feature_extraction . Agg ( ... on = 'revenue' , by = 'place' , ... how = stats . Count () ... ) >>> agg = compose . TransformerUnion ( mean , count ) We can now update each transformer and obtain their output with a single function call: >>> from pprint import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint ( agg . transform_one ( x )) { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 42.0 } { 'revenue_count_by_place' : 1 , 'revenue_mean_by_place' : 16.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 2 , 'revenue_mean_by_place' : 50.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 20.0 } { 'revenue_count_by_place' : 3 , 'revenue_mean_by_place' : 50.0 } Note that you can use the + operator as a shorthand notation: agg = mean + count This allows you to build complex pipelines in a very terse manner. For instance, we can create a pipeline that scales each feature and fits a logistic regression as so: >>> from river import linear_model as lm >>> from river import preprocessing as pp >>> model = ( ... ( mean + count ) | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) Whice is equivalent to the following code: >>> model = compose . Pipeline ( ... compose . TransformerUnion ( mean , count ), ... pp . StandardScaler (), ... lm . LogisticRegression () ... ) Note that you access any part of a TransformerUnion by name: >>> model [ 'TransformerUnion' ][ 'Agg' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Mean () ) >>> model [ 'TransformerUnion' ][ 'Agg1' ] Agg ( on = \"revenue\" by = [ 'place' ] how = Count () ) You can also manually provide a name for each step: >>> agg = compose . TransformerUnion ( ... ( 'Mean revenue by place' , mean ), ... ( '# by place' , count ) ... ) Mini-batch example: >>> X = pd . DataFrame ([ ... { \"place\" : 2 , \"revenue\" : 42 }, ... { \"place\" : 3 , \"revenue\" : 16 }, ... { \"place\" : 3 , \"revenue\" : 24 }, ... { \"place\" : 2 , \"revenue\" : 58 }, ... { \"place\" : 3 , \"revenue\" : 20 }, ... { \"place\" : 2 , \"revenue\" : 50 }, ... ]) Since we need a transformer with mini-batch support to demonstrate, we shall use a StandardScaler . >>> from river import compose >>> from river import preprocessing >>> agg = ( ... compose . Select ( \"place\" ) + ... ( compose . Select ( \"revenue\" ) | preprocessing . StandardScaler ()) ... ) >>> _ = agg . learn_many ( X ) >>> agg . transform_many ( X ) place revenue 0 2 0.441250 1 3 - 1.197680 2 3 - 0.693394 3 2 1.449823 4 3 - 0.945537 5 2 0.945537","title":"Examples"},{"location":"api/compose/TransformerUnion/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update each transformer. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) \u2013 defaults to None learn_one Update each transformer. Parameters x ( dict ) y \u2013 defaults to None transform_many Passes the data through each transformer and packs the results together. Parameters X ( pandas.core.frame.DataFrame ) transform_one Passes the data through each transformer and packs the results together. Parameters x ( dict )","title":"Methods"},{"location":"api/datasets/AirlinePassengers/","text":"AirlinePassengers \u00b6 Monthly number of international airline passengers. The stream contains 144 items and only one single feature, which is the month. The goal is to predict the number of passengers each month by capturing the trend and the seasonality of the data. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 International airline passengers: monthly totals in thousands. Jan 49 \u2013 Dec 60 \u21a9","title":"AirlinePassengers"},{"location":"api/datasets/AirlinePassengers/#airlinepassengers","text":"Monthly number of international airline passengers. The stream contains 144 items and only one single feature, which is the month. The goal is to predict the number of passengers each month by capturing the trend and the seasonality of the data.","title":"AirlinePassengers"},{"location":"api/datasets/AirlinePassengers/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/AirlinePassengers/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/AirlinePassengers/#references","text":"International airline passengers: monthly totals in thousands. Jan 49 \u2013 Dec 60 \u21a9","title":"References"},{"location":"api/datasets/Bananas/","text":"Bananas \u00b6 Bananas dataset. An artificial dataset where instances belongs to several clusters with a banana shape. There are two attributes that correspond to the x and y axis, respectively. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 OpenML page \u21a9","title":"Bananas"},{"location":"api/datasets/Bananas/#bananas","text":"Bananas dataset. An artificial dataset where instances belongs to several clusters with a banana shape. There are two attributes that correspond to the x and y axis, respectively.","title":"Bananas"},{"location":"api/datasets/Bananas/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/Bananas/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Bananas/#references","text":"OpenML page \u21a9","title":"References"},{"location":"api/datasets/Bikes/","text":"Bikes \u00b6 Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 A short introduction and conclusion to the OpenBikes 2016 Challenge \u21a9","title":"Bikes"},{"location":"api/datasets/Bikes/#bikes","text":"Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse.","title":"Bikes"},{"location":"api/datasets/Bikes/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Bikes/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Bikes/#references","text":"A short introduction and conclusion to the OpenBikes 2016 Challenge \u21a9","title":"References"},{"location":"api/datasets/ChickWeights/","text":"ChickWeights \u00b6 Chick weights along time. The stream contains 578 items and 3 features. The goal is to predict the weight of each chick along time, according to the diet the chick is on. The data is ordered by time and then by chick. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Chick weight dataset overview \u21a9","title":"ChickWeights"},{"location":"api/datasets/ChickWeights/#chickweights","text":"Chick weights along time. The stream contains 578 items and 3 features. The goal is to predict the weight of each chick along time, according to the diet the chick is on. The data is ordered by time and then by chick.","title":"ChickWeights"},{"location":"api/datasets/ChickWeights/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/ChickWeights/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/ChickWeights/#references","text":"Chick weight dataset overview \u21a9","title":"References"},{"location":"api/datasets/CreditCard/","text":"CreditCard \u00b6 Credit card frauds. The datasets contains transactions made by credit cards in September 2013 by european cardholders. This dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions. It contains only numerical input variables which are the result of a PCA transformation. Unfortunately, due to confidentiality issues, we cannot provide the original features and more background information about the data. Features V1, V2, ... V28 are the principal components obtained with PCA, the only features which have not been transformed with PCA are 'Time' and 'Amount'. Feature 'Time' contains the seconds elapsed between each transaction and the first transaction in the dataset. The feature 'Amount' is the transaction Amount, this feature can be used for example-dependant cost-senstive learning. Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015 \u21a9 Dal Pozzolo, Andrea; Caelen, Olivier; Le Borgne, Yann-Ael; Waterschoot, Serge; Bontempi, Gianluca. Learned lessons in credit card fraud detection from a practitioner perspective, Expert systems with applications,41,10,4915-4928,2014, Pergamon \u21a9 Dal Pozzolo, Andrea; Boracchi, Giacomo; Caelen, Olivier; Alippi, Cesare; Bontempi, Gianluca. Credit card fraud detection: a realistic modeling and a novel learning strategy, IEEE transactions on neural networks and learning systems,29,8,3784-3797,2018,IEEE \u21a9 Dal Pozzolo, Andrea Adaptive Machine learning for credit card fraud detection ULB MLG PhD thesis (supervised by G. Bontempi) \u21a9 Carcillo, Fabrizio; Dal Pozzolo, Andrea; Le Borgne, Yann-Ael; Caelen, Olivier; Mazzer, Yannis; Bontempi, Gianluca. Scarff: a scalable framework for streaming credit card fraud detection with Spark, Information fusion,41, 182-194,2018,Elsevier \u21a9 Carcillo, Fabrizio; Le Borgne, Yann-Ael; Caelen, Olivier; Bontempi, Gianluca. Streaming active learning strategies for real-life credit card fraud detection: assessment and visualization, International Journal of Data Science and Analytics, 5,4,285-300,2018,Springer International Publishing \u21a9 Bertrand Lebichot, Yann-Ael Le Borgne, Liyun He, Frederic Oble, Gianluca Bontempi Deep-Learning Domain Adaptation Techniques for Credit Cards Fraud Detection, INNSBDDL 2019: Recent Advances in Big Data and Deep Learning, pp 78-88, 2019 \u21a9 Fabrizio Carcillo, Yann-Ael Le Borgne, Olivier Caelen, Frederic Oble, Gianluca Bontempi Combining Unsupervised and Supervised Learning in Credit Card Fraud Detection Information Sciences, 2019 \u21a9","title":"CreditCard"},{"location":"api/datasets/CreditCard/#creditcard","text":"Credit card frauds. The datasets contains transactions made by credit cards in September 2013 by european cardholders. This dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions. It contains only numerical input variables which are the result of a PCA transformation. Unfortunately, due to confidentiality issues, we cannot provide the original features and more background information about the data. Features V1, V2, ... V28 are the principal components obtained with PCA, the only features which have not been transformed with PCA are 'Time' and 'Amount'. Feature 'Time' contains the seconds elapsed between each transaction and the first transaction in the dataset. The feature 'Amount' is the transaction Amount, this feature can be used for example-dependant cost-senstive learning. Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise.","title":"CreditCard"},{"location":"api/datasets/CreditCard/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/CreditCard/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/CreditCard/#references","text":"Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015 \u21a9 Dal Pozzolo, Andrea; Caelen, Olivier; Le Borgne, Yann-Ael; Waterschoot, Serge; Bontempi, Gianluca. Learned lessons in credit card fraud detection from a practitioner perspective, Expert systems with applications,41,10,4915-4928,2014, Pergamon \u21a9 Dal Pozzolo, Andrea; Boracchi, Giacomo; Caelen, Olivier; Alippi, Cesare; Bontempi, Gianluca. Credit card fraud detection: a realistic modeling and a novel learning strategy, IEEE transactions on neural networks and learning systems,29,8,3784-3797,2018,IEEE \u21a9 Dal Pozzolo, Andrea Adaptive Machine learning for credit card fraud detection ULB MLG PhD thesis (supervised by G. Bontempi) \u21a9 Carcillo, Fabrizio; Dal Pozzolo, Andrea; Le Borgne, Yann-Ael; Caelen, Olivier; Mazzer, Yannis; Bontempi, Gianluca. Scarff: a scalable framework for streaming credit card fraud detection with Spark, Information fusion,41, 182-194,2018,Elsevier \u21a9 Carcillo, Fabrizio; Le Borgne, Yann-Ael; Caelen, Olivier; Bontempi, Gianluca. Streaming active learning strategies for real-life credit card fraud detection: assessment and visualization, International Journal of Data Science and Analytics, 5,4,285-300,2018,Springer International Publishing \u21a9 Bertrand Lebichot, Yann-Ael Le Borgne, Liyun He, Frederic Oble, Gianluca Bontempi Deep-Learning Domain Adaptation Techniques for Credit Cards Fraud Detection, INNSBDDL 2019: Recent Advances in Big Data and Deep Learning, pp 78-88, 2019 \u21a9 Fabrizio Carcillo, Yann-Ael Le Borgne, Olivier Caelen, Frederic Oble, Gianluca Bontempi Combining Unsupervised and Supervised Learning in Credit Card Fraud Detection Information Sciences, 2019 \u21a9","title":"References"},{"location":"api/datasets/Elec2/","text":"Elec2 \u00b6 Electricity prices in New South Wales. This is a binary classification task, where the goal is to predict if the price of electricity will go up or down. This data was collected from the Australian New South Wales Electricity Market. In this market, prices are not fixed and are affected by demand and supply of the market. They are set every five minutes. Electricity transfers to/from the neighboring state of Victoria were done to alleviate fluctuations. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 SPLICE-2 Comparative Evaluation: Electricity Pricing \u21a9 DataHub description \u21a9","title":"Elec2"},{"location":"api/datasets/Elec2/#elec2","text":"Electricity prices in New South Wales. This is a binary classification task, where the goal is to predict if the price of electricity will go up or down. This data was collected from the Australian New South Wales Electricity Market. In this market, prices are not fixed and are affected by demand and supply of the market. They are set every five minutes. Electricity transfers to/from the neighboring state of Victoria were done to alleviate fluctuations.","title":"Elec2"},{"location":"api/datasets/Elec2/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Elec2/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Elec2/#references","text":"SPLICE-2 Comparative Evaluation: Electricity Pricing \u21a9 DataHub description \u21a9","title":"References"},{"location":"api/datasets/HTTP/","text":"HTTP \u00b6 HTTP dataset of the KDD 1999 cup. The goal is to predict whether or not an HTTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 HTTP (KDDCUP99) dataset \u21a9","title":"HTTP"},{"location":"api/datasets/HTTP/#http","text":"HTTP dataset of the KDD 1999 cup. The goal is to predict whether or not an HTTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.","title":"HTTP"},{"location":"api/datasets/HTTP/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/HTTP/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/HTTP/#references","text":"HTTP (KDDCUP99) dataset \u21a9","title":"References"},{"location":"api/datasets/Higgs/","text":"Higgs \u00b6 Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"Higgs"},{"location":"api/datasets/Higgs/#higgs","text":"Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes.","title":"Higgs"},{"location":"api/datasets/Higgs/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Higgs/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Higgs/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/ImageSegments/","text":"ImageSegments \u00b6 Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"ImageSegments"},{"location":"api/datasets/ImageSegments/#imagesegments","text":"Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass.","title":"ImageSegments"},{"location":"api/datasets/ImageSegments/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/ImageSegments/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/ImageSegments/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/Insects/","text":"Insects \u00b6 Insects dataset. This dataset has different variants, which are: abrupt_balanced - abrupt_imbalanced - gradual_balanced - gradual_imbalanced - incremental-abrupt_balanced - incremental-abrupt_imbalanced - incremental-reoccurring_balanced - incremental-reoccurring_imbalanced - incremental_balanced - incremental_imbalanced - out-of-control The number of samples and the difficulty change from one variant to another. The number of classes is always the same (6), except for the last variant (24). Parameters \u00b6 variant \u2013 defaults to abrupt_balanced Indicates which variant of the dataset to load. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 USP DS repository \u21a9 Souza, V., Reis, D.M.D., Maletzke, A.G. and Batista, G.E., 2020. Challenges in Benchmarking Stream Learning Algorithms with Real-world Data. arXiv preprint arXiv:2005.00113. \u21a9","title":"Insects"},{"location":"api/datasets/Insects/#insects","text":"Insects dataset. This dataset has different variants, which are: abrupt_balanced - abrupt_imbalanced - gradual_balanced - gradual_imbalanced - incremental-abrupt_balanced - incremental-abrupt_imbalanced - incremental-reoccurring_balanced - incremental-reoccurring_imbalanced - incremental_balanced - incremental_imbalanced - out-of-control The number of samples and the difficulty change from one variant to another. The number of classes is always the same (6), except for the last variant (24).","title":"Insects"},{"location":"api/datasets/Insects/#parameters","text":"variant \u2013 defaults to abrupt_balanced Indicates which variant of the dataset to load.","title":"Parameters"},{"location":"api/datasets/Insects/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Insects/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Insects/#references","text":"USP DS repository \u21a9 Souza, V., Reis, D.M.D., Maletzke, A.G. and Batista, G.E., 2020. Challenges in Benchmarking Stream Learning Algorithms with Real-world Data. arXiv preprint arXiv:2005.00113. \u21a9","title":"References"},{"location":"api/datasets/Keystroke/","text":"Keystroke \u00b6 CMU keystroke dataset. Users are tasked to type in a password. The task is to determine which user is typing in the password. The only difference with the original dataset is that the \"sessionIndex\" and \"rep\" attributes have been dropped. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Keystroke Dynamics - Benchmark Data Set \u21a9","title":"Keystroke"},{"location":"api/datasets/Keystroke/#keystroke","text":"CMU keystroke dataset. Users are tasked to type in a password. The task is to determine which user is typing in the password. The only difference with the original dataset is that the \"sessionIndex\" and \"rep\" attributes have been dropped.","title":"Keystroke"},{"location":"api/datasets/Keystroke/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Keystroke/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Keystroke/#references","text":"Keystroke Dynamics - Benchmark Data Set \u21a9","title":"References"},{"location":"api/datasets/MaliciousURL/","text":"MaliciousURL \u00b6 Malicious URLs dataset. This dataset contains features about URLs that are classified as malicious or not. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Detecting Malicious URLs \u21a9 Identifying Suspicious URLs: An Application of Large-Scale Online Learning \u21a9","title":"MaliciousURL"},{"location":"api/datasets/MaliciousURL/#maliciousurl","text":"Malicious URLs dataset. This dataset contains features about URLs that are classified as malicious or not.","title":"MaliciousURL"},{"location":"api/datasets/MaliciousURL/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/MaliciousURL/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/MaliciousURL/#references","text":"Detecting Malicious URLs \u21a9 Identifying Suspicious URLs: An Application of Large-Scale Online Learning \u21a9","title":"References"},{"location":"api/datasets/MovieLens100K/","text":"MovieLens100K \u00b6 MovieLens 100K dataset. MovieLens datasets were collected by the GroupLens Research Project at the University of Minnesota. This dataset consists of 100,000 ratings (1-5) from 943 users on 1682 movies. Each user has rated at least 20 movies. User and movie information are provided. The data was collected through the MovieLens web site (movielens.umn.edu) during the seven-month period from September 19th, 1997 through April 22nd, 1998. Parameters \u00b6 unpack_user_and_item \u2013 defaults to False Whether or not the user and item should be extracted from the context and included as extra keyword arguments. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 The MovieLens Datasets: History and Context \u21a9","title":"MovieLens100K"},{"location":"api/datasets/MovieLens100K/#movielens100k","text":"MovieLens 100K dataset. MovieLens datasets were collected by the GroupLens Research Project at the University of Minnesota. This dataset consists of 100,000 ratings (1-5) from 943 users on 1682 movies. Each user has rated at least 20 movies. User and movie information are provided. The data was collected through the MovieLens web site (movielens.umn.edu) during the seven-month period from September 19th, 1997 through April 22nd, 1998.","title":"MovieLens100K"},{"location":"api/datasets/MovieLens100K/#parameters","text":"unpack_user_and_item \u2013 defaults to False Whether or not the user and item should be extracted from the context and included as extra keyword arguments.","title":"Parameters"},{"location":"api/datasets/MovieLens100K/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/MovieLens100K/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/MovieLens100K/#references","text":"The MovieLens Datasets: History and Context \u21a9","title":"References"},{"location":"api/datasets/Music/","text":"Music \u00b6 Bike sharing station information from the city of Toulouse. The goal is to predict to which kinds of moods a song pertains to. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Read, J., Reutemann, P., Pfahringer, B. and Holmes, G., 2016. MEKA: a multi-label/multi-target extension to WEKA. The Journal of Machine Learning Research, 17(1), pp.667-671. \u21a9","title":"Music"},{"location":"api/datasets/Music/#music","text":"Bike sharing station information from the city of Toulouse. The goal is to predict to which kinds of moods a song pertains to.","title":"Music"},{"location":"api/datasets/Music/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Music/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Music/#references","text":"Read, J., Reutemann, P., Pfahringer, B. and Holmes, G., 2016. MEKA: a multi-label/multi-target extension to WEKA. The Journal of Machine Learning Research, 17(1), pp.667-671. \u21a9","title":"References"},{"location":"api/datasets/Phishing/","text":"Phishing \u00b6 Phishing websites. This dataset contains features from web pages that are classified as phishing or not. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"Phishing"},{"location":"api/datasets/Phishing/#phishing","text":"Phishing websites. This dataset contains features from web pages that are classified as phishing or not.","title":"Phishing"},{"location":"api/datasets/Phishing/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/Phishing/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Phishing/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/Restaurants/","text":"Restaurants \u00b6 Data from the Kaggle Recruit Restaurants challenge. The goal is to predict the number of visitors in each of 829 Japanese restaurants over a priod of roughly 16 weeks. The data is ordered by date and then by restaurant ID. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Recruit Restaurant Visitor Forecasting \u21a9","title":"Restaurants"},{"location":"api/datasets/Restaurants/#restaurants","text":"Data from the Kaggle Recruit Restaurants challenge. The goal is to predict the number of visitors in each of 829 Japanese restaurants over a priod of roughly 16 weeks. The data is ordered by date and then by restaurant ID.","title":"Restaurants"},{"location":"api/datasets/Restaurants/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Restaurants/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Restaurants/#references","text":"Recruit Restaurant Visitor Forecasting \u21a9","title":"References"},{"location":"api/datasets/SMSSpam/","text":"SMSSpam \u00b6 SMS Spam Collection dataset. The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 Almeida, T.A., Hidalgo, J.M.G. and Yamakami, A., 2011, September. Contributions to the study of SMS spam filtering: new collection and results. In Proceedings of the 11th ACM symposium on Document engineering (pp. 259-262). \u21a9","title":"SMSSpam"},{"location":"api/datasets/SMSSpam/#smsspam","text":"SMS Spam Collection dataset. The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not.","title":"SMSSpam"},{"location":"api/datasets/SMSSpam/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/SMSSpam/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/SMSSpam/#references","text":"Almeida, T.A., Hidalgo, J.M.G. and Yamakami, A., 2011, September. Contributions to the study of SMS spam filtering: new collection and results. In Proceedings of the 11th ACM symposium on Document engineering (pp. 259-262). \u21a9","title":"References"},{"location":"api/datasets/SMTP/","text":"SMTP \u00b6 SMTP dataset from the KDD 1999 cup. The goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 SMTP (KDDCUP99) dataset \u21a9","title":"SMTP"},{"location":"api/datasets/SMTP/#smtp","text":"SMTP dataset from the KDD 1999 cup. The goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.","title":"SMTP"},{"location":"api/datasets/SMTP/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/SMTP/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/SMTP/#references","text":"SMTP (KDDCUP99) dataset \u21a9","title":"References"},{"location":"api/datasets/SolarFlare/","text":"SolarFlare \u00b6 Solar flare multi-output regression. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 UCI page \u21a9","title":"SolarFlare"},{"location":"api/datasets/SolarFlare/#solarflare","text":"Solar flare multi-output regression.","title":"SolarFlare"},{"location":"api/datasets/SolarFlare/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/SolarFlare/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/SolarFlare/#references","text":"UCI page \u21a9","title":"References"},{"location":"api/datasets/TREC07/","text":"TREC07 \u00b6 TREC's 2007 Spam Track dataset. The data contains 75,419 chronologically ordered items, i.e. 3 months of emails delivered to a particular server in 2007. Spam messages represent 66.6% of the dataset. The goal is to predict whether an email is a spam or not. The available raw features are: sender, recipients, date, subject, body. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 TREC 2007 Spam Track Overview \u21a9 Code ran to parse the dataset \u21a9","title":"TREC07"},{"location":"api/datasets/TREC07/#trec07","text":"TREC's 2007 Spam Track dataset. The data contains 75,419 chronologically ordered items, i.e. 3 months of emails delivered to a particular server in 2007. Spam messages represent 66.6% of the dataset. The goal is to predict whether an email is a spam or not. The available raw features are: sender, recipients, date, subject, body.","title":"TREC07"},{"location":"api/datasets/TREC07/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/TREC07/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/TREC07/#references","text":"TREC 2007 Spam Track Overview \u21a9 Code ran to parse the dataset \u21a9","title":"References"},{"location":"api/datasets/Taxis/","text":"Taxis \u00b6 Taxi ride durations in New York City. The goal is to predict the duration of taxi rides in New York City. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int ) References \u00b6 New York City Taxi Trip Duration competition on Kaggle \u21a9","title":"Taxis"},{"location":"api/datasets/Taxis/#taxis","text":"Taxi ride durations in New York City. The goal is to predict the duration of taxi rides in New York City.","title":"Taxis"},{"location":"api/datasets/Taxis/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/Taxis/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/Taxis/#references","text":"New York City Taxi Trip Duration competition on Kaggle \u21a9","title":"References"},{"location":"api/datasets/TrumpApproval/","text":"TrumpApproval \u00b6 Donald Trump approval ratings. This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Trump Approval Ratings \u21a9","title":"TrumpApproval"},{"location":"api/datasets/TrumpApproval/#trumpapproval","text":"Donald Trump approval ratings. This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model.","title":"TrumpApproval"},{"location":"api/datasets/TrumpApproval/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/TrumpApproval/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/TrumpApproval/#references","text":"Trump Approval Ratings \u21a9","title":"References"},{"location":"api/datasets/WaterFlow/","text":"WaterFlow \u00b6 Water flow through a pipeline branch. The series includes hourly values for about 2 months, March 2022 to May 2022. The values are expressed in liters per second. There are four anomalous segments in the series: 3 \"low value\" moments: this is due to water losses or human intervention for maintenance. - A small peak in the water inflow after the first 2 segments: this is due to a pumping operation into the main pipeline, when more water pressure is needed. This dataset is well suited for time series forecasting models, as well as anomaly detection methods. Ideally, the goal is to build a time series forecasting model that is robust to the anomalous segments. This data has been kindly donated by the TecnojJest s.r.l. company (www.invidea.it) from Italy. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"WaterFlow"},{"location":"api/datasets/WaterFlow/#waterflow","text":"Water flow through a pipeline branch. The series includes hourly values for about 2 months, March 2022 to May 2022. The values are expressed in liters per second. There are four anomalous segments in the series: 3 \"low value\" moments: this is due to water losses or human intervention for maintenance. - A small peak in the water inflow after the first 2 segments: this is due to a pumping operation into the main pipeline, when more water pressure is needed. This dataset is well suited for time series forecasting models, as well as anomaly detection methods. Ideally, the goal is to build a time series forecasting model that is robust to the anomalous segments. This data has been kindly donated by the TecnojJest s.r.l. company (www.invidea.it) from Italy.","title":"WaterFlow"},{"location":"api/datasets/WaterFlow/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/WaterFlow/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/base/Dataset/","text":"Dataset \u00b6 Base class for all datasets. All datasets inherit from this class, be they stored in a file or generated on the fly. Parameters \u00b6 task Type of task the dataset is meant for. Should be one of: - \"Regression\" - \"Binary classification\" - \"Multi-class classification\" - \"Multi-output binary classification\" - \"Multi-output regression\" n_features Number of features in the dataset. n_samples \u2013 defaults to None Number of samples in the dataset. n_classes \u2013 defaults to None Number of classes in the dataset, only applies to classification datasets. n_outputs \u2013 defaults to None Number of outputs the target is made of, only applies to multi-output datasets. sparse \u2013 defaults to False Whether the dataset is sparse or not. Attributes \u00b6 desc Return the description from the docstring. Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"Dataset"},{"location":"api/datasets/base/Dataset/#dataset","text":"Base class for all datasets. All datasets inherit from this class, be they stored in a file or generated on the fly.","title":"Dataset"},{"location":"api/datasets/base/Dataset/#parameters","text":"task Type of task the dataset is meant for. Should be one of: - \"Regression\" - \"Binary classification\" - \"Multi-class classification\" - \"Multi-output binary classification\" - \"Multi-output regression\" n_features Number of features in the dataset. n_samples \u2013 defaults to None Number of samples in the dataset. n_classes \u2013 defaults to None Number of classes in the dataset, only applies to classification datasets. n_outputs \u2013 defaults to None Number of outputs the target is made of, only applies to multi-output datasets. sparse \u2013 defaults to False Whether the dataset is sparse or not.","title":"Parameters"},{"location":"api/datasets/base/Dataset/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/datasets/base/Dataset/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/base/FileDataset/","text":"FileDataset \u00b6 Base class for datasets that are stored in a local file. Small datasets that are part of the river package inherit from this class. Parameters \u00b6 filename The file's name. directory \u2013 defaults to None The directory where the file is contained. Defaults to the location of the datasets module. desc Extra dataset parameters to pass as keyword arguments. Attributes \u00b6 desc Return the description from the docstring. path Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"FileDataset"},{"location":"api/datasets/base/FileDataset/#filedataset","text":"Base class for datasets that are stored in a local file. Small datasets that are part of the river package inherit from this class.","title":"FileDataset"},{"location":"api/datasets/base/FileDataset/#parameters","text":"filename The file's name. directory \u2013 defaults to None The directory where the file is contained. Defaults to the location of the datasets module. desc Extra dataset parameters to pass as keyword arguments.","title":"Parameters"},{"location":"api/datasets/base/FileDataset/#attributes","text":"desc Return the description from the docstring. path","title":"Attributes"},{"location":"api/datasets/base/FileDataset/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/base/RemoteDataset/","text":"RemoteDataset \u00b6 Base class for datasets that are stored in a remote file. Medium and large datasets that are not part of the river package inherit from this class. The filename doesn't have to be provided if unpack is False. Indeed in the latter case the filename will be inferred from the URL. Parameters \u00b6 url The URL the dataset is located at. size The expected download size. unpack \u2013 defaults to True Whether to unpack the download or not. filename \u2013 defaults to None An optional name to given to the file if the file is unpacked. desc Extra dataset parameters to pass as keyword arguments. Attributes \u00b6 desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path Methods \u00b6 download take Iterate over the k samples. Parameters k ( int )","title":"RemoteDataset"},{"location":"api/datasets/base/RemoteDataset/#remotedataset","text":"Base class for datasets that are stored in a remote file. Medium and large datasets that are not part of the river package inherit from this class. The filename doesn't have to be provided if unpack is False. Indeed in the latter case the filename will be inferred from the URL.","title":"RemoteDataset"},{"location":"api/datasets/base/RemoteDataset/#parameters","text":"url The URL the dataset is located at. size The expected download size. unpack \u2013 defaults to True Whether to unpack the download or not. filename \u2013 defaults to None An optional name to given to the file if the file is unpacked. desc Extra dataset parameters to pass as keyword arguments.","title":"Parameters"},{"location":"api/datasets/base/RemoteDataset/#attributes","text":"desc Return the description from the docstring. is_downloaded Indicate whether or the data has been correctly downloaded. path","title":"Attributes"},{"location":"api/datasets/base/RemoteDataset/#methods","text":"download take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/datasets/base/SyntheticDataset/","text":"SyntheticDataset \u00b6 A synthetic dataset. Parameters \u00b6 task Type of task the dataset is meant for. Should be one of: - \"Regression\" - \"Binary classification\" - \"Multi-class classification\" - \"Multi-output binary classification\" - \"Multi-output regression\" n_features Number of features in the dataset. n_samples \u2013 defaults to None Number of samples in the dataset. n_classes \u2013 defaults to None Number of classes in the dataset, only applies to classification datasets. n_outputs \u2013 defaults to None Number of outputs the target is made of, only applies to multi-output datasets. sparse \u2013 defaults to False Whether the dataset is sparse or not. Attributes \u00b6 desc Return the description from the docstring. Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"SyntheticDataset"},{"location":"api/datasets/base/SyntheticDataset/#syntheticdataset","text":"A synthetic dataset.","title":"SyntheticDataset"},{"location":"api/datasets/base/SyntheticDataset/#parameters","text":"task Type of task the dataset is meant for. Should be one of: - \"Regression\" - \"Binary classification\" - \"Multi-class classification\" - \"Multi-output binary classification\" - \"Multi-output regression\" n_features Number of features in the dataset. n_samples \u2013 defaults to None Number of samples in the dataset. n_classes \u2013 defaults to None Number of classes in the dataset, only applies to classification datasets. n_outputs \u2013 defaults to None Number of outputs the target is made of, only applies to multi-output datasets. sparse \u2013 defaults to False Whether the dataset is sparse or not.","title":"Parameters"},{"location":"api/datasets/base/SyntheticDataset/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/datasets/base/SyntheticDataset/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/drift/ADWIN/","text":"ADWIN \u00b6 Adaptive Windowing method for concept drift detection. ADWIN (ADaptive WINdowing) is a popular drift detection method with mathematical guarantees. ADWIN efficiently keeps a variable-length window of recent items; such that it holds that there has no been change in the data distribution. This window is further divided into two sub-windows \\((W_0, W_1)\\) used to determine if a change has happened. ADWIN compares the average of \\(W_0\\) and \\(W_1\\) to confirm that they correspond to the same distribution. Concept drift is detected if the distribution equality no longer holds. Upon detecting a drift, \\(W_0\\) is replaced by \\(W_1\\) and a new \\(W_1\\) is initialized. ADWIN uses a confidence value \\(\\delta=\\in(0,1)\\) to determine if the two sub-windows correspond to the same distribution. Input : value can be any numeric value related to the definition of concept change for the data analyzed. For example, using 0's or 1's to track drift in a classifier's performance as follows: 0: Means the learners prediction was wrong 1: Means the learners prediction was correct Parameters \u00b6 delta \u2013 defaults to 0.002 Confidence value. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. delta estimation Error estimation n_detections total variance warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. width Window size Examples \u00b6 >>> import random >>> from river import drift >>> rng = random . Random ( 12345 ) >>> adwin = drift . ADWIN () >>> # Simulate a data stream composed by two data distributions >>> data_stream = rng . choices ([ 0 , 1 ], k = 1000 ) + rng . choices ( range ( 4 , 8 ), k = 1000 ) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , _ = adwin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) ... adwin . reset () # Good practice Change detected at index 1023 , input value : 4 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Apart from adding the element value to the window, by inserting it in the correct bucket, it will also update the relevant statistics, in this case the total sum of all values, the window width and the total variance. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple References \u00b6 Albert Bifet and Ricard Gavalda. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"ADWIN"},{"location":"api/drift/ADWIN/#adwin","text":"Adaptive Windowing method for concept drift detection. ADWIN (ADaptive WINdowing) is a popular drift detection method with mathematical guarantees. ADWIN efficiently keeps a variable-length window of recent items; such that it holds that there has no been change in the data distribution. This window is further divided into two sub-windows \\((W_0, W_1)\\) used to determine if a change has happened. ADWIN compares the average of \\(W_0\\) and \\(W_1\\) to confirm that they correspond to the same distribution. Concept drift is detected if the distribution equality no longer holds. Upon detecting a drift, \\(W_0\\) is replaced by \\(W_1\\) and a new \\(W_1\\) is initialized. ADWIN uses a confidence value \\(\\delta=\\in(0,1)\\) to determine if the two sub-windows correspond to the same distribution. Input : value can be any numeric value related to the definition of concept change for the data analyzed. For example, using 0's or 1's to track drift in a classifier's performance as follows: 0: Means the learners prediction was wrong 1: Means the learners prediction was correct","title":"ADWIN"},{"location":"api/drift/ADWIN/#parameters","text":"delta \u2013 defaults to 0.002 Confidence value.","title":"Parameters"},{"location":"api/drift/ADWIN/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. delta estimation Error estimation n_detections total variance warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. width Window size","title":"Attributes"},{"location":"api/drift/ADWIN/#examples","text":">>> import random >>> from river import drift >>> rng = random . Random ( 12345 ) >>> adwin = drift . ADWIN () >>> # Simulate a data stream composed by two data distributions >>> data_stream = rng . choices ([ 0 , 1 ], k = 1000 ) + rng . choices ( range ( 4 , 8 ), k = 1000 ) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , _ = adwin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) ... adwin . reset () # Good practice Change detected at index 1023 , input value : 4","title":"Examples"},{"location":"api/drift/ADWIN/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Apart from adding the element value to the window, by inserting it in the correct bucket, it will also update the relevant statistics, in this case the total sum of all values, the window width and the total variance. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple","title":"Methods"},{"location":"api/drift/ADWIN/#references","text":"Albert Bifet and Ricard Gavalda. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"References"},{"location":"api/drift/DDM/","text":"DDM \u00b6 Drift Detection Method. DDM (Drift Detection Method) is a concept change detection method based on the PAC learning model premise, that the learner's error rate will decrease as the number of analysed samples increase, as long as the data distribution is stationary. If the algorithm detects an increase in the error rate, that surpasses a calculated threshold, either change is detected or the algorithm will warn the user that change may occur in the near future, which is called the warning zone. The detection threshold is calculated in function of two statistics, obtained when \\((p_i + s_i)\\) is minimum: \\(p_{min}\\) : The minimum recorded error rate. \\(s_{min}\\) : The minimum recorded standard deviation. At instant \\(i\\) , the detection algorithm uses: \\(p_i\\) : The error rate at instant \\(i\\) . \\(s_i\\) : The standard deviation at instant \\(i\\) . The conditions for entering the warning zone and detecting change are as follows [see implementation note bellow]: if \\(p_i + s_i \\geq p_{min} + 2 * s_{min}\\) -> Warning zone if \\(p_i + s_i \\geq p_{min} + 3 * s_{min}\\) -> Change detected Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Parameters \u00b6 min_num_instances \u2013 defaults to 30 The minimum required number of analyzed samples so change can be detected. This is used to avoid false detections during the early moments of the detector, when the weight of one sample is important. warning_level \u2013 defaults to 2.0 Warning level. out_control_level \u2013 defaults to 3.0 Out-control level. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import random >>> from river import drift >>> rng = random . Random ( 42 ) >>> ddm = drift . DDM () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = ddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1101 , input value : 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Notes \u00b6 In this implementation, the conditions to signal drift and warning are \\(p_i + s_i > thershold\\) instead of \\(p_i + s_i \\geq thershold\\) . This is to avoid a corner case when a classifier is consistently wrong ( value=1 ) that results in DDM indicating a drift every min_num_instances . This modification is consistent with the implementation in MOA. References \u00b6 Jo\u00e3o Gama, Pedro Medas, Gladys Castillo, Pedro Pereira Rodrigues: Learning with Drift Detection. SBIA 2004: 286-295 \u21a9","title":"DDM"},{"location":"api/drift/DDM/#ddm","text":"Drift Detection Method. DDM (Drift Detection Method) is a concept change detection method based on the PAC learning model premise, that the learner's error rate will decrease as the number of analysed samples increase, as long as the data distribution is stationary. If the algorithm detects an increase in the error rate, that surpasses a calculated threshold, either change is detected or the algorithm will warn the user that change may occur in the near future, which is called the warning zone. The detection threshold is calculated in function of two statistics, obtained when \\((p_i + s_i)\\) is minimum: \\(p_{min}\\) : The minimum recorded error rate. \\(s_{min}\\) : The minimum recorded standard deviation. At instant \\(i\\) , the detection algorithm uses: \\(p_i\\) : The error rate at instant \\(i\\) . \\(s_i\\) : The standard deviation at instant \\(i\\) . The conditions for entering the warning zone and detecting change are as follows [see implementation note bellow]: if \\(p_i + s_i \\geq p_{min} + 2 * s_{min}\\) -> Warning zone if \\(p_i + s_i \\geq p_{min} + 3 * s_{min}\\) -> Change detected Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\)","title":"DDM"},{"location":"api/drift/DDM/#parameters","text":"min_num_instances \u2013 defaults to 30 The minimum required number of analyzed samples so change can be detected. This is used to avoid false detections during the early moments of the detector, when the weight of one sample is important. warning_level \u2013 defaults to 2.0 Warning level. out_control_level \u2013 defaults to 3.0 Out-control level.","title":"Parameters"},{"location":"api/drift/DDM/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/DDM/#examples","text":">>> import random >>> from river import drift >>> rng = random . Random ( 42 ) >>> ddm = drift . DDM () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = ddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1101 , input value : 1","title":"Examples"},{"location":"api/drift/DDM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number )","title":"Methods"},{"location":"api/drift/DDM/#notes","text":"In this implementation, the conditions to signal drift and warning are \\(p_i + s_i > thershold\\) instead of \\(p_i + s_i \\geq thershold\\) . This is to avoid a corner case when a classifier is consistently wrong ( value=1 ) that results in DDM indicating a drift every min_num_instances . This modification is consistent with the implementation in MOA.","title":"Notes"},{"location":"api/drift/DDM/#references","text":"Jo\u00e3o Gama, Pedro Medas, Gladys Castillo, Pedro Pereira Rodrigues: Learning with Drift Detection. SBIA 2004: 286-295 \u21a9","title":"References"},{"location":"api/drift/EDDM/","text":"EDDM \u00b6 Early Drift Detection Method. EDDM (Early Drift Detection Method) aims to improve the detection rate of gradual concept drift in DDM, while keeping a good performance against abrupt concept drift. This method works by keeping track of the average distance between two errors instead of only the error rate. For this, it is necessary to keep track of the running average distance and the running standard deviation, as well as the maximum distance and the maximum standard deviation. The algorithm works similarly to the DDM algorithm, by keeping track of statistics only. It works with the running average distance ( \\(p_i'\\) ) and the running standard deviation ( \\(s_i'\\) ), as well as \\(p'_{max}\\) and \\(s'_{max}\\) , which are the values of \\(p_i'\\) and \\(s_i'\\) when \\((p_i' + 2 * s_i')\\) reaches its maximum. Like DDM, there are two threshold values that define the borderline between no change, warning zone, and drift detected. These are as follows: if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\alpha\\) -> Warning zone if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\beta\\) -> Change detected \\(\\alpha\\) and \\(\\beta\\) are set to 0.95 and 0.9, respectively. Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Parameters \u00b6 min_num_instances \u2013 defaults to 30 The minimum required number of analyzed samples so change can be detected. This is used to avoid false detections during the early moments of the detector, when the weight of one sample is important. warning_level \u2013 defaults to 0.95 Warning level. out_control_level \u2013 defaults to 0.9 Out-control level. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import random >>> from river import drift >>> rng = random . Random ( 42 ) >>> eddm = drift . EDDM () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = eddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 105 , input value : 1 Change detected at index 245 , input value : 1 Change detected at index 332 , input value : 1 Change detected at index 451 , input value : 1 Change detected at index 537 , input value : 1 Change detected at index 843 , input value : 1 Change detected at index 914 , input value : 1 Change detected at index 1015 , input value : 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. References \u00b6 Early Drift Detection Method. Manuel Baena-Garcia, Jose Del Campo-Avila, Ra\u00fal Fidalgo, Albert Bifet, Ricard Gavalda, Rafael Morales-Bueno. In Fourth International Workshop on Knowledge Discovery from Data Streams, 2006. \u21a9","title":"EDDM"},{"location":"api/drift/EDDM/#eddm","text":"Early Drift Detection Method. EDDM (Early Drift Detection Method) aims to improve the detection rate of gradual concept drift in DDM, while keeping a good performance against abrupt concept drift. This method works by keeping track of the average distance between two errors instead of only the error rate. For this, it is necessary to keep track of the running average distance and the running standard deviation, as well as the maximum distance and the maximum standard deviation. The algorithm works similarly to the DDM algorithm, by keeping track of statistics only. It works with the running average distance ( \\(p_i'\\) ) and the running standard deviation ( \\(s_i'\\) ), as well as \\(p'_{max}\\) and \\(s'_{max}\\) , which are the values of \\(p_i'\\) and \\(s_i'\\) when \\((p_i' + 2 * s_i')\\) reaches its maximum. Like DDM, there are two threshold values that define the borderline between no change, warning zone, and drift detected. These are as follows: if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\alpha\\) -> Warning zone if \\((p_i' + 2 * s_i')/(p'_{max} + 2 * s'_{max}) < \\beta\\) -> Change detected \\(\\alpha\\) and \\(\\beta\\) are set to 0.95 and 0.9, respectively. Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\)","title":"EDDM"},{"location":"api/drift/EDDM/#parameters","text":"min_num_instances \u2013 defaults to 30 The minimum required number of analyzed samples so change can be detected. This is used to avoid false detections during the early moments of the detector, when the weight of one sample is important. warning_level \u2013 defaults to 0.95 Warning level. out_control_level \u2013 defaults to 0.9 Out-control level.","title":"Parameters"},{"location":"api/drift/EDDM/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/EDDM/#examples","text":">>> import random >>> from river import drift >>> rng = random . Random ( 42 ) >>> eddm = drift . EDDM () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = eddm . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 105 , input value : 1 Change detected at index 245 , input value : 1 Change detected at index 332 , input value : 1 Change detected at index 451 , input value : 1 Change detected at index 537 , input value : 1 Change detected at index 843 , input value : 1 Change detected at index 914 , input value : 1 Change detected at index 1015 , input value : 1","title":"Examples"},{"location":"api/drift/EDDM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/EDDM/#references","text":"Early Drift Detection Method. Manuel Baena-Garcia, Jose Del Campo-Avila, Ra\u00fal Fidalgo, Albert Bifet, Ricard Gavalda, Rafael Morales-Bueno. In Fourth International Workshop on Knowledge Discovery from Data Streams, 2006. \u21a9","title":"References"},{"location":"api/drift/HDDM-A/","text":"HDDM_A \u00b6 Drift Detection Method based on Hoeffding\u2019s bounds with moving average-test. HDDM_A is a drift detection method based on the Hoeffding\u2019s inequality. HDDM_A uses the average as estimator. It receives as input a stream of real values and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA. Parameters \u00b6 drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning two_sided_test \u2013 defaults to False If True , will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided). Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import random >>> from river.drift import HDDM_A >>> rng = random . Random ( 42 ) >>> hddm_a = HDDM_A () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_a . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1046 , input value : 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. References \u00b6 Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"HDDM_A"},{"location":"api/drift/HDDM-A/#hddm_a","text":"Drift Detection Method based on Hoeffding\u2019s bounds with moving average-test. HDDM_A is a drift detection method based on the Hoeffding\u2019s inequality. HDDM_A uses the average as estimator. It receives as input a stream of real values and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA.","title":"HDDM_A"},{"location":"api/drift/HDDM-A/#parameters","text":"drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning two_sided_test \u2013 defaults to False If True , will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).","title":"Parameters"},{"location":"api/drift/HDDM-A/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/HDDM-A/#examples","text":">>> import random >>> from river.drift import HDDM_A >>> rng = random . Random ( 42 ) >>> hddm_a = HDDM_A () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_a . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1046 , input value : 1","title":"Examples"},{"location":"api/drift/HDDM-A/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/HDDM-A/#references","text":"Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"References"},{"location":"api/drift/HDDM-W/","text":"HDDM_W \u00b6 Drift Detection Method based on Hoeffding\u2019s bounds with moving weighted average-test. HDDM_W is an online drift detection method based on McDiarmid's bounds. HDDM_W uses the Exponentially Weighted Moving Average (EWMA) statistic as estimator. It receives as input a stream of real predictions and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA. Parameters \u00b6 drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning lambda_option \u2013 defaults to 0.05 The weight given to recent data. Smaller values mean less weight given to recent data. two_sided_test \u2013 defaults to False If True, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided). Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import random >>> from river import drift >>> rng = random . Random ( 42 ) >>> hddm_w = drift . HDDM_W () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_w . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1014 , input value : 1 Methods \u00b6 SampleInfo clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple References \u00b6 Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"HDDM_W"},{"location":"api/drift/HDDM-W/#hddm_w","text":"Drift Detection Method based on Hoeffding\u2019s bounds with moving weighted average-test. HDDM_W is an online drift detection method based on McDiarmid's bounds. HDDM_W uses the Exponentially Weighted Moving Average (EWMA) statistic as estimator. It receives as input a stream of real predictions and returns the estimated status of the stream: STABLE, WARNING or DRIFT. Input: value must be a binary signal, where 1 indicates error. For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t the true target label \\(y\\) : 0: Correct, \\(y=y'\\) 1: Error, \\(y \\neq y'\\) Implementation based on MOA.","title":"HDDM_W"},{"location":"api/drift/HDDM-W/#parameters","text":"drift_confidence \u2013 defaults to 0.001 Confidence to the drift warning_confidence \u2013 defaults to 0.005 Confidence to the warning lambda_option \u2013 defaults to 0.05 The weight given to recent data. Smaller values mean less weight given to recent data. two_sided_test \u2013 defaults to False If True, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).","title":"Parameters"},{"location":"api/drift/HDDM-W/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/HDDM-W/#examples","text":">>> import random >>> from river import drift >>> rng = random . Random ( 42 ) >>> hddm_w = drift . HDDM_W () >>> # Simulate a data stream as a uniform distribution of 1's and 0's >>> data_stream = rng . choices ([ 0 , 1 ], k = 2000 ) >>> # Change the data distribution from index 999 to 1500, simulating an >>> # increase in error rate (1 indicates error) >>> data_stream [ 999 : 1500 ] = [ 1 ] * 500 >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , in_warning = hddm_w . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1014 , input value : 1","title":"Examples"},{"location":"api/drift/HDDM-W/#methods","text":"SampleInfo clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : tuple","title":"Methods"},{"location":"api/drift/HDDM-W/#references","text":"Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"References"},{"location":"api/drift/KSWIN/","text":"KSWIN \u00b6 Kolmogorov-Smirnov Windowing method for concept drift detection. Parameters \u00b6 alpha ( float ) \u2013 defaults to 0.005 Probability for the test statistic of the Kolmogorov-Smirnov-Test. The alpha parameter is very sensitive, therefore should be set below 0.01. window_size ( int ) \u2013 defaults to 100 Size of the sliding window. stat_size ( int ) \u2013 defaults to 30 Size of the statistic window. seed ( int ) \u2013 defaults to None Random seed for reproducibility. window ( Iterable ) \u2013 defaults to None Already collected data to avoid cold start. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import random >>> from river import drift >>> rng = random . Random ( 12345 ) >>> kswin = drift . KSWIN ( alpha = 0.0001 , seed = 42 ) >>> # Simulate a data stream composed by two data distributions >>> data_stream = rng . choices ([ 0 , 1 ], k = 1000 ) + rng . choices ( range ( 4 , 8 ), k = 1000 ) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , _ = kswin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) ... kswin . reset () # Good practice Change detected at index 1016 , input value : 6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Adds an element on top of the sliding window and removes the oldest one from the window. Afterwards, the KS-test is performed. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. Notes \u00b6 KSWIN (Kolmogorov-Smirnov Windowing) is a concept change detection method based on the Kolmogorov-Smirnov (KS) statistical test. KS-test is a statistical test with no assumption of underlying data distribution. KSWIN can monitor data or performance distributions. Note that the detector accepts one dimensional input as array. KSWIN maintains a sliding window \\(\\Psi\\) of fixed size \\(n\\) (window_size). The last \\(r\\) (stat_size) samples of \\(\\Psi\\) are assumed to represent the last concept considered as \\(R\\) . From the first \\(n-r\\) samples of \\(\\Psi\\) , \\(r\\) samples are uniformly drawn, representing an approximated last concept \\(W\\) . The KS-test is performed on the windows \\(R\\) and \\(W\\) of the same size. KS -test compares the distance of the empirical cumulative data distribution \\(dist(R,W)\\) . A concept drift is detected by KSWIN if: \\[ dist(R,W) > \\sqrt{-\\frac{ln\\alpha}{r}} \\] The difference in empirical data distributions between the windows \\(R\\) and \\(W\\) is too large since \\(R\\) and \\(W\\) come from the same distribution. References \u00b6 Christoph Raab, Moritz Heusinger, Frank-Michael Schleif, Reactive Soft Prototype Computing for Concept Drift Streams, Neurocomputing, 2020, \u21a9","title":"KSWIN"},{"location":"api/drift/KSWIN/#kswin","text":"Kolmogorov-Smirnov Windowing method for concept drift detection.","title":"KSWIN"},{"location":"api/drift/KSWIN/#parameters","text":"alpha ( float ) \u2013 defaults to 0.005 Probability for the test statistic of the Kolmogorov-Smirnov-Test. The alpha parameter is very sensitive, therefore should be set below 0.01. window_size ( int ) \u2013 defaults to 100 Size of the sliding window. stat_size ( int ) \u2013 defaults to 30 Size of the statistic window. seed ( int ) \u2013 defaults to None Random seed for reproducibility. window ( Iterable ) \u2013 defaults to None Already collected data to avoid cold start.","title":"Parameters"},{"location":"api/drift/KSWIN/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/KSWIN/#examples","text":">>> import random >>> from river import drift >>> rng = random . Random ( 12345 ) >>> kswin = drift . KSWIN ( alpha = 0.0001 , seed = 42 ) >>> # Simulate a data stream composed by two data distributions >>> data_stream = rng . choices ([ 0 , 1 ], k = 1000 ) + rng . choices ( range ( 4 , 8 ), k = 1000 ) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , _ = kswin . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) ... kswin . reset () # Good practice Change detected at index 1016 , input value : 6","title":"Examples"},{"location":"api/drift/KSWIN/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Adds an element on top of the sliding window and removes the oldest one from the window. Afterwards, the KS-test is performed. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/KSWIN/#notes","text":"KSWIN (Kolmogorov-Smirnov Windowing) is a concept change detection method based on the Kolmogorov-Smirnov (KS) statistical test. KS-test is a statistical test with no assumption of underlying data distribution. KSWIN can monitor data or performance distributions. Note that the detector accepts one dimensional input as array. KSWIN maintains a sliding window \\(\\Psi\\) of fixed size \\(n\\) (window_size). The last \\(r\\) (stat_size) samples of \\(\\Psi\\) are assumed to represent the last concept considered as \\(R\\) . From the first \\(n-r\\) samples of \\(\\Psi\\) , \\(r\\) samples are uniformly drawn, representing an approximated last concept \\(W\\) . The KS-test is performed on the windows \\(R\\) and \\(W\\) of the same size. KS -test compares the distance of the empirical cumulative data distribution \\(dist(R,W)\\) . A concept drift is detected by KSWIN if: \\[ dist(R,W) > \\sqrt{-\\frac{ln\\alpha}{r}} \\] The difference in empirical data distributions between the windows \\(R\\) and \\(W\\) is too large since \\(R\\) and \\(W\\) come from the same distribution.","title":"Notes"},{"location":"api/drift/KSWIN/#references","text":"Christoph Raab, Moritz Heusinger, Frank-Michael Schleif, Reactive Soft Prototype Computing for Concept Drift Streams, Neurocomputing, 2020, \u21a9","title":"References"},{"location":"api/drift/PageHinkley/","text":"PageHinkley \u00b6 Page-Hinkley method for concept drift detection. This change detection method works by computing the observed values and their mean up to the current moment. Page-Hinkley does not signal warning zones, only change detections. The method works by means of the Page-Hinkley test. In general lines it will detect a concept drift if the observed mean at some instant is greater then a threshold value lambda. Parameters \u00b6 min_instances \u2013 defaults to 30 The minimum number of instances before detecting change. delta \u2013 defaults to 0.005 The delta factor for the Page Hinkley test. threshold \u2013 defaults to 50 The change detection threshold (lambda). alpha \u2013 defaults to 0.9999 The forgetting factor, used to weight the observed value and the mean. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import random >>> from river import drift >>> rng = random . Random ( 12345 ) >>> ph = drift . PageHinkley () >>> # Simulate a data stream composed by two data distributions >>> data_stream = rng . choices ([ 0 , 1 ], k = 1000 ) + rng . choices ( range ( 4 , 8 ), k = 1000 ) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , _ = ph . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1006 , input value : 5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. References \u00b6 E. S. Page. 1954. Continuous Inspection Schemes. Biometrika 41, 1/2 (1954), 100\u2013115. \u21a9","title":"PageHinkley"},{"location":"api/drift/PageHinkley/#pagehinkley","text":"Page-Hinkley method for concept drift detection. This change detection method works by computing the observed values and their mean up to the current moment. Page-Hinkley does not signal warning zones, only change detections. The method works by means of the Page-Hinkley test. In general lines it will detect a concept drift if the observed mean at some instant is greater then a threshold value lambda.","title":"PageHinkley"},{"location":"api/drift/PageHinkley/#parameters","text":"min_instances \u2013 defaults to 30 The minimum number of instances before detecting change. delta \u2013 defaults to 0.005 The delta factor for the Page Hinkley test. threshold \u2013 defaults to 50 The change detection threshold (lambda). alpha \u2013 defaults to 0.9999 The forgetting factor, used to weight the observed value and the mean.","title":"Parameters"},{"location":"api/drift/PageHinkley/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/PageHinkley/#examples","text":">>> import random >>> from river import drift >>> rng = random . Random ( 12345 ) >>> ph = drift . PageHinkley () >>> # Simulate a data stream composed by two data distributions >>> data_stream = rng . choices ([ 0 , 1 ], k = 1000 ) + rng . choices ( range ( 4 , 8 ), k = 1000 ) >>> # Update drift detector and verify if change is detected >>> for i , val in enumerate ( data_stream ): ... in_drift , _ = ph . update ( val ) ... if in_drift : ... print ( f \"Change detected at index { i } , input value: { val } \" ) Change detected at index 1006 , input value : 5","title":"Examples"},{"location":"api/drift/PageHinkley/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns tuple : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/PageHinkley/#references","text":"E. S. Page. 1954. Continuous Inspection Schemes. Biometrika 41, 1/2 (1954), 100\u2013115. \u21a9","title":"References"},{"location":"api/drift/PeriodicTrigger/","text":"PeriodicTrigger \u00b6 Generate pseudo drift detection signals. There are two approaches 1 : fixed where the drift signal is generated every t_0 samples. - random corresponds to a pseudo-random drift detection strategy. Parameters \u00b6 trigger_method ( str ) \u2013 defaults to fixed The trigger method to use. * fixed * random t_0 ( int ) \u2013 defaults to 300 Reference point to define triggers. w ( int ) \u2013 defaults to 0 Auxiliary parameter whose purpose is twofold: - if trigger_method=\"fixed\" , the periodic drift signals will only start after an initial warm-up period randomly defined between [0, w] . Useful to avoid that all ensemble members are reset at the same time when periodic triggers are used as the adaptation strategy. - if trigger_method=\"random\" , w defines the probability bounds of triggering a drift. The chance of triggering a drift is \\(0.5\\) after observing t_0 instances and becomes \\(1\\) after monitoring t_0 + w / 2 instances. A sigmoid function is used to produce values between [0, 1] that are used as the reset probabilities. dynamic_cloning ( bool ) \u2013 defaults to False Whether to change the seed and w values each time clone() is called. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Attributes \u00b6 change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone. Examples \u00b6 >>> import random >>> from river import drift >>> rng = random . Random ( 42 ) The observed values will not affect the periodic triggers. >>> data = [ rng . gauss ( 0 , 1 ) for _ in range ( 1000 )] Let's start with the fixed drift signals: >>> ptrigger = PeriodicTrigger ( t_0 = 500 , seed = 42 ) >>> for i , v in enumerate ( data ): ... in_drift , _ = ptrigger . update ( v ) ... if in_drift : ... print ( f \"Drift detected at instance { i } .\" ) Drift detected at instance 499. Drift detected at instance 999. Now, the random drift signals: >>> rtrigger = PeriodicTrigger ( ... trigger_method = \"random\" , ... t_0 = 500 , ... w = 100 , ... dynamic_cloning = True , ... seed = 42 ... ) >>> for i , v in enumerate ( data ): ... in_drift , _ = rtrigger . update ( v ) ... if in_drift : ... print ( f \"Drift detected at instance { i } .\" ) Drift detected at instance 368. Drift detected at instance 817. Remember to set a w > 0 value if random triggers are used: >>> try : ... PeriodicTrigger ( trigger_method = \"random\" ) ... except ValueError as ve : ... print ( ve ) The 'w' value must be greater than zero when 'trigger_method' is 'random' . Since we set dynamic_cloning to True , a clone of the periodic trigger will have its internal paramenters changed: >>> rtrigger = rtrigger . clone () >>> for i , v in enumerate ( data ): ... in_drift , _ = rtrigger . update ( v ) ... if in_drift : ... print ( f \"Drift detected at instance { i } .\" ) Drift detected at instance 429. Drift detected at instance 728. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected. Notes \u00b6 When used in ensembles, a naive implementation of periodic drift signals would make all ensemble members reset at the same time. To avoid that, the dynamic_cloning parameter can be set to True . In this case, every time the clone method of this detector is called in an ensemble a new seed is defined. If dynamic_cloning=True and trigger_method=\"fixed\" , a new w between [0, t_0] will also be created for the new cloned instance. References \u00b6 Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini, Bernhard Pfahringer, and Albert Bifet. On Ensemble Techniques for Data Stream Regression. IJCNN'20. International Joint Conference on Neural Networks. 2020. \u21a9","title":"PeriodicTrigger"},{"location":"api/drift/PeriodicTrigger/#periodictrigger","text":"Generate pseudo drift detection signals. There are two approaches 1 : fixed where the drift signal is generated every t_0 samples. - random corresponds to a pseudo-random drift detection strategy.","title":"PeriodicTrigger"},{"location":"api/drift/PeriodicTrigger/#parameters","text":"trigger_method ( str ) \u2013 defaults to fixed The trigger method to use. * fixed * random t_0 ( int ) \u2013 defaults to 300 Reference point to define triggers. w ( int ) \u2013 defaults to 0 Auxiliary parameter whose purpose is twofold: - if trigger_method=\"fixed\" , the periodic drift signals will only start after an initial warm-up period randomly defined between [0, w] . Useful to avoid that all ensemble members are reset at the same time when periodic triggers are used as the adaptation strategy. - if trigger_method=\"random\" , w defines the probability bounds of triggering a drift. The chance of triggering a drift is \\(0.5\\) after observing t_0 instances and becomes \\(1\\) after monitoring t_0 + w / 2 instances. A sigmoid function is used to produce values between [0, 1] that are used as the reset probabilities. dynamic_cloning ( bool ) \u2013 defaults to False Whether to change the seed and w values each time clone() is called. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/drift/PeriodicTrigger/#attributes","text":"change_detected Concept drift alarm. True if concept drift is detected. warning_detected Warning zone alarm. Indicates if the drift detector is in the warning zone. Applicability depends on each drift detector implementation. True if the change detector is in the warning zone.","title":"Attributes"},{"location":"api/drift/PeriodicTrigger/#examples","text":">>> import random >>> from river import drift >>> rng = random . Random ( 42 ) The observed values will not affect the periodic triggers. >>> data = [ rng . gauss ( 0 , 1 ) for _ in range ( 1000 )] Let's start with the fixed drift signals: >>> ptrigger = PeriodicTrigger ( t_0 = 500 , seed = 42 ) >>> for i , v in enumerate ( data ): ... in_drift , _ = ptrigger . update ( v ) ... if in_drift : ... print ( f \"Drift detected at instance { i } .\" ) Drift detected at instance 499. Drift detected at instance 999. Now, the random drift signals: >>> rtrigger = PeriodicTrigger ( ... trigger_method = \"random\" , ... t_0 = 500 , ... w = 100 , ... dynamic_cloning = True , ... seed = 42 ... ) >>> for i , v in enumerate ( data ): ... in_drift , _ = rtrigger . update ( v ) ... if in_drift : ... print ( f \"Drift detected at instance { i } .\" ) Drift detected at instance 368. Drift detected at instance 817. Remember to set a w > 0 value if random triggers are used: >>> try : ... PeriodicTrigger ( trigger_method = \"random\" ) ... except ValueError as ve : ... print ( ve ) The 'w' value must be greater than zero when 'trigger_method' is 'random' . Since we set dynamic_cloning to True , a clone of the periodic trigger will have its internal paramenters changed: >>> rtrigger = rtrigger . clone () >>> for i , v in enumerate ( data ): ... in_drift , _ = rtrigger . update ( v ) ... if in_drift : ... print ( f \"Drift detected at instance { i } .\" ) Drift detected at instance 429. Drift detected at instance 728.","title":"Examples"},{"location":"api/drift/PeriodicTrigger/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. reset Reset the change detector. update Update the change detector with a single data point. Parameters value ( numbers.Number ) Returns typing.Tuple[bool, bool] : A tuple (drift, warning) where its elements indicate if a drift or a warning is detected.","title":"Methods"},{"location":"api/drift/PeriodicTrigger/#notes","text":"When used in ensembles, a naive implementation of periodic drift signals would make all ensemble members reset at the same time. To avoid that, the dynamic_cloning parameter can be set to True . In this case, every time the clone method of this detector is called in an ensemble a new seed is defined. If dynamic_cloning=True and trigger_method=\"fixed\" , a new w between [0, t_0] will also be created for the new cloned instance.","title":"Notes"},{"location":"api/drift/PeriodicTrigger/#references","text":"Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini, Bernhard Pfahringer, and Albert Bifet. On Ensemble Techniques for Data Stream Regression. IJCNN'20. International Joint Conference on Neural Networks. 2020. \u21a9","title":"References"},{"location":"api/dummy/NoChangeClassifier/","text":"NoChangeClassifier \u00b6 Dummy classifier which returns the last class seen. The predict_one method will output the last class seen whilst predict_proba_one will return 1 for the last class seen and 0 for the others. Attributes \u00b6 last_class The last class seen. classes The set of classes seen. Examples \u00b6 Taken from example 2.1 from this page . >>> import pprint >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . NoChangeClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '\u2212' >>> pprint . pprint ( model . predict_proba_one ( new_sentence )) { '+' : 0 , '\u2212' : 1 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"NoChangeClassifier"},{"location":"api/dummy/NoChangeClassifier/#nochangeclassifier","text":"Dummy classifier which returns the last class seen. The predict_one method will output the last class seen whilst predict_proba_one will return 1 for the last class seen and 0 for the others.","title":"NoChangeClassifier"},{"location":"api/dummy/NoChangeClassifier/#attributes","text":"last_class The last class seen. classes The set of classes seen.","title":"Attributes"},{"location":"api/dummy/NoChangeClassifier/#examples","text":"Taken from example 2.1 from this page . >>> import pprint >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . NoChangeClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '\u2212' >>> pprint . pprint ( model . predict_proba_one ( new_sentence )) { '+' : 0 , '\u2212' : 1 }","title":"Examples"},{"location":"api/dummy/NoChangeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/dummy/PriorClassifier/","text":"PriorClassifier \u00b6 Dummy classifier which uses the prior distribution. The predict_one method will output the most common class whilst predict_proba_one will return the normalized class counts. Attributes \u00b6 counts ( collections.Counter ) Class counts. n ( int ) Total number of seen instances. Examples \u00b6 Taken from example 2.1 from this page >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . PriorClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '+' >>> model . predict_proba_one ( new_sentence ) { '+' : 0.75 , '\u2212' : 0.25 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"PriorClassifier"},{"location":"api/dummy/PriorClassifier/#priorclassifier","text":"Dummy classifier which uses the prior distribution. The predict_one method will output the most common class whilst predict_proba_one will return the normalized class counts.","title":"PriorClassifier"},{"location":"api/dummy/PriorClassifier/#attributes","text":"counts ( collections.Counter ) Class counts. n ( int ) Total number of seen instances.","title":"Attributes"},{"location":"api/dummy/PriorClassifier/#examples","text":"Taken from example 2.1 from this page >>> from river import dummy >>> sentences = [ ... ( 'glad happy glad' , '+' ), ... ( 'glad glad joyful' , '+' ), ... ( 'glad pleasant' , '+' ), ... ( 'miserable sad glad' , '\u2212' ) ... ] >>> model = dummy . PriorClassifier () >>> for sentence , label in sentences : ... model = model . learn_one ( sentence , label ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) '+' >>> model . predict_proba_one ( new_sentence ) { '+' : 0.75 , '\u2212' : 0.25 }","title":"Examples"},{"location":"api/dummy/PriorClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/dummy/StatisticRegressor/","text":"StatisticRegressor \u00b6 Dummy regressor that uses a univariate statistic to make predictions. Parameters \u00b6 statistic ( river.stats.base.Univariate ) Examples \u00b6 >>> from pprint import pprint >>> from river import dummy >>> from river import stats >>> sentences = [ ... ( 'glad happy glad' , 3 ), ... ( 'glad glad joyful' , 3 ), ... ( 'glad pleasant' , 2 ), ... ( 'miserable sad glad' , - 3 ) ... ] >>> model = dummy . StatisticRegressor ( stats . Mean ()) >>> for sentence , score in sentences : ... model = model . learn_one ( sentence , score ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) 1.25 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"StatisticRegressor"},{"location":"api/dummy/StatisticRegressor/#statisticregressor","text":"Dummy regressor that uses a univariate statistic to make predictions.","title":"StatisticRegressor"},{"location":"api/dummy/StatisticRegressor/#parameters","text":"statistic ( river.stats.base.Univariate )","title":"Parameters"},{"location":"api/dummy/StatisticRegressor/#examples","text":">>> from pprint import pprint >>> from river import dummy >>> from river import stats >>> sentences = [ ... ( 'glad happy glad' , 3 ), ... ( 'glad glad joyful' , 3 ), ... ( 'glad pleasant' , 2 ), ... ( 'miserable sad glad' , - 3 ) ... ] >>> model = dummy . StatisticRegressor ( stats . Mean ()) >>> for sentence , score in sentences : ... model = model . learn_one ( sentence , score ) >>> new_sentence = 'glad sad miserable pleasant glad' >>> model . predict_one ( new_sentence ) 1.25","title":"Examples"},{"location":"api/dummy/StatisticRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/ensemble/ADWINBaggingClassifier/","text":"ADWINBaggingClassifier \u00b6 ADWIN Bagging classifier. ADWIN Bagging 1 is the online bagging method of Oza and Russell 2 with the addition of the ADWIN algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier. Parameters \u00b6 model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 models Examples \u00b6 >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . ADWINBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.83 % Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Averages the predictions of each classifier. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009. \u21a9 Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001. \u21a9","title":"ADWINBaggingClassifier"},{"location":"api/ensemble/ADWINBaggingClassifier/#adwinbaggingclassifier","text":"ADWIN Bagging classifier. ADWIN Bagging 1 is the online bagging method of Oza and Russell 2 with the addition of the ADWIN algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.","title":"ADWINBaggingClassifier"},{"location":"api/ensemble/ADWINBaggingClassifier/#parameters","text":"model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/ADWINBaggingClassifier/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/ADWINBaggingClassifier/#examples","text":">>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . ADWINBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.83 %","title":"Examples"},{"location":"api/ensemble/ADWINBaggingClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Averages the predictions of each classifier. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/ADWINBaggingClassifier/#references","text":"Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009. \u21a9 Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001. \u21a9","title":"References"},{"location":"api/ensemble/AdaBoostClassifier/","text":"AdaBoostClassifier \u00b6 Boosting for classification For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter lambda. The lambda parameter is updated when the weaks learners fit successively the same observation. Parameters \u00b6 model ( base.Classifier ) The classifier to boost. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 wrong_weight ( collections.defaultdict ) Number of times a model has made a mistake when making predictions. correct_weight ( collections.defaultdict ) Number of times a model has predicted the right label when making predictions. Examples \u00b6 In the following example three tree classifiers are boosted together. The performance is slightly better than when using a single tree. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . Phishing () >>> metric = metrics . LogLoss () >>> model = ensemble . AdaBoostClassifier ( ... model = ( ... tree . HoeffdingTreeClassifier ( ... split_criterion = 'gini' , ... split_confidence = 1e-5 , ... grace_period = 2000 ... ) ... ), ... n_models = 5 , ... seed = 42 ... ) >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.370805 >>> print ( model ) AdaBoostClassifier ( HoeffdingTreeClassifier ) Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"AdaBoostClassifier"},{"location":"api/ensemble/AdaBoostClassifier/#adaboostclassifier","text":"Boosting for classification For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter lambda. The lambda parameter is updated when the weaks learners fit successively the same observation.","title":"AdaBoostClassifier"},{"location":"api/ensemble/AdaBoostClassifier/#parameters","text":"model ( base.Classifier ) The classifier to boost. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/AdaBoostClassifier/#attributes","text":"wrong_weight ( collections.defaultdict ) Number of times a model has made a mistake when making predictions. correct_weight ( collections.defaultdict ) Number of times a model has predicted the right label when making predictions.","title":"Attributes"},{"location":"api/ensemble/AdaBoostClassifier/#examples","text":"In the following example three tree classifiers are boosted together. The performance is slightly better than when using a single tree. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . Phishing () >>> metric = metrics . LogLoss () >>> model = ensemble . AdaBoostClassifier ( ... model = ( ... tree . HoeffdingTreeClassifier ( ... split_criterion = 'gini' , ... split_confidence = 1e-5 , ... grace_period = 2000 ... ) ... ), ... n_models = 5 , ... seed = 42 ... ) >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.370805 >>> print ( model ) AdaBoostClassifier ( HoeffdingTreeClassifier )","title":"Examples"},{"location":"api/ensemble/AdaBoostClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/AdaBoostClassifier/#references","text":"Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"References"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/","text":"AdaptiveRandomForestClassifier \u00b6 Adaptive Random Forest classifier. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts It also allows training background trees, which start training if a warning is detected and replace the active tree if the warning escalates to a drift. Parameters \u00b6 n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features ( Union[bool, str, int] ) \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.MultiClassMetric ) \u2013 defaults to Accuracy: 0.00% Metric used to track trees performance within the ensemble. disable_weighted_vote \u2013 defaults to False If True , disables the weighted vote prediction. drift_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain [ Tree parameter ] Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Hellinger Distance split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba [ Tree parameter ] Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 [ Tree parameter ] Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None [ Tree parameter ] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False [ Tree parameter ] If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False [ Tree parameter ] If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False [ Tree parameter ] If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True [ Tree parameter ] If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Attributes \u00b6 models Examples \u00b6 >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import synth >>> dataset = synth . ConceptDriftStream ( seed = 42 , position = 500 , ... width = 40 ) . take ( 1000 ) >>> model = ensemble . AdaptiveRandomForestClassifier ( seed = 8 , leaf_prediction = \"mc\" ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 76.68 % Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Heitor Murilo Gomes, Albert Bifet, Jesse Read, Jean Paul Barddal, Fabricio Enembreck, Bernhard Pfharinger, Geoff Holmes, Talel Abdessalem. Adaptive random forests for evolving data stream classification. In Machine Learning, DOI: 10.1007/s10994-017-5642-8, Springer, 2017. \u21a9","title":"AdaptiveRandomForestClassifier"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#adaptiverandomforestclassifier","text":"Adaptive Random Forest classifier. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts It also allows training background trees, which start training if a warning is detected and replace the active tree if the warning escalates to a drift.","title":"AdaptiveRandomForestClassifier"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#parameters","text":"n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features ( Union[bool, str, int] ) \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.MultiClassMetric ) \u2013 defaults to Accuracy: 0.00% Metric used to track trees performance within the ensemble. disable_weighted_vote \u2013 defaults to False If True , disables the weighted vote prediction. drift_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( Union[ base.DriftDetector , NoneType] ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain [ Tree parameter ] Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Hellinger Distance split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba [ Tree parameter ] Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 [ Tree parameter ] Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None [ Tree parameter ] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False [ Tree parameter ] If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False [ Tree parameter ] If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False [ Tree parameter ] If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True [ Tree parameter ] If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#examples","text":">>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import synth >>> dataset = synth . ConceptDriftStream ( seed = 42 , position = 500 , ... width = 40 ) . take ( 1000 ) >>> model = ensemble . AdaptiveRandomForestClassifier ( seed = 8 , leaf_prediction = \"mc\" ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 76.68 %","title":"Examples"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/AdaptiveRandomForestClassifier/#references","text":"Heitor Murilo Gomes, Albert Bifet, Jesse Read, Jean Paul Barddal, Fabricio Enembreck, Bernhard Pfharinger, Geoff Holmes, Talel Abdessalem. Adaptive random forests for evolving data stream classification. In Machine Learning, DOI: 10.1007/s10994-017-5642-8, Springer, 2017. \u21a9","title":"References"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/","text":"AdaptiveRandomForestRegressor \u00b6 Adaptive Random Forest regressor. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts Notice that this implementation is slightly different from the original algorithm proposed in 2 . The HoeffdingTreeRegressor is used as base learner, instead of FIMT-DD . It also adds a new strategy to monitor the predictions and check for concept drifts. The deviations of the predictions to the target are monitored and normalized in the [0, 1] range to fulfill ADWIN's requirements. We assume that the data subjected to the normalization follows a normal distribution, and thus, lies within the interval of the mean \\(\\pm3\\sigma\\) . Parameters \u00b6 n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . aggregation_method ( str ) \u2013 defaults to median The method to use to aggregate predictions in the ensemble. - 'mean' - 'median' - If selected will disable the weighted vote. lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to MSE: 0. Metric used to track trees performance within the ensemble. Depending, on the configuration, this metric is also used to weight predictions from the members of the ensemble. disable_weighted_vote \u2013 defaults to True If True , disables the weighted vote prediction, i.e. does not assign weights to individual tree's predictions and uses the arithmetic mean instead. Otherwise will use the metric value to weight predictions. drift_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model [ Tree parameter ] Prediction mechanism used at leaves. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None [ Tree parameter ] The regression model used to provide responses if leaf_prediction='model' . If not provided, an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 [ Tree parameter ] The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None [ Tree parameter ] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters.By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 [ Tree parameter ] The minimum number of samples every branch resulting from a split candidate must have to be considered valid. binary_split ( bool ) \u2013 defaults to False [ Tree parameter ] If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False [ Tree parameter ] If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False [ Tree parameter ] If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True [ Tree parameter ] If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Attributes \u00b6 models valid_aggregation_method Valid aggregation_method values. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import ensemble >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... ensemble . AdaptiveRandomForestRegressor ( seed = 42 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.134919 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Gomes, H.M., Bifet, A., Read, J., Barddal, J.P., Enembreck, F., Pfharinger, B., Holmes, G. and Abdessalem, T., 2017. Adaptive random forests for evolving data stream classification. Machine Learning, 106(9-10), pp.1469-1495. \u21a9 Gomes, H.M., Barddal, J.P., Boiko, L.E., Bifet, A., 2018. Adaptive random forests for data stream regression. ESANN 2018. \u21a9","title":"AdaptiveRandomForestRegressor"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#adaptiverandomforestregressor","text":"Adaptive Random Forest regressor. The 3 most important aspects of Adaptive Random Forest 1 are: inducing diversity through re-sampling inducing diversity through randomly selecting subsets of features for node splits drift detectors per base tree, which cause selective resets in response to drifts Notice that this implementation is slightly different from the original algorithm proposed in 2 . The HoeffdingTreeRegressor is used as base learner, instead of FIMT-DD . It also adds a new strategy to monitor the predictions and check for concept drifts. The deviations of the predictions to the target are monitored and normalized in the [0, 1] range to fulfill ADWIN's requirements. We assume that the data subjected to the normalization follows a normal distribution, and thus, lies within the interval of the mean \\(\\pm3\\sigma\\) .","title":"AdaptiveRandomForestRegressor"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#parameters","text":"n_models ( int ) \u2013 defaults to 10 Number of trees in the ensemble. max_features \u2013 defaults to sqrt Max number of attributes for each node split. - If int , then consider max_features at each split. - If float , then max_features is a percentage and int(max_features * n_features) features are considered per split. - If \"sqrt\", then max_features=sqrt(n_features) . - If \"log2\", then max_features=log2(n_features) . - If None, then max_features=n_features . aggregation_method ( str ) \u2013 defaults to median The method to use to aggregate predictions in the ensemble. - 'mean' - 'median' - If selected will disable the weighted vote. lambda_value ( int ) \u2013 defaults to 6 The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging). metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to MSE: 0. Metric used to track trees performance within the ensemble. Depending, on the configuration, this metric is also used to weight predictions from the members of the ensemble. disable_weighted_vote \u2013 defaults to True If True , disables the weighted vote prediction, i.e. does not assign weights to individual tree's predictions and uses the arithmetic mean instead. Otherwise will use the metric value to weight predictions. drift_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Drift Detection method. Set to None to disable Drift detection. warning_detector ( base.DriftDetector ) \u2013 defaults to ADWIN Warning Detection method. Set to None to disable warning detection. grace_period ( int ) \u2013 defaults to 50 [ Tree parameter ] Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None [ Tree parameter ] The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 0.01 [ Tree parameter ] Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 [ Tree parameter ] Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model [ Tree parameter ] Prediction mechanism used at leaves. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None [ Tree parameter ] The regression model used to provide responses if leaf_prediction='model' . If not provided, an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 [ Tree parameter ] The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None [ Tree parameter ] List of Nominal attributes. If empty, then assume that all attributes are numerical. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None [ Tree parameter ] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters.By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 [ Tree parameter ] The minimum number of samples every branch resulting from a split candidate must have to be considered valid. binary_split ( bool ) \u2013 defaults to False [ Tree parameter ] If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 [ Tree parameter ] Maximum memory (MB) consumed by the tree. memory_estimate_period ( int ) \u2013 defaults to 2000000 [ Tree parameter ] Number of instances between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False [ Tree parameter ] If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False [ Tree parameter ] If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True [ Tree parameter ] If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#attributes","text":"models valid_aggregation_method Valid aggregation_method values.","title":"Attributes"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import ensemble >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... ensemble . AdaptiveRandomForestRegressor ( seed = 42 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.134919","title":"Examples"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/AdaptiveRandomForestRegressor/#references","text":"Gomes, H.M., Bifet, A., Read, J., Barddal, J.P., Enembreck, F., Pfharinger, B., Holmes, G. and Abdessalem, T., 2017. Adaptive random forests for evolving data stream classification. Machine Learning, 106(9-10), pp.1469-1495. \u21a9 Gomes, H.M., Barddal, J.P., Boiko, L.E., Bifet, A., 2018. Adaptive random forests for data stream regression. ESANN 2018. \u21a9","title":"References"},{"location":"api/ensemble/BaggingClassifier/","text":"BaggingClassifier \u00b6 Online bootstrap aggregation for classification. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.utils.random.poisson(1).pmf(k) to obtain more detailed values. Parameters \u00b6 model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 models Examples \u00b6 In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . BaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.83 % >>> print ( model ) BaggingClassifier ( StandardScaler | LogisticRegression ) Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Averages the predictions of each classifier. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"BaggingClassifier"},{"location":"api/ensemble/BaggingClassifier/#baggingclassifier","text":"Online bootstrap aggregation for classification. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.utils.random.poisson(1).pmf(k) to obtain more detailed values.","title":"BaggingClassifier"},{"location":"api/ensemble/BaggingClassifier/#parameters","text":"model ( base.Classifier ) The classifier to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/BaggingClassifier/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/BaggingClassifier/#examples","text":"In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . BaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.83 % >>> print ( model ) BaggingClassifier ( StandardScaler | LogisticRegression )","title":"Examples"},{"location":"api/ensemble/BaggingClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Averages the predictions of each classifier. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/BaggingClassifier/#references","text":"Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"References"},{"location":"api/ensemble/BaggingRegressor/","text":"BaggingRegressor \u00b6 Online bootstrap aggregation for regression. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.utils.random.poisson(1).pmf(k) for more detailed values. Parameters \u00b6 model ( base.Regressor ) The regressor to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 models Examples \u00b6 In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = preprocessing . StandardScaler () >>> model |= ensemble . BaggingRegressor ( ... model = linear_model . LinearRegression ( intercept_lr = 0.1 ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.68886 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Averages the predictions of each regressor. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"BaggingRegressor"},{"location":"api/ensemble/BaggingRegressor/#baggingregressor","text":"Online bootstrap aggregation for regression. For each incoming observation, each model's learn_one method is called k times where k is sampled from a Poisson distribution of parameter 1. k thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do scipy.stats.utils.random.poisson(1).pmf(k) for more detailed values.","title":"BaggingRegressor"},{"location":"api/ensemble/BaggingRegressor/#parameters","text":"model ( base.Regressor ) The regressor to bag. n_models \u2013 defaults to 10 The number of models in the ensemble. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/BaggingRegressor/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/BaggingRegressor/#examples","text":"In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression. >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = preprocessing . StandardScaler () >>> model |= ensemble . BaggingRegressor ( ... model = linear_model . LinearRegression ( intercept_lr = 0.1 ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.68886","title":"Examples"},{"location":"api/ensemble/BaggingRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Averages the predictions of each regressor. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/BaggingRegressor/#references","text":"Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9","title":"References"},{"location":"api/ensemble/EWARegressor/","text":"EWARegressor \u00b6 Exponentially Weighted Average regressor. Parameters \u00b6 models ( List[ base.Regressor ] ) The regressors to hedge. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function that has to be minimized. Defaults to optim.losses.Squared . learning_rate \u2013 defaults to 0.5 The learning rate by which the model weights are multiplied at each iteration. Attributes \u00b6 models Examples \u00b6 >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import stream >>> optimizers = [ ... optim . SGD ( 0.01 ), ... optim . RMSProp (), ... optim . AdaGrad () ... ] >>> for optimizer in optimizers : ... ... dataset = datasets . TrumpApproval () ... metric = metrics . MAE () ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... optimizer = optimizer , ... intercept_lr = .1 ... ) ... ) ... ... print ( optimizer , evaluate . progressive_val_score ( dataset , model , metric )) SGD MAE : 0.555971 RMSProp MAE : 0.528284 AdaGrad MAE : 0.481461 >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> hedge = ( ... preprocessing . StandardScaler () | ... ensemble . EWARegressor ( ... [ ... linear_model . LinearRegression ( optimizer = o , intercept_lr = .1 ) ... for o in optimizers ... ], ... learning_rate = 0.005 ... ) ... ) >>> evaluate . progressive_val_score ( dataset , hedge , metric ) MAE : 0.494832 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self learn_predict_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Online Learning from Experts: Weighed Majority and Hedge \u21a9 Wikipedia page on the multiplicative weight update method \u21a9 Kivinen, J. and Warmuth, M.K., 1997. Exponentiated gradient versus gradient descent for linear predictors. information and computation, 132(1), pp.1-63. \u21a9","title":"EWARegressor"},{"location":"api/ensemble/EWARegressor/#ewaregressor","text":"Exponentially Weighted Average regressor.","title":"EWARegressor"},{"location":"api/ensemble/EWARegressor/#parameters","text":"models ( List[ base.Regressor ] ) The regressors to hedge. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function that has to be minimized. Defaults to optim.losses.Squared . learning_rate \u2013 defaults to 0.5 The learning rate by which the model weights are multiplied at each iteration.","title":"Parameters"},{"location":"api/ensemble/EWARegressor/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/EWARegressor/#examples","text":">>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import stream >>> optimizers = [ ... optim . SGD ( 0.01 ), ... optim . RMSProp (), ... optim . AdaGrad () ... ] >>> for optimizer in optimizers : ... ... dataset = datasets . TrumpApproval () ... metric = metrics . MAE () ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... optimizer = optimizer , ... intercept_lr = .1 ... ) ... ) ... ... print ( optimizer , evaluate . progressive_val_score ( dataset , model , metric )) SGD MAE : 0.555971 RMSProp MAE : 0.528284 AdaGrad MAE : 0.481461 >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> hedge = ( ... preprocessing . StandardScaler () | ... ensemble . EWARegressor ( ... [ ... linear_model . LinearRegression ( optimizer = o , intercept_lr = .1 ) ... for o in optimizers ... ], ... learning_rate = 0.005 ... ) ... ) >>> evaluate . progressive_val_score ( dataset , hedge , metric ) MAE : 0.494832","title":"Examples"},{"location":"api/ensemble/EWARegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self learn_predict_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/EWARegressor/#references","text":"Online Learning from Experts: Weighed Majority and Hedge \u21a9 Wikipedia page on the multiplicative weight update method \u21a9 Kivinen, J. and Warmuth, M.K., 1997. Exponentiated gradient versus gradient descent for linear predictors. information and computation, 132(1), pp.1-63. \u21a9","title":"References"},{"location":"api/ensemble/LeveragingBaggingClassifier/","text":"LeveragingBaggingClassifier \u00b6 Leveraging Bagging ensemble classifier. Leveraging Bagging [^1] is an improvement over the Oza Bagging algorithm. The bagging performance is leveraged by increasing the re-sampling. It uses a poisson distribution to simulate the re-sampling process. To increase re-sampling it uses a higher w value of the Poisson distribution (agerage number of events), 6 by default, increasing the input space diversity, by attributing a different range of weights to the data samples. To deal with concept drift, Leveraging Bagging uses the ADWIN algorithm to monitor the performance of each member of the enemble If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier. Parameters \u00b6 model ( base.Classifier ) The classifier to bag. n_models ( int ) \u2013 defaults to 10 The number of models in the ensemble. w ( float ) \u2013 defaults to 6 Indicates the average number of events. This is the lambda parameter of the Poisson distribution used to compute the re-sampling weight. adwin_delta ( float ) \u2013 defaults to 0.002 The delta parameter for the ADWIN change detector. bagging_method ( str ) \u2013 defaults to bag The bagging method to use. Can be one of the following: * 'bag' - Leveraging Bagging using ADWIN. * 'me' - Assigns \\(weight=1\\) if sample is misclassified, otherwise \\(weight=error/(1-error)\\) . * 'half' - Use resampling without replacement for half of the instances. * 'wt' - Resample without taking out all instances. * 'subag' - Resampling without replacement. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 bagging_methods Valid bagging_method options. models Examples \u00b6 >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . LeveragingBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 88.73 % Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Averages the predictions of each classifier. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"LeveragingBaggingClassifier"},{"location":"api/ensemble/LeveragingBaggingClassifier/#leveragingbaggingclassifier","text":"Leveraging Bagging ensemble classifier. Leveraging Bagging [^1] is an improvement over the Oza Bagging algorithm. The bagging performance is leveraged by increasing the re-sampling. It uses a poisson distribution to simulate the re-sampling process. To increase re-sampling it uses a higher w value of the Poisson distribution (agerage number of events), 6 by default, increasing the input space diversity, by attributing a different range of weights to the data samples. To deal with concept drift, Leveraging Bagging uses the ADWIN algorithm to monitor the performance of each member of the enemble If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.","title":"LeveragingBaggingClassifier"},{"location":"api/ensemble/LeveragingBaggingClassifier/#parameters","text":"model ( base.Classifier ) The classifier to bag. n_models ( int ) \u2013 defaults to 10 The number of models in the ensemble. w ( float ) \u2013 defaults to 6 Indicates the average number of events. This is the lambda parameter of the Poisson distribution used to compute the re-sampling weight. adwin_delta ( float ) \u2013 defaults to 0.002 The delta parameter for the ADWIN change detector. bagging_method ( str ) \u2013 defaults to bag The bagging method to use. Can be one of the following: * 'bag' - Leveraging Bagging using ADWIN. * 'me' - Assigns \\(weight=1\\) if sample is misclassified, otherwise \\(weight=error/(1-error)\\) . * 'half' - Use resampling without replacement for half of the instances. * 'wt' - Resample without taking out all instances. * 'subag' - Resampling without replacement. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/ensemble/LeveragingBaggingClassifier/#attributes","text":"bagging_methods Valid bagging_method options. models","title":"Attributes"},{"location":"api/ensemble/LeveragingBaggingClassifier/#examples","text":">>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ensemble . LeveragingBaggingClassifier ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 88.73 %","title":"Examples"},{"location":"api/ensemble/LeveragingBaggingClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Averages the predictions of each classifier. Parameters x remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/SRPClassifier/","text":"SRPClassifier \u00b6 Streaming Random Patches ensemble classifier. The Streaming Random Patches (SRP) 1 is an ensemble method that simulates bagging or random subspaces. The default algorithm uses both bagging and random subspaces, namely Random Patches. The default base estimator is a Hoeffding Tree, but other base estimators can be used (differently from random forest variations). Parameters \u00b6 model ( base.Estimator ) \u2013 defaults to None The base estimator. n_models ( int ) \u2013 defaults to 10 Number of members in the ensemble. subspace_size ( Union[int, float, str] ) \u2013 defaults to 0.6 Number of features per subset for each classifier where M is the total number of features. A negative value means M - subspace_size . Only applies when using random subspaces or random patches. * If int indicates the number of features to use. Valid range [2, M]. * If float indicates the percentage of features to use, Valid range (0., 1.]. * 'sqrt' - sqrt(M)+1 * 'rmsqrt' - Residual from M-(sqrt(M)+1) training_method ( str ) \u2013 defaults to patches The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches. lam ( int ) \u2013 defaults to 6 Lambda value for resampling. drift_detector ( base.DriftDetector ) \u2013 defaults to None Drift detector. warning_detector ( base.DriftDetector ) \u2013 defaults to None Warning detector. disable_detector ( str ) \u2013 defaults to off Option to disable drift detectors: * If 'off' , detectors are enabled. * If 'drift' , disables concept drift detection and the background learner. * If 'warning' , disables the background learner and ensemble members are reset if drift is detected. disable_weighted_vote ( bool ) \u2013 defaults to False If True, disables weighted voting. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. metric ( Union[river.metrics.base.ClassificationMetric, NoneType] ) \u2013 defaults to None The metric to track members performance within the ensemble. This implementation assumes that larger values are better when using weighted votes. Attributes \u00b6 models Examples \u00b6 >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import synth >>> from river import tree >>> dataset = synth . ConceptDriftStream ( ... seed = 42 , ... position = 500 , ... width = 50 ... ) . take ( 1000 ) >>> base_model = tree . HoeffdingTreeClassifier ( ... grace_period = 50 , split_confidence = 0.01 , ... nominal_attributes = [ 'age' , 'car' , 'zipcode' ] ... ) >>> model = ensemble . SRPClassifier ( ... model = base_model , n_models = 3 , seed = 42 , ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 73.27 % Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reset reverse S.reverse() -- reverse IN PLACE sort Notes \u00b6 This implementation uses n_models=10 as default given the impact on processing time. The optimal number of models depends on the data and resources available. References \u00b6 Heitor Murilo Gomes, Jesse Read, Albert Bifet. Streaming Random Patches for Evolving Data Stream Classification. IEEE International Conference on Data Mining (ICDM), 2019. \u21a9","title":"SRPClassifier"},{"location":"api/ensemble/SRPClassifier/#srpclassifier","text":"Streaming Random Patches ensemble classifier. The Streaming Random Patches (SRP) 1 is an ensemble method that simulates bagging or random subspaces. The default algorithm uses both bagging and random subspaces, namely Random Patches. The default base estimator is a Hoeffding Tree, but other base estimators can be used (differently from random forest variations).","title":"SRPClassifier"},{"location":"api/ensemble/SRPClassifier/#parameters","text":"model ( base.Estimator ) \u2013 defaults to None The base estimator. n_models ( int ) \u2013 defaults to 10 Number of members in the ensemble. subspace_size ( Union[int, float, str] ) \u2013 defaults to 0.6 Number of features per subset for each classifier where M is the total number of features. A negative value means M - subspace_size . Only applies when using random subspaces or random patches. * If int indicates the number of features to use. Valid range [2, M]. * If float indicates the percentage of features to use, Valid range (0., 1.]. * 'sqrt' - sqrt(M)+1 * 'rmsqrt' - Residual from M-(sqrt(M)+1) training_method ( str ) \u2013 defaults to patches The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches. lam ( int ) \u2013 defaults to 6 Lambda value for resampling. drift_detector ( base.DriftDetector ) \u2013 defaults to None Drift detector. warning_detector ( base.DriftDetector ) \u2013 defaults to None Warning detector. disable_detector ( str ) \u2013 defaults to off Option to disable drift detectors: * If 'off' , detectors are enabled. * If 'drift' , disables concept drift detection and the background learner. * If 'warning' , disables the background learner and ensemble members are reset if drift is detected. disable_weighted_vote ( bool ) \u2013 defaults to False If True, disables weighted voting. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. metric ( Union[river.metrics.base.ClassificationMetric, NoneType] ) \u2013 defaults to None The metric to track members performance within the ensemble. This implementation assumes that larger values are better when using weighted votes.","title":"Parameters"},{"location":"api/ensemble/SRPClassifier/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/SRPClassifier/#examples","text":">>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import synth >>> from river import tree >>> dataset = synth . ConceptDriftStream ( ... seed = 42 , ... position = 500 , ... width = 50 ... ) . take ( 1000 ) >>> base_model = tree . HoeffdingTreeClassifier ( ... grace_period = 50 , split_confidence = 0.01 , ... nominal_attributes = [ 'age' , 'car' , 'zipcode' ] ... ) >>> model = ensemble . SRPClassifier ( ... model = base_model , n_models = 3 , seed = 42 , ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 73.27 %","title":"Examples"},{"location":"api/ensemble/SRPClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reset reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/SRPClassifier/#notes","text":"This implementation uses n_models=10 as default given the impact on processing time. The optimal number of models depends on the data and resources available.","title":"Notes"},{"location":"api/ensemble/SRPClassifier/#references","text":"Heitor Murilo Gomes, Jesse Read, Albert Bifet. Streaming Random Patches for Evolving Data Stream Classification. IEEE International Conference on Data Mining (ICDM), 2019. \u21a9","title":"References"},{"location":"api/ensemble/SRPRegressor/","text":"SRPRegressor \u00b6 Streaming Random Patches ensemble regressor. The Streaming Random Patches 1 ensemble method for regression trains each base learner on a subset of features and instances from the original data, namely a random patch. This strategy to enforce diverse base models is similar to the one in the random forest, yet it is not restricted to using decision trees as base learner. This method is an adaptation of 2 for regression. Parameters \u00b6 model ( base.Regressor ) \u2013 defaults to None The base estimator. n_models ( int ) \u2013 defaults to 10 Number of members in the ensemble. subspace_size ( Union[int, float, str] ) \u2013 defaults to 0.6 Number of features per subset for each classifier where M is the total number of features. A negative value means M - subspace_size . Only applies when using random subspaces or random patches. * If int indicates the number of features to use. Valid range [2, M]. * If float indicates the percentage of features to use, Valid range (0., 1.]. * 'sqrt' - sqrt(M)+1 * 'rmsqrt' - Residual from M-(sqrt(M)+1) training_method ( str ) \u2013 defaults to patches The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches. lam ( int ) \u2013 defaults to 6 Lambda value for bagging. drift_detector ( base.DriftDetector ) \u2013 defaults to None Drift detector. warning_detector ( base.DriftDetector ) \u2013 defaults to None Warning detector. disable_detector ( str ) \u2013 defaults to off Option to disable drift detectors: * If 'off' , detectors are enabled. * If 'drift' , disables concept drift detection and the background learner. * If 'warning' , disables the background learner and ensemble members are reset if drift is detected. disable_weighted_vote ( bool ) \u2013 defaults to True If True, disables weighted voting. drift_detection_criteria ( str ) \u2013 defaults to error The criteria used to track drifts. * 'error' - absolute error. * 'prediction' - predicted target values. aggregation_method ( str ) \u2013 defaults to mean The method to use to aggregate predictions in the ensemble. * 'mean' * 'median' seed \u2013 defaults to None Random number generator seed for reproducibility. metric ( Union[river.metrics.base.RegressionMetric, NoneType] ) \u2013 defaults to None The metric to track members performance within the ensemble. Attributes \u00b6 models Examples \u00b6 >>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import synth >>> from river import tree >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gsg' , ... position = ( 350 , 750 ), ... transition_window = 200 , ... seed = 42 ... ) . take ( 1000 ) >>> base_model = tree . HoeffdingTreeRegressor ( grace_period = 50 ) >>> model = ensemble . SRPRegressor ( ... model = base_model , ... training_method = \"patches\" , ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . R2 () >>> evaluate . progressive_val_score ( dataset , model , metric ) R2 : 0.571263 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reset reverse S.reverse() -- reverse IN PLACE sort Notes \u00b6 This implementation uses n_models=10 as default given the impact on processing time. The optimal number of models depends on the data and resources available. References \u00b6 Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini, Bernhard Pfahringer, and Albert Bifet. On Ensemble Techniques for Data Stream Regression. IJCNN'20. International Joint Conference on Neural Networks. 2020. \u21a9 Heitor Murilo Gomes, Jesse Read, Albert Bifet. Streaming Random Patches for Evolving Data Stream Classification. IEEE International Conference on Data Mining (ICDM), 2019. \u21a9","title":"SRPRegressor"},{"location":"api/ensemble/SRPRegressor/#srpregressor","text":"Streaming Random Patches ensemble regressor. The Streaming Random Patches 1 ensemble method for regression trains each base learner on a subset of features and instances from the original data, namely a random patch. This strategy to enforce diverse base models is similar to the one in the random forest, yet it is not restricted to using decision trees as base learner. This method is an adaptation of 2 for regression.","title":"SRPRegressor"},{"location":"api/ensemble/SRPRegressor/#parameters","text":"model ( base.Regressor ) \u2013 defaults to None The base estimator. n_models ( int ) \u2013 defaults to 10 Number of members in the ensemble. subspace_size ( Union[int, float, str] ) \u2013 defaults to 0.6 Number of features per subset for each classifier where M is the total number of features. A negative value means M - subspace_size . Only applies when using random subspaces or random patches. * If int indicates the number of features to use. Valid range [2, M]. * If float indicates the percentage of features to use, Valid range (0., 1.]. * 'sqrt' - sqrt(M)+1 * 'rmsqrt' - Residual from M-(sqrt(M)+1) training_method ( str ) \u2013 defaults to patches The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches. lam ( int ) \u2013 defaults to 6 Lambda value for bagging. drift_detector ( base.DriftDetector ) \u2013 defaults to None Drift detector. warning_detector ( base.DriftDetector ) \u2013 defaults to None Warning detector. disable_detector ( str ) \u2013 defaults to off Option to disable drift detectors: * If 'off' , detectors are enabled. * If 'drift' , disables concept drift detection and the background learner. * If 'warning' , disables the background learner and ensemble members are reset if drift is detected. disable_weighted_vote ( bool ) \u2013 defaults to True If True, disables weighted voting. drift_detection_criteria ( str ) \u2013 defaults to error The criteria used to track drifts. * 'error' - absolute error. * 'prediction' - predicted target values. aggregation_method ( str ) \u2013 defaults to mean The method to use to aggregate predictions in the ensemble. * 'mean' * 'median' seed \u2013 defaults to None Random number generator seed for reproducibility. metric ( Union[river.metrics.base.RegressionMetric, NoneType] ) \u2013 defaults to None The metric to track members performance within the ensemble.","title":"Parameters"},{"location":"api/ensemble/SRPRegressor/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/SRPRegressor/#examples","text":">>> from river import ensemble >>> from river import evaluate >>> from river import metrics >>> from river import synth >>> from river import tree >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gsg' , ... position = ( 350 , 750 ), ... transition_window = 200 , ... seed = 42 ... ) . take ( 1000 ) >>> base_model = tree . HoeffdingTreeRegressor ( grace_period = 50 ) >>> model = ensemble . SRPRegressor ( ... model = base_model , ... training_method = \"patches\" , ... n_models = 3 , ... seed = 42 ... ) >>> metric = metrics . R2 () >>> evaluate . progressive_val_score ( dataset , model , metric ) R2 : 0.571263","title":"Examples"},{"location":"api/ensemble/SRPRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reset reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/SRPRegressor/#notes","text":"This implementation uses n_models=10 as default given the impact on processing time. The optimal number of models depends on the data and resources available.","title":"Notes"},{"location":"api/ensemble/SRPRegressor/#references","text":"Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini, Bernhard Pfahringer, and Albert Bifet. On Ensemble Techniques for Data Stream Regression. IJCNN'20. International Joint Conference on Neural Networks. 2020. \u21a9 Heitor Murilo Gomes, Jesse Read, Albert Bifet. Streaming Random Patches for Evolving Data Stream Classification. IEEE International Conference on Data Mining (ICDM), 2019. \u21a9","title":"References"},{"location":"api/ensemble/StackingClassifier/","text":"StackingClassifier \u00b6 Stacking for binary classification. Parameters \u00b6 models ( List[ base.Classifier ] ) meta_classifier ( base.Classifier ) include_features \u2013 defaults to True Indicates whether or not the original features should be provided to the meta-model along with the predictions from each model. Attributes \u00b6 models Examples \u00b6 >>> from river import compose >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = compose . Pipeline ( ... ( 'scale' , pp . StandardScaler ()), ... ( 'stack' , ensemble . StackingClassifier ( ... [ ... lm . LogisticRegression (), ... lm . PAClassifier ( mode = 1 , C = 0.01 ), ... lm . PAClassifier ( mode = 2 , C = 0.01 ), ... ], ... meta_classifier = lm . LogisticRegression () ... )) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 88.14 % Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 A Kaggler's Guide to Model Stacking in Practice \u21a9","title":"StackingClassifier"},{"location":"api/ensemble/StackingClassifier/#stackingclassifier","text":"Stacking for binary classification.","title":"StackingClassifier"},{"location":"api/ensemble/StackingClassifier/#parameters","text":"models ( List[ base.Classifier ] ) meta_classifier ( base.Classifier ) include_features \u2013 defaults to True Indicates whether or not the original features should be provided to the meta-model along with the predictions from each model.","title":"Parameters"},{"location":"api/ensemble/StackingClassifier/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/StackingClassifier/#examples","text":">>> from river import compose >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = compose . Pipeline ( ... ( 'scale' , pp . StandardScaler ()), ... ( 'stack' , ensemble . StackingClassifier ( ... [ ... lm . LogisticRegression (), ... lm . PAClassifier ( mode = 1 , C = 0.01 ), ... lm . PAClassifier ( mode = 2 , C = 0.01 ), ... ], ... meta_classifier = lm . LogisticRegression () ... )) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 88.14 %","title":"Examples"},{"location":"api/ensemble/StackingClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/ensemble/StackingClassifier/#references","text":"A Kaggler's Guide to Model Stacking in Practice \u21a9","title":"References"},{"location":"api/ensemble/VotingClassifier/","text":"VotingClassifier \u00b6 Voting classifier. A classification is made by aggregating the predictions of each model in the ensemble. The probabilities for each class are summed up if use_probabilities is set to True . If not, the probabilities are ignored and each prediction is weighted the same. In this case, it's important that you use an odd number of classifiers. A random class will be picked if the number of classifiers is even. Parameters \u00b6 models ( List[ base.Classifier ] ) The classifiers. use_probabilities \u2013 defaults to True Whether or to weight each prediction with its associated probability. Attributes \u00b6 models Examples \u00b6 >>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import naive_bayes >>> from river import preprocessing >>> from river import tree >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... ensemble . VotingClassifier ([ ... linear_model . LogisticRegression (), ... tree . HoeffdingTreeClassifier (), ... naive_bayes . GaussianNB () ... ]) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.14 % Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"VotingClassifier"},{"location":"api/ensemble/VotingClassifier/#votingclassifier","text":"Voting classifier. A classification is made by aggregating the predictions of each model in the ensemble. The probabilities for each class are summed up if use_probabilities is set to True . If not, the probabilities are ignored and each prediction is weighted the same. In this case, it's important that you use an odd number of classifiers. A random class will be picked if the number of classifiers is even.","title":"VotingClassifier"},{"location":"api/ensemble/VotingClassifier/#parameters","text":"models ( List[ base.Classifier ] ) The classifiers. use_probabilities \u2013 defaults to True Whether or to weight each prediction with its associated probability.","title":"Parameters"},{"location":"api/ensemble/VotingClassifier/#attributes","text":"models","title":"Attributes"},{"location":"api/ensemble/VotingClassifier/#examples","text":">>> from river import datasets >>> from river import ensemble >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import naive_bayes >>> from river import preprocessing >>> from river import tree >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... ensemble . VotingClassifier ([ ... linear_model . LogisticRegression (), ... tree . HoeffdingTreeClassifier (), ... naive_bayes . GaussianNB () ... ]) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.14 %","title":"Examples"},{"location":"api/ensemble/VotingClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/evaluate/Track/","text":"Track \u00b6 A track evaluate a model's performance. The following metrics are recorded: - FLOPS: floating point operations per second. - Time, which should be interpreted with wisdom. Indeed time can depend on the architecture and local resource situations. Comparison via FLOPS should be preferred. - The model's memory footprint. - The model's predictive performance on the track's dataset. \u00b6 Parameters \u00b6 name ( str ) The name of the track. dataset The dataset from which samples will be retrieved. A slice must be used if the dataset is a data generator. metric The metric(s) used to track performance. n_samples ( int ) \u2013 defaults to None The number of samples that are going to be processed by the track. Methods \u00b6 run","title":"Track"},{"location":"api/evaluate/Track/#track","text":"A track evaluate a model's performance. The following metrics are recorded:","title":"Track"},{"location":"api/evaluate/Track/#-flops-floating-point-operations-per-second-time-which-should-be-interpreted-with-wisdom-indeed-time-can-depend-on-the-architecture-and-local-resource-situations-comparison-via-flops-should-be-preferred-the-models-memory-footprint-the-models-predictive-performance-on-the-tracks-dataset","text":"","title":"- FLOPS: floating point operations per second. - Time, which should be interpreted with wisdom. Indeed time can depend on the architecture     and local resource situations. Comparison via FLOPS should be preferred. - The model's memory footprint. - The model's predictive performance on the track's dataset."},{"location":"api/evaluate/Track/#parameters","text":"name ( str ) The name of the track. dataset The dataset from which samples will be retrieved. A slice must be used if the dataset is a data generator. metric The metric(s) used to track performance. n_samples ( int ) \u2013 defaults to None The number of samples that are going to be processed by the track.","title":"Parameters"},{"location":"api/evaluate/Track/#methods","text":"run","title":"Methods"},{"location":"api/evaluate/iter-progressive-val-score/","text":"iter_progressive_val_score \u00b6 Evaluates the performance of a model on a streaming dataset and yields results. This does exactly the same as evaluate.progressive_val_score . The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results. Parameters \u00b6 dataset ( Iterable[Tuple[dict, Any]] ) The stream of observations against which the model will be evaluated. model The model to evaluate. metric ( river.metrics.base.Metric ) The metric used to evaluate the model's predictions. moment ( Union[str, Callable] ) \u2013 defaults to None The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. delay ( Union[str, int, datetime.timedelta, Callable] ) \u2013 defaults to None The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. step \u2013 defaults to 1 Iteration number at which to yield results. This only takes into account the predictions, and not the training steps. measure_time \u2013 defaults to False Whether or not to measure the elapsed time. measure_memory \u2013 defaults to False Whether or not to measure the memory usage of the model. Examples \u00b6 Take the following model: >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) We can evaluate it on the Phishing dataset as so: >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> steps = evaluate . iter_progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... step = 200 ... ) >>> for step in steps : ... print ( step ) { 'ROCAUC' : ROCAUC : 89.80 % , 'Step' : 200 } { 'ROCAUC' : ROCAUC : 92.09 % , 'Step' : 400 } { 'ROCAUC' : ROCAUC : 93.13 % , 'Step' : 600 } { 'ROCAUC' : ROCAUC : 93.99 % , 'Step' : 800 } { 'ROCAUC' : ROCAUC : 94.74 % , 'Step' : 1000 } { 'ROCAUC' : ROCAUC : 95.03 % , 'Step' : 1200 } References \u00b6 Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9 Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9","title":"iter_progressive_val_score"},{"location":"api/evaluate/iter-progressive-val-score/#iter_progressive_val_score","text":"Evaluates the performance of a model on a streaming dataset and yields results. This does exactly the same as evaluate.progressive_val_score . The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results.","title":"iter_progressive_val_score"},{"location":"api/evaluate/iter-progressive-val-score/#parameters","text":"dataset ( Iterable[Tuple[dict, Any]] ) The stream of observations against which the model will be evaluated. model The model to evaluate. metric ( river.metrics.base.Metric ) The metric used to evaluate the model's predictions. moment ( Union[str, Callable] ) \u2013 defaults to None The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. delay ( Union[str, int, datetime.timedelta, Callable] ) \u2013 defaults to None The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. step \u2013 defaults to 1 Iteration number at which to yield results. This only takes into account the predictions, and not the training steps. measure_time \u2013 defaults to False Whether or not to measure the elapsed time. measure_memory \u2013 defaults to False Whether or not to measure the memory usage of the model.","title":"Parameters"},{"location":"api/evaluate/iter-progressive-val-score/#examples","text":"Take the following model: >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) We can evaluate it on the Phishing dataset as so: >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> steps = evaluate . iter_progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... step = 200 ... ) >>> for step in steps : ... print ( step ) { 'ROCAUC' : ROCAUC : 89.80 % , 'Step' : 200 } { 'ROCAUC' : ROCAUC : 92.09 % , 'Step' : 400 } { 'ROCAUC' : ROCAUC : 93.13 % , 'Step' : 600 } { 'ROCAUC' : ROCAUC : 93.99 % , 'Step' : 800 } { 'ROCAUC' : ROCAUC : 94.74 % , 'Step' : 1000 } { 'ROCAUC' : ROCAUC : 95.03 % , 'Step' : 1200 }","title":"Examples"},{"location":"api/evaluate/iter-progressive-val-score/#references","text":"Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9 Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9","title":"References"},{"location":"api/evaluate/load-binary-clf-tracks/","text":"load_binary_clf_tracks \u00b6 Return binary classification tracks.","title":"load_binary_clf_tracks"},{"location":"api/evaluate/load-binary-clf-tracks/#load_binary_clf_tracks","text":"Return binary classification tracks.","title":"load_binary_clf_tracks"},{"location":"api/evaluate/progressive-val-score/","text":"progressive_val_score \u00b6 Evaluates the performance of a model on a streaming dataset. This method is the canonical way to evaluate a model's performance. When used correctly, it allows you to exactly assess how a model would have performed in a production scenario. dataset is converted into a stream of questions and answers. At each step the model is either asked to predict an observation, or is either updated. The target is only revealed to the model after a certain amount of time, which is determined by the delay parameter. Note that under the hood this uses the stream.simulate_qa function to go through the data in arrival order. By default, there is no delay, which means that the samples are processed one after the other. When there is no delay, this function essentially performs progressive validation. When there is a delay, then we refer to it as delayed progressive validation. It is recommended to use this method when you want to determine a model's performance on a dataset. In particular, it is advised to use the delay parameter in order to get a reliable assessment. Indeed, in a production scenario, it is often the case that ground truths are made available after a certain amount of time. By using this method, you can reproduce this scenario and therefore truthfully assess what would have been the performance of a model on a given dataset. Parameters \u00b6 dataset ( Iterable[Tuple[dict, Any]] ) The stream of observations against which the model will be evaluated. model The model to evaluate. metric ( river.metrics.base.Metric ) The metric used to evaluate the model's predictions. moment ( Union[str, Callable] ) \u2013 defaults to None The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. delay ( Union[str, int, datetime.timedelta, Callable] ) \u2013 defaults to None The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. print_every \u2013 defaults to 0 Iteration number at which to print the current metric. This only takes into account the predictions, and not the training steps. show_time \u2013 defaults to False Whether or not to display the elapsed time. show_memory \u2013 defaults to False Whether or not to display the memory usage of the model. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress. Examples \u00b6 Take the following model: >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) We can evaluate it on the Phishing dataset as so: >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 ... ) [ 200 ] ROCAUC : 89.80 % [ 400 ] ROCAUC : 92.09 % [ 600 ] ROCAUC : 93.13 % [ 800 ] ROCAUC : 93.99 % [ 1 , 000 ] ROCAUC : 94.74 % [ 1 , 200 ] ROCAUC : 95.03 % ROCAUC : 95.04 % We haven't specified a delay, therefore this is strictly equivalent to the following piece of code: >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) >>> metric = metrics . ROCAUC () >>> for x , y in datasets . Phishing (): ... y_pred = model . predict_proba_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric ROCAUC : 95.04 % When print_every is specified, the current state is printed at regular intervals. Under the hood, Python's print method is being used. You can pass extra keyword arguments to modify its behavior. For instance, you may use the file argument if you want to log the progress to a file of your choice. >>> with open ( 'progress.log' , 'w' ) as f : ... metric = evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 , ... file = f ... ) >>> with open ( 'progress.log' ) as f : ... for line in f . read () . splitlines (): ... print ( line ) [ 200 ] ROCAUC : 94.00 % [ 400 ] ROCAUC : 94.70 % [ 600 ] ROCAUC : 95.17 % [ 800 ] ROCAUC : 95.42 % [ 1 , 000 ] ROCAUC : 95.82 % [ 1 , 200 ] ROCAUC : 96.00 % Note that the performance is slightly better than above because we haven't used a fresh copy of the model. Instead, we've reused the existing model which has already done a full pass on the data. >>> import os ; os . remove ( 'progress.log' ) References \u00b6 Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9 Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9","title":"progressive_val_score"},{"location":"api/evaluate/progressive-val-score/#progressive_val_score","text":"Evaluates the performance of a model on a streaming dataset. This method is the canonical way to evaluate a model's performance. When used correctly, it allows you to exactly assess how a model would have performed in a production scenario. dataset is converted into a stream of questions and answers. At each step the model is either asked to predict an observation, or is either updated. The target is only revealed to the model after a certain amount of time, which is determined by the delay parameter. Note that under the hood this uses the stream.simulate_qa function to go through the data in arrival order. By default, there is no delay, which means that the samples are processed one after the other. When there is no delay, this function essentially performs progressive validation. When there is a delay, then we refer to it as delayed progressive validation. It is recommended to use this method when you want to determine a model's performance on a dataset. In particular, it is advised to use the delay parameter in order to get a reliable assessment. Indeed, in a production scenario, it is often the case that ground truths are made available after a certain amount of time. By using this method, you can reproduce this scenario and therefore truthfully assess what would have been the performance of a model on a given dataset.","title":"progressive_val_score"},{"location":"api/evaluate/progressive-val-score/#parameters","text":"dataset ( Iterable[Tuple[dict, Any]] ) The stream of observations against which the model will be evaluated. model The model to evaluate. metric ( river.metrics.base.Metric ) The metric used to evaluate the model's predictions. moment ( Union[str, Callable] ) \u2013 defaults to None The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. delay ( Union[str, int, datetime.timedelta, Callable] ) \u2013 defaults to None The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. print_every \u2013 defaults to 0 Iteration number at which to print the current metric. This only takes into account the predictions, and not the training steps. show_time \u2013 defaults to False Whether or not to display the elapsed time. show_memory \u2013 defaults to False Whether or not to display the memory usage of the model. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress.","title":"Parameters"},{"location":"api/evaluate/progressive-val-score/#examples","text":"Take the following model: >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) We can evaluate it on the Phishing dataset as so: >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 ... ) [ 200 ] ROCAUC : 89.80 % [ 400 ] ROCAUC : 92.09 % [ 600 ] ROCAUC : 93.13 % [ 800 ] ROCAUC : 93.99 % [ 1 , 000 ] ROCAUC : 94.74 % [ 1 , 200 ] ROCAUC : 95.03 % ROCAUC : 95.04 % We haven't specified a delay, therefore this is strictly equivalent to the following piece of code: >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) >>> metric = metrics . ROCAUC () >>> for x , y in datasets . Phishing (): ... y_pred = model . predict_proba_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric ROCAUC : 95.04 % When print_every is specified, the current state is printed at regular intervals. Under the hood, Python's print method is being used. You can pass extra keyword arguments to modify its behavior. For instance, you may use the file argument if you want to log the progress to a file of your choice. >>> with open ( 'progress.log' , 'w' ) as f : ... metric = evaluate . progressive_val_score ( ... model = model , ... dataset = datasets . Phishing (), ... metric = metrics . ROCAUC (), ... print_every = 200 , ... file = f ... ) >>> with open ( 'progress.log' ) as f : ... for line in f . read () . splitlines (): ... print ( line ) [ 200 ] ROCAUC : 94.00 % [ 400 ] ROCAUC : 94.70 % [ 600 ] ROCAUC : 95.17 % [ 800 ] ROCAUC : 95.42 % [ 1 , 000 ] ROCAUC : 95.82 % [ 1 , 200 ] ROCAUC : 96.00 % Note that the performance is slightly better than above because we haven't used a fresh copy of the model. Instead, we've reused the existing model which has already done a full pass on the data. >>> import os ; os . remove ( 'progress.log' )","title":"Examples"},{"location":"api/evaluate/progressive-val-score/#references","text":"Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9 Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9","title":"References"},{"location":"api/facto/FFMClassifier/","text":"FFMClassifier \u00b6 Field-aware Factorization Machine for binary classification. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, False ) ... ) >>> model = facto . FFMClassifier ( ... n_factors = 10 , ... intercept = .5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50).","title":"FFMClassifier"},{"location":"api/facto/FFMClassifier/#ffmclassifier","text":"Field-aware Factorization Machine for binary classification. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FFMClassifier"},{"location":"api/facto/FFMClassifier/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FFMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FFMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, False ) ... ) >>> model = facto . FFMClassifier ( ... n_factors = 10 , ... intercept = .5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) True","title":"Examples"},{"location":"api/facto/FFMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/FFMClassifier/#references","text":"Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50).","title":"References"},{"location":"api/facto/FFMRegressor/","text":"FFMRegressor \u00b6 Field-aware Factorization Machine for regression. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, 2 ) ... ) >>> model = facto . FFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) 5.319945 >>> report = model . debug_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23501 5.23501 user_Bob 1.00000 0.11438 0.11438 time 0.14000 0.03186 0.00446 item_Harry Potter ( time ) - time ( item ) 0.14000 0.03153 0.00441 user_Bob ( time ) - time ( user ) 0.14000 0.02864 0.00401 item_Harry Potter 1.00000 0.00000 0.00000 user_Bob ( item ) - item_Harry Potter ( user ) 1.00000 - 0.04232 - 0.04232 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50). \u21a9","title":"FFMRegressor"},{"location":"api/facto/FFMRegressor/#ffmregressor","text":"Field-aware Factorization Machine for regression. The model equation is defined by: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] Where \\mathbf{v} {j, f {j'}} is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\mathbf{v}_{j', f_j} is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FFMRegressor"},{"location":"api/facto/FFMRegressor/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FFMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FFMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, 2 ) ... ) >>> model = facto . FFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) 5.319945 >>> report = model . debug_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23501 5.23501 user_Bob 1.00000 0.11438 0.11438 time 0.14000 0.03186 0.00446 item_Harry Potter ( time ) - time ( item ) 0.14000 0.03153 0.00441 user_Bob ( time ) - time ( user ) 0.14000 0.02864 0.00401 item_Harry Potter 1.00000 0.00000 0.00000 user_Bob ( item ) - item_Harry Potter ( user ) 1.00000 - 0.04232 - 0.04232","title":"Examples"},{"location":"api/facto/FFMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/FFMRegressor/#references","text":"Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50). \u21a9","title":"References"},{"location":"api/facto/FMClassifier/","text":"FMClassifier \u00b6 Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"FMClassifier"},{"location":"api/facto/FMClassifier/#fmclassifier","text":"Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"FMClassifier"},{"location":"api/facto/FMClassifier/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True","title":"Examples"},{"location":"api/facto/FMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/FMClassifier/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"References"},{"location":"api/facto/FMRegressor/","text":"FMRegressor \u00b6 Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236504 >>> report = model . debug_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23426 5.23426 Bob - Harry Potter 1.00000 0.00224 0.00224 Harry Potter 1.00000 0.00000 0.00000 Bob 1.00000 0.00000 0.00000 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"FMRegressor"},{"location":"api/facto/FMRegressor/#fmregressor","text":"Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"FMRegressor"},{"location":"api/facto/FMRegressor/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/FMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236504 >>> report = model . debug_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23426 5.23426 Bob - Harry Potter 1.00000 0.00224 0.00224 Harry Potter 1.00000 0.00000 0.00000 Bob 1.00000 0.00000 0.00000","title":"Examples"},{"location":"api/facto/FMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/FMRegressor/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9 Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9","title":"References"},{"location":"api/facto/FwFMClassifier/","text":"FwFMClassifier \u00b6 Field-weighted Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FwFMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"FwFMClassifier"},{"location":"api/facto/FwFMClassifier/#fwfmclassifier","text":"Field-weighted Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FwFMClassifier"},{"location":"api/facto/FwFMClassifier/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FwFMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs.","title":"Attributes"},{"location":"api/facto/FwFMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, False ) ... ) >>> model = facto . FwFMClassifier ( ... n_factors = 10 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) True","title":"Examples"},{"location":"api/facto/FwFMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/FwFMClassifier/#references","text":"Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"References"},{"location":"api/facto/FwFMRegressor/","text":"FwFMRegressor \u00b6 Field-weighted Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] . Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FwFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236501 >>> report = model . debug_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23426 5.23426 Bob ( Harry Potter ) - Harry Potter ( Bob ) 1.00000 0.00224 0.00224 Harry Potter 1.00000 0.00000 0.00000 Bob 1.00000 0.00000 0.00000 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"FwFMRegressor"},{"location":"api/facto/FwFMRegressor/#fwfmregressor","text":"Field-weighted Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: feature_name.split('_')[0] .","title":"FwFMRegressor"},{"location":"api/facto/FwFMRegressor/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. int_weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the field pairs interaction weights. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/FwFMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features. interaction_weights The current interaction strengths of field pairs.","title":"Attributes"},{"location":"api/facto/FwFMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = facto . FwFMRegressor ( ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... model = model . learn_one ( x , y ) >>> model . predict_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) 5.236501 >>> report = model . debug_one ({ 'Bob' : 1 , 'Harry Potter' : 1 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23426 5.23426 Bob ( Harry Potter ) - Harry Potter ( Bob ) 1.00000 0.00224 0.00224 Harry Potter 1.00000 0.00000 0.00000 Bob 1.00000 0.00000 0.00000","title":"Examples"},{"location":"api/facto/FwFMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/FwFMRegressor/#references","text":"Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9","title":"References"},{"location":"api/facto/HOFMClassifier/","text":"HOFMClassifier \u00b6 Higher-Order Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, False ) ... ) >>> model = facto . HOFMClassifier ( ... degree = 3 , ... n_factors = 10 , ... intercept = .5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) True Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"HOFMClassifier"},{"location":"api/facto/HOFMClassifier/#hofmclassifier","text":"Higher-Order Factorization Machine for binary classification. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"HOFMClassifier"},{"location":"api/facto/HOFMClassifier/#parameters","text":"degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/HOFMClassifier/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/HOFMClassifier/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, True ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, False ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, True ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, False ) ... ) >>> model = facto . HOFMClassifier ( ... degree = 3 , ... n_factors = 10 , ... intercept = .5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) True","title":"Examples"},{"location":"api/facto/HOFMClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) sample_weight \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/facto/HOFMClassifier/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"References"},{"location":"api/facto/HOFMRegressor/","text":"HOFMRegressor \u00b6 Higher-Order Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Parameters \u00b6 degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note thatthe intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility. Attributes \u00b6 weights The current weights assigned to the features. latents The current latent weights assigned to the features. Examples \u00b6 >>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, 2 ) ... ) >>> model = facto . HOFMRegressor ( ... degree = 3 , ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) 5.311745 >>> report = model . debug_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23495 5.23495 user_Bob 1.00000 0.11436 0.11436 time 0.14000 0.03185 0.00446 user_Bob - time 0.14000 0.00884 0.00124 user_Bob - item_Harry Potter - time 0.14000 0.00117 0.00016 item_Harry Potter 1.00000 0.00000 0.00000 item_Harry Potter - time 0.14000 - 0.00695 - 0.00097 user_Bob - item_Harry Potter 1.00000 - 0.04246 - 0.04246 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"HOFMRegressor"},{"location":"api/facto/HOFMRegressor/#hofmregressor","text":"Higher-Order Factorization Machine for regression. The model equation is defined as: \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.","title":"HOFMRegressor"},{"location":"api/facto/HOFMRegressor/#parameters","text":"degree \u2013 defaults to 3 Polynomial degree or model order. n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. weight_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the feature weights. Note thatthe intercept is handled separately. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. sample_normalization \u2013 defaults to False Whether to divide each element of x by x 's L2-norm. l1_weight \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. l2_weight \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. l1_latent \u2013 defaults to 0.0 Amount of L1 regularization used to push latent weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. intercept \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. An instance of optim.schedulers.Constant is used if a float is passed. No intercept will be used if this is set to 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Defaults to optim.initializers.Zeros() . latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. Defaults to optim.initializers.Normal(mu=.0, sigma=.1, random_state=self.random_state) . clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed ( int ) \u2013 defaults to None Randomization seed used for reproducibility.","title":"Parameters"},{"location":"api/facto/HOFMRegressor/#attributes","text":"weights The current weights assigned to the features. latents The current latent weights assigned to the features.","title":"Attributes"},{"location":"api/facto/HOFMRegressor/#examples","text":">>> from river import facto >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' , 'time' : .12 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' , 'time' : .13 }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' , 'time' : .14 }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' , 'time' : .15 }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter ' , 'time' : .16 }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' , 'time' : .13 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' , 'time' : .12 }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' , 'time' : .16 }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' , 'time' : .10 }, 2 ) ... ) >>> model = facto . HOFMRegressor ( ... degree = 3 , ... n_factors = 10 , ... intercept = 5 , ... seed = 42 , ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) 5.311745 >>> report = model . debug_one ({ 'user' : 'Bob' , 'item' : 'Harry Potter' , 'time' : .14 }) >>> print ( report ) Name Value Weight Contribution Intercept 1.00000 5.23495 5.23495 user_Bob 1.00000 0.11436 0.11436 time 0.14000 0.03185 0.00446 user_Bob - time 0.14000 0.00884 0.00124 user_Bob - item_Harry Potter - time 0.14000 0.00117 0.00016 item_Harry Potter 1.00000 0.00000 0.00000 item_Harry Potter - time 0.14000 - 0.00695 - 0.00097 user_Bob - item_Harry Potter 1.00000 - 0.04246 - 0.04246","title":"Examples"},{"location":"api/facto/HOFMRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the FM regressor. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) sample_weight \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/facto/HOFMRegressor/#references","text":"Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9","title":"References"},{"location":"api/feature-extraction/Agg/","text":"Agg \u00b6 Computes a streaming aggregate. This transformer allows to compute an aggregate statistic, very much like the groupby method from pandas , but on a streaming dataset. This makes use of the streaming statistics from the stats module. When learn_one is called, the running statistic how of group by is updated with the value of on . Meanwhile, the output of transform_one is a single-element dictionary, where the key is the name of the aggregate and the value is the current value of the statistic for the relevant group. The key is automatically inferred from the parameters. Note that you can use a compose.TransformerUnion to extract many aggregate statistics in a concise manner. Parameters \u00b6 on ( str ) The feature on which to compute the aggregate statistic. by ( Union[str, List[str], NoneType] ) The feature by which to group the data. All the data is included in the aggregate if this is None . how ( river.stats.base.Univariate ) The statistic to compute. Attributes \u00b6 state Return the current values for each group. Examples -------- >>> X = [ ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 42}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 16}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 24}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 58}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 20}, ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 50}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 10}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 80}, ... ] >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx.Agg(on=\"revenue\", by=\"place\", how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state Taco Bell 57.5 Burger King 17.5 Name: revenue_mean_by_place, dtype: float64 >>> agg = fx.Agg(on=\"revenue\", by=[\"country\", \"place\"], how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state country place France Taco Bell 46.0 Sweden Burger King 18.0 France Burger King 17.0 Sweden Taco Bell 69.0 Name: revenue_mean_by_country_and_place, dtype: float64 Examples \u00b6 Consider the following dataset: >>> X = [ ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 50 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 10 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 80 } ... ] As an example, we can calculate the average (how) revenue (on) for each place (by): >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx . Agg ( ... on = 'revenue' , ... by = 'place' , ... how = stats . Mean () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_mean_by_place' : 42.0 } { 'revenue_mean_by_place' : 16.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 17.5 } { 'revenue_mean_by_place' : 57.5 } You can compute an aggregate over multiple keys by passing a tuple to the by argument. For instance, we can compute the maximum (how) revenue (on) per place as well as per day (by): >>> agg = fx . Agg ( ... on = 'revenue' , ... by = [ 'place' , 'country' ], ... how = stats . Max () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 } { 'revenue_max_by_place_and_country' : 16 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 58 } { 'revenue_max_by_place_and_country' : 20 } { 'revenue_max_by_place_and_country' : 50 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 80 } You can use a compose.TransformerUnion in order to calculate multiple aggregates in one go. The latter can be constructed by using the + operator: >>> agg = ( ... fx . Agg ( on = 'revenue' , by = 'place' , how = stats . Mean ()) + ... fx . Agg ( on = 'revenue' , by = [ 'place' , 'country' ], how = stats . Max ()) ... ) >>> import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint . pprint ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 , 'revenue_mean_by_place' : 42.0 } { 'revenue_max_by_place_and_country' : 16 , 'revenue_mean_by_place' : 16.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 58 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 20 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 50 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 17.5 } { 'revenue_max_by_place_and_country' : 80 , 'revenue_mean_by_place' : 57.5 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Streaming groupbys in pandas for big datasets \u21a9","title":"Agg"},{"location":"api/feature-extraction/Agg/#agg","text":"Computes a streaming aggregate. This transformer allows to compute an aggregate statistic, very much like the groupby method from pandas , but on a streaming dataset. This makes use of the streaming statistics from the stats module. When learn_one is called, the running statistic how of group by is updated with the value of on . Meanwhile, the output of transform_one is a single-element dictionary, where the key is the name of the aggregate and the value is the current value of the statistic for the relevant group. The key is automatically inferred from the parameters. Note that you can use a compose.TransformerUnion to extract many aggregate statistics in a concise manner.","title":"Agg"},{"location":"api/feature-extraction/Agg/#parameters","text":"on ( str ) The feature on which to compute the aggregate statistic. by ( Union[str, List[str], NoneType] ) The feature by which to group the data. All the data is included in the aggregate if this is None . how ( river.stats.base.Univariate ) The statistic to compute.","title":"Parameters"},{"location":"api/feature-extraction/Agg/#attributes","text":"state Return the current values for each group. Examples -------- >>> X = [ ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 42}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 16}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 24}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 58}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 20}, ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 50}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 10}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 80}, ... ] >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx.Agg(on=\"revenue\", by=\"place\", how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state Taco Bell 57.5 Burger King 17.5 Name: revenue_mean_by_place, dtype: float64 >>> agg = fx.Agg(on=\"revenue\", by=[\"country\", \"place\"], how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state country place France Taco Bell 46.0 Sweden Burger King 18.0 France Burger King 17.0 Sweden Taco Bell 69.0 Name: revenue_mean_by_country_and_place, dtype: float64","title":"Attributes"},{"location":"api/feature-extraction/Agg/#examples","text":"Consider the following dataset: >>> X = [ ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 42 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 16 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 24 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 58 }, ... { 'country' : 'Sweden' , 'place' : 'Burger King' , 'revenue' : 20 }, ... { 'country' : 'France' , 'place' : 'Taco Bell' , 'revenue' : 50 }, ... { 'country' : 'France' , 'place' : 'Burger King' , 'revenue' : 10 }, ... { 'country' : 'Sweden' , 'place' : 'Taco Bell' , 'revenue' : 80 } ... ] As an example, we can calculate the average (how) revenue (on) for each place (by): >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx . Agg ( ... on = 'revenue' , ... by = 'place' , ... how = stats . Mean () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_mean_by_place' : 42.0 } { 'revenue_mean_by_place' : 16.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 20.0 } { 'revenue_mean_by_place' : 50.0 } { 'revenue_mean_by_place' : 17.5 } { 'revenue_mean_by_place' : 57.5 } You can compute an aggregate over multiple keys by passing a tuple to the by argument. For instance, we can compute the maximum (how) revenue (on) per place as well as per day (by): >>> agg = fx . Agg ( ... on = 'revenue' , ... by = [ 'place' , 'country' ], ... how = stats . Max () ... ) >>> for x in X : ... agg = agg . learn_one ( x ) ... print ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 } { 'revenue_max_by_place_and_country' : 16 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 58 } { 'revenue_max_by_place_and_country' : 20 } { 'revenue_max_by_place_and_country' : 50 } { 'revenue_max_by_place_and_country' : 24 } { 'revenue_max_by_place_and_country' : 80 } You can use a compose.TransformerUnion in order to calculate multiple aggregates in one go. The latter can be constructed by using the + operator: >>> agg = ( ... fx . Agg ( on = 'revenue' , by = 'place' , how = stats . Mean ()) + ... fx . Agg ( on = 'revenue' , by = [ 'place' , 'country' ], how = stats . Max ()) ... ) >>> import pprint >>> for x in X : ... agg = agg . learn_one ( x ) ... pprint . pprint ( agg . transform_one ( x )) { 'revenue_max_by_place_and_country' : 42 , 'revenue_mean_by_place' : 42.0 } { 'revenue_max_by_place_and_country' : 16 , 'revenue_mean_by_place' : 16.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 58 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 20 , 'revenue_mean_by_place' : 20.0 } { 'revenue_max_by_place_and_country' : 50 , 'revenue_mean_by_place' : 50.0 } { 'revenue_max_by_place_and_country' : 24 , 'revenue_mean_by_place' : 17.5 } { 'revenue_max_by_place_and_country' : 80 , 'revenue_mean_by_place' : 57.5 }","title":"Examples"},{"location":"api/feature-extraction/Agg/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/Agg/#references","text":"Streaming groupbys in pandas for big datasets \u21a9","title":"References"},{"location":"api/feature-extraction/BagOfWords/","text":"BagOfWords \u00b6 Counts tokens in sentences. This transformer can be used to counts tokens in a given piece of text. It takes care of normalizing the text before tokenizing it. In mini-batch settings, this transformers allows to convert a series of pandas of text into sparse dataframe. Note that the parameters are identical to those of feature_extraction.TFIDF . Parameters \u00b6 on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then each learn_one and transform_one will assume that each x that is provided is a str , andnot a dict . strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams. Examples \u00b6 By default, BagOfWords will take as input a sentence, preprocess it, tokenize the preprocessed text, and then return a collections.Counter containing the number of occurrences of each token. >>> from river import feature_extraction as fx >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> bow = fx . BagOfWords () >>> for sentence in corpus : ... print ( bow . transform_one ( sentence )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Note that learn_one does not have to be called because BagOfWords is stateless. You can call it but it won't do anything. In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> bow = fx . BagOfWords ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... print ( bow . transform_one ( x )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) The ngram_range parameter can be used to extract n-grams (including unigrams): >>> ngrammer = fx . BagOfWords ( ngram_range = ( 1 , 2 )) >>> ngrams = ngrammer . transform_one ( 'I love the smell of napalm in the morning' ) >>> for ngram , count in ngrams . items (): ... print ( ngram , count ) love 1 the 2 smell 1 of 1 napalm 1 in 1 morning 1 ( 'love' , 'the' ) 1 ( 'the' , 'smell' ) 1 ( 'smell' , 'of' ) 1 ( 'of' , 'napalm' ) 1 ( 'napalm' , 'in' ) 1 ( 'in' , 'the' ) 1 ( 'the' , 'morning' ) 1 BagOfWord allows to build a term-frequency pandas sparse dataframe with the transform_many method. >>> import pandas as pd >>> X = pd . Series ([ 'Hello world' , 'Hello River' ], index = [ 'river' , 'rocks' ]) >>> bow = fx . BagOfWords () >>> bow . transform_many ( X = X ) hello world river river 1 1 0 rocks 1 0 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"BagOfWords"},{"location":"api/feature-extraction/BagOfWords/#bagofwords","text":"Counts tokens in sentences. This transformer can be used to counts tokens in a given piece of text. It takes care of normalizing the text before tokenizing it. In mini-batch settings, this transformers allows to convert a series of pandas of text into sparse dataframe. Note that the parameters are identical to those of feature_extraction.TFIDF .","title":"BagOfWords"},{"location":"api/feature-extraction/BagOfWords/#parameters","text":"on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then each learn_one and transform_one will assume that each x that is provided is a str , andnot a dict . strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams.","title":"Parameters"},{"location":"api/feature-extraction/BagOfWords/#examples","text":"By default, BagOfWords will take as input a sentence, preprocess it, tokenize the preprocessed text, and then return a collections.Counter containing the number of occurrences of each token. >>> from river import feature_extraction as fx >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> bow = fx . BagOfWords () >>> for sentence in corpus : ... print ( bow . transform_one ( sentence )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Note that learn_one does not have to be called because BagOfWords is stateless. You can call it but it won't do anything. In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> bow = fx . BagOfWords ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... print ( bow . transform_one ( x )) Counter ({ 'this' : 1 , 'is' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) Counter ({ 'document' : 2 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'second' : 1 }) Counter ({ 'and' : 1 , 'this' : 1 , 'is' : 1 , 'the' : 1 , 'third' : 1 , 'one' : 1 }) Counter ({ 'is' : 1 , 'this' : 1 , 'the' : 1 , 'first' : 1 , 'document' : 1 }) The ngram_range parameter can be used to extract n-grams (including unigrams): >>> ngrammer = fx . BagOfWords ( ngram_range = ( 1 , 2 )) >>> ngrams = ngrammer . transform_one ( 'I love the smell of napalm in the morning' ) >>> for ngram , count in ngrams . items (): ... print ( ngram , count ) love 1 the 2 smell 1 of 1 napalm 1 in 1 morning 1 ( 'love' , 'the' ) 1 ( 'the' , 'smell' ) 1 ( 'smell' , 'of' ) 1 ( 'of' , 'napalm' ) 1 ( 'napalm' , 'in' ) 1 ( 'in' , 'the' ) 1 ( 'the' , 'morning' ) 1 BagOfWord allows to build a term-frequency pandas sparse dataframe with the transform_many method. >>> import pandas as pd >>> X = pd . Series ([ 'Hello world' , 'Hello River' ], index = [ 'river' , 'rocks' ]) >>> bow = fx . BagOfWords () >>> bow . transform_many ( X = X ) hello world river river 1 1 0 rocks 1 0 1","title":"Examples"},{"location":"api/feature-extraction/BagOfWords/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/PolynomialExtender/","text":"PolynomialExtender \u00b6 Polynomial feature extender. Generate features consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. Be aware that the number of outputted features scales polynomially in the number of input features and exponentially in the degree. High degrees can cause overfitting. Parameters \u00b6 degree \u2013 defaults to 2 The maximum degree of the polynomial features. interaction_only \u2013 defaults to False If True then only combinations that include an element at most once will be computed. include_bias \u2013 defaults to False Whether or not to include a dummy feature which is always equal to 1. bias_name \u2013 defaults to bias Name to give to the bias feature. Examples \u00b6 >>> from river import feature_extraction as fx >>> X = [ ... { 'x' : 0 , 'y' : 1 }, ... { 'x' : 2 , 'y' : 3 }, ... { 'x' : 4 , 'y' : 5 } ... ] >>> poly = fx . PolynomialExtender ( degree = 2 , include_bias = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'x*x' : 0 , 'x*y' : 0 , 'y*y' : 1 , 'bias' : 1 } { 'x' : 2 , 'y' : 3 , 'x*x' : 4 , 'x*y' : 6 , 'y*y' : 9 , 'bias' : 1 } { 'x' : 4 , 'y' : 5 , 'x*x' : 16 , 'x*y' : 20 , 'y*y' : 25 , 'bias' : 1 } >>> X = [ ... { 'x' : 0 , 'y' : 1 , 'z' : 2 }, ... { 'x' : 2 , 'y' : 3 , 'z' : 2 }, ... { 'x' : 4 , 'y' : 5 , 'z' : 2 } ... ] >>> poly = fx . PolynomialExtender ( degree = 3 , interaction_only = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'z' : 2 , 'x*y' : 0 , 'x*z' : 0 , 'y*z' : 2 , 'x*y*z' : 0 } { 'x' : 2 , 'y' : 3 , 'z' : 2 , 'x*y' : 6 , 'x*z' : 4 , 'y*z' : 6 , 'x*y*z' : 12 } { 'x' : 4 , 'y' : 5 , 'z' : 2 , 'x*y' : 20 , 'x*z' : 8 , 'y*z' : 10 , 'x*y*z' : 40 } Polynomial features are typically used for a linear model to capture interactions between features. This may done by setting up a pipeline, as so: >>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = ( ... fx . PolynomialExtender () | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.88 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"PolynomialExtender"},{"location":"api/feature-extraction/PolynomialExtender/#polynomialextender","text":"Polynomial feature extender. Generate features consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. Be aware that the number of outputted features scales polynomially in the number of input features and exponentially in the degree. High degrees can cause overfitting.","title":"PolynomialExtender"},{"location":"api/feature-extraction/PolynomialExtender/#parameters","text":"degree \u2013 defaults to 2 The maximum degree of the polynomial features. interaction_only \u2013 defaults to False If True then only combinations that include an element at most once will be computed. include_bias \u2013 defaults to False Whether or not to include a dummy feature which is always equal to 1. bias_name \u2013 defaults to bias Name to give to the bias feature.","title":"Parameters"},{"location":"api/feature-extraction/PolynomialExtender/#examples","text":">>> from river import feature_extraction as fx >>> X = [ ... { 'x' : 0 , 'y' : 1 }, ... { 'x' : 2 , 'y' : 3 }, ... { 'x' : 4 , 'y' : 5 } ... ] >>> poly = fx . PolynomialExtender ( degree = 2 , include_bias = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'x*x' : 0 , 'x*y' : 0 , 'y*y' : 1 , 'bias' : 1 } { 'x' : 2 , 'y' : 3 , 'x*x' : 4 , 'x*y' : 6 , 'y*y' : 9 , 'bias' : 1 } { 'x' : 4 , 'y' : 5 , 'x*x' : 16 , 'x*y' : 20 , 'y*y' : 25 , 'bias' : 1 } >>> X = [ ... { 'x' : 0 , 'y' : 1 , 'z' : 2 }, ... { 'x' : 2 , 'y' : 3 , 'z' : 2 }, ... { 'x' : 4 , 'y' : 5 , 'z' : 2 } ... ] >>> poly = fx . PolynomialExtender ( degree = 3 , interaction_only = True ) >>> for x in X : ... print ( poly . transform_one ( x )) { 'x' : 0 , 'y' : 1 , 'z' : 2 , 'x*y' : 0 , 'x*z' : 0 , 'y*z' : 2 , 'x*y*z' : 0 } { 'x' : 2 , 'y' : 3 , 'z' : 2 , 'x*y' : 6 , 'x*z' : 4 , 'y*z' : 6 , 'x*y*z' : 12 } { 'x' : 4 , 'y' : 5 , 'z' : 2 , 'x*y' : 20 , 'x*z' : 8 , 'y*z' : 10 , 'x*y*z' : 40 } Polynomial features are typically used for a linear model to capture interactions between features. This may done by setting up a pipeline, as so: >>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = ( ... fx . PolynomialExtender () | ... pp . StandardScaler () | ... lm . LogisticRegression () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.88 %","title":"Examples"},{"location":"api/feature-extraction/PolynomialExtender/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/RBFSampler/","text":"RBFSampler \u00b6 Extracts random features which approximate an RBF kernel. This is a powerful way to give non-linear capacity to linear classifiers. This method is also called \"random Fourier features\" in the literature. Parameters \u00b6 gamma \u2013 defaults to 1.0 RBF kernel parameter in (-gamma * x^2) . n_components \u2013 defaults to 100 Number of samples per original feature. Equals the dimensionality of the computed feature space. seed ( int ) \u2013 defaults to None Random number seed. Examples \u00b6 >>> from river import feature_extraction as fx >>> from river import linear_model as lm >>> from river import optim >>> from river import stream >>> # XOR function >>> X = [[ 0 , 0 ], [ 1 , 1 ], [ 1 , 0 ], [ 0 , 1 ]] >>> Y = [ 0 , 0 , 1 , 1 ] >>> model = lm . LogisticRegression ( optimizer = optim . SGD ( .1 )) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 0 1 1 >>> model = ( ... fx . RBFSampler ( seed = 3 ) | ... lm . LogisticRegression ( optimizer = optim . SGD ( .1 )) ... ) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 1 1 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values. References \u00b6 Rahimi, A. and Recht, B., 2008. Random features for large-scale kernel machines. In Advances in neural information processing systems (pp. 1177-1184 \u21a9","title":"RBFSampler"},{"location":"api/feature-extraction/RBFSampler/#rbfsampler","text":"Extracts random features which approximate an RBF kernel. This is a powerful way to give non-linear capacity to linear classifiers. This method is also called \"random Fourier features\" in the literature.","title":"RBFSampler"},{"location":"api/feature-extraction/RBFSampler/#parameters","text":"gamma \u2013 defaults to 1.0 RBF kernel parameter in (-gamma * x^2) . n_components \u2013 defaults to 100 Number of samples per original feature. Equals the dimensionality of the computed feature space. seed ( int ) \u2013 defaults to None Random number seed.","title":"Parameters"},{"location":"api/feature-extraction/RBFSampler/#examples","text":">>> from river import feature_extraction as fx >>> from river import linear_model as lm >>> from river import optim >>> from river import stream >>> # XOR function >>> X = [[ 0 , 0 ], [ 1 , 1 ], [ 1 , 0 ], [ 0 , 1 ]] >>> Y = [ 0 , 0 , 1 , 1 ] >>> model = lm . LogisticRegression ( optimizer = optim . SGD ( .1 )) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 0 1 1 >>> model = ( ... fx . RBFSampler ( seed = 3 ) | ... lm . LogisticRegression ( optimizer = optim . SGD ( .1 )) ... ) >>> for x , y in stream . iter_array ( X , Y ): ... model = model . learn_one ( x , y ) ... y_pred = model . predict_one ( x ) ... print ( y , int ( y_pred )) 0 0 0 0 1 1 1 1","title":"Examples"},{"location":"api/feature-extraction/RBFSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/RBFSampler/#references","text":"Rahimi, A. and Recht, B., 2008. Random features for large-scale kernel machines. In Advances in neural information processing systems (pp. 1177-1184 \u21a9","title":"References"},{"location":"api/feature-extraction/TFIDF/","text":"TFIDF \u00b6 Computes TF-IDF values from sentences. The TF-IDF formula is the same one as scikit-learn. The only difference is the fact that the document frequencies are determined online, whereas in a batch setting they can be determined by performing an initial pass through the data. Note that the parameters are identical to those of feature_extraction.BagOfWords . Parameters \u00b6 normalize \u2013 defaults to True Whether or not the TF-IDF values by their L2 norm. on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then the input is treated as a document instead of a set of features. strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams. Only works if tokenizer is not set to False . Attributes \u00b6 dfs ( collections.defaultdict) ) Document counts. n ( int ) Number of scanned documents. Examples \u00b6 >>> from river import feature_extraction >>> tfidf = feature_extraction . TFIDF () >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> for sentence in corpus : ... tfidf = tfidf . learn_one ( sentence ) ... print ( tfidf . transform_one ( sentence )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 } In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> tfidf = feature_extraction . TFIDF ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... tfidf = tfidf . learn_one ( x ) ... print ( tfidf . transform_one ( x )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"TFIDF"},{"location":"api/feature-extraction/TFIDF/#tfidf","text":"Computes TF-IDF values from sentences. The TF-IDF formula is the same one as scikit-learn. The only difference is the fact that the document frequencies are determined online, whereas in a batch setting they can be determined by performing an initial pass through the data. Note that the parameters are identical to those of feature_extraction.BagOfWords .","title":"TFIDF"},{"location":"api/feature-extraction/TFIDF/#parameters","text":"normalize \u2013 defaults to True Whether or not the TF-IDF values by their L2 norm. on ( str ) \u2013 defaults to None The name of the feature that contains the text to vectorize. If None , then the input is treated as a document instead of a set of features. strip_accents \u2013 defaults to True Whether or not to strip accent characters. lowercase \u2013 defaults to True Whether or not to convert all characters to lowercase. preprocessor ( Callable ) \u2013 defaults to None Override the preprocessing step while preserving the tokenizing and n-grams generation steps. tokenizer ( Callable ) \u2013 defaults to None A function used to convert preprocessed text into a dict of tokens. By default, a regex formula that works well in most cases is used. ngram_range \u2013 defaults to (1, 1) The lower and upper boundary of the range n-grams to be extracted. All values of n such that min_n <= n <= max_n will be used. For example an ngram_range of (1, 1) means only unigrams, (1, 2) means unigrams and bigrams, and (2, 2) means only bigrams. Only works if tokenizer is not set to False .","title":"Parameters"},{"location":"api/feature-extraction/TFIDF/#attributes","text":"dfs ( collections.defaultdict) ) Document counts. n ( int ) Number of scanned documents.","title":"Attributes"},{"location":"api/feature-extraction/TFIDF/#examples","text":">>> from river import feature_extraction >>> tfidf = feature_extraction . TFIDF () >>> corpus = [ ... 'This is the first document.' , ... 'This document is the second document.' , ... 'And this is the third one.' , ... 'Is this the first document?' , ... ] >>> for sentence in corpus : ... tfidf = tfidf . learn_one ( sentence ) ... print ( tfidf . transform_one ( sentence )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 } In the above example, a string is passed to transform_one . You can also indicate which field to access if the string is stored in a dictionary: >>> tfidf = feature_extraction . TFIDF ( on = 'sentence' ) >>> for sentence in corpus : ... x = { 'sentence' : sentence } ... tfidf = tfidf . learn_one ( x ) ... print ( tfidf . transform_one ( x )) { 'this' : 0.447 , 'is' : 0.447 , 'the' : 0.447 , 'first' : 0.447 , 'document' : 0.447 } { 'this' : 0.333 , 'document' : 0.667 , 'is' : 0.333 , 'the' : 0.333 , 'second' : 0.469 } { 'and' : 0.497 , 'this' : 0.293 , 'is' : 0.293 , 'the' : 0.293 , 'third' : 0.497 , 'one' : 0.497 } { 'is' : 0.384 , 'this' : 0.384 , 'the' : 0.384 , 'first' : 0.580 , 'document' : 0.469 }","title":"Examples"},{"location":"api/feature-extraction/TFIDF/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self process_text transform_many Transform pandas series of string into term-frequency pandas sparse dataframe. Parameters X ( pandas.core.series.Series ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/TargetAgg/","text":"TargetAgg \u00b6 Computes a streaming aggregate of the target values. This transformer is identical to feature_extraction.Agg , the only difference is that it operates on the target rather than on a feature. At each step, the running statistic how of target values in group by is updated with the target. It is therefore a supervised transformer. Parameters \u00b6 by ( Union[str, List[str], NoneType] ) The feature by which to group the target values. All the data is included in the aggregate if this is None . how ( river.stats.base.Univariate ) The statistic to compute. target_name \u2013 defaults to y The target name which is used in the result. Attributes \u00b6 state Return the current values for each group. Examples -------- >>> X = [ ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 42}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 16}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 24}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 58}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 20}, ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 50}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 10}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 80}, ... ] >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx.Agg(on=\"revenue\", by=\"place\", how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state Taco Bell 57.5 Burger King 17.5 Name: revenue_mean_by_place, dtype: float64 >>> agg = fx.Agg(on=\"revenue\", by=[\"country\", \"place\"], how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state country place France Taco Bell 46.0 Sweden Burger King 18.0 France Burger King 17.0 Sweden Taco Bell 69.0 Name: revenue_mean_by_country_and_place, dtype: float64 target_name Examples \u00b6 Consider the following dataset, where the second value of each value is the target: >>> dataset = [ ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 42 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 16 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 24 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 58 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 20 ), ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 50 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 10 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 80 ) ... ] As an example, let's perform a target encoding of the place feature. Instead of simply updating a running average, we use a stats.BayesianMean which allows us to incorporate some prior knowledge. This makes subsequent models less prone to overfitting. Indeed, it dampens the fact that too few samples might have been seen within a group. >>> from river import feature_extraction >>> from river import stats >>> agg = feature_extraction . TargetAgg ( ... by = 'place' , ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'y_bayes_mean_by_place' : 3.0 } { 'y_bayes_mean_by_place' : 3.0 } { 'y_bayes_mean_by_place' : 9.5 } { 'y_bayes_mean_by_place' : 22.5 } { 'y_bayes_mean_by_place' : 14.333 } { 'y_bayes_mean_by_place' : 34.333 } { 'y_bayes_mean_by_place' : 15.75 } { 'y_bayes_mean_by_place' : 38.25 } Just like with feature_extraction.Agg , we can specify multiple features on which to group the data: >>> agg = feature_extraction . TargetAgg ( ... by = [ 'place' , 'country' ], ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 9.5 } { 'y_bayes_mean_by_place_and_country' : 22.5 } { 'y_bayes_mean_by_place_and_country' : 13.5 } { 'y_bayes_mean_by_place_and_country' : 30.5 } >>> agg . state place country Taco Bell France 31.666667 Burger King Sweden 13.000000 France 12.333333 Taco Bell Sweden 47.000000 Name : y_bayes_mean_by_place_and_country , dtype : float64 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Streaming groupbys in pandas for big datasets","title":"TargetAgg"},{"location":"api/feature-extraction/TargetAgg/#targetagg","text":"Computes a streaming aggregate of the target values. This transformer is identical to feature_extraction.Agg , the only difference is that it operates on the target rather than on a feature. At each step, the running statistic how of target values in group by is updated with the target. It is therefore a supervised transformer.","title":"TargetAgg"},{"location":"api/feature-extraction/TargetAgg/#parameters","text":"by ( Union[str, List[str], NoneType] ) The feature by which to group the target values. All the data is included in the aggregate if this is None . how ( river.stats.base.Univariate ) The statistic to compute. target_name \u2013 defaults to y The target name which is used in the result.","title":"Parameters"},{"location":"api/feature-extraction/TargetAgg/#attributes","text":"state Return the current values for each group. Examples -------- >>> X = [ ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 42}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 16}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 24}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 58}, ... {\"country\": \"Sweden\", \"place\": \"Burger King\", \"revenue\": 20}, ... {\"country\": \"France\", \"place\": \"Taco Bell\", \"revenue\": 50}, ... {\"country\": \"France\", \"place\": \"Burger King\", \"revenue\": 10}, ... {\"country\": \"Sweden\", \"place\": \"Taco Bell\", \"revenue\": 80}, ... ] >>> from river import feature_extraction as fx >>> from river import stats >>> agg = fx.Agg(on=\"revenue\", by=\"place\", how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state Taco Bell 57.5 Burger King 17.5 Name: revenue_mean_by_place, dtype: float64 >>> agg = fx.Agg(on=\"revenue\", by=[\"country\", \"place\"], how=stats.Mean()) >>> for x in X: ... agg = agg.learn_one(x) >>> agg.state country place France Taco Bell 46.0 Sweden Burger King 18.0 France Burger King 17.0 Sweden Taco Bell 69.0 Name: revenue_mean_by_country_and_place, dtype: float64 target_name","title":"Attributes"},{"location":"api/feature-extraction/TargetAgg/#examples","text":"Consider the following dataset, where the second value of each value is the target: >>> dataset = [ ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 42 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 16 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 24 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 58 ), ... ({ 'country' : 'Sweden' , 'place' : 'Burger King' }, 20 ), ... ({ 'country' : 'France' , 'place' : 'Taco Bell' }, 50 ), ... ({ 'country' : 'France' , 'place' : 'Burger King' }, 10 ), ... ({ 'country' : 'Sweden' , 'place' : 'Taco Bell' }, 80 ) ... ] As an example, let's perform a target encoding of the place feature. Instead of simply updating a running average, we use a stats.BayesianMean which allows us to incorporate some prior knowledge. This makes subsequent models less prone to overfitting. Indeed, it dampens the fact that too few samples might have been seen within a group. >>> from river import feature_extraction >>> from river import stats >>> agg = feature_extraction . TargetAgg ( ... by = 'place' , ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'y_bayes_mean_by_place' : 3.0 } { 'y_bayes_mean_by_place' : 3.0 } { 'y_bayes_mean_by_place' : 9.5 } { 'y_bayes_mean_by_place' : 22.5 } { 'y_bayes_mean_by_place' : 14.333 } { 'y_bayes_mean_by_place' : 34.333 } { 'y_bayes_mean_by_place' : 15.75 } { 'y_bayes_mean_by_place' : 38.25 } Just like with feature_extraction.Agg , we can specify multiple features on which to group the data: >>> agg = feature_extraction . TargetAgg ( ... by = [ 'place' , 'country' ], ... how = stats . BayesianMean ( ... prior = 3 , ... prior_weight = 1 ... ) ... ) >>> for x , y in dataset : ... print ( agg . transform_one ( x )) ... agg = agg . learn_one ( x , y ) { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 3.0 } { 'y_bayes_mean_by_place_and_country' : 9.5 } { 'y_bayes_mean_by_place_and_country' : 22.5 } { 'y_bayes_mean_by_place_and_country' : 13.5 } { 'y_bayes_mean_by_place_and_country' : 30.5 } >>> agg . state place country Taco Bell France 31.666667 Burger King Sweden 13.000000 France 12.333333 Taco Bell Sweden 47.000000 Name : y_bayes_mean_by_place_and_country , dtype : float64","title":"Examples"},{"location":"api/feature-extraction/TargetAgg/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-extraction/TargetAgg/#references","text":"Streaming groupbys in pandas for big datasets","title":"References"},{"location":"api/feature-selection/PoissonInclusion/","text":"PoissonInclusion \u00b6 Randomly selects features with an inclusion trial. When a new feature is encountered, it is selected with probability p . The number of times a feature needs to beseen before it is added to the model follows a geometric distribution with expected value 1 / p . This feature selection method is meant to be used when you have a very large amount of sparse features. Parameters \u00b6 p ( float ) Probability of including a feature the first time it is encountered. seed ( int ) \u2013 defaults to None Random seed value used for reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import feature_selection >>> from river import stream >>> selector = feature_selection . PoissonInclusion ( p = 0.1 , seed = 42 ) >>> dataset = iter ( datasets . TrumpApproval ()) >>> feature_names = next ( dataset )[ 0 ] . keys () >>> n = 0 >>> while True : ... x , y = next ( dataset ) ... xt = selector . transform_one ( x ) ... if xt . keys () == feature_names : ... break ... n += 1 >>> n 12 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9","title":"PoissonInclusion"},{"location":"api/feature-selection/PoissonInclusion/#poissoninclusion","text":"Randomly selects features with an inclusion trial. When a new feature is encountered, it is selected with probability p . The number of times a feature needs to beseen before it is added to the model follows a geometric distribution with expected value 1 / p . This feature selection method is meant to be used when you have a very large amount of sparse features.","title":"PoissonInclusion"},{"location":"api/feature-selection/PoissonInclusion/#parameters","text":"p ( float ) Probability of including a feature the first time it is encountered. seed ( int ) \u2013 defaults to None Random seed value used for reproducibility.","title":"Parameters"},{"location":"api/feature-selection/PoissonInclusion/#examples","text":">>> from river import datasets >>> from river import feature_selection >>> from river import stream >>> selector = feature_selection . PoissonInclusion ( p = 0.1 , seed = 42 ) >>> dataset = iter ( datasets . TrumpApproval ()) >>> feature_names = next ( dataset )[ 0 ] . keys () >>> n = 0 >>> while True : ... x , y = next ( dataset ) ... xt = selector . transform_one ( x ) ... if xt . keys () == feature_names : ... break ... n += 1 >>> n 12","title":"Examples"},{"location":"api/feature-selection/PoissonInclusion/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-selection/PoissonInclusion/#references","text":"McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9","title":"References"},{"location":"api/feature-selection/SelectKBest/","text":"SelectKBest \u00b6 Removes all but the \\(k\\) highest scoring features. Parameters \u00b6 similarity ( river.stats.base.Bivariate ) k \u2013 defaults to 10 The number of features to keep. Attributes \u00b6 similarities ( dict ) The similarity instances used for each feature. leaderboard ( dict ) The actual similarity measures. Examples \u00b6 >>> from pprint import pprint >>> from river import feature_selection >>> from river import stats >>> from river import stream >>> from sklearn import datasets >>> X , y = datasets . make_regression ( ... n_samples = 100 , ... n_features = 10 , ... n_informative = 2 , ... random_state = 42 ... ) >>> selector = feature_selection . SelectKBest ( ... similarity = stats . PearsonCorr (), ... k = 2 ... ) >>> for xi , yi , in stream . iter_array ( X , y ): ... selector = selector . learn_one ( xi , yi ) >>> pprint ( selector . leaderboard ) Counter ({ 9 : 0.7898 , 7 : 0.5444 , 8 : 0.1062 , 2 : 0.0638 , 4 : 0.0538 , 5 : 0.0271 , 1 : - 0.0312 , 6 : - 0.0657 , 3 : - 0.1501 , 0 : - 0.1895 }) >>> selector . transform_one ( xi ) { 7 : - 1.2795 , 9 : - 1.8408 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"SelectKBest"},{"location":"api/feature-selection/SelectKBest/#selectkbest","text":"Removes all but the \\(k\\) highest scoring features.","title":"SelectKBest"},{"location":"api/feature-selection/SelectKBest/#parameters","text":"similarity ( river.stats.base.Bivariate ) k \u2013 defaults to 10 The number of features to keep.","title":"Parameters"},{"location":"api/feature-selection/SelectKBest/#attributes","text":"similarities ( dict ) The similarity instances used for each feature. leaderboard ( dict ) The actual similarity measures.","title":"Attributes"},{"location":"api/feature-selection/SelectKBest/#examples","text":">>> from pprint import pprint >>> from river import feature_selection >>> from river import stats >>> from river import stream >>> from sklearn import datasets >>> X , y = datasets . make_regression ( ... n_samples = 100 , ... n_features = 10 , ... n_informative = 2 , ... random_state = 42 ... ) >>> selector = feature_selection . SelectKBest ( ... similarity = stats . PearsonCorr (), ... k = 2 ... ) >>> for xi , yi , in stream . iter_array ( X , y ): ... selector = selector . learn_one ( xi , yi ) >>> pprint ( selector . leaderboard ) Counter ({ 9 : 0.7898 , 7 : 0.5444 , 8 : 0.1062 , 2 : 0.0638 , 4 : 0.0538 , 5 : 0.0271 , 1 : - 0.0312 , 6 : - 0.0657 , 3 : - 0.1501 , 0 : - 0.1895 }) >>> selector . transform_one ( xi ) { 7 : - 1.2795 , 9 : - 1.8408 }","title":"Examples"},{"location":"api/feature-selection/SelectKBest/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x and a target y . Parameters x ( dict ) y ( Union[bool, str, int, numbers.Number] ) Returns SupervisedTransformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/feature-selection/VarianceThreshold/","text":"VarianceThreshold \u00b6 Removes low-variance features. Parameters \u00b6 threshold \u2013 defaults to 0 Only features with a variance above the threshold will be kept. min_samples \u2013 defaults to 2 The minimum number of samples required to perform selection. Attributes \u00b6 variances ( dict ) The variance of each feature. Examples \u00b6 >>> from river import feature_selection >>> from river import stream >>> X = [ ... [ 0 , 2 , 0 , 3 ], ... [ 0 , 1 , 4 , 3 ], ... [ 0 , 1 , 1 , 3 ] ... ] >>> selector = feature_selection . VarianceThreshold () >>> for x , _ in stream . iter_array ( X ): ... print ( selector . learn_one ( x ) . transform_one ( x )) { 0 : 0 , 1 : 2 , 2 : 0 , 3 : 3 } { 1 : 1 , 2 : 4 } { 1 : 1 , 2 : 1 } Methods \u00b6 check_feature clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"VarianceThreshold"},{"location":"api/feature-selection/VarianceThreshold/#variancethreshold","text":"Removes low-variance features.","title":"VarianceThreshold"},{"location":"api/feature-selection/VarianceThreshold/#parameters","text":"threshold \u2013 defaults to 0 Only features with a variance above the threshold will be kept. min_samples \u2013 defaults to 2 The minimum number of samples required to perform selection.","title":"Parameters"},{"location":"api/feature-selection/VarianceThreshold/#attributes","text":"variances ( dict ) The variance of each feature.","title":"Attributes"},{"location":"api/feature-selection/VarianceThreshold/#examples","text":">>> from river import feature_selection >>> from river import stream >>> X = [ ... [ 0 , 2 , 0 , 3 ], ... [ 0 , 1 , 4 , 3 ], ... [ 0 , 1 , 1 , 3 ] ... ] >>> selector = feature_selection . VarianceThreshold () >>> for x , _ in stream . iter_array ( X ): ... print ( selector . learn_one ( x ) . transform_one ( x )) { 0 : 0 , 1 : 2 , 2 : 0 , 3 : 3 } { 1 : 1 , 2 : 4 } { 1 : 1 , 2 : 1 }","title":"Examples"},{"location":"api/feature-selection/VarianceThreshold/#methods","text":"check_feature clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/imblearn/ChebyshevOverSampler/","text":"ChebyshevOverSampler \u00b6 Over-sampling for imbalanced regression using Chebyshev's inequality. Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\) . For any real number \\(t > 0\\) , the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\) . Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\) , and assuming \\(t > 1\\) , the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\) . Alternatively, one can use \\(t\\) directly to estimate a frequency weight \\(\\kappa = \\lceil t\\rceil\\) and define an over-sampling strategy for extreme and rare target values 1 . Each incoming instance is used \\(\\kappa\\) times to update the underlying regressor. Frequent target values contribute only once to the underlying regressor, whereas rares cases are used multiple times for training. Parameters \u00b6 regressor ( base.Regressor ) The regression model that will receive the biased sample. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import metrics >>> from river import preprocessing >>> from river import rules >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . ChebyshevOverSampler ( ... regressor = rules . AMRules ( ... n_min = 50 , delta = 0.01 ... ) ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 1.152726 [ 1 , 000 ] MAE : 0.954873 MAE : 0.954049 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y kwargs Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466. \u21a9","title":"ChebyshevOverSampler"},{"location":"api/imblearn/ChebyshevOverSampler/#chebyshevoversampler","text":"Over-sampling for imbalanced regression using Chebyshev's inequality. Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\) . For any real number \\(t > 0\\) , the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\) . Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\) , and assuming \\(t > 1\\) , the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\) . Alternatively, one can use \\(t\\) directly to estimate a frequency weight \\(\\kappa = \\lceil t\\rceil\\) and define an over-sampling strategy for extreme and rare target values 1 . Each incoming instance is used \\(\\kappa\\) times to update the underlying regressor. Frequent target values contribute only once to the underlying regressor, whereas rares cases are used multiple times for training.","title":"ChebyshevOverSampler"},{"location":"api/imblearn/ChebyshevOverSampler/#parameters","text":"regressor ( base.Regressor ) The regression model that will receive the biased sample.","title":"Parameters"},{"location":"api/imblearn/ChebyshevOverSampler/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import metrics >>> from river import preprocessing >>> from river import rules >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . ChebyshevOverSampler ( ... regressor = rules . AMRules ( ... n_min = 50 , delta = 0.01 ... ) ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 1.152726 [ 1 , 000 ] MAE : 0.954873 MAE : 0.954049","title":"Examples"},{"location":"api/imblearn/ChebyshevOverSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y kwargs Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/imblearn/ChebyshevOverSampler/#references","text":"Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466. \u21a9","title":"References"},{"location":"api/imblearn/ChebyshevUnderSampler/","text":"ChebyshevUnderSampler \u00b6 Under-sampling for imbalanced regression using Chebyshev's inequality. Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\) . For any real number \\(t > 0\\) , the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\) . Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\) , and assuming \\(t > 1\\) , the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\) . The reciprocal of this probability is used for under-sampling 1 the most frequent cases. Extreme valued or rare cases have higher probabilities of selection, whereas the most frequent cases are likely to be discarded. Still, frequent cases have a small chance of being selected (controlled via the sp parameter) in case few rare instances were observed. Parameters \u00b6 regressor ( base.Regressor ) The regression model that will receive the biased sample. sp ( float ) \u2013 defaults to 0.15 Second chance probability. Even if an example is not initially selected for training, it still has a small chance of being selected in case the number of rare case observed so far is small. seed ( int ) \u2013 defaults to None Random seed to support reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import metrics >>> from river import preprocessing >>> from river import rules >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . ChebyshevUnderSampler ( ... regressor = rules . AMRules ( ... n_min = 50 , delta = 0.01 ... ), ... seed = 42 ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 1.633571 [ 1 , 000 ] MAE : 1.460907 MAE : 1.4604 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y kwargs Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466. \u21a9","title":"ChebyshevUnderSampler"},{"location":"api/imblearn/ChebyshevUnderSampler/#chebyshevundersampler","text":"Under-sampling for imbalanced regression using Chebyshev's inequality. Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\) . For any real number \\(t > 0\\) , the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\) . Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\) , and assuming \\(t > 1\\) , the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\) . The reciprocal of this probability is used for under-sampling 1 the most frequent cases. Extreme valued or rare cases have higher probabilities of selection, whereas the most frequent cases are likely to be discarded. Still, frequent cases have a small chance of being selected (controlled via the sp parameter) in case few rare instances were observed.","title":"ChebyshevUnderSampler"},{"location":"api/imblearn/ChebyshevUnderSampler/#parameters","text":"regressor ( base.Regressor ) The regression model that will receive the biased sample. sp ( float ) \u2013 defaults to 0.15 Second chance probability. Even if an example is not initially selected for training, it still has a small chance of being selected in case the number of rare case observed so far is small. seed ( int ) \u2013 defaults to None Random seed to support reproducibility.","title":"Parameters"},{"location":"api/imblearn/ChebyshevUnderSampler/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import metrics >>> from river import preprocessing >>> from river import rules >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . ChebyshevUnderSampler ( ... regressor = rules . AMRules ( ... n_min = 50 , delta = 0.01 ... ), ... seed = 42 ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 1.633571 [ 1 , 000 ] MAE : 1.460907 MAE : 1.4604","title":"Examples"},{"location":"api/imblearn/ChebyshevUnderSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y kwargs Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/imblearn/ChebyshevUnderSampler/#references","text":"Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466. \u21a9","title":"References"},{"location":"api/imblearn/HardSamplingClassifier/","text":"HardSamplingClassifier \u00b6 Hard sampling classifier. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place. Parameters \u00b6 classifier ( base.Classifier ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( Union[ optim.losses.BinaryLoss , optim.losses.MultiClassLoss ] ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed. Attributes \u00b6 classifier Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingClassifier ( ... classifier = linear_model . LogisticRegression (), ... p = 0.1 , ... size = 40 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = model , ... metric = metrics . ROCAUC (), ... print_every = 500 , ... ) [ 500 ] ROCAUC : 92.71 % [ 1 , 000 ] ROCAUC : 94.75 % ROCAUC : 95.05 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"HardSamplingClassifier"},{"location":"api/imblearn/HardSamplingClassifier/#hardsamplingclassifier","text":"Hard sampling classifier. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place.","title":"HardSamplingClassifier"},{"location":"api/imblearn/HardSamplingClassifier/#parameters","text":"classifier ( base.Classifier ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( Union[ optim.losses.BinaryLoss , optim.losses.MultiClassLoss ] ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed.","title":"Parameters"},{"location":"api/imblearn/HardSamplingClassifier/#attributes","text":"classifier","title":"Attributes"},{"location":"api/imblearn/HardSamplingClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingClassifier ( ... classifier = linear_model . LogisticRegression (), ... p = 0.1 , ... size = 40 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = model , ... metric = metrics . ROCAUC (), ... print_every = 500 , ... ) [ 500 ] ROCAUC : 92.71 % [ 1 , 000 ] ROCAUC : 94.75 % ROCAUC : 95.05 %","title":"Examples"},{"location":"api/imblearn/HardSamplingClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/HardSamplingRegressor/","text":"HardSamplingRegressor \u00b6 Hard sampling regressor. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place. Parameters \u00b6 regressor ( base.Regressor ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed. Attributes \u00b6 regressor Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingRegressor ( ... regressor = linear_model . LinearRegression (), ... p = .2 , ... size = 30 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 2.292501 [ 1 , 000 ] MAE : 1.395797 MAE : 1.394693 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one","title":"HardSamplingRegressor"},{"location":"api/imblearn/HardSamplingRegressor/#hardsamplingregressor","text":"Hard sampling regressor. This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes it's place.","title":"HardSamplingRegressor"},{"location":"api/imblearn/HardSamplingRegressor/#parameters","text":"regressor ( base.Regressor ) size ( int ) Size of the buffer. p ( float ) Probability of updating the model with a sample from the buffer instead of a new incoming sample. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None Criterion used to evaluate the hardness of a sample. seed ( int ) \u2013 defaults to None Random seed.","title":"Parameters"},{"location":"api/imblearn/HardSamplingRegressor/#attributes","text":"regressor","title":"Attributes"},{"location":"api/imblearn/HardSamplingRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... imblearn . HardSamplingRegressor ( ... regressor = linear_model . LinearRegression (), ... p = .2 , ... size = 30 , ... seed = 42 , ... ) ... ) >>> evaluate . progressive_val_score ( ... datasets . TrumpApproval (), ... model , ... metrics . MAE (), ... print_every = 500 ... ) [ 500 ] MAE : 2.292501 [ 1 , 000 ] MAE : 1.395797 MAE : 1.394693","title":"Examples"},{"location":"api/imblearn/HardSamplingRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one predict_one","title":"Methods"},{"location":"api/imblearn/RandomOverSampler/","text":"RandomOverSampler \u00b6 Random over-sampling. This is a wrapper for classifiers. It will train the provided classifier by over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of reverse rejection sampling. See Working with imbalanced data for example usage. Parameters \u00b6 classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> model = imblearn . RandomOverSampler ( ... ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... desired_dist = { False : 0.4 , True : 0.6 }, ... seed = 42 ... ) >>> dataset = datasets . CreditCard () . take ( 3000 ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.054338 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"RandomOverSampler"},{"location":"api/imblearn/RandomOverSampler/#randomoversampler","text":"Random over-sampling. This is a wrapper for classifiers. It will train the provided classifier by over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of reverse rejection sampling. See Working with imbalanced data for example usage.","title":"RandomOverSampler"},{"location":"api/imblearn/RandomOverSampler/#parameters","text":"classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/imblearn/RandomOverSampler/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> model = imblearn . RandomOverSampler ( ... ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... desired_dist = { False : 0.4 , True : 0.6 }, ... seed = 42 ... ) >>> dataset = datasets . CreditCard () . take ( 3000 ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.054338","title":"Examples"},{"location":"api/imblearn/RandomOverSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/RandomSampler/","text":"RandomSampler \u00b6 Random sampling by mixing under-sampling and over-sampling. This is a wrapper for classifiers. It will train the provided classifier by both under-sampling and over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. See Working with imbalanced data for example usage. Parameters \u00b6 classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. If set to None , then the observations will be sampled uniformly at random, which is stricly equivalent to using ensemble.BaggingClassifier . sampling_rate \u2013 defaults to 1.0 The desired ratio of data to sample. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> model = imblearn . RandomSampler ( ... ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... desired_dist = { False : 0.4 , True : 0.6 }, ... sampling_rate = 0.8 , ... seed = 42 ... ) >>> dataset = datasets . CreditCard () . take ( 3000 ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.131988 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"RandomSampler"},{"location":"api/imblearn/RandomSampler/#randomsampler","text":"Random sampling by mixing under-sampling and over-sampling. This is a wrapper for classifiers. It will train the provided classifier by both under-sampling and over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. See Working with imbalanced data for example usage.","title":"RandomSampler"},{"location":"api/imblearn/RandomSampler/#parameters","text":"classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. If set to None , then the observations will be sampled uniformly at random, which is stricly equivalent to using ensemble.BaggingClassifier . sampling_rate \u2013 defaults to 1.0 The desired ratio of data to sample. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/imblearn/RandomSampler/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> model = imblearn . RandomSampler ( ... ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... desired_dist = { False : 0.4 , True : 0.6 }, ... sampling_rate = 0.8 , ... seed = 42 ... ) >>> dataset = datasets . CreditCard () . take ( 3000 ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.131988","title":"Examples"},{"location":"api/imblearn/RandomSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/RandomUnderSampler/","text":"RandomUnderSampler \u00b6 Random under-sampling. This is a wrapper for classifiers. It will train the provided classifier by under-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of rejection sampling. See Working with imbalanced data for example usage. Parameters \u00b6 classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> model = imblearn . RandomUnderSampler ( ... ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... desired_dist = { False : 0.4 , True : 0.6 }, ... seed = 42 ... ) >>> dataset = datasets . CreditCard () . take ( 3000 ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.0728 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Under-sampling a dataset with desired ratios \u21a9 Wikipedia article on rejection sampling \u21a9","title":"RandomUnderSampler"},{"location":"api/imblearn/RandomUnderSampler/#randomundersampler","text":"Random under-sampling. This is a wrapper for classifiers. It will train the provided classifier by under-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of rejection sampling. See Working with imbalanced data for example usage.","title":"RandomUnderSampler"},{"location":"api/imblearn/RandomUnderSampler/#parameters","text":"classifier ( base.Classifier ) desired_dist ( dict ) The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/imblearn/RandomUnderSampler/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import imblearn >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> model = imblearn . RandomUnderSampler ( ... ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ), ... desired_dist = { False : 0.4 , True : 0.6 }, ... seed = 42 ... ) >>> dataset = datasets . CreditCard () . take ( 3000 ) >>> metric = metrics . LogLoss () >>> evaluate . progressive_val_score ( dataset , model , metric ) LogLoss : 0.0728","title":"Examples"},{"location":"api/imblearn/RandomUnderSampler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/imblearn/RandomUnderSampler/#references","text":"Under-sampling a dataset with desired ratios \u21a9 Wikipedia article on rejection sampling \u21a9","title":"References"},{"location":"api/linear-model/ALMAClassifier/","text":"ALMAClassifier \u00b6 Approximate Large Margin Algorithm (ALMA). Parameters \u00b6 p \u2013 defaults to 2 alpha \u2013 defaults to 0.9 B \u2013 defaults to 1.1111111111111112 C \u2013 defaults to 1.4142135623730951 Attributes \u00b6 w ( collections.defaultdict ) The current weights. k ( int ) The number of instances seen during training. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . ALMAClassifier () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 82.64 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. References \u00b6 Gentile, Claudio. \"A new approximate maximal margin classification algorithm.\" Journal of Machine Learning Research 2.Dec (2001): 213-242 \u21a9","title":"ALMAClassifier"},{"location":"api/linear-model/ALMAClassifier/#almaclassifier","text":"Approximate Large Margin Algorithm (ALMA).","title":"ALMAClassifier"},{"location":"api/linear-model/ALMAClassifier/#parameters","text":"p \u2013 defaults to 2 alpha \u2013 defaults to 0.9 B \u2013 defaults to 1.1111111111111112 C \u2013 defaults to 1.4142135623730951","title":"Parameters"},{"location":"api/linear-model/ALMAClassifier/#attributes","text":"w ( collections.defaultdict ) The current weights. k ( int ) The number of instances seen during training.","title":"Attributes"},{"location":"api/linear-model/ALMAClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . ALMAClassifier () ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 82.64 %","title":"Examples"},{"location":"api/linear-model/ALMAClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/ALMAClassifier/#references","text":"Gentile, Claudio. \"A new approximate maximal margin classification algorithm.\" Journal of Machine Learning Research 2.Dec (2001): 213-242 \u21a9","title":"References"},{"location":"api/linear-model/LinearRegression/","text":"LinearRegression \u00b6 Linear regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler . Parameters \u00b6 optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. l1 \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Attributes \u00b6 weights ( dict ) The current weights. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = .1 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.555971 >>> model [ 'LinearRegression' ] . intercept 35.617670 You can call the debug_one method to break down a prediction. This works even if the linear regression is part of a pipeline. >>> x , y = next ( iter ( dataset )) >>> report = model . debug_one ( x ) >>> print ( report ) 0. Input -------- gallup : 43.84321 ( float ) ipsos : 46.19925 ( float ) morning_consult : 48.31875 ( float ) ordinal_date : 736389 ( int ) rasmussen : 44.10469 ( float ) you_gov : 43.63691 ( float ) < BLANKLINE > 1. StandardScaler ----------------- gallup : 1.18810 ( float ) ipsos : 2.10348 ( float ) morning_consult : 2.73545 ( float ) ordinal_date : - 1.73032 ( float ) rasmussen : 1.26872 ( float ) you_gov : 1.48391 ( float ) < BLANKLINE > 2. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 35.61767 35.61767 ipsos 2.10348 0.62689 1.31866 morning_consult 2.73545 0.24180 0.66144 gallup 1.18810 0.43568 0.51764 rasmussen 1.26872 0.28118 0.35674 you_gov 1.48391 0.03123 0.04634 ordinal_date - 1.73032 3.45162 - 5.97242 < BLANKLINE > Prediction : 32.54607 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the linear regression. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w \u2013 defaults to 1.0 Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters X Returns The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"LinearRegression"},{"location":"api/linear-model/LinearRegression/#linearregression","text":"Linear regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler .","title":"LinearRegression"},{"location":"api/linear-model/LinearRegression/#parameters","text":"optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately. loss ( optim.losses.RegressionLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. l1 \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[ optim.base.Scheduler , float] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme.","title":"Parameters"},{"location":"api/linear-model/LinearRegression/#attributes","text":"weights ( dict ) The current weights.","title":"Attributes"},{"location":"api/linear-model/LinearRegression/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = .1 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.555971 >>> model [ 'LinearRegression' ] . intercept 35.617670 You can call the debug_one method to break down a prediction. This works even if the linear regression is part of a pipeline. >>> x , y = next ( iter ( dataset )) >>> report = model . debug_one ( x ) >>> print ( report ) 0. Input -------- gallup : 43.84321 ( float ) ipsos : 46.19925 ( float ) morning_consult : 48.31875 ( float ) ordinal_date : 736389 ( int ) rasmussen : 44.10469 ( float ) you_gov : 43.63691 ( float ) < BLANKLINE > 1. StandardScaler ----------------- gallup : 1.18810 ( float ) ipsos : 2.10348 ( float ) morning_consult : 2.73545 ( float ) ordinal_date : - 1.73032 ( float ) rasmussen : 1.26872 ( float ) you_gov : 1.48391 ( float ) < BLANKLINE > 2. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 35.61767 35.61767 ipsos 2.10348 0.62689 1.31866 morning_consult 2.73545 0.24180 0.66144 gallup 1.18810 0.43568 0.51764 rasmussen 1.26872 0.28118 0.35674 you_gov 1.48391 0.03123 0.04634 ordinal_date - 1.73032 3.45162 - 5.97242 < BLANKLINE > Prediction : 32.54607","title":"Examples"},{"location":"api/linear-model/LinearRegression/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Debugs the output of the linear regression. Parameters x ( dict ) decimals ( int ) \u2013 defaults to 5 Returns str : A table which explains the output. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchRegressor : self learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w \u2013 defaults to 1.0 Returns Regressor : self predict_many Predict the outcome for each given sample. Parameters X Returns The predicted outcomes. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/linear-model/LogisticRegression/","text":"LogisticRegression \u00b6 Logistic regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler . Parameters \u00b6 optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept is handled separately. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. Defaults to optim.losses.Log . l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. l1 \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[float, optim.base.Scheduler ] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Attributes \u00b6 weights The current weights. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer = optim . SGD ( .1 )) ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.96 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"LogisticRegression"},{"location":"api/linear-model/LogisticRegression/#logisticregression","text":"Logistic regression. This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: learn_many , predict_many , predict_proba_many . Each method takes as input a pandas.DataFrame where each column represents a feature. It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a preprocessing.StandardScaler .","title":"LogisticRegression"},{"location":"api/linear-model/LogisticRegression/#parameters","text":"optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. Note that the intercept is handled separately. loss ( optim.losses.BinaryLoss ) \u2013 defaults to None The loss function to optimize for. Defaults to optim.losses.Log . l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. l1 \u2013 defaults to 0.0 Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. intercept_init \u2013 defaults to 0.0 Initial intercept value. intercept_lr ( Union[float, optim.base.Scheduler ] ) \u2013 defaults to 0.01 Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme.","title":"Parameters"},{"location":"api/linear-model/LogisticRegression/#attributes","text":"weights The current weights.","title":"Attributes"},{"location":"api/linear-model/LogisticRegression/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer = optim . SGD ( .1 )) ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 88.96 %","title":"Examples"},{"location":"api/linear-model/LogisticRegression/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/PAClassifier/","text":"PAClassifier \u00b6 Passive-aggressive learning for classification. Parameters \u00b6 C \u2013 defaults to 1.0 mode \u2013 defaults to 1 learn_intercept \u2013 defaults to True Examples \u00b6 The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> from sklearn import model_selection >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_classification ( ... n_samples = 5000 , ... n_features = 4 , ... n_informative = 2 , ... n_redundant = 0 , ... n_repeated = 0 , ... n_classes = 2 , ... n_clusters_per_class = 2 ... ) >>> X_train , X_test , y_train , y_test = model_selection . train_test_split ( ... X , ... y , ... test_size = 0.35 , ... random_state = 1000 ... ) >>> model = linear_model . PAClassifier ( ... C = 0.01 , ... mode = 1 ... ) >>> for xi , yi in stream . iter_array ( X_train , y_train ): ... y_pred = model . learn_one ( xi , yi ) >>> metric = metrics . Accuracy () + metrics . LogLoss () >>> for xi , yi in stream . iter_array ( X_test , y_test ): ... metric = metric . update ( yi , model . predict_proba_one ( xi )) >>> print ( metric ) Accuracy : 88.46 % , LogLoss : 0.325727 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. References \u00b6 Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585 \u21a9","title":"PAClassifier"},{"location":"api/linear-model/PAClassifier/#paclassifier","text":"Passive-aggressive learning for classification.","title":"PAClassifier"},{"location":"api/linear-model/PAClassifier/#parameters","text":"C \u2013 defaults to 1.0 mode \u2013 defaults to 1 learn_intercept \u2013 defaults to True","title":"Parameters"},{"location":"api/linear-model/PAClassifier/#examples","text":"The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> from sklearn import model_selection >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_classification ( ... n_samples = 5000 , ... n_features = 4 , ... n_informative = 2 , ... n_redundant = 0 , ... n_repeated = 0 , ... n_classes = 2 , ... n_clusters_per_class = 2 ... ) >>> X_train , X_test , y_train , y_test = model_selection . train_test_split ( ... X , ... y , ... test_size = 0.35 , ... random_state = 1000 ... ) >>> model = linear_model . PAClassifier ( ... C = 0.01 , ... mode = 1 ... ) >>> for xi , yi in stream . iter_array ( X_train , y_train ): ... y_pred = model . learn_one ( xi , yi ) >>> metric = metrics . Accuracy () + metrics . LogLoss () >>> for xi , yi in stream . iter_array ( X_test , y_test ): ... metric = metric . update ( yi , model . predict_proba_one ( xi )) >>> print ( metric ) Accuracy : 88.46 % , LogLoss : 0.325727","title":"Examples"},{"location":"api/linear-model/PAClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/PAClassifier/#references","text":"Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585 \u21a9","title":"References"},{"location":"api/linear-model/PARegressor/","text":"PARegressor \u00b6 Passive-aggressive learning for regression. Parameters \u00b6 C \u2013 defaults to 1.0 mode \u2013 defaults to 1 eps \u2013 defaults to 0.1 learn_intercept \u2013 defaults to True Examples \u00b6 The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_regression ( n_samples = 500 , n_features = 4 ) >>> model = linear_model . PARegressor ( ... C = 0.01 , ... mode = 2 , ... eps = 0.1 , ... learn_intercept = False ... ) >>> metric = metrics . MAE () + metrics . MSE () >>> for xi , yi in stream . iter_array ( X , y ): ... y_pred = model . predict_one ( xi ) ... model = model . learn_one ( xi , yi ) ... metric = metric . update ( yi , y_pred ) >>> print ( metric ) MAE : 9.809402 , MSE : 472.393532 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. References \u00b6 Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585. \u21a9","title":"PARegressor"},{"location":"api/linear-model/PARegressor/#paregressor","text":"Passive-aggressive learning for regression.","title":"PARegressor"},{"location":"api/linear-model/PARegressor/#parameters","text":"C \u2013 defaults to 1.0 mode \u2013 defaults to 1 eps \u2013 defaults to 0.1 learn_intercept \u2013 defaults to True","title":"Parameters"},{"location":"api/linear-model/PARegressor/#examples","text":"The following example is taken from this blog post . >>> from river import linear_model >>> from river import metrics >>> from river import stream >>> import numpy as np >>> from sklearn import datasets >>> np . random . seed ( 1000 ) >>> X , y = datasets . make_regression ( n_samples = 500 , n_features = 4 ) >>> model = linear_model . PARegressor ( ... C = 0.01 , ... mode = 2 , ... eps = 0.1 , ... learn_intercept = False ... ) >>> metric = metrics . MAE () + metrics . MSE () >>> for xi , yi in stream . iter_array ( X , y ): ... y_pred = model . predict_one ( xi ) ... model = model . learn_one ( xi , yi ) ... metric = metric . update ( yi , y_pred ) >>> print ( metric ) MAE : 9.809402 , MSE : 472.393532","title":"Examples"},{"location":"api/linear-model/PARegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction.","title":"Methods"},{"location":"api/linear-model/PARegressor/#references","text":"Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585. \u21a9","title":"References"},{"location":"api/linear-model/Perceptron/","text":"Perceptron \u00b6 Perceptron classifier. In this implementation, the Perceptron is viewed as a special case of the logistic regression. The loss function that is used is the Hinge loss with a threshold set to 0, whilst the learning rate of the stochastic gradient descent procedure is set to 1 for both the weights and the intercept. Parameters \u00b6 l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. Attributes \u00b6 weights The current weights. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = pp . StandardScaler () | lm . Perceptron () >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 85.84 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Perceptron"},{"location":"api/linear-model/Perceptron/#perceptron","text":"Perceptron classifier. In this implementation, the Perceptron is viewed as a special case of the logistic regression. The loss function that is used is the Hinge loss with a threshold set to 0, whilst the learning rate of the stochastic gradient descent procedure is set to 1 for both the weights and the intercept.","title":"Perceptron"},{"location":"api/linear-model/Perceptron/#parameters","text":"l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme.","title":"Parameters"},{"location":"api/linear-model/Perceptron/#attributes","text":"weights The current weights.","title":"Attributes"},{"location":"api/linear-model/Perceptron/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model as lm >>> from river import metrics >>> from river import preprocessing as pp >>> dataset = datasets . Phishing () >>> model = pp . StandardScaler () | lm . Perceptron () >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 85.84 %","title":"Examples"},{"location":"api/linear-model/Perceptron/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update the model with a mini-batch of features X and boolean targets y . Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) w ( Union[float, pandas.core.series.Series] ) \u2013 defaults to 1 Returns MiniBatchClassifier : self learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Predict the outcome probabilities for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A dataframe with probabilities of True and False for each sample. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/SoftmaxRegression/","text":"SoftmaxRegression \u00b6 Softmax regression is a generalization of logistic regression to multiple classes. Softmax regression is also known as \"multinomial logistic regression\". There are a set weights for each class, hence the weights attribute is a nested collections.defaultdict . The main advantage of using this instead of a one-vs-all logistic regression is that the probabilities will be calibrated. Moreover softmax regression is more robust to outliers. Parameters \u00b6 optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used to tune the weights. loss ( optim.losses.MultiClassLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0 Amount of L2 regularization used to push weights towards 0. Attributes \u00b6 weights ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> model = preprocessing . StandardScaler () >>> model |= linear_model . SoftmaxRegression () >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 81.88 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. References \u00b6 Course on classification stochastic gradient descent \u21a9 Binary vs. Multi-Class Logistic Regression \u21a9","title":"SoftmaxRegression"},{"location":"api/linear-model/SoftmaxRegression/#softmaxregression","text":"Softmax regression is a generalization of logistic regression to multiple classes. Softmax regression is also known as \"multinomial logistic regression\". There are a set weights for each class, hence the weights attribute is a nested collections.defaultdict . The main advantage of using this instead of a one-vs-all logistic regression is that the probabilities will be calibrated. Moreover softmax regression is more robust to outliers.","title":"SoftmaxRegression"},{"location":"api/linear-model/SoftmaxRegression/#parameters","text":"optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used to tune the weights. loss ( optim.losses.MultiClassLoss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0 Amount of L2 regularization used to push weights towards 0.","title":"Parameters"},{"location":"api/linear-model/SoftmaxRegression/#attributes","text":"weights ( collections.defaultdict )","title":"Attributes"},{"location":"api/linear-model/SoftmaxRegression/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> model = preprocessing . StandardScaler () >>> model |= linear_model . SoftmaxRegression () >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 81.88 %","title":"Examples"},{"location":"api/linear-model/SoftmaxRegression/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/linear-model/SoftmaxRegression/#references","text":"Course on classification stochastic gradient descent \u21a9 Binary vs. Multi-Class Logistic Regression \u21a9","title":"References"},{"location":"api/linear-model/base/GLM/","text":"GLM \u00b6 Generalized Linear Model. This serves as a base class for linear and logistic regression. Parameters \u00b6 optimizer The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately. loss The loss function to optimize for. l2 Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. l1 Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. intercept_init Initial intercept value. intercept_lr Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient Clips the absolute value of each gradient value. initializer Weights initialization scheme. Attributes \u00b6 weights Methods \u00b6 learn_many learn_one","title":"GLM"},{"location":"api/linear-model/base/GLM/#glm","text":"Generalized Linear Model. This serves as a base class for linear and logistic regression.","title":"GLM"},{"location":"api/linear-model/base/GLM/#parameters","text":"optimizer The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately. loss The loss function to optimize for. l2 Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. l1 Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported. intercept_init Initial intercept value. intercept_lr Learning rate scheduler used for updating the intercept. A optim.schedulers.Constant is used if a float is provided. The intercept is not updated when this is set to 0. clip_gradient Clips the absolute value of each gradient value. initializer Weights initialization scheme.","title":"Parameters"},{"location":"api/linear-model/base/GLM/#attributes","text":"weights","title":"Attributes"},{"location":"api/linear-model/base/GLM/#methods","text":"learn_many learn_one","title":"Methods"},{"location":"api/metrics/Accuracy/","text":"Accuracy \u00b6 Accuracy score, which is the percentage of exact matches. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Accuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Accuracy : 60.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Accuracy"},{"location":"api/metrics/Accuracy/#accuracy","text":"Accuracy score, which is the percentage of exact matches.","title":"Accuracy"},{"location":"api/metrics/Accuracy/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/Accuracy/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Accuracy/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Accuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Accuracy : 60.00 %","title":"Examples"},{"location":"api/metrics/Accuracy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/AdjustedMutualInfo/","text":"AdjustedMutualInfo \u00b6 Adjusted Mutual Information between two clusterings. Adjusted Mutual Information (AMI) is an adjustment of the Mutual Information score that accounts for chance. It corrects the effect of agreement solely due to chance between clusterings, similar to the way the Adjusted Rand Index corrects the Rand Index. It is closely related to variation of information. The adjusted measure, however, is no longer metrical. For two clusterings \\(U\\) and \\(V\\) , the Adjusted Mutual Information is calculated as: \\[ AMI(U, V) = \\frac{MI(U, V) - E(MI(U, V))}{avg(H(U), H(V)) - E(MI(U, V))} \\] This metric is independent of the permutation of the class or cluster label values; furthermore, it is also symmetric. This can be useful to measure the agreement of two label assignments strategies on the same dataset, regardless of the ground truth. However, due to the complexity of the Expected Mutual Info Score, the computation of this metric is an order of magnitude slower than most other metrics, in general. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. average_method \u2013 defaults to arithmetic This parameter defines how to compute the normalizer in the denominator. Possible options include min , max , arithmetic and geometric . Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . AdjustedMutualInfo () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.0 0.105891 0.298792 >>> metric AdjustedMutualInfo : 0.298792 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia contributors. (2021, March 17). Mutual information. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Mutual_information&oldid=1012714929 \u21a9","title":"AdjustedMutualInfo"},{"location":"api/metrics/AdjustedMutualInfo/#adjustedmutualinfo","text":"Adjusted Mutual Information between two clusterings. Adjusted Mutual Information (AMI) is an adjustment of the Mutual Information score that accounts for chance. It corrects the effect of agreement solely due to chance between clusterings, similar to the way the Adjusted Rand Index corrects the Rand Index. It is closely related to variation of information. The adjusted measure, however, is no longer metrical. For two clusterings \\(U\\) and \\(V\\) , the Adjusted Mutual Information is calculated as: \\[ AMI(U, V) = \\frac{MI(U, V) - E(MI(U, V))}{avg(H(U), H(V)) - E(MI(U, V))} \\] This metric is independent of the permutation of the class or cluster label values; furthermore, it is also symmetric. This can be useful to measure the agreement of two label assignments strategies on the same dataset, regardless of the ground truth. However, due to the complexity of the Expected Mutual Info Score, the computation of this metric is an order of magnitude slower than most other metrics, in general.","title":"AdjustedMutualInfo"},{"location":"api/metrics/AdjustedMutualInfo/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. average_method \u2013 defaults to arithmetic This parameter defines how to compute the normalizer in the denominator. Possible options include min , max , arithmetic and geometric .","title":"Parameters"},{"location":"api/metrics/AdjustedMutualInfo/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/AdjustedMutualInfo/#examples","text":">>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . AdjustedMutualInfo () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.0 0.105891 0.298792 >>> metric AdjustedMutualInfo : 0.298792","title":"Examples"},{"location":"api/metrics/AdjustedMutualInfo/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/AdjustedMutualInfo/#references","text":"Wikipedia contributors. (2021, March 17). Mutual information. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Mutual_information&oldid=1012714929 \u21a9","title":"References"},{"location":"api/metrics/AdjustedRand/","text":"AdjustedRand \u00b6 Adjusted Rand Index. The Adjusted Rand Index is the corrected-for-chance version of the Rand Index 1 2 . Such a correction for chance establishes a baseline by using the expected similarity of all pair-wise comparisions between clusterings specified by a random model. Traditionally, the Rand Index was corrected using the Permutation Model for Clustering. However, the premises of the permutation model are frequently violated; in many clustering scenarios, either the number of clusters or the size distribution of those clusters vary drastically. Variations of the adjusted Rand Index account for different models of random clusterings. Though the Rand Index may only yield a value between 0 and 1, the Adjusted Rand index can yield negative values if the index is less than the expected index. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 0 , 0 , 1 , 1 , 1 ] >>> y_pred = [ 0 , 0 , 1 , 1 , 2 , 2 ] >>> metric = metrics . AdjustedRand () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.0 0.09090909090909091 0.24242424242424243 >>> metric AdjustedRand : 0.242424 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia contributors. (2021, January 13). Rand index. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Rand_index&oldid=1000098911 \u21a9 W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\". Journal of the American Statistical Association. American Statistical Association. 66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239. \u21a9","title":"AdjustedRand"},{"location":"api/metrics/AdjustedRand/#adjustedrand","text":"Adjusted Rand Index. The Adjusted Rand Index is the corrected-for-chance version of the Rand Index 1 2 . Such a correction for chance establishes a baseline by using the expected similarity of all pair-wise comparisions between clusterings specified by a random model. Traditionally, the Rand Index was corrected using the Permutation Model for Clustering. However, the premises of the permutation model are frequently violated; in many clustering scenarios, either the number of clusters or the size distribution of those clusters vary drastically. Variations of the adjusted Rand Index account for different models of random clusterings. Though the Rand Index may only yield a value between 0 and 1, the Adjusted Rand index can yield negative values if the index is less than the expected index.","title":"AdjustedRand"},{"location":"api/metrics/AdjustedRand/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/AdjustedRand/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/AdjustedRand/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 0 , 0 , 1 , 1 , 1 ] >>> y_pred = [ 0 , 0 , 1 , 1 , 2 , 2 ] >>> metric = metrics . AdjustedRand () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.0 0.09090909090909091 0.24242424242424243 >>> metric AdjustedRand : 0.242424","title":"Examples"},{"location":"api/metrics/AdjustedRand/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/AdjustedRand/#references","text":"Wikipedia contributors. (2021, January 13). Rand index. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Rand_index&oldid=1000098911 \u21a9 W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\". Journal of the American Statistical Association. American Statistical Association. 66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239. \u21a9","title":"References"},{"location":"api/metrics/BalancedAccuracy/","text":"BalancedAccuracy \u00b6 Balanced accuracy. Balanced accuracy is the average of recall obtained on each class. It is used to deal with imbalanced datasets in binary and multi-class classification problems. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , False , True ] >>> y_pred = [ True , False , True , True , True , False ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 % >>> y_true = [ 0 , 1 , 0 , 0 , 1 , 0 ] >>> y_pred = [ 0 , 1 , 0 , 0 , 0 , 1 ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"BalancedAccuracy"},{"location":"api/metrics/BalancedAccuracy/#balancedaccuracy","text":"Balanced accuracy. Balanced accuracy is the average of recall obtained on each class. It is used to deal with imbalanced datasets in binary and multi-class classification problems.","title":"BalancedAccuracy"},{"location":"api/metrics/BalancedAccuracy/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/BalancedAccuracy/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/BalancedAccuracy/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , False , True ] >>> y_pred = [ True , False , True , True , True , False ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 % >>> y_true = [ 0 , 1 , 0 , 0 , 1 , 0 ] >>> y_pred = [ 0 , 1 , 0 , 0 , 0 , 1 ] >>> metric = metrics . BalancedAccuracy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric BalancedAccuracy : 62.50 %","title":"Examples"},{"location":"api/metrics/BalancedAccuracy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/ClassificationReport/","text":"ClassificationReport \u00b6 A report for monitoring a classifier. This class maintains a set of metrics and updates each of them every time update is called. You can print this class at any time during a model's lifetime to get a tabular visualization of various metrics. You can wrap a metrics.ClassificationReport with metrics.Rolling in order to obtain a classification report over a window of observations. You can also wrap it with metrics.TimeRolling to obtain a report over a period of time. Parameters \u00b6 decimals \u2013 defaults to 2 The number of decimals to display in each cell. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 'pear' , 'apple' , 'banana' , 'banana' , 'banana' ] >>> y_pred = [ 'apple' , 'pear' , 'banana' , 'banana' , 'apple' ] >>> report = metrics . ClassificationReport () >>> for yt , yp in zip ( y_true , y_pred ): ... report = report . update ( yt , yp ) >>> print ( report ) Precision Recall F1 Support < BLANKLINE > apple 0.00 % 0.00 % 0.00 % 1 banana 100.00 % 66.67 % 80.00 % 3 pear 0.00 % 0.00 % 0.00 % 1 < BLANKLINE > Macro 33.33 % 22.22 % 26.67 % Micro 40.00 % 40.00 % 40.00 % Weighted 60.00 % 40.00 % 48.00 % < BLANKLINE > 40.00 % accuracy Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ClassificationReport"},{"location":"api/metrics/ClassificationReport/#classificationreport","text":"A report for monitoring a classifier. This class maintains a set of metrics and updates each of them every time update is called. You can print this class at any time during a model's lifetime to get a tabular visualization of various metrics. You can wrap a metrics.ClassificationReport with metrics.Rolling in order to obtain a classification report over a window of observations. You can also wrap it with metrics.TimeRolling to obtain a report over a period of time.","title":"ClassificationReport"},{"location":"api/metrics/ClassificationReport/#parameters","text":"decimals \u2013 defaults to 2 The number of decimals to display in each cell. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/ClassificationReport/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/ClassificationReport/#examples","text":">>> from river import metrics >>> y_true = [ 'pear' , 'apple' , 'banana' , 'banana' , 'banana' ] >>> y_pred = [ 'apple' , 'pear' , 'banana' , 'banana' , 'apple' ] >>> report = metrics . ClassificationReport () >>> for yt , yp in zip ( y_true , y_pred ): ... report = report . update ( yt , yp ) >>> print ( report ) Precision Recall F1 Support < BLANKLINE > apple 0.00 % 0.00 % 0.00 % 1 banana 100.00 % 66.67 % 80.00 % 3 pear 0.00 % 0.00 % 0.00 % 1 < BLANKLINE > Macro 33.33 % 22.22 % 26.67 % Micro 40.00 % 40.00 % 40.00 % Weighted 60.00 % 40.00 % 48.00 % < BLANKLINE > 40.00 % accuracy","title":"Examples"},{"location":"api/metrics/ClassificationReport/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/CohenKappa/","text":"CohenKappa \u00b6 Cohen's Kappa score. Cohen's Kappa expresses the level of agreement between two annotators on a classification problem. It is defined as \\[ \\kappa = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the expected agreement when both annotators assign labels randomly. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> metric = metrics . CohenKappa () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric CohenKappa : 42.86 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 J. Cohen (1960). \"A coefficient of agreement for nominal scales\". Educational and Psychological Measurement 20(1):37-46. doi:10.1177/001316446002000104. \u21a9","title":"CohenKappa"},{"location":"api/metrics/CohenKappa/#cohenkappa","text":"Cohen's Kappa score. Cohen's Kappa expresses the level of agreement between two annotators on a classification problem. It is defined as \\[ \\kappa = (p_o - p_e) / (1 - p_e) \\] where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the expected agreement when both annotators assign labels randomly.","title":"CohenKappa"},{"location":"api/metrics/CohenKappa/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/CohenKappa/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/CohenKappa/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> metric = metrics . CohenKappa () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric CohenKappa : 42.86 %","title":"Examples"},{"location":"api/metrics/CohenKappa/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/CohenKappa/#references","text":"J. Cohen (1960). \"A coefficient of agreement for nominal scales\". Educational and Psychological Measurement 20(1):37-46. doi:10.1177/001316446002000104. \u21a9","title":"References"},{"location":"api/metrics/Completeness/","text":"Completeness \u00b6 Completeness Score. Completeness 1 is symmetrical to homogeneity. In order to satisfy the completeness criteria, a clustering must assign all of those datapoints that are members of a single class to a single cluster. To evaluate completeness, we examine the distribution cluster assignments within each class. In a perfectly complete clustering solution, each of these distributions will be completely skewed to a single cluster. We can evaluate this degree of skew by calculating the conditional entropy of the proposed cluster distribution given the class of the component data points. However, in the worst case scenario, each class is represented by every cluster with a distribution equal to the distribution of cluster sizes. Therefore, symmetric to the claculation above, we define completeness as: \\[ c = \\begin{cases} 1 if H(K) = 0, \\\\ 1 - \\frac{H(K|C)}{H(K)} otherwise. \\end{cases}. \\] Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . Completeness () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 1.0 0.3836885465963443 0.5880325916843805 0.6666666666666667 >>> metric Completeness : 66.67 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Andrew Rosenberg and Julia Hirschberg (2007). V-Measure: A conditional entropy-based external cluster evaluation measure. Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 410 - 420, Prague, June 2007. \u21a9","title":"Completeness"},{"location":"api/metrics/Completeness/#completeness","text":"Completeness Score. Completeness 1 is symmetrical to homogeneity. In order to satisfy the completeness criteria, a clustering must assign all of those datapoints that are members of a single class to a single cluster. To evaluate completeness, we examine the distribution cluster assignments within each class. In a perfectly complete clustering solution, each of these distributions will be completely skewed to a single cluster. We can evaluate this degree of skew by calculating the conditional entropy of the proposed cluster distribution given the class of the component data points. However, in the worst case scenario, each class is represented by every cluster with a distribution equal to the distribution of cluster sizes. Therefore, symmetric to the claculation above, we define completeness as: \\[ c = \\begin{cases} 1 if H(K) = 0, \\\\ 1 - \\frac{H(K|C)}{H(K)} otherwise. \\end{cases}. \\]","title":"Completeness"},{"location":"api/metrics/Completeness/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/Completeness/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Completeness/#examples","text":">>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . Completeness () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 1.0 0.3836885465963443 0.5880325916843805 0.6666666666666667 >>> metric Completeness : 66.67 %","title":"Examples"},{"location":"api/metrics/Completeness/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Completeness/#references","text":"Andrew Rosenberg and Julia Hirschberg (2007). V-Measure: A conditional entropy-based external cluster evaluation measure. Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 410 - 420, Prague, June 2007. \u21a9","title":"References"},{"location":"api/metrics/ConfusionMatrix/","text":"ConfusionMatrix \u00b6 Confusion Matrix for binary and multi-class classification. Parameters \u00b6 classes \u2013 defaults to None The initial set of classes. This is optional and serves only for displaying purposes. Attributes \u00b6 classes total_false_negatives total_false_positives total_true_negatives total_true_positives Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> cm = metrics . ConfusionMatrix () >>> for yt , yp in zip ( y_true , y_pred ): ... cm = cm . update ( yt , yp ) >>> cm ant bird cat ant 2 0 0 bird 0 0 1 cat 1 0 2 >>> cm [ 'bird' ][ 'cat' ] 1.0 Methods \u00b6 false_negatives false_positives revert support true_negatives true_positives update Notes \u00b6 This confusion matrix is a 2D matrix of shape (n_classes, n_classes) , corresponding to a single-target (binary and multi-class) classification task. Each row represents true (actual) class-labels, while each column corresponds to the predicted class-labels. For example, an entry in position [1, 2] means that the true class-label is 1, and the predicted class-label is 2 (incorrect prediction). This structure is used to keep updated statistics about a single-output classifier's performance and to compute multiple evaluation metrics.","title":"ConfusionMatrix"},{"location":"api/metrics/ConfusionMatrix/#confusionmatrix","text":"Confusion Matrix for binary and multi-class classification.","title":"ConfusionMatrix"},{"location":"api/metrics/ConfusionMatrix/#parameters","text":"classes \u2013 defaults to None The initial set of classes. This is optional and serves only for displaying purposes.","title":"Parameters"},{"location":"api/metrics/ConfusionMatrix/#attributes","text":"classes total_false_negatives total_false_positives total_true_negatives total_true_positives","title":"Attributes"},{"location":"api/metrics/ConfusionMatrix/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' ] >>> cm = metrics . ConfusionMatrix () >>> for yt , yp in zip ( y_true , y_pred ): ... cm = cm . update ( yt , yp ) >>> cm ant bird cat ant 2 0 0 bird 0 0 1 cat 1 0 2 >>> cm [ 'bird' ][ 'cat' ] 1.0","title":"Examples"},{"location":"api/metrics/ConfusionMatrix/#methods","text":"false_negatives false_positives revert support true_negatives true_positives update","title":"Methods"},{"location":"api/metrics/ConfusionMatrix/#notes","text":"This confusion matrix is a 2D matrix of shape (n_classes, n_classes) , corresponding to a single-target (binary and multi-class) classification task. Each row represents true (actual) class-labels, while each column corresponds to the predicted class-labels. For example, an entry in position [1, 2] means that the true class-label is 1, and the predicted class-label is 2 (incorrect prediction). This structure is used to keep updated statistics about a single-output classifier's performance and to compute multiple evaluation metrics.","title":"Notes"},{"location":"api/metrics/CrossEntropy/","text":"CrossEntropy \u00b6 Multiclass generalization of the logarithmic loss. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> metric = metrics . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 1.222454 1.169691 1.258864 1.321597 >>> metric CrossEntropy : 1.321598 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"CrossEntropy"},{"location":"api/metrics/CrossEntropy/#crossentropy","text":"Multiclass generalization of the logarithmic loss.","title":"CrossEntropy"},{"location":"api/metrics/CrossEntropy/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/CrossEntropy/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> metric = metrics . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 1.222454 1.169691 1.258864 1.321597 >>> metric CrossEntropy : 1.321598","title":"Examples"},{"location":"api/metrics/CrossEntropy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/F1/","text":"F1 \u00b6 Binary F1 score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . F1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric F1 : 40.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"F1"},{"location":"api/metrics/F1/#f1","text":"Binary F1 score.","title":"F1"},{"location":"api/metrics/F1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/F1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/F1/#examples","text":">>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . F1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric F1 : 40.00 %","title":"Examples"},{"location":"api/metrics/F1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/FBeta/","text":"FBeta \u00b6 Binary F-Beta score. The FBeta score is a weighted harmonic mean between precision and recall. The higher the beta value, the higher the recall will be taken into account. When beta equals 1, precision and recall and equivalently weighted, which results in the F1 score (see metrics.F1 ). Parameters \u00b6 beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 precision ( metrics.Precision ) recall ( metrics.Recall ) Examples \u00b6 >>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . FBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric FBeta : 35.71 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"FBeta"},{"location":"api/metrics/FBeta/#fbeta","text":"Binary F-Beta score. The FBeta score is a weighted harmonic mean between precision and recall. The higher the beta value, the higher the recall will be taken into account. When beta equals 1, precision and recall and equivalently weighted, which results in the F1 score (see metrics.F1 ).","title":"FBeta"},{"location":"api/metrics/FBeta/#parameters","text":"beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/FBeta/#attributes","text":"precision ( metrics.Precision ) recall ( metrics.Recall )","title":"Attributes"},{"location":"api/metrics/FBeta/#examples","text":">>> from river import metrics >>> y_true = [ False , False , False , True , True , True ] >>> y_pred = [ False , False , True , True , False , False ] >>> metric = metrics . FBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric FBeta : 35.71 %","title":"Examples"},{"location":"api/metrics/FBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/FowlkesMallows/","text":"FowlkesMallows \u00b6 Fowlkes-Mallows Index. The Fowlkes-Mallows Index 1 2 is an external evaluation method that is used to determine the similarity between two clusterings, and also a metric to measure confusion matrices. The measure of similarity could be either between two hierarchical clusterings or a clustering and a benchmark classification. A higher value for the Fowlkes-Mallows index indicates a greater similarity between the clusters and the benchmark classifications. The Fowlkes-Mallows Index, for two cluster algorithms, is defined as: \\[ FM = \\sqrt{PPV \\times TPR} = \\sqrt{\\frac{TP}{TP+FP} \\times \\frac{TP}{TP+FN}} \\] where TP, FP, FN are respectively the number of true positives, false positives and false negatives; TPR is the True Positive Rate (or Sensitivity/Recall), PPV is the Positive Predictive Rate (or Precision). Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 0 , 0 , 1 , 1 , 1 ] >>> y_pred = [ 0 , 0 , 1 , 1 , 2 , 2 ] >>> metric = metrics . FowlkesMallows () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) FowlkesMallows : 0.00 % FowlkesMallows : 100.00 % FowlkesMallows : 57.74 % FowlkesMallows : 40.82 % FowlkesMallows : 35.36 % FowlkesMallows : 47.14 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia contributors. (2020, December 22). Fowlkes\u2013Mallows index. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Fowlkes%E2%80%93Mallows_index&oldid=995714222 \u21a9 E. B. Fowkles and C. L. Mallows (1983). \u201cA method for comparing two hierarchical clusterings\u201d. Journal of the American Statistical Association \u21a9","title":"FowlkesMallows"},{"location":"api/metrics/FowlkesMallows/#fowlkesmallows","text":"Fowlkes-Mallows Index. The Fowlkes-Mallows Index 1 2 is an external evaluation method that is used to determine the similarity between two clusterings, and also a metric to measure confusion matrices. The measure of similarity could be either between two hierarchical clusterings or a clustering and a benchmark classification. A higher value for the Fowlkes-Mallows index indicates a greater similarity between the clusters and the benchmark classifications. The Fowlkes-Mallows Index, for two cluster algorithms, is defined as: \\[ FM = \\sqrt{PPV \\times TPR} = \\sqrt{\\frac{TP}{TP+FP} \\times \\frac{TP}{TP+FN}} \\] where TP, FP, FN are respectively the number of true positives, false positives and false negatives; TPR is the True Positive Rate (or Sensitivity/Recall), PPV is the Positive Predictive Rate (or Precision).","title":"FowlkesMallows"},{"location":"api/metrics/FowlkesMallows/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/FowlkesMallows/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/FowlkesMallows/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 0 , 0 , 1 , 1 , 1 ] >>> y_pred = [ 0 , 0 , 1 , 1 , 2 , 2 ] >>> metric = metrics . FowlkesMallows () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) FowlkesMallows : 0.00 % FowlkesMallows : 100.00 % FowlkesMallows : 57.74 % FowlkesMallows : 40.82 % FowlkesMallows : 35.36 % FowlkesMallows : 47.14 %","title":"Examples"},{"location":"api/metrics/FowlkesMallows/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/FowlkesMallows/#references","text":"Wikipedia contributors. (2020, December 22). Fowlkes\u2013Mallows index. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Fowlkes%E2%80%93Mallows_index&oldid=995714222 \u21a9 E. B. Fowkles and C. L. Mallows (1983). \u201cA method for comparing two hierarchical clusterings\u201d. Journal of the American Statistical Association \u21a9","title":"References"},{"location":"api/metrics/GeometricMean/","text":"GeometricMean \u00b6 Geometric mean score. The geometric mean is a good indicator of a classifier's performance in the presence of class imbalance because it is independent of the distribution of examples between classes. This implementation computes the geometric mean of class-wise sensitivity (recall). \\[ gm = \\sqrt[n]{s_1\\cdot s_2\\cdot s_3\\cdot \\ldots\\cdot s_n} \\] where \\(s_i\\) is the sensitivity (recall) of class \\(i\\) and \\(n\\) is the number of classes. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' , 'bird' ] >>> metric = metrics . GeometricMean () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric GeometricMean : 69.34 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Barandela, R. et al. \u201cStrategies for learning in class imbalance problems\u201d, Pattern Recognition, 36(3), (2003), pp 849-851. \u21a9","title":"GeometricMean"},{"location":"api/metrics/GeometricMean/#geometricmean","text":"Geometric mean score. The geometric mean is a good indicator of a classifier's performance in the presence of class imbalance because it is independent of the distribution of examples between classes. This implementation computes the geometric mean of class-wise sensitivity (recall). \\[ gm = \\sqrt[n]{s_1\\cdot s_2\\cdot s_3\\cdot \\ldots\\cdot s_n} \\] where \\(s_i\\) is the sensitivity (recall) of class \\(i\\) and \\(n\\) is the number of classes.","title":"GeometricMean"},{"location":"api/metrics/GeometricMean/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/GeometricMean/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/GeometricMean/#examples","text":">>> from river import metrics >>> y_true = [ 'cat' , 'ant' , 'cat' , 'cat' , 'ant' , 'bird' , 'bird' ] >>> y_pred = [ 'ant' , 'ant' , 'cat' , 'cat' , 'ant' , 'cat' , 'bird' ] >>> metric = metrics . GeometricMean () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric GeometricMean : 69.34 %","title":"Examples"},{"location":"api/metrics/GeometricMean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/GeometricMean/#references","text":"Barandela, R. et al. \u201cStrategies for learning in class imbalance problems\u201d, Pattern Recognition, 36(3), (2003), pp 849-851. \u21a9","title":"References"},{"location":"api/metrics/Homogeneity/","text":"Homogeneity \u00b6 Homogeneity Score. Homogeneity metric 1 of a cluster labeling given a ground truth. In order to satisfy the homogeneity criteria, a clustering must assign only those data points that are members of a single class to a single cluster. That is, the class distribution within each cluster should be skewed to a single class, that is, zero entropy. We determine how close a given clustering is to this ideal by examining the conditional entropy of the class distribution given the proposed clustering. However, in an imperfect situation, the size of this value is dependent on the size of the dataset and the distribution of class sizes. Therefore, instead of taking the raw conditional entropy, we normalize by the maximum reduction in entropy the clustering information could provide. As such, we define homogeneity as: \\[ h = \\begin{cases} 1 if H(C) = 0, \\\\ 1 - \\frac{H(C|K)}{H(C)} otherwise. \\end{cases}. \\] Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . Homogeneity () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.311278 0.37515 0.42062 >>> metric Homogeneity : 42.06 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Andrew Rosenberg and Julia Hirschberg (2007). V-Measure: A conditional entropy-based external cluster evaluation measure. Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 410 - 420, Prague, June 2007. \u21a9","title":"Homogeneity"},{"location":"api/metrics/Homogeneity/#homogeneity","text":"Homogeneity Score. Homogeneity metric 1 of a cluster labeling given a ground truth. In order to satisfy the homogeneity criteria, a clustering must assign only those data points that are members of a single class to a single cluster. That is, the class distribution within each cluster should be skewed to a single class, that is, zero entropy. We determine how close a given clustering is to this ideal by examining the conditional entropy of the class distribution given the proposed clustering. However, in an imperfect situation, the size of this value is dependent on the size of the dataset and the distribution of class sizes. Therefore, instead of taking the raw conditional entropy, we normalize by the maximum reduction in entropy the clustering information could provide. As such, we define homogeneity as: \\[ h = \\begin{cases} 1 if H(C) = 0, \\\\ 1 - \\frac{H(C|K)}{H(C)} otherwise. \\end{cases}. \\]","title":"Homogeneity"},{"location":"api/metrics/Homogeneity/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/Homogeneity/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Homogeneity/#examples","text":">>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . Homogeneity () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.311278 0.37515 0.42062 >>> metric Homogeneity : 42.06 %","title":"Examples"},{"location":"api/metrics/Homogeneity/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Homogeneity/#references","text":"Andrew Rosenberg and Julia Hirschberg (2007). V-Measure: A conditional entropy-based external cluster evaluation measure. Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 410 - 420, Prague, June 2007. \u21a9","title":"References"},{"location":"api/metrics/Jaccard/","text":"Jaccard \u00b6 Jaccard score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ False , True , True ] >>> y_pred = [ True , True , True ] >>> metric = metrics . Jaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Jaccard : 0.00 % Jaccard : 50.00 % Jaccard : 66.67 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Jaccard index \u21a9","title":"Jaccard"},{"location":"api/metrics/Jaccard/#jaccard","text":"Jaccard score.","title":"Jaccard"},{"location":"api/metrics/Jaccard/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/Jaccard/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Jaccard/#examples","text":">>> from river import metrics >>> y_true = [ False , True , True ] >>> y_pred = [ True , True , True ] >>> metric = metrics . Jaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Jaccard : 0.00 % Jaccard : 50.00 % Jaccard : 66.67 %","title":"Examples"},{"location":"api/metrics/Jaccard/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Jaccard/#references","text":"Jaccard index \u21a9","title":"References"},{"location":"api/metrics/LogLoss/","text":"LogLoss \u00b6 Binary logarithmic loss. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , False , True ] >>> y_pred = [ 0.9 , 0.1 , 0.2 , 0.65 ] >>> metric = metrics . LogLoss () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 0.105360 0.105360 0.144621 0.216161 >>> metric LogLoss : 0.216162 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"LogLoss"},{"location":"api/metrics/LogLoss/#logloss","text":"Binary logarithmic loss.","title":"LogLoss"},{"location":"api/metrics/LogLoss/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/LogLoss/#examples","text":">>> from river import metrics >>> y_true = [ True , False , False , True ] >>> y_pred = [ 0.9 , 0.1 , 0.2 , 0.65 ] >>> metric = metrics . LogLoss () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) ... print ( metric . get ()) 0.105360 0.105360 0.144621 0.216161 >>> metric LogLoss : 0.216162","title":"Examples"},{"location":"api/metrics/LogLoss/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/MAE/","text":"MAE \u00b6 Mean absolute error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MAE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.333 0.5 >>> metric MAE : 0.5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"MAE"},{"location":"api/metrics/MAE/#mae","text":"Mean absolute error.","title":"MAE"},{"location":"api/metrics/MAE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MAE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MAE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.333 0.5 >>> metric MAE : 0.5","title":"Examples"},{"location":"api/metrics/MAE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/MCC/","text":"MCC \u00b6 Matthews correlation coefficient. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ True , True , True , False ] >>> y_pred = [ True , False , True , True ] >>> mcc = metrics . MCC () >>> for yt , yp in zip ( y_true , y_pred ): ... mcc = mcc . update ( yt , yp ) >>> mcc MCC : - 0.333333 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia article \u21a9","title":"MCC"},{"location":"api/metrics/MCC/#mcc","text":"Matthews correlation coefficient.","title":"MCC"},{"location":"api/metrics/MCC/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/MCC/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MCC/#examples","text":">>> from river import metrics >>> y_true = [ True , True , True , False ] >>> y_pred = [ True , False , True , True ] >>> mcc = metrics . MCC () >>> for yt , yp in zip ( y_true , y_pred ): ... mcc = mcc . update ( yt , yp ) >>> mcc MCC : - 0.333333","title":"Examples"},{"location":"api/metrics/MCC/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MCC/#references","text":"Wikipedia article \u21a9","title":"References"},{"location":"api/metrics/MSE/","text":"MSE \u00b6 Mean squared error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.25 0.25 0.1666 0.375 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"MSE"},{"location":"api/metrics/MSE/#mse","text":"Mean squared error.","title":"MSE"},{"location":"api/metrics/MSE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MSE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . MSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.25 0.25 0.1666 0.375","title":"Examples"},{"location":"api/metrics/MSE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/MacroF1/","text":"MacroF1 \u00b6 Macro-average F1 score. This works by computing the F1 score per class, and then performs a global average. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroF1 : 100.00 % MacroF1 : 33.33 % MacroF1 : 55.56 % MacroF1 : 55.56 % MacroF1 : 48.89 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroF1"},{"location":"api/metrics/MacroF1/#macrof1","text":"Macro-average F1 score. This works by computing the F1 score per class, and then performs a global average.","title":"MacroF1"},{"location":"api/metrics/MacroF1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroF1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MacroF1/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroF1 : 100.00 % MacroF1 : 33.33 % MacroF1 : 55.56 % MacroF1 : 55.56 % MacroF1 : 48.89 %","title":"Examples"},{"location":"api/metrics/MacroF1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MacroFBeta/","text":"MacroFBeta \u00b6 Macro-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global average. Parameters \u00b6 beta Weight of precision in harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroFBeta ( beta = .8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroFBeta : 100.00 % MacroFBeta : 31.06 % MacroFBeta : 54.04 % MacroFBeta : 54.04 % MacroFBeta : 48.60 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroFBeta"},{"location":"api/metrics/MacroFBeta/#macrofbeta","text":"Macro-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global average.","title":"MacroFBeta"},{"location":"api/metrics/MacroFBeta/#parameters","text":"beta Weight of precision in harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MacroFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroFBeta ( beta = .8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroFBeta : 100.00 % MacroFBeta : 31.06 % MacroFBeta : 54.04 % MacroFBeta : 54.04 % MacroFBeta : 48.60 %","title":"Examples"},{"location":"api/metrics/MacroFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MacroJaccard/","text":"MacroJaccard \u00b6 Macro-average Jaccard score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroJaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroJaccard : 100.00 % MacroJaccard : 25.00 % MacroJaccard : 50.00 % MacroJaccard : 50.00 % MacroJaccard : 38.89 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroJaccard"},{"location":"api/metrics/MacroJaccard/#macrojaccard","text":"Macro-average Jaccard score.","title":"MacroJaccard"},{"location":"api/metrics/MacroJaccard/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroJaccard/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MacroJaccard/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroJaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroJaccard : 100.00 % MacroJaccard : 25.00 % MacroJaccard : 50.00 % MacroJaccard : 50.00 % MacroJaccard : 38.89 %","title":"Examples"},{"location":"api/metrics/MacroJaccard/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MacroPrecision/","text":"MacroPrecision \u00b6 Macro-average precision score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroPrecision : 100.00 % MacroPrecision : 25.00 % MacroPrecision : 50.00 % MacroPrecision : 50.00 % MacroPrecision : 50.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroPrecision"},{"location":"api/metrics/MacroPrecision/#macroprecision","text":"Macro-average precision score.","title":"MacroPrecision"},{"location":"api/metrics/MacroPrecision/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroPrecision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MacroPrecision/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroPrecision : 100.00 % MacroPrecision : 25.00 % MacroPrecision : 50.00 % MacroPrecision : 50.00 % MacroPrecision : 50.00 %","title":"Examples"},{"location":"api/metrics/MacroPrecision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MacroRecall/","text":"MacroRecall \u00b6 Macro-average recall score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroRecall : 100.00 % MacroRecall : 50.00 % MacroRecall : 66.67 % MacroRecall : 66.67 % MacroRecall : 55.56 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroRecall"},{"location":"api/metrics/MacroRecall/#macrorecall","text":"Macro-average recall score.","title":"MacroRecall"},{"location":"api/metrics/MacroRecall/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MacroRecall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MacroRecall/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MacroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MacroRecall : 100.00 % MacroRecall : 50.00 % MacroRecall : 66.67 % MacroRecall : 66.67 % MacroRecall : 55.56 %","title":"Examples"},{"location":"api/metrics/MacroRecall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroF1/","text":"MicroF1 \u00b6 Micro-average F1 score. This computes the F1 score by merging all the predictions and true labels, and then computes a global F1 score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroF1 : 60.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"MicroF1"},{"location":"api/metrics/MicroF1/#microf1","text":"Micro-average F1 score. This computes the F1 score by merging all the predictions and true labels, and then computes a global F1 score.","title":"MicroF1"},{"location":"api/metrics/MicroF1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroF1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MicroF1/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroF1 : 60.00 %","title":"Examples"},{"location":"api/metrics/MicroF1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroF1/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"References"},{"location":"api/metrics/MicroFBeta/","text":"MicroFBeta \u00b6 Micro-average F-Beta score. This computes the F-Beta score by merging all the predictions and true labels, and then computes a global F-Beta score. Parameters \u00b6 beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroFBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroFBeta : 60.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem?","title":"MicroFBeta"},{"location":"api/metrics/MicroFBeta/#microfbeta","text":"Micro-average F-Beta score. This computes the F-Beta score by merging all the predictions and true labels, and then computes a global F-Beta score.","title":"MicroFBeta"},{"location":"api/metrics/MicroFBeta/#parameters","text":"beta ( float ) Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MicroFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 0 ] >>> y_pred = [ 0 , 1 , 1 , 2 , 1 ] >>> metric = metrics . MicroFBeta ( beta = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric MicroFBeta : 60.00 %","title":"Examples"},{"location":"api/metrics/MicroFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroFBeta/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem?","title":"References"},{"location":"api/metrics/MicroJaccard/","text":"MicroJaccard \u00b6 Micro-average Jaccard score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroJaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroJaccard : 100.00 % MicroJaccard : 33.33 % MicroJaccard : 50.00 % MicroJaccard : 60.00 % MicroJaccard : 42.86 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MicroJaccard"},{"location":"api/metrics/MicroJaccard/#microjaccard","text":"Micro-average Jaccard score.","title":"MicroJaccard"},{"location":"api/metrics/MicroJaccard/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroJaccard/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MicroJaccard/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroJaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroJaccard : 100.00 % MicroJaccard : 33.33 % MicroJaccard : 50.00 % MicroJaccard : 60.00 % MicroJaccard : 42.86 %","title":"Examples"},{"location":"api/metrics/MicroJaccard/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroPrecision/","text":"MicroPrecision \u00b6 Micro-average precision score. The micro-average precision score is exactly equivalent to the micro-average recall as well as the micro-average F1 score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroPrecision : 100.00 % MicroPrecision : 50.00 % MicroPrecision : 66.67 % MicroPrecision : 75.00 % MicroPrecision : 60.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"MicroPrecision"},{"location":"api/metrics/MicroPrecision/#microprecision","text":"Micro-average precision score. The micro-average precision score is exactly equivalent to the micro-average recall as well as the micro-average F1 score.","title":"MicroPrecision"},{"location":"api/metrics/MicroPrecision/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroPrecision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MicroPrecision/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroPrecision : 100.00 % MicroPrecision : 50.00 % MicroPrecision : 66.67 % MicroPrecision : 75.00 % MicroPrecision : 60.00 %","title":"Examples"},{"location":"api/metrics/MicroPrecision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroPrecision/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"References"},{"location":"api/metrics/MicroRecall/","text":"MicroRecall \u00b6 Micro-average recall score. The micro-average recall is exactly equivalent to the micro-average precision as well as the micro-average F1 score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroRecall : 100.00 % MicroRecall : 50.00 % MicroRecall : 66.67 % MicroRecall : 75.00 % MicroRecall : 60.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"MicroRecall"},{"location":"api/metrics/MicroRecall/#microrecall","text":"Micro-average recall score. The micro-average recall is exactly equivalent to the micro-average precision as well as the micro-average F1 score.","title":"MicroRecall"},{"location":"api/metrics/MicroRecall/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MicroRecall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MicroRecall/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MicroRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MicroRecall : 100.00 % MicroRecall : 50.00 % MicroRecall : 66.67 % MicroRecall : 75.00 % MicroRecall : 60.00 %","title":"Examples"},{"location":"api/metrics/MicroRecall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MicroRecall/#references","text":"Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9","title":"References"},{"location":"api/metrics/MultiFBeta/","text":"MultiFBeta \u00b6 Multi-class F-Beta score with different betas per class. The multiclass F-Beta score is the arithmetic average of the binary F-Beta scores of each class. The mean can be weighted by providing class weights. Parameters \u00b6 betas Weight of precision in the harmonic mean of each class. weights Class weights. If not provided then uniform weights will be used. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MultiFBeta ( ... betas = { 0 : 0.25 , 1 : 1 , 2 : 4 }, ... weights = { 0 : 1 , 1 : 1 , 2 : 2 } ... ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MultiFBeta : 100.00 % MultiFBeta : 25.76 % MultiFBeta : 62.88 % MultiFBeta : 62.88 % MultiFBeta : 46.88 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiFBeta"},{"location":"api/metrics/MultiFBeta/#multifbeta","text":"Multi-class F-Beta score with different betas per class. The multiclass F-Beta score is the arithmetic average of the binary F-Beta scores of each class. The mean can be weighted by providing class weights.","title":"MultiFBeta"},{"location":"api/metrics/MultiFBeta/#parameters","text":"betas Weight of precision in the harmonic mean of each class. weights Class weights. If not provided then uniform weights will be used. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MultiFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MultiFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . MultiFBeta ( ... betas = { 0 : 0.25 , 1 : 1 , 2 : 4 }, ... weights = { 0 : 1 , 1 : 1 , 2 : 2 } ... ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MultiFBeta : 100.00 % MultiFBeta : 25.76 % MultiFBeta : 62.88 % MultiFBeta : 62.88 % MultiFBeta : 46.88 %","title":"Examples"},{"location":"api/metrics/MultiFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MutualInfo/","text":"MutualInfo \u00b6 Mutual Information between two clusterings. The Mutual Information 1 is a measure of the similarity between two labels of the same data. Where \\(|U_i|\\) is the number of samples in cluster \\(U_i\\) and \\(|V_j|\\) is the number of the samples in cluster \\(V_j\\) , the Mutual Information between clusterings \\(U\\) and \\(V\\) can be calculated as: \\[ MI(U,V) = \\sum_{i=1}^{|U|} \\sum_{v=1}^{|V|} \\frac{|U_i \\cup V_j|}{N} \\log \\frac{N |U_i \\cup V_j|}{|U_i| |V_j|} \\] This metric is independent of the absolute values of the labels: a permutation of the class or cluster label values won't change the score. This metric is furthermore symmetric: switching y_true and y_pred will return the same score value. This can be useful to measure the agreement of two independent label assignments strategies on the same dataset when the real ground truth is not known. The Mutual Information can be equivalently expressed as: \\[ MI(U,V) = H(U) - H(U | V) = H(V) - H(V | U) \\] where \\(H(U)\\) and \\(H(V)\\) are the marginal entropies, \\(H(U | V)\\) and \\(H(V | U)\\) are the conditional entropies. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . MutualInfo () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.0 0.0 0.0 0.215761 0.395752 0.462098 >>> metric MutualInfo : 0.462098 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia contributors. (2021, March 17). Mutual information. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Mutual_information&oldid=1012714929 \u21a9","title":"MutualInfo"},{"location":"api/metrics/MutualInfo/#mutualinfo","text":"Mutual Information between two clusterings. The Mutual Information 1 is a measure of the similarity between two labels of the same data. Where \\(|U_i|\\) is the number of samples in cluster \\(U_i\\) and \\(|V_j|\\) is the number of the samples in cluster \\(V_j\\) , the Mutual Information between clusterings \\(U\\) and \\(V\\) can be calculated as: \\[ MI(U,V) = \\sum_{i=1}^{|U|} \\sum_{v=1}^{|V|} \\frac{|U_i \\cup V_j|}{N} \\log \\frac{N |U_i \\cup V_j|}{|U_i| |V_j|} \\] This metric is independent of the absolute values of the labels: a permutation of the class or cluster label values won't change the score. This metric is furthermore symmetric: switching y_true and y_pred will return the same score value. This can be useful to measure the agreement of two independent label assignments strategies on the same dataset when the real ground truth is not known. The Mutual Information can be equivalently expressed as: \\[ MI(U,V) = H(U) - H(U | V) = H(V) - H(V | U) \\] where \\(H(U)\\) and \\(H(V)\\) are the marginal entropies, \\(H(U | V)\\) and \\(H(V | U)\\) are the conditional entropies.","title":"MutualInfo"},{"location":"api/metrics/MutualInfo/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/MutualInfo/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/MutualInfo/#examples","text":">>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . MutualInfo () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.0 0.0 0.0 0.215761 0.395752 0.462098 >>> metric MutualInfo : 0.462098","title":"Examples"},{"location":"api/metrics/MutualInfo/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/MutualInfo/#references","text":"Wikipedia contributors. (2021, March 17). Mutual information. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Mutual_information&oldid=1012714929 \u21a9","title":"References"},{"location":"api/metrics/NormalizedMutualInfo/","text":"NormalizedMutualInfo \u00b6 Normalized Mutual Information between two clusterings. Normalized Mutual Information (NMI) is a normalized version of the Mutual Information (MI) score to scale the results between the range of 0 (no mutual information) and 1 (perfectly mutual information). In the formula, the mutual information will be normalized by a generalized mean of the entropy of true and predicted labels, defined by the average_method . We note that this measure is not adjusted for chance (i.e corrected the effect of result agreement solely due to chance); as a result, the Adjusted Mutual Info Score will mostly be preferred. However, this metric is still symmetric, which means that switching true and predicted labels will not alter the score value. This fact can be useful when the metric is used to measure the agreement between two indepedent label solutions on the same dataset, when the ground truth remains unknown. Another advantage of the metric is that as it is based on the calculation of entropy-related measures, it is independent of the permutation of class/cluster labels. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. average_method \u2013 defaults to arithmetic This parameter defines how to compute the normalizer in the denominator. Possible options include min , max , arithmetic and geometric . Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . NormalizedMutualInfo () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.343711 0.458065 0.515803 >>> metric NormalizedMutualInfo : 0.515804 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia contributors. (2021, March 17). Mutual information. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Mutual_information&oldid=1012714929 \u21a9","title":"NormalizedMutualInfo"},{"location":"api/metrics/NormalizedMutualInfo/#normalizedmutualinfo","text":"Normalized Mutual Information between two clusterings. Normalized Mutual Information (NMI) is a normalized version of the Mutual Information (MI) score to scale the results between the range of 0 (no mutual information) and 1 (perfectly mutual information). In the formula, the mutual information will be normalized by a generalized mean of the entropy of true and predicted labels, defined by the average_method . We note that this measure is not adjusted for chance (i.e corrected the effect of result agreement solely due to chance); as a result, the Adjusted Mutual Info Score will mostly be preferred. However, this metric is still symmetric, which means that switching true and predicted labels will not alter the score value. This fact can be useful when the metric is used to measure the agreement between two indepedent label solutions on the same dataset, when the ground truth remains unknown. Another advantage of the metric is that as it is based on the calculation of entropy-related measures, it is independent of the permutation of class/cluster labels.","title":"NormalizedMutualInfo"},{"location":"api/metrics/NormalizedMutualInfo/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. average_method \u2013 defaults to arithmetic This parameter defines how to compute the normalizer in the denominator. Possible options include min , max , arithmetic and geometric .","title":"Parameters"},{"location":"api/metrics/NormalizedMutualInfo/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/NormalizedMutualInfo/#examples","text":">>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . NormalizedMutualInfo () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.343711 0.458065 0.515803 >>> metric NormalizedMutualInfo : 0.515804","title":"Examples"},{"location":"api/metrics/NormalizedMutualInfo/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/NormalizedMutualInfo/#references","text":"Wikipedia contributors. (2021, March 17). Mutual information. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Mutual_information&oldid=1012714929 \u21a9","title":"References"},{"location":"api/metrics/Precision/","text":"Precision \u00b6 Binary precision score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Precision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Precision : 100.00 % Precision : 50.00 % Precision : 50.00 % Precision : 66.67 % Precision : 75.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Precision"},{"location":"api/metrics/Precision/#precision","text":"Binary precision score.","title":"Precision"},{"location":"api/metrics/Precision/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/Precision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Precision/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Precision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Precision : 100.00 % Precision : 50.00 % Precision : 50.00 % Precision : 66.67 % Precision : 75.00 %","title":"Examples"},{"location":"api/metrics/Precision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/R2/","text":"R2 \u00b6 Coefficient of determination ( \\(R^2\\) ) score The coefficient of determination, denoted \\(R^2\\) or \\(r^2\\) , is the proportion of the variance in the dependent variable that is predictable from the independent variable(s). 1 Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of \\(y\\) , disregarding the input features, would get a \\(R^2\\) score of 0.0. \\(R^2\\) is not defined when less than 2 samples have been observed. This implementation returns 0.0 in this case. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . R2 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.0 0.9183 0.9230 0.9486 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Coefficient of determination (Wikipedia) \u21a9","title":"R2"},{"location":"api/metrics/R2/#r2","text":"Coefficient of determination ( \\(R^2\\) ) score The coefficient of determination, denoted \\(R^2\\) or \\(r^2\\) , is the proportion of the variance in the dependent variable that is predictable from the independent variable(s). 1 Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of \\(y\\) , disregarding the input features, would get a \\(R^2\\) score of 0.0. \\(R^2\\) is not defined when less than 2 samples have been observed. This implementation returns 0.0 in this case.","title":"R2"},{"location":"api/metrics/R2/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/R2/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . R2 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.0 0.9183 0.9230 0.9486","title":"Examples"},{"location":"api/metrics/R2/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/R2/#references","text":"Coefficient of determination (Wikipedia) \u21a9","title":"References"},{"location":"api/metrics/RMSE/","text":"RMSE \u00b6 Root mean squared error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.408248 0.612372 >>> metric RMSE : 0.612372 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"RMSE"},{"location":"api/metrics/RMSE/#rmse","text":"Root mean squared error.","title":"RMSE"},{"location":"api/metrics/RMSE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/RMSE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSE () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 0.5 0.5 0.408248 0.612372 >>> metric RMSE : 0.612372","title":"Examples"},{"location":"api/metrics/RMSE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/RMSLE/","text":"RMSLE \u00b6 Root mean squared logarithmic error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSLE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric RMSLE : 0.357826 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"RMSLE"},{"location":"api/metrics/RMSLE/#rmsle","text":"Root mean squared logarithmic error.","title":"RMSLE"},{"location":"api/metrics/RMSLE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/RMSLE/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . RMSLE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric RMSLE : 0.357826","title":"Examples"},{"location":"api/metrics/RMSLE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/ROCAUC/","text":"ROCAUC \u00b6 Receiving Operating Characteristic Area Under the Curve. This metric is an approximation of the true ROC AUC. Computing the true ROC AUC would require storing all the predictions and ground truths, which isn't desirable. The approximation error is not significant as long as the predicted probabilities are well calibrated. In any case, this metric can still be used to reliably compare models between each other. Parameters \u00b6 n_thresholds \u2013 defaults to 10 The number of thresholds used for discretizing the ROC curve. A higher value will lead to more accurate results, but will also cost more time and memory. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 0 , 1 , 1 ] >>> y_pred = [ .1 , .4 , .35 , .8 ] >>> metric = metrics . ROCAUC () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 87.50 % The true ROC AUC is in fact 0.75. We can improve the accuracy by increasing the amount of thresholds. This comes at the cost more computation time and more memory usage. >>> metric = metrics . ROCAUC ( n_thresholds = 20 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 75.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ROCAUC"},{"location":"api/metrics/ROCAUC/#rocauc","text":"Receiving Operating Characteristic Area Under the Curve. This metric is an approximation of the true ROC AUC. Computing the true ROC AUC would require storing all the predictions and ground truths, which isn't desirable. The approximation error is not significant as long as the predicted probabilities are well calibrated. In any case, this metric can still be used to reliably compare models between each other.","title":"ROCAUC"},{"location":"api/metrics/ROCAUC/#parameters","text":"n_thresholds \u2013 defaults to 10 The number of thresholds used for discretizing the ROC curve. A higher value will lead to more accurate results, but will also cost more time and memory. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/ROCAUC/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/ROCAUC/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 0 , 1 , 1 ] >>> y_pred = [ .1 , .4 , .35 , .8 ] >>> metric = metrics . ROCAUC () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 87.50 % The true ROC AUC is in fact 0.75. We can improve the accuracy by increasing the amount of thresholds. This comes at the cost more computation time and more memory usage. >>> metric = metrics . ROCAUC ( n_thresholds = 20 ) >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ROCAUC : 75.00 %","title":"Examples"},{"location":"api/metrics/ROCAUC/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Rand/","text":"Rand \u00b6 Rand Index. The Rand Index 1 2 is a measure of the similarity between two data clusterings. Given a set of elements S and two partitions of S to compare, X and Y , define the following: a, the number of pairs of elements in S that are in the same subset in X and in the same subset in Y b, the number of pairs of elements in S that are in the different subset in X and in different subsets in Y c, the number of pairs of elements in S that are in the same subset in X and in different subsets in Y d, the number of pairs of elements in S that are in the different subset in X and in the same subset in Y The Rand index, R, is \\[ R = rac{a+b}{a+b+c+d} = rac{a+b}{ rac{n(n-1)}{2}}. \\] Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 0 , 0 , 1 , 1 , 1 ] >>> y_pred = [ 0 , 0 , 1 , 1 , 2 , 2 ] >>> metric = metrics . Rand () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Rand : 0.666667 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Wikipedia contributors. (2021, January 13). Rand index. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Rand_index&oldid=1000098911 \u21a9 W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\". Journal of the American Statistical Association. American Statistical Association. 66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239. \u21a9","title":"Rand"},{"location":"api/metrics/Rand/#rand","text":"Rand Index. The Rand Index 1 2 is a measure of the similarity between two data clusterings. Given a set of elements S and two partitions of S to compare, X and Y , define the following: a, the number of pairs of elements in S that are in the same subset in X and in the same subset in Y b, the number of pairs of elements in S that are in the different subset in X and in different subsets in Y c, the number of pairs of elements in S that are in the same subset in X and in different subsets in Y d, the number of pairs of elements in S that are in the different subset in X and in the same subset in Y The Rand index, R, is \\[ R = rac{a+b}{a+b+c+d} = rac{a+b}{ rac{n(n-1)}{2}}. \\]","title":"Rand"},{"location":"api/metrics/Rand/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/Rand/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Rand/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 0 , 0 , 1 , 1 , 1 ] >>> y_pred = [ 0 , 0 , 1 , 1 , 2 , 2 ] >>> metric = metrics . Rand () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric Rand : 0.666667","title":"Examples"},{"location":"api/metrics/Rand/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Rand/#references","text":"Wikipedia contributors. (2021, January 13). Rand index. In Wikipedia, The Free Encyclopedia, from https://en.wikipedia.org/w/index.php?title=Rand_index&oldid=1000098911 \u21a9 W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\". Journal of the American Statistical Association. American Statistical Association. 66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239. \u21a9","title":"References"},{"location":"api/metrics/Recall/","text":"Recall \u00b6 Binary recall score. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Recall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Recall : 100.00 % Recall : 100.00 % Recall : 50.00 % Recall : 66.67 % Recall : 75.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Recall"},{"location":"api/metrics/Recall/#recall","text":"Binary recall score.","title":"Recall"},{"location":"api/metrics/Recall/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/Recall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Recall/#examples","text":">>> from river import metrics >>> y_true = [ True , False , True , True , True ] >>> y_pred = [ True , True , False , True , True ] >>> metric = metrics . Recall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) Recall : 100.00 % Recall : 100.00 % Recall : 50.00 % Recall : 66.67 % Recall : 75.00 %","title":"Examples"},{"location":"api/metrics/Recall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Rolling/","text":"Rolling \u00b6 Wrapper for computing metrics over a window. This wrapper metric allows you to apply a metric over a window of observations. Under the hood, a buffer with the window_size most recent pairs of (y_true, y_pred) is memorised. When the buffer is full, the oldest pair is removed and the revert method of the metric is called with said pair. You should use metrics.Rolling to evaluate a metric over a window of fixed sized. You can use metrics.TimeRolling to instead evaluate a metric over a period of time. Parameters \u00b6 metric ( river.metrics.base.Metric ) A metric. window_size ( int ) The number of most recent (y_true, y_pred) pairs on which to evaluate the metric. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels window_size works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . Rolling ( metrics . MSE (), window_size = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MSE : 0.25 ( rolling 2 ) MSE : 0.25 ( rolling 2 ) MSE : 0.125 ( rolling 2 ) MSE : 0.5 ( rolling 2 ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Rolling"},{"location":"api/metrics/Rolling/#rolling","text":"Wrapper for computing metrics over a window. This wrapper metric allows you to apply a metric over a window of observations. Under the hood, a buffer with the window_size most recent pairs of (y_true, y_pred) is memorised. When the buffer is full, the oldest pair is removed and the revert method of the metric is called with said pair. You should use metrics.Rolling to evaluate a metric over a window of fixed sized. You can use metrics.TimeRolling to instead evaluate a metric over a period of time.","title":"Rolling"},{"location":"api/metrics/Rolling/#parameters","text":"metric ( river.metrics.base.Metric ) A metric. window_size ( int ) The number of most recent (y_true, y_pred) pairs on which to evaluate the metric.","title":"Parameters"},{"location":"api/metrics/Rolling/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels window_size works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/Rolling/#examples","text":">>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 8 ] >>> metric = metrics . Rolling ( metrics . MSE (), window_size = 2 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) MSE : 0.25 ( rolling 2 ) MSE : 0.25 ( rolling 2 ) MSE : 0.125 ( rolling 2 ) MSE : 0.5 ( rolling 2 )","title":"Examples"},{"location":"api/metrics/Rolling/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/SMAPE/","text":"SMAPE \u00b6 Symmetric mean absolute percentage error. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.0672 , 0.0672 ] >>> y_pred = [ 0 , 0.102 , 0.107 , 0.047 , 0.1 , 0.032 , 0.047 , 0.108 , 0.089 ] >>> metric = metrics . SMAPE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric SMAPE : 37.869392 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"SMAPE"},{"location":"api/metrics/SMAPE/#smape","text":"Symmetric mean absolute percentage error.","title":"SMAPE"},{"location":"api/metrics/SMAPE/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/SMAPE/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.07533 , 0.0672 , 0.0672 ] >>> y_pred = [ 0 , 0.102 , 0.107 , 0.047 , 0.1 , 0.032 , 0.047 , 0.108 , 0.089 ] >>> metric = metrics . SMAPE () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric SMAPE : 37.869392","title":"Examples"},{"location":"api/metrics/SMAPE/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/Silhouette/","text":"Silhouette \u00b6 Silhouette coefficient 1 , roughly speaking, is the ratio between cohesion and the average distances from the points to their second-closest centroid. It rewards the clustering algorithm where points are very close to their assigned centroids and far from any other centroids, that is, clustering results with good cohesion and good separation. It rewards clusterings where points are very close to their assigned centroids and far from any other centroids, that is clusterings with good cohesion and good separation. 2 The definition of Silhouette coefficient for online clustering evaluation is different from that of batch learning. It does not store information and calculate pairwise distances between all points at the same time, since the practice is too expensive for an incremental metric. Attributes \u00b6 bigger_is_better Indicates if a high value is better than a low one or not. Examples \u00b6 >>> from river import cluster >>> from river import stream >>> from river import metrics >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ], ... [ - 2 , 2 ], ... [ - 2 , 4 ], ... [ - 2 , 0 ] ... ] >>> k_means = cluster . KMeans ( n_clusters = 3 , halflife = 0.4 , sigma = 3 , seed = 0 ) >>> metric = metrics . Silhouette () >>> for x , _ in stream . iter_array ( X ): ... k_means = k_means . learn_one ( x ) ... y_pred = k_means . predict_one ( x ) ... metric = metric . update ( x , y_pred , k_means . centers ) >>> metric Silhouette : 0.32145 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters x y_pred centers sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters x y_pred centers sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Rousseeuw, P. (1987). Silhouettes: a graphical aid to the intepretation and validation of cluster analysis 20, 53 - 65. DOI: 10.1016/0377-0427(87)90125-7 \u21a9 Bifet, A. et al. (2018). \"Machine Learning for Data Streams\". DOI: 10.7551/mitpress/10654.001.0001. \u21a9","title":"Silhouette"},{"location":"api/metrics/Silhouette/#silhouette","text":"Silhouette coefficient 1 , roughly speaking, is the ratio between cohesion and the average distances from the points to their second-closest centroid. It rewards the clustering algorithm where points are very close to their assigned centroids and far from any other centroids, that is, clustering results with good cohesion and good separation. It rewards clusterings where points are very close to their assigned centroids and far from any other centroids, that is clusterings with good cohesion and good separation. 2 The definition of Silhouette coefficient for online clustering evaluation is different from that of batch learning. It does not store information and calculate pairwise distances between all points at the same time, since the practice is too expensive for an incremental metric.","title":"Silhouette"},{"location":"api/metrics/Silhouette/#attributes","text":"bigger_is_better Indicates if a high value is better than a low one or not.","title":"Attributes"},{"location":"api/metrics/Silhouette/#examples","text":">>> from river import cluster >>> from river import stream >>> from river import metrics >>> X = [ ... [ 1 , 2 ], ... [ 1 , 4 ], ... [ 1 , 0 ], ... [ 4 , 2 ], ... [ 4 , 4 ], ... [ 4 , 0 ], ... [ - 2 , 2 ], ... [ - 2 , 4 ], ... [ - 2 , 0 ] ... ] >>> k_means = cluster . KMeans ( n_clusters = 3 , halflife = 0.4 , sigma = 3 , seed = 0 ) >>> metric = metrics . Silhouette () >>> for x , _ in stream . iter_array ( X ): ... k_means = k_means . learn_one ( x ) ... y_pred = k_means . predict_one ( x ) ... metric = metric . update ( x , y_pred , k_means . centers ) >>> metric Silhouette : 0.32145","title":"Examples"},{"location":"api/metrics/Silhouette/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. revert Revert the metric. Parameters x y_pred centers sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters x y_pred centers sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/Silhouette/#references","text":"Rousseeuw, P. (1987). Silhouettes: a graphical aid to the intepretation and validation of cluster analysis 20, 53 - 65. DOI: 10.1016/0377-0427(87)90125-7 \u21a9 Bifet, A. et al. (2018). \"Machine Learning for Data Streams\". DOI: 10.7551/mitpress/10654.001.0001. \u21a9","title":"References"},{"location":"api/metrics/TimeRolling/","text":"TimeRolling \u00b6 Wrapper for computing metrics over a period of time. Parameters \u00b6 metric ( river.metrics.base.Metric ) A metric. period ( datetime.timedelta ) A period of time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> import datetime as dt >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 9 ] >>> days = [ 1 , 2 , 3 , 4 ] >>> metric = metrics . TimeRolling ( metrics . MAE (), period = dt . timedelta ( days = 2 )) >>> for yt , yp , day in zip ( y_true , y_pred , days ): ... t = dt . datetime ( 2019 , 1 , day ) ... print ( metric . update ( yt , yp , t )) MAE : 0.5 ( rolling 2 days , 0 : 00 : 00 ) MAE : 0.5 ( rolling 2 days , 0 : 00 : 00 ) MAE : 0.25 ( rolling 2 days , 0 : 00 : 00 ) MAE : 1. ( rolling 2 days , 0 : 00 : 00 ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred update Update the metric. Parameters y_true y_pred t works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"TimeRolling"},{"location":"api/metrics/TimeRolling/#timerolling","text":"Wrapper for computing metrics over a period of time.","title":"TimeRolling"},{"location":"api/metrics/TimeRolling/#parameters","text":"metric ( river.metrics.base.Metric ) A metric. period ( datetime.timedelta ) A period of time.","title":"Parameters"},{"location":"api/metrics/TimeRolling/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/TimeRolling/#examples","text":">>> import datetime as dt >>> from river import metrics >>> y_true = [ 3 , - 0.5 , 2 , 7 ] >>> y_pred = [ 2.5 , 0.0 , 2 , 9 ] >>> days = [ 1 , 2 , 3 , 4 ] >>> metric = metrics . TimeRolling ( metrics . MAE (), period = dt . timedelta ( days = 2 )) >>> for yt , yp , day in zip ( y_true , y_pred , days ): ... t = dt . datetime ( 2019 , 1 , day ) ... print ( metric . update ( yt , yp , t )) MAE : 0.5 ( rolling 2 days , 0 : 00 : 00 ) MAE : 0.5 ( rolling 2 days , 0 : 00 : 00 ) MAE : 0.25 ( rolling 2 days , 0 : 00 : 00 ) MAE : 1. ( rolling 2 days , 0 : 00 : 00 )","title":"Examples"},{"location":"api/metrics/TimeRolling/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred update Update the metric. Parameters y_true y_pred t works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/VBeta/","text":"VBeta \u00b6 VBeta. VBeta (or V-Measure) 1 is an external entropy-based cluster evaluation measure. It provides an elegant solution to many problems that affect previously defined cluster evaluation measures including Dependance of clustering algorithm or dataset, The \"problem of matching\", where the clustering of only a portion of data points are evaluated, and Accurate evaluation and combination of two desirable aspects of clustering, homogeneity and completeness. Based upon the calculations of homogeneity and completeness, a clustering solution's V-measure is calculated by computing the weighted harmonic mean of homogeneity and completeness, \\[ V_{\\beta} = \\frac{(1 + \\beta) \\times h \\times c}{\\beta \\times h + c}. \\] Parameters \u00b6 beta ( float ) \u2013 defaults to 1.0 Weight of Homogeneity in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . VBeta ( beta = 1.0 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.3437110184854507 0.4580652856440158 0.5158037429793888 >>> metric VBeta : 51.58 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator ) References \u00b6 Andrew Rosenberg and Julia Hirschberg (2007). V-Measure: A conditional entropy-based external cluster evaluation measure. Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 410 - 420, Prague, June 2007. \u21a9","title":"VBeta"},{"location":"api/metrics/VBeta/#vbeta","text":"VBeta. VBeta (or V-Measure) 1 is an external entropy-based cluster evaluation measure. It provides an elegant solution to many problems that affect previously defined cluster evaluation measures including Dependance of clustering algorithm or dataset, The \"problem of matching\", where the clustering of only a portion of data points are evaluated, and Accurate evaluation and combination of two desirable aspects of clustering, homogeneity and completeness. Based upon the calculations of homogeneity and completeness, a clustering solution's V-measure is calculated by computing the weighted harmonic mean of homogeneity and completeness, \\[ V_{\\beta} = \\frac{(1 + \\beta) \\times h \\times c}{\\beta \\times h + c}. \\]","title":"VBeta"},{"location":"api/metrics/VBeta/#parameters","text":"beta ( float ) \u2013 defaults to 1.0 Weight of Homogeneity in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/VBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/VBeta/#examples","text":">>> from river import metrics >>> y_true = [ 1 , 1 , 2 , 2 , 3 , 3 ] >>> y_pred = [ 1 , 1 , 1 , 2 , 2 , 2 ] >>> metric = metrics . VBeta ( beta = 1.0 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp ) . get ()) 1.0 1.0 0.0 0.3437110184854507 0.4580652856440158 0.5158037429793888 >>> metric VBeta : 51.58 %","title":"Examples"},{"location":"api/metrics/VBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/VBeta/#references","text":"Andrew Rosenberg and Julia Hirschberg (2007). V-Measure: A conditional entropy-based external cluster evaluation measure. Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pp. 410 - 420, Prague, June 2007. \u21a9","title":"References"},{"location":"api/metrics/WeightedF1/","text":"WeightedF1 \u00b6 Weighted-average F1 score. This works by computing the F1 score per class, and then performs a global weighted average by using the support of each class. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedF1 : 100.00 % WeightedF1 : 33.33 % WeightedF1 : 55.56 % WeightedF1 : 66.67 % WeightedF1 : 61.33 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedF1"},{"location":"api/metrics/WeightedF1/#weightedf1","text":"Weighted-average F1 score. This works by computing the F1 score per class, and then performs a global weighted average by using the support of each class.","title":"WeightedF1"},{"location":"api/metrics/WeightedF1/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedF1/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/WeightedF1/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedF1 () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedF1 : 100.00 % WeightedF1 : 33.33 % WeightedF1 : 55.56 % WeightedF1 : 66.67 % WeightedF1 : 61.33 %","title":"Examples"},{"location":"api/metrics/WeightedF1/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedFBeta/","text":"WeightedFBeta \u00b6 Weighted-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global weighted average according to the support of each class. Parameters \u00b6 beta Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedFBeta ( beta = 0.8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedFBeta : 100.00 % WeightedFBeta : 31.06 % WeightedFBeta : 54.04 % WeightedFBeta : 65.53 % WeightedFBeta : 62.63 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedFBeta"},{"location":"api/metrics/WeightedFBeta/#weightedfbeta","text":"Weighted-average F-Beta score. This works by computing the F-Beta score per class, and then performs a global weighted average according to the support of each class.","title":"WeightedFBeta"},{"location":"api/metrics/WeightedFBeta/#parameters","text":"beta Weight of precision in the harmonic mean. cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedFBeta/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/WeightedFBeta/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedFBeta ( beta = 0.8 ) >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedFBeta : 100.00 % WeightedFBeta : 31.06 % WeightedFBeta : 54.04 % WeightedFBeta : 65.53 % WeightedFBeta : 62.63 %","title":"Examples"},{"location":"api/metrics/WeightedFBeta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedJaccard/","text":"WeightedJaccard \u00b6 Weighted average Jaccard score. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedJaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedJaccard : 100.00 % WeightedJaccard : 25.00 % WeightedJaccard : 50.00 % WeightedJaccard : 62.50 % WeightedJaccard : 50.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedJaccard"},{"location":"api/metrics/WeightedJaccard/#weightedjaccard","text":"Weighted average Jaccard score.","title":"WeightedJaccard"},{"location":"api/metrics/WeightedJaccard/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedJaccard/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/WeightedJaccard/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedJaccard () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedJaccard : 100.00 % WeightedJaccard : 25.00 % WeightedJaccard : 50.00 % WeightedJaccard : 62.50 % WeightedJaccard : 50.00 %","title":"Examples"},{"location":"api/metrics/WeightedJaccard/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedPrecision/","text":"WeightedPrecision \u00b6 Weighted-average precision score. This uses the support of each label to compute an average score, whereas metrics.MacroPrecision ignores the support. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedPrecision : 100.00 % WeightedPrecision : 25.00 % WeightedPrecision : 50.00 % WeightedPrecision : 62.50 % WeightedPrecision : 70.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedPrecision"},{"location":"api/metrics/WeightedPrecision/#weightedprecision","text":"Weighted-average precision score. This uses the support of each label to compute an average score, whereas metrics.MacroPrecision ignores the support.","title":"WeightedPrecision"},{"location":"api/metrics/WeightedPrecision/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedPrecision/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/WeightedPrecision/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedPrecision () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedPrecision : 100.00 % WeightedPrecision : 25.00 % WeightedPrecision : 50.00 % WeightedPrecision : 62.50 % WeightedPrecision : 70.00 %","title":"Examples"},{"location":"api/metrics/WeightedPrecision/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/WeightedRecall/","text":"WeightedRecall \u00b6 Weighted-average recall score. This uses the support of each label to compute an average score, whereas MacroRecall ignores the support. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedRecall : 100.00 % WeightedRecall : 50.00 % WeightedRecall : 66.67 % WeightedRecall : 75.00 % WeightedRecall : 60.00 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WeightedRecall"},{"location":"api/metrics/WeightedRecall/#weightedrecall","text":"Weighted-average recall score. This uses the support of each label to compute an average score, whereas MacroRecall ignores the support.","title":"WeightedRecall"},{"location":"api/metrics/WeightedRecall/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/WeightedRecall/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/WeightedRecall/#examples","text":">>> from river import metrics >>> y_true = [ 0 , 1 , 2 , 2 , 2 ] >>> y_pred = [ 0 , 0 , 2 , 2 , 1 ] >>> metric = metrics . WeightedRecall () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( metric . update ( yt , yp )) WeightedRecall : 100.00 % WeightedRecall : 50.00 % WeightedRecall : 66.67 % WeightedRecall : 75.00 % WeightedRecall : 60.00 %","title":"Examples"},{"location":"api/metrics/WeightedRecall/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/base/BinaryMetric/","text":"BinaryMetric \u00b6 Mother class for all binary classification metrics. Parameters \u00b6 cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\". Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"BinaryMetric"},{"location":"api/metrics/base/BinaryMetric/#binarymetric","text":"Mother class for all binary classification metrics.","title":"BinaryMetric"},{"location":"api/metrics/base/BinaryMetric/#parameters","text":"cm \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. pos_val \u2013 defaults to True Value to treat as \"positive\".","title":"Parameters"},{"location":"api/metrics/base/BinaryMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/base/BinaryMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( bool ) y_pred ( Union[bool, float, Dict[bool, float]] ) sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/base/ClassificationMetric/","text":"ClassificationMetric \u00b6 Mother class for all classification metrics. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"ClassificationMetric"},{"location":"api/metrics/base/ClassificationMetric/#classificationmetric","text":"Mother class for all classification metrics.","title":"ClassificationMetric"},{"location":"api/metrics/base/ClassificationMetric/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/base/ClassificationMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/base/ClassificationMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/base/Metric/","text":"Metric \u00b6 Mother class for all metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Metric"},{"location":"api/metrics/base/Metric/#metric","text":"Mother class for all metrics.","title":"Metric"},{"location":"api/metrics/base/Metric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/base/Metric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/base/Metrics/","text":"Metrics \u00b6 A container class for handling multiple metrics at once. Parameters \u00b6 metrics str_sep \u2013 defaults to , Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get Return the current value of the metric. index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item is_better_than pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 sort update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Metrics"},{"location":"api/metrics/base/Metrics/#metrics","text":"A container class for handling multiple metrics at once.","title":"Metrics"},{"location":"api/metrics/base/Metrics/#parameters","text":"metrics str_sep \u2013 defaults to ,","title":"Parameters"},{"location":"api/metrics/base/Metrics/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/base/Metrics/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other get Return the current value of the metric. index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item is_better_than pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 sort update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/base/MultiClassMetric/","text":"MultiClassMetric \u00b6 Mother class for all multi-class classification metrics. Parameters \u00b6 cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiClassMetric"},{"location":"api/metrics/base/MultiClassMetric/#multiclassmetric","text":"Mother class for all multi-class classification metrics.","title":"MultiClassMetric"},{"location":"api/metrics/base/MultiClassMetric/#parameters","text":"cm ( river.metrics.confusion.ConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/base/MultiClassMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels Indicates if labels are required, rather than probabilities. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/base/MultiClassMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/base/RegressionMetric/","text":"RegressionMetric \u00b6 Mother class for all regression metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"RegressionMetric"},{"location":"api/metrics/base/RegressionMetric/#regressionmetric","text":"Mother class for all regression metrics.","title":"RegressionMetric"},{"location":"api/metrics/base/RegressionMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/base/RegressionMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( numbers.Number ) y_pred ( numbers.Number ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/base/WrapperMetric/","text":"WrapperMetric \u00b6 Mother class for all metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"WrapperMetric"},{"location":"api/metrics/base/WrapperMetric/#wrappermetric","text":"Mother class for all metrics.","title":"WrapperMetric"},{"location":"api/metrics/base/WrapperMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/base/WrapperMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight update Update the metric. Parameters y_true y_pred sample_weight works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/multioutput/ExactMatch/","text":"ExactMatch \u00b6 Exact match score. This is the most strict multi-label metric, defined as the number of samples that have all their labels correctly classified, divided by the total number of samples. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Examples \u00b6 >>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . multioutput . ExactMatch () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExactMatch : 33.33 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"ExactMatch"},{"location":"api/metrics/multioutput/ExactMatch/#exactmatch","text":"Exact match score. This is the most strict multi-label metric, defined as the number of samples that have all their labels correctly classified, divided by the total number of samples.","title":"ExactMatch"},{"location":"api/metrics/multioutput/ExactMatch/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/multioutput/ExactMatch/#examples","text":">>> from river import metrics >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False }, ... { 0 : True , 1 : True , 2 : False }, ... ] >>> metric = metrics . multioutput . ExactMatch () >>> for yt , yp in zip ( y_true , y_pred ): ... metric = metric . update ( yt , yp ) >>> metric ExactMatch : 33.33 %","title":"Examples"},{"location":"api/metrics/multioutput/ExactMatch/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model","title":"Methods"},{"location":"api/metrics/multioutput/MacroAverage/","text":"MacroAverage \u00b6 Macro-average wrapper. A copy of the provided metric is made for each output. The arithmetic average of all the metrics is returned. Parameters \u00b6 metric A classification or a regression metric. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MacroAverage"},{"location":"api/metrics/multioutput/MacroAverage/#macroaverage","text":"Macro-average wrapper. A copy of the provided metric is made for each output. The arithmetic average of all the metrics is returned.","title":"MacroAverage"},{"location":"api/metrics/multioutput/MacroAverage/#parameters","text":"metric A classification or a regression metric.","title":"Parameters"},{"location":"api/metrics/multioutput/MacroAverage/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/multioutput/MacroAverage/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/multioutput/MicroAverage/","text":"MicroAverage \u00b6 Micro-average wrapper. The provided metric is updated with the value of each output. Parameters \u00b6 metric A classification or a regression metric. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MicroAverage"},{"location":"api/metrics/multioutput/MicroAverage/#microaverage","text":"Micro-average wrapper. The provided metric is updated with the value of each output.","title":"MicroAverage"},{"location":"api/metrics/multioutput/MicroAverage/#parameters","text":"metric A classification or a regression metric.","title":"Parameters"},{"location":"api/metrics/multioutput/MicroAverage/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/multioutput/MicroAverage/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/","text":"MultiLabelConfusionMatrix \u00b6 Multi-label confusion matrix. Under the hood, this stores one metrics.ConfusionMatrix for each output. Examples \u00b6 >>> from river import metrics >>> cm = metrics . multioutput . MultiLabelConfusionMatrix () >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False } ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False } ... ] >>> for yt , yp in zip ( y_true , y_pred ): ... cm = cm . update ( yt , yp ) >>> cm 0 False True False 0 1 True 0 1 < BLANKLINE > 1 False True False 0 0 True 1 1 < BLANKLINE > 2 False True False 1 0 True 0 1 Methods \u00b6 revert update","title":"MultiLabelConfusionMatrix"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/#multilabelconfusionmatrix","text":"Multi-label confusion matrix. Under the hood, this stores one metrics.ConfusionMatrix for each output.","title":"MultiLabelConfusionMatrix"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/#examples","text":">>> from river import metrics >>> cm = metrics . multioutput . MultiLabelConfusionMatrix () >>> y_true = [ ... { 0 : False , 1 : True , 2 : True }, ... { 0 : True , 1 : True , 2 : False } ... ] >>> y_pred = [ ... { 0 : True , 1 : True , 2 : True }, ... { 0 : True , 1 : False , 2 : False } ... ] >>> for yt , yp in zip ( y_true , y_pred ): ... cm = cm . update ( yt , yp ) >>> cm 0 False True False 0 1 True 0 1 < BLANKLINE > 1 False True False 0 0 True 1 1 < BLANKLINE > 2 False True False 1 0 True 0 1","title":"Examples"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/#methods","text":"revert update","title":"Methods"},{"location":"api/metrics/multioutput/PerOutput/","text":"PerOutput \u00b6 Per-output wrapper. A copy of the metric is maintained for each output. Parameters \u00b6 metric A classification or a regression metric. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"PerOutput"},{"location":"api/metrics/multioutput/PerOutput/#peroutput","text":"Per-output wrapper. A copy of the metric is maintained for each output.","title":"PerOutput"},{"location":"api/metrics/multioutput/PerOutput/#parameters","text":"metric A classification or a regression metric.","title":"Parameters"},{"location":"api/metrics/multioutput/PerOutput/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. metric Gives access to the wrapped metric. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/multioutput/PerOutput/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 update Update the metric. Parameters y_true y_pred sample_weight \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/","text":"MultiOutputClassificationMetric \u00b6 Mother class for all multi-output classification metrics. Parameters \u00b6 cm ( river.metrics.multioutput.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiOutputClassificationMetric"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#multioutputclassificationmetric","text":"Mother class for all multi-output classification metrics.","title":"MultiOutputClassificationMetric"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#parameters","text":"cm ( river.metrics.multioutput.confusion.MultiLabelConfusionMatrix ) \u2013 defaults to None This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.","title":"Parameters"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. requires_labels works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 correction \u2013 defaults to None update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[bool, str, int]] ) y_pred ( Union[Dict[Union[str, int], Union[bool, str, int]], Dict[Union[str, int], Dict[Union[bool, str, int], float]]] ) sample_weight ( numbers.Number ) \u2013 defaults to 1.0 works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/","text":"MultiOutputRegressionMetric \u00b6 Mother class for all multi-output regression metrics. Attributes \u00b6 bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"MultiOutputRegressionMetric"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/#multioutputregressionmetric","text":"Mother class for all multi-output regression metrics.","title":"MultiOutputRegressionMetric"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/#attributes","text":"bigger_is_better Indicate if a high value is better than a low one or not. works_with_weights Indicate whether the model takes into consideration the effect of sample weights","title":"Attributes"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the metric. is_better_than revert Revert the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) update Update the metric. Parameters y_true ( Dict[Union[str, int], Union[float, int]] ) y_pred ( Dict[Union[str, int], Union[float, int]] ) sample_weight ( numbers.Number ) works_with Indicates whether or not a metric can work with a given model. Parameters model ( river.base.estimator.Estimator )","title":"Methods"},{"location":"api/misc/CovMatrix/","text":"CovMatrix \u00b6 Sample covariance matrix. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. Examples \u00b6 >>> import numpy as np >>> import pandas as pd >>> from river import misc >>> np . random . seed ( 42 ) >>> X = pd . DataFrame ( np . random . random (( 8 , 3 )), columns = [ \"red\" , \"green\" , \"blue\" ]) >>> X red green blue 0 0.374540 0.950714 0.731994 1 0.598658 0.156019 0.155995 2 0.058084 0.866176 0.601115 3 0.708073 0.020584 0.969910 4 0.832443 0.212339 0.181825 5 0.183405 0.304242 0.524756 6 0.431945 0.291229 0.611853 7 0.139494 0.292145 0.366362 >>> cov = misc . CovMatrix () >>> for x in X . to_dict ( orient = \"records\" ): ... cov = cov . update ( x ) >>> cov blue green red blue 0.076 0.020 - 0.010 green 0.020 0.113 - 0.053 red - 0.010 - 0.053 0.079 There is also an update_many method to process mini-batches. The results are identical. >>> cov = misc . CovMatrix () >>> cov = cov . update_many ( X ) >>> cov blue green red blue 0.076 0.020 - 0.010 green 0.020 0.113 - 0.053 red - 0.010 - 0.053 0.079 The covariances are stored in a dictionary, meaning any one of them can be accessed as such: >>> cov [ \"blue\" , \"green\" ] Cov : 0.020292 Diagonal entries are variances: >>> cov [ \"blue\" , \"blue\" ] Var : 0.076119 Methods \u00b6 clear D.clear() -> None. Remove all items from D. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update Update with a single sample. Parameters x ( dict ) update_many Update with many samples. Parameters X ( pandas.core.frame.DataFrame ) values D.values() -> an object providing a view on D's values","title":"CovMatrix"},{"location":"api/misc/CovMatrix/#covmatrix","text":"Sample covariance matrix.","title":"CovMatrix"},{"location":"api/misc/CovMatrix/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/misc/CovMatrix/#examples","text":">>> import numpy as np >>> import pandas as pd >>> from river import misc >>> np . random . seed ( 42 ) >>> X = pd . DataFrame ( np . random . random (( 8 , 3 )), columns = [ \"red\" , \"green\" , \"blue\" ]) >>> X red green blue 0 0.374540 0.950714 0.731994 1 0.598658 0.156019 0.155995 2 0.058084 0.866176 0.601115 3 0.708073 0.020584 0.969910 4 0.832443 0.212339 0.181825 5 0.183405 0.304242 0.524756 6 0.431945 0.291229 0.611853 7 0.139494 0.292145 0.366362 >>> cov = misc . CovMatrix () >>> for x in X . to_dict ( orient = \"records\" ): ... cov = cov . update ( x ) >>> cov blue green red blue 0.076 0.020 - 0.010 green 0.020 0.113 - 0.053 red - 0.010 - 0.053 0.079 There is also an update_many method to process mini-batches. The results are identical. >>> cov = misc . CovMatrix () >>> cov = cov . update_many ( X ) >>> cov blue green red blue 0.076 0.020 - 0.010 green 0.020 0.113 - 0.053 red - 0.010 - 0.053 0.079 The covariances are stored in a dictionary, meaning any one of them can be accessed as such: >>> cov [ \"blue\" , \"green\" ] Cov : 0.020292 Diagonal entries are variances: >>> cov [ \"blue\" , \"blue\" ] Var : 0.076119","title":"Examples"},{"location":"api/misc/CovMatrix/#methods","text":"clear D.clear() -> None. Remove all items from D. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update Update with a single sample. Parameters x ( dict ) update_many Update with many samples. Parameters X ( pandas.core.frame.DataFrame ) values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/misc/Histogram/","text":"Histogram \u00b6 Streaming histogram. Parameters \u00b6 max_bins \u2013 defaults to 256 Maximal number of bins. Attributes \u00b6 n Total number of seen values. Examples \u00b6 >>> from river import misc >>> import matplotlib.pyplot as plt >>> import numpy as np >>> np . random . seed ( 42 ) >>> values = np . hstack (( ... np . random . normal ( - 3 , 1 , 1000 ), ... np . random . normal ( 3 , 1 , 1000 ), ... )) >>> hist = misc . Histogram ( max_bins = 60 ) >>> for x in values : ... hist = hist . update ( x ) >>> ax = plt . bar ( ... x = [( b . left + b . right ) / 2 for b in hist ], ... height = [ b . count for b in hist ], ... width = [( b . right - b . left ) / 2 for b in hist ] ... ) .. image:: ../../docs/img/histogram_docstring.svg :align: center Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item cdf Cumulative distribution function. Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item iter_cdf Yields CDF values for a sorted iterable of values. This is faster than calling cdf with many values. Parameters X verbose \u2013 defaults to False pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update References \u00b6 Ben-Haim, Y. and Tom-Tov, E., 2010. A streaming parallel decision tree algorithm. Journal of Machine Learning Research, 11(Feb), pp.849-872. \u21a9 Go implementation \u21a9","title":"Histogram"},{"location":"api/misc/Histogram/#histogram","text":"Streaming histogram.","title":"Histogram"},{"location":"api/misc/Histogram/#parameters","text":"max_bins \u2013 defaults to 256 Maximal number of bins.","title":"Parameters"},{"location":"api/misc/Histogram/#attributes","text":"n Total number of seen values.","title":"Attributes"},{"location":"api/misc/Histogram/#examples","text":">>> from river import misc >>> import matplotlib.pyplot as plt >>> import numpy as np >>> np . random . seed ( 42 ) >>> values = np . hstack (( ... np . random . normal ( - 3 , 1 , 1000 ), ... np . random . normal ( 3 , 1 , 1000 ), ... )) >>> hist = misc . Histogram ( max_bins = 60 ) >>> for x in values : ... hist = hist . update ( x ) >>> ax = plt . bar ( ... x = [( b . left + b . right ) / 2 for b in hist ], ... height = [ b . count for b in hist ], ... width = [( b . right - b . left ) / 2 for b in hist ] ... ) .. image:: ../../docs/img/histogram_docstring.svg :align: center","title":"Examples"},{"location":"api/misc/Histogram/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item cdf Cumulative distribution function. Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item iter_cdf Yields CDF values for a sorted iterable of values. This is faster than calling cdf with many values. Parameters X verbose \u2013 defaults to False pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update","title":"Methods"},{"location":"api/misc/Histogram/#references","text":"Ben-Haim, Y. and Tom-Tov, E., 2010. A streaming parallel decision tree algorithm. Journal of Machine Learning Research, 11(Feb), pp.849-872. \u21a9 Go implementation \u21a9","title":"References"},{"location":"api/misc/SDFT/","text":"SDFT \u00b6 Sliding Discrete Fourier Transform (SDFT). Initially, the coefficients are all equal to 0, up until enough values have been seen. A call to numpy.fft.fft is triggered once window_size values have been seen. Subsequent values will update the coefficients online. This is much faster than recomputing an FFT from scratch for every new value. Parameters \u00b6 window_size The size of the window. Attributes \u00b6 window_size Examples \u00b6 >>> import numpy as np >>> from river import misc >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> window_size = 5 >>> sdft = misc . SDFT ( window_size ) >>> for i , x in enumerate ( X ): ... sdft = sdft . update ( x ) ... ... if i + 1 >= window_size : ... assert np . allclose ( sdft . coefficients , np . fft . fft ( X [ i + 1 - window_size : i + 1 ])) Methods \u00b6 update References \u00b6 Jacobsen, E. and Lyons, R., 2003. The sliding DFT. IEEE Signal Processing Magazine, 20(2), pp.74-80. <https://www.comm.utoronto.ca/~dimitris/ece431/slidingdft.pdf> _ \u21a9 Understanding and Implementing the Sliding DFT <https://www.dsprelated.com/showarticle/776.php> _ \u21a9","title":"SDFT"},{"location":"api/misc/SDFT/#sdft","text":"Sliding Discrete Fourier Transform (SDFT). Initially, the coefficients are all equal to 0, up until enough values have been seen. A call to numpy.fft.fft is triggered once window_size values have been seen. Subsequent values will update the coefficients online. This is much faster than recomputing an FFT from scratch for every new value.","title":"SDFT"},{"location":"api/misc/SDFT/#parameters","text":"window_size The size of the window.","title":"Parameters"},{"location":"api/misc/SDFT/#attributes","text":"window_size","title":"Attributes"},{"location":"api/misc/SDFT/#examples","text":">>> import numpy as np >>> from river import misc >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> window_size = 5 >>> sdft = misc . SDFT ( window_size ) >>> for i , x in enumerate ( X ): ... sdft = sdft . update ( x ) ... ... if i + 1 >= window_size : ... assert np . allclose ( sdft . coefficients , np . fft . fft ( X [ i + 1 - window_size : i + 1 ]))","title":"Examples"},{"location":"api/misc/SDFT/#methods","text":"update","title":"Methods"},{"location":"api/misc/SDFT/#references","text":"Jacobsen, E. and Lyons, R., 2003. The sliding DFT. IEEE Signal Processing Magazine, 20(2), pp.74-80. <https://www.comm.utoronto.ca/~dimitris/ece431/slidingdft.pdf> _ \u21a9 Understanding and Implementing the Sliding DFT <https://www.dsprelated.com/showarticle/776.php> _ \u21a9","title":"References"},{"location":"api/misc/Skyline/","text":"Skyline \u00b6 A skyline is set of points which is not dominated by any other point. This implementation uses a block nested loop. Identical observations are all part of the skyline if applicable. Parameters \u00b6 minimize ( list ) \u2013 defaults to None A list of features for which the values need to be minimized. Can be omitted as long as maximize is specified. maximize ( list ) \u2013 defaults to None A list of features for which the values need to be maximized. Can be omitted as long as minimize is specified. Examples \u00b6 Here is an example taken from this blog post. >>> import random >>> from river import misc >>> import matplotlib.pyplot as plt >>> city_prices = { ... 'Bordeaux' : 4045 , ... 'Lyon' : 4547 , ... 'Toulouse' : 3278 ... } >>> def random_house (): ... city = random . choice ([ 'Bordeaux' , 'Lyon' , 'Toulouse' ]) ... size = round ( random . gauss ( 200 , 50 )) ... price = round ( random . uniform ( 0.8 , 1.2 ) * city_prices [ city ] * size ) ... return { 'city' : city , 'size' : size , 'price' : price } >>> skyline = misc . Skyline ( minimize = [ 'price' ], maximize = [ 'size' ]) >>> random . seed ( 42 ) >>> for _ in range ( 100 ): ... house = random_house () ... skyline = skyline . update ( house ) >>> print ( len ( skyline )) 13 >>> print ( skyline [ 0 ]) { 'city' : 'Toulouse' , 'size' : 280 , 'price' : 763202 } >>> fig , ax = plt . subplots () >>> scatter = ax . scatter ( ... x = [ h [ 'size' ] for h in skyline ], ... y = [ h [ 'price' ] for h in skyline ] ... ) >>> grid = ax . grid () >>> title = ax . set_title ( 'Houses skyline' ) >>> xlabel = ax . set_xlabel ( 'Size' ) >>> ylabel = ax . set_ylabel ( 'Price' ) .. image:: ../../docs/img/skyline_docstring.svg :align: center Here is another example using the kart data from Mario Kart: Double Dash!! . >>> import collections >>> from river import misc >>> Kart = collections . namedtuple ( ... 'Kart' , ... 'name speed off_road acceleration weight turbo' ... ) >>> karts = [ ... Kart ( 'Red Fire' , 5 , 4 , 4 , 5 , 2 ), ... Kart ( 'Green Fire' , 7 , 3 , 3 , 4 , 2 ), ... Kart ( 'Heart Coach' , 4 , 6 , 6 , 5 , 2 ), ... Kart ( 'Bloom Coach' , 6 , 4 , 5 , 3 , 2 ), ... Kart ( 'Turbo Yoshi' , 4 , 5 , 6 , 6 , 2 ), ... Kart ( 'Turbo Birdo' , 6 , 4 , 4 , 7 , 2 ), ... Kart ( 'Goo-Goo Buggy' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Rattle Buggy' , 2 , 9 , 8 , 2 , 3 ), ... Kart ( 'Toad Kart' , 3 , 9 , 7 , 2 , 3 ), ... Kart ( 'Toadette Kart' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Koopa Dasher' , 2 , 8 , 8 , 3 , 3 ), ... Kart ( 'Para-Wing' , 1 , 8 , 9 , 3 , 3 ), ... Kart ( 'DK Jumbo' , 8 , 2 , 2 , 8 , 1 ), ... Kart ( 'Barrel Train' , 8 , 7 , 3 , 5 , 3 ), ... Kart ( 'Koopa King' , 9 , 1 , 1 , 9 , 1 ), ... Kart ( 'Bullet Blaster' , 8 , 1 , 4 , 1 , 3 ), ... Kart ( 'Wario Car' , 7 , 3 , 3 , 7 , 1 ), ... Kart ( 'Waluigi Racer' , 5 , 9 , 5 , 6 , 2 ), ... Kart ( 'Piranha Pipes' , 8 , 7 , 2 , 9 , 1 ), ... Kart ( 'Boo Pipes' , 2 , 9 , 8 , 9 , 1 ), ... Kart ( 'Parade Kart' , 7 , 3 , 4 , 7 , 3 ) ... ] >>> skyline = misc . Skyline ( ... maximize = [ 'speed' , 'off_road' , 'acceleration' , 'turbo' ], ... minimize = [ 'weight' ] ... ) >>> for kart in karts : ... skyline = skyline . update ( kart . _asdict ()) >>> best_cart_names = [ kart [ 'name' ] for kart in skyline ] >>> for name in best_cart_names : ... print ( f '- { name } ' ) - Green Fire - Heart Coach - Bloom Coach - Goo - Goo Buggy - Rattle Buggy - Toad Kart - Toadette Kart - Barrel Train - Koopa King - Bullet Blaster - Waluigi Racer - Parade Kart >>> for name in sorted ( set ( kart . name for kart in karts ) - set ( best_cart_names )): ... print ( f '- { name } ' ) - Boo Pipes - DK Jumbo - Koopa Dasher - Para - Wing - Piranha Pipes - Red Fire - Turbo Birdo - Turbo Yoshi - Wario Car Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update References \u00b6 Skyline queries in Python \u21a9 Borzsony, S., Kossmann, D. and Stocker, K., 2001, April. The skyline operator. In Proceedings 17th international conference on data engineering (pp. 421-430). IEEE. \u21a9 Tao, Y. and Papadias, D., 2006. Maintaining sliding window skylines on data streams. IEEE Transactions on Knowledge and Data Engineering, 18(3), pp.377-391. \u21a9","title":"Skyline"},{"location":"api/misc/Skyline/#skyline","text":"A skyline is set of points which is not dominated by any other point. This implementation uses a block nested loop. Identical observations are all part of the skyline if applicable.","title":"Skyline"},{"location":"api/misc/Skyline/#parameters","text":"minimize ( list ) \u2013 defaults to None A list of features for which the values need to be minimized. Can be omitted as long as maximize is specified. maximize ( list ) \u2013 defaults to None A list of features for which the values need to be maximized. Can be omitted as long as minimize is specified.","title":"Parameters"},{"location":"api/misc/Skyline/#examples","text":"Here is an example taken from this blog post. >>> import random >>> from river import misc >>> import matplotlib.pyplot as plt >>> city_prices = { ... 'Bordeaux' : 4045 , ... 'Lyon' : 4547 , ... 'Toulouse' : 3278 ... } >>> def random_house (): ... city = random . choice ([ 'Bordeaux' , 'Lyon' , 'Toulouse' ]) ... size = round ( random . gauss ( 200 , 50 )) ... price = round ( random . uniform ( 0.8 , 1.2 ) * city_prices [ city ] * size ) ... return { 'city' : city , 'size' : size , 'price' : price } >>> skyline = misc . Skyline ( minimize = [ 'price' ], maximize = [ 'size' ]) >>> random . seed ( 42 ) >>> for _ in range ( 100 ): ... house = random_house () ... skyline = skyline . update ( house ) >>> print ( len ( skyline )) 13 >>> print ( skyline [ 0 ]) { 'city' : 'Toulouse' , 'size' : 280 , 'price' : 763202 } >>> fig , ax = plt . subplots () >>> scatter = ax . scatter ( ... x = [ h [ 'size' ] for h in skyline ], ... y = [ h [ 'price' ] for h in skyline ] ... ) >>> grid = ax . grid () >>> title = ax . set_title ( 'Houses skyline' ) >>> xlabel = ax . set_xlabel ( 'Size' ) >>> ylabel = ax . set_ylabel ( 'Price' ) .. image:: ../../docs/img/skyline_docstring.svg :align: center Here is another example using the kart data from Mario Kart: Double Dash!! . >>> import collections >>> from river import misc >>> Kart = collections . namedtuple ( ... 'Kart' , ... 'name speed off_road acceleration weight turbo' ... ) >>> karts = [ ... Kart ( 'Red Fire' , 5 , 4 , 4 , 5 , 2 ), ... Kart ( 'Green Fire' , 7 , 3 , 3 , 4 , 2 ), ... Kart ( 'Heart Coach' , 4 , 6 , 6 , 5 , 2 ), ... Kart ( 'Bloom Coach' , 6 , 4 , 5 , 3 , 2 ), ... Kart ( 'Turbo Yoshi' , 4 , 5 , 6 , 6 , 2 ), ... Kart ( 'Turbo Birdo' , 6 , 4 , 4 , 7 , 2 ), ... Kart ( 'Goo-Goo Buggy' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Rattle Buggy' , 2 , 9 , 8 , 2 , 3 ), ... Kart ( 'Toad Kart' , 3 , 9 , 7 , 2 , 3 ), ... Kart ( 'Toadette Kart' , 1 , 9 , 9 , 2 , 3 ), ... Kart ( 'Koopa Dasher' , 2 , 8 , 8 , 3 , 3 ), ... Kart ( 'Para-Wing' , 1 , 8 , 9 , 3 , 3 ), ... Kart ( 'DK Jumbo' , 8 , 2 , 2 , 8 , 1 ), ... Kart ( 'Barrel Train' , 8 , 7 , 3 , 5 , 3 ), ... Kart ( 'Koopa King' , 9 , 1 , 1 , 9 , 1 ), ... Kart ( 'Bullet Blaster' , 8 , 1 , 4 , 1 , 3 ), ... Kart ( 'Wario Car' , 7 , 3 , 3 , 7 , 1 ), ... Kart ( 'Waluigi Racer' , 5 , 9 , 5 , 6 , 2 ), ... Kart ( 'Piranha Pipes' , 8 , 7 , 2 , 9 , 1 ), ... Kart ( 'Boo Pipes' , 2 , 9 , 8 , 9 , 1 ), ... Kart ( 'Parade Kart' , 7 , 3 , 4 , 7 , 3 ) ... ] >>> skyline = misc . Skyline ( ... maximize = [ 'speed' , 'off_road' , 'acceleration' , 'turbo' ], ... minimize = [ 'weight' ] ... ) >>> for kart in karts : ... skyline = skyline . update ( kart . _asdict ()) >>> best_cart_names = [ kart [ 'name' ] for kart in skyline ] >>> for name in best_cart_names : ... print ( f '- { name } ' ) - Green Fire - Heart Coach - Bloom Coach - Goo - Goo Buggy - Rattle Buggy - Toad Kart - Toadette Kart - Barrel Train - Koopa King - Bullet Blaster - Waluigi Racer - Parade Kart >>> for name in sorted ( set ( kart . name for kart in karts ) - set ( best_cart_names )): ... print ( f '- { name } ' ) - Boo Pipes - DK Jumbo - Koopa Dasher - Para - Wing - Piranha Pipes - Red Fire - Turbo Birdo - Turbo Yoshi - Wario Car","title":"Examples"},{"location":"api/misc/Skyline/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort update","title":"Methods"},{"location":"api/misc/Skyline/#references","text":"Skyline queries in Python \u21a9 Borzsony, S., Kossmann, D. and Stocker, K., 2001, April. The skyline operator. In Proceedings 17th international conference on data engineering (pp. 421-430). IEEE. \u21a9 Tao, Y. and Papadias, D., 2006. Maintaining sliding window skylines on data streams. IEEE Transactions on Knowledge and Data Engineering, 18(3), pp.377-391. \u21a9","title":"References"},{"location":"api/model-selection/EpsilonGreedyRegressor/","text":"EpsilonGreedyRegressor \u00b6 Model selection based on the \\(\\eps\\) -greedy bandit strategy. Performs model selection by using an \\(\\eps\\) -greedy bandit strategy. A model is selected for each learning step. The best model is selected (1 - \\(\\eps\\) %) of the time. Selection bias is a common problem when using bandits for online model selection. This bias can be mitigated by using a burn-in phase. Each model is given the chance to learn during the first burn_in steps. Parameters \u00b6 models The models to choose from. metric \u2013 defaults to None The metric that is used to compare models with each other. Defaults to metrics.MAE . epsilon \u2013 defaults to 0.1 The fraction of time exploration is performed rather than exploitation. decay \u2013 defaults to 0.0 Exponential factor at which epsilon decays. burn_in \u2013 defaults to 100 The number of initial steps during which each model is updated. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 best_model The current best model. burn_in decay epsilon models seed Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import model_selection >>> from river import optim >>> from river import preprocessing >>> models = [ ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... for lr in [ 0.0001 , 0.001 , 1e-05 , 0.01 ] ... ] >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... model_selection . EpsilonGreedyRegressor ( ... models , ... epsilon = 0.1 , ... decay = 0.001 , ... burn_in = 100 , ... seed = 1 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.363516 >>> model [ 'EpsilonGreedyRegressor' ] . bandit Ranking MAE Pulls Share #2 15.850129 111 8.53% #1 13.060601 117 8.99% #3 16.519079 109 8.38% #0 1.387839 964 74.10% >>> model [ 'EpsilonGreedyRegressor' ] . best_model LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 \u03b5-Greedy Algorithm - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9","title":"EpsilonGreedyRegressor"},{"location":"api/model-selection/EpsilonGreedyRegressor/#epsilongreedyregressor","text":"Model selection based on the \\(\\eps\\) -greedy bandit strategy. Performs model selection by using an \\(\\eps\\) -greedy bandit strategy. A model is selected for each learning step. The best model is selected (1 - \\(\\eps\\) %) of the time. Selection bias is a common problem when using bandits for online model selection. This bias can be mitigated by using a burn-in phase. Each model is given the chance to learn during the first burn_in steps.","title":"EpsilonGreedyRegressor"},{"location":"api/model-selection/EpsilonGreedyRegressor/#parameters","text":"models The models to choose from. metric \u2013 defaults to None The metric that is used to compare models with each other. Defaults to metrics.MAE . epsilon \u2013 defaults to 0.1 The fraction of time exploration is performed rather than exploitation. decay \u2013 defaults to 0.0 Exponential factor at which epsilon decays. burn_in \u2013 defaults to 100 The number of initial steps during which each model is updated. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/model-selection/EpsilonGreedyRegressor/#attributes","text":"best_model The current best model. burn_in decay epsilon models seed","title":"Attributes"},{"location":"api/model-selection/EpsilonGreedyRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import model_selection >>> from river import optim >>> from river import preprocessing >>> models = [ ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... for lr in [ 0.0001 , 0.001 , 1e-05 , 0.01 ] ... ] >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... model_selection . EpsilonGreedyRegressor ( ... models , ... epsilon = 0.1 , ... decay = 0.001 , ... burn_in = 100 , ... seed = 1 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.363516 >>> model [ 'EpsilonGreedyRegressor' ] . bandit Ranking MAE Pulls Share #2 15.850129 111 8.53% #1 13.060601 117 8.99% #3 16.519079 109 8.38% #0 1.387839 964 74.10% >>> model [ 'EpsilonGreedyRegressor' ] . best_model LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () )","title":"Examples"},{"location":"api/model-selection/EpsilonGreedyRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/model-selection/EpsilonGreedyRegressor/#references","text":"\u03b5-Greedy Algorithm - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9","title":"References"},{"location":"api/model-selection/GreedyRegressor/","text":"GreedyRegressor \u00b6 Greedy selection regressor. This selection method simply updates each model at each time step. The current best model is used to make predictions. It's greedy in the sense that updating each model can be costly. On the other hand, bandit-like algorithms are more temperate in that only update a subset of the models at each step. Parameters \u00b6 models ( List[ base.Regressor ] ) The models to select from. metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to None The metric that is used to measure the performance of each model. Attributes \u00b6 best_model The current best model. models Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import model_selection >>> from river import optim >>> from river import preprocessing >>> models = [ ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... for lr in [ 1e-5 , 1e-4 , 1e-3 , 1e-2 ] ... ] >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> model = ( ... preprocessing . StandardScaler () | ... model_selection . GreedyRegressor ( models , metric ) ... ) >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.35 Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"GreedyRegressor"},{"location":"api/model-selection/GreedyRegressor/#greedyregressor","text":"Greedy selection regressor. This selection method simply updates each model at each time step. The current best model is used to make predictions. It's greedy in the sense that updating each model can be costly. On the other hand, bandit-like algorithms are more temperate in that only update a subset of the models at each step.","title":"GreedyRegressor"},{"location":"api/model-selection/GreedyRegressor/#parameters","text":"models ( List[ base.Regressor ] ) The models to select from. metric ( river.metrics.base.RegressionMetric ) \u2013 defaults to None The metric that is used to measure the performance of each model.","title":"Parameters"},{"location":"api/model-selection/GreedyRegressor/#attributes","text":"best_model The current best model. models","title":"Attributes"},{"location":"api/model-selection/GreedyRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import model_selection >>> from river import optim >>> from river import preprocessing >>> models = [ ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... for lr in [ 1e-5 , 1e-4 , 1e-3 , 1e-2 ] ... ] >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> model = ( ... preprocessing . StandardScaler () | ... model_selection . GreedyRegressor ( models , metric ) ... ) >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.35","title":"Examples"},{"location":"api/model-selection/GreedyRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/model-selection/SuccessiveHalvingClassifier/","text":"SuccessiveHalvingClassifier \u00b6 Successive halving algorithm for classification. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{(2n)}) \\times eta)\\] Parameters \u00b6 models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress. Attributes \u00b6 best_model The current best model. models Examples \u00b6 As an example, let's use successive halving to tune the optimizer of a logistic regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import utils >>> from river import optim >>> models = utils . expand_param_grid ( model , { ... 'LogisticRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 , .005 ]}), ... ( optim . Adam , { 'beta_1' : [ .01 , .001 ], 'lr' : [ .1 , .01 , .001 ]}), ... ( optim . Adam , { 'beta_1' : [ .1 ], 'lr' : [ .001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingClassifier . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import model_selection >>> sh = model_selection . SuccessiveHalvingClassifier ( ... models , ... metric = metrics . Accuracy (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingClassifier is also a classifier with a learn_one and a predict_proba_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = sh , ... metric = metrics . ROCAUC () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best Accuracy : 80.00 % [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best Accuracy : 84.00 % [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best Accuracy : 86.14 % [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best Accuracy : 84.80 % ROCAUC : 95.29 % We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler ( with_std = True ), LogisticRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.01 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Log ( weight_pos = 1. weight_neg = 1. ) l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) ) Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"SuccessiveHalvingClassifier"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#successivehalvingclassifier","text":"Successive halving algorithm for classification. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{(2n)}) \\times eta)\\]","title":"SuccessiveHalvingClassifier"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#parameters","text":"models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress.","title":"Parameters"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#attributes","text":"best_model The current best model. models","title":"Attributes"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#examples","text":"As an example, let's use successive halving to tune the optimizer of a logistic regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression () ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import utils >>> from river import optim >>> models = utils . expand_param_grid ( model , { ... 'LogisticRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 , .005 ]}), ... ( optim . Adam , { 'beta_1' : [ .01 , .001 ], 'lr' : [ .1 , .01 , .001 ]}), ... ( optim . Adam , { 'beta_1' : [ .1 ], 'lr' : [ .001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingClassifier . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import model_selection >>> sh = model_selection . SuccessiveHalvingClassifier ( ... models , ... metric = metrics . Accuracy (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingClassifier is also a classifier with a learn_one and a predict_proba_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . Phishing (), ... model = sh , ... metric = metrics . ROCAUC () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best Accuracy : 80.00 % [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best Accuracy : 84.00 % [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best Accuracy : 86.14 % [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best Accuracy : 84.80 % ROCAUC : 95.29 % We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler ( with_std = True ), LogisticRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.01 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Log ( weight_pos = 1. weight_neg = 1. ) l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) )","title":"Examples"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#references","text":"Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"References"},{"location":"api/model-selection/SuccessiveHalvingRegressor/","text":"SuccessiveHalvingRegressor \u00b6 Successive halving algorithm for regression. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{2n}) \\times eta)\\] Parameters \u00b6 models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress. Attributes \u00b6 best_model The current best model. models Examples \u00b6 As an example, let's use successive halving to tune the optimizer of a linear regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = .1 ) ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import optim >>> from river import utils >>> models = utils . expand_param_grid ( model , { ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 , .005 ]}), ... ( optim . Adam , { 'beta_1' : [ .01 , .001 ], 'lr' : [ .1 , .01 , .001 ]}), ... ( optim . Adam , { 'beta_1' : [ .1 ], 'lr' : [ .001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingRegressor . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import model_selection >>> sh = model_selection . SuccessiveHalvingRegressor ( ... models , ... metric = metrics . MAE (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingRegressor is also a regressor with a learn_one and a predict_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . TrumpApproval (), ... model = sh , ... metric = metrics . MAE () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best MAE : 4.540491 [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best MAE : 2.458765 [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best MAE : 1.583751 [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best MAE : 1.147296 MAE : 0.488387 We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler ( with_std = True ), LinearRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.1 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.1 ) clip_gradient = 1e+12 initializer = Zeros () ) ) Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"SuccessiveHalvingRegressor"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#successivehalvingregressor","text":"Successive halving algorithm for regression. Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most budget model updates will be performed in total. If you have k combinations of hyperparameters and that your dataset contains n observations, then the maximal budget you can allocate is: \\[\\frac{2kn}{eta}\\] It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. If you have a budget of B , and that your dataset contains n observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: \\[\\ceil(\\floor(\\frac{B}{2n}) \\times eta)\\]","title":"SuccessiveHalvingRegressor"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#parameters","text":"models The models to compare. metric ( river.metrics.base.Metric ) Metric used for comparing models with. budget ( int ) Total number of model updates you wish to allocate. eta \u2013 defaults to 2 Rate of elimination. At every rung, math.ceil(k / eta) models are kept, where k is the number of models that have reached the rung. A higher eta value will focus on less models but will allocate more iterations to the best models. verbose \u2013 defaults to False Whether to display progress or not. print_kwargs Extra keyword arguments are passed to the print function. For instance, this allows providing a file argument, which indicates where to output progress.","title":"Parameters"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#attributes","text":"best_model The current best model. models","title":"Attributes"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#examples","text":"As an example, let's use successive halving to tune the optimizer of a linear regression. We'll first define the model. >>> from river import linear_model >>> from river import preprocessing >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = .1 ) ... ) Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates. >>> from river import optim >>> from river import utils >>> models = utils . expand_param_grid ( model , { ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 , .005 ]}), ... ( optim . Adam , { 'beta_1' : [ .01 , .001 ], 'lr' : [ .1 , .01 , .001 ]}), ... ( optim . Adam , { 'beta_1' : [ .1 ], 'lr' : [ .001 ]}), ... ] ... } ... }) We can check how many models we've created. >>> len ( models ) 10 We can now pass these models to a SuccessiveHalvingRegressor . We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest. >>> from river import model_selection >>> sh = model_selection . SuccessiveHalvingRegressor ( ... models , ... metric = metrics . MAE (), ... budget = 2000 , ... eta = 2 , ... verbose = True ... ) A SuccessiveHalvingRegressor is also a regressor with a learn_one and a predict_one method. We can therefore evaluate it like any other classifier with evaluate.progressive_val_score . >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> evaluate . progressive_val_score ( ... dataset = datasets . TrumpApproval (), ... model = sh , ... metric = metrics . MAE () ... ) [ 1 ] 5 removed 5 left 50 iterations budget used : 500 budget left : 1500 best MAE : 4.540491 [ 2 ] 2 removed 3 left 100 iterations budget used : 1000 budget left : 1000 best MAE : 2.458765 [ 3 ] 1 removed 2 left 166 iterations budget used : 1498 budget left : 502 best MAE : 1.583751 [ 4 ] 1 removed 1 left 250 iterations budget used : 1998 budget left : 2 best MAE : 1.147296 MAE : 0.488387 We can now view the best model. >>> sh . best_model Pipeline ( StandardScaler ( with_std = True ), LinearRegression ( optimizer = Adam ( lr = Constant ( learning_rate = 0.1 ) beta_1 = 0.01 beta_2 = 0.999 eps = 1e-08 ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.1 ) clip_gradient = 1e+12 initializer = Zeros () ) )","title":"Examples"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#references","text":"Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9 Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9 Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9","title":"References"},{"location":"api/model-selection/UCBRegressor/","text":"UCBRegressor \u00b6 Model selection based on the UCB bandit strategy. Due to the nature of this algorithm, it's recommended to scale the target so that it exhibits sub-gaussian properties. This can be done by using a preprocessing.TargetStandardScaler . Parameters \u00b6 models The models to choose from. metric \u2013 defaults to None The metric that is used to compare models with each other. Defaults to metrics.MAE . delta \u2013 defaults to 1 Exploration parameter. burn_in \u2013 defaults to 100 The number of initial steps during which each model is updated. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Attributes \u00b6 best_model The current best model. burn_in delta models seed Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import model_selection >>> from river import optim >>> from river import preprocessing >>> models = [ ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... for lr in [ 0.0001 , 0.001 , 1e-05 , 0.01 ] ... ] >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... preprocessing . TargetStandardScaler ( ... model_selection . UCBRegressor ( ... models , ... delta = 1 , ... burn_in = 0 , ... seed = 42 ... ) ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.410815 >>> model [ 'TargetStandardScaler' ] . regressor . bandit Ranking MAE Pulls Share #3 1.441458 8 0.80% #1 0.291200 242 24.18% #2 0.808878 19 1.90% #0 0.204892 732 73.13% >>> model [ 'TargetStandardScaler' ] . regressor . best_model LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Lai, T. L., & Robbins, H. (1985). Asymptotically efficient adaptive allocation rules. Advances in applied mathematics, 6(1), 4-22. \u21a9 Upper Confidence Bounds - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9 The Upper Confidence Bound Algorithm - Bandit Algorithms \u21a9","title":"UCBRegressor"},{"location":"api/model-selection/UCBRegressor/#ucbregressor","text":"Model selection based on the UCB bandit strategy. Due to the nature of this algorithm, it's recommended to scale the target so that it exhibits sub-gaussian properties. This can be done by using a preprocessing.TargetStandardScaler .","title":"UCBRegressor"},{"location":"api/model-selection/UCBRegressor/#parameters","text":"models The models to choose from. metric \u2013 defaults to None The metric that is used to compare models with each other. Defaults to metrics.MAE . delta \u2013 defaults to 1 Exploration parameter. burn_in \u2013 defaults to 100 The number of initial steps during which each model is updated. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/model-selection/UCBRegressor/#attributes","text":"best_model The current best model. burn_in delta models seed","title":"Attributes"},{"location":"api/model-selection/UCBRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import model_selection >>> from river import optim >>> from river import preprocessing >>> models = [ ... linear_model . LinearRegression ( optimizer = optim . SGD ( lr = lr )) ... for lr in [ 0.0001 , 0.001 , 1e-05 , 0.01 ] ... ] >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... preprocessing . TargetStandardScaler ( ... model_selection . UCBRegressor ( ... models , ... delta = 1 , ... burn_in = 0 , ... seed = 42 ... ) ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.410815 >>> model [ 'TargetStandardScaler' ] . regressor . bandit Ranking MAE Pulls Share #3 1.441458 8 0.80% #1 0.291200 242 24.18% #2 0.808878 19 1.90% #0 0.204892 732 73.13% >>> model [ 'TargetStandardScaler' ] . regressor . best_model LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.01 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () )","title":"Examples"},{"location":"api/model-selection/UCBRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/model-selection/UCBRegressor/#references","text":"Lai, T. L., & Robbins, H. (1985). Asymptotically efficient adaptive allocation rules. Advances in applied mathematics, 6(1), 4-22. \u21a9 Upper Confidence Bounds - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9 The Upper Confidence Bound Algorithm - Bandit Algorithms \u21a9","title":"References"},{"location":"api/model-selection/base/ModelSelectionClassifier/","text":"ModelSelectionClassifier \u00b6 A model selector for classification. Parameters \u00b6 models ( Iterator[ base.Estimator ] ) metric ( river.metrics.base.Metric ) Attributes \u00b6 best_model The current best model. models Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"ModelSelectionClassifier"},{"location":"api/model-selection/base/ModelSelectionClassifier/#modelselectionclassifier","text":"A model selector for classification.","title":"ModelSelectionClassifier"},{"location":"api/model-selection/base/ModelSelectionClassifier/#parameters","text":"models ( Iterator[ base.Estimator ] ) metric ( river.metrics.base.Metric )","title":"Parameters"},{"location":"api/model-selection/base/ModelSelectionClassifier/#attributes","text":"best_model The current best model. models","title":"Attributes"},{"location":"api/model-selection/base/ModelSelectionClassifier/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) kwargs Returns Classifier : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/model-selection/base/ModelSelectionRegressor/","text":"ModelSelectionRegressor \u00b6 A model selector for regression. Parameters \u00b6 models ( Iterator[ base.Estimator ] ) metric ( river.metrics.base.Metric ) Attributes \u00b6 best_model The current best model. models Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"ModelSelectionRegressor"},{"location":"api/model-selection/base/ModelSelectionRegressor/#modelselectionregressor","text":"A model selector for regression.","title":"ModelSelectionRegressor"},{"location":"api/model-selection/base/ModelSelectionRegressor/#parameters","text":"models ( Iterator[ base.Estimator ] ) metric ( river.metrics.base.Metric )","title":"Parameters"},{"location":"api/model-selection/base/ModelSelectionRegressor/#attributes","text":"best_model The current best model. models","title":"Attributes"},{"location":"api/model-selection/base/ModelSelectionRegressor/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters item clear S.clear() -> None -- remove all items from S clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/multiclass/OneVsOneClassifier/","text":"OneVsOneClassifier \u00b6 One-vs-One (OvO) multiclass strategy. This strategy consists in fitting one binary classifier for each pair of classes. Because we are in a streaming context, the number of classes isn't known from the start, hence new classifiers are instantiated on the fly. The number of classifiers is k * (k - 1) / 2 , where k is the number of classes. However, each call to learn_one only requires training k - 1 models. Indeed, only the models that pertain to the given label have to be trained. Meanwhile, making a prediction requires going through each and every model. Parameters \u00b6 classifier A binary classifier, although a multi-class classifier will work too. Attributes \u00b6 classifiers ( dict ) A mapping between pairs of classes and classifiers. The keys are tuples which contain a pair of classes. Each pair is sorted in lexicographical order. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovo = multiclass . OneVsOneClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovo >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 80.76 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"OneVsOneClassifier"},{"location":"api/multiclass/OneVsOneClassifier/#onevsoneclassifier","text":"One-vs-One (OvO) multiclass strategy. This strategy consists in fitting one binary classifier for each pair of classes. Because we are in a streaming context, the number of classes isn't known from the start, hence new classifiers are instantiated on the fly. The number of classifiers is k * (k - 1) / 2 , where k is the number of classes. However, each call to learn_one only requires training k - 1 models. Indeed, only the models that pertain to the given label have to be trained. Meanwhile, making a prediction requires going through each and every model.","title":"OneVsOneClassifier"},{"location":"api/multiclass/OneVsOneClassifier/#parameters","text":"classifier A binary classifier, although a multi-class classifier will work too.","title":"Parameters"},{"location":"api/multiclass/OneVsOneClassifier/#attributes","text":"classifiers ( dict ) A mapping between pairs of classes and classifiers. The keys are tuples which contain a pair of classes. Each pair is sorted in lexicographical order.","title":"Attributes"},{"location":"api/multiclass/OneVsOneClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovo = multiclass . OneVsOneClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovo >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 80.76 %","title":"Examples"},{"location":"api/multiclass/OneVsOneClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/multiclass/OneVsRestClassifier/","text":"OneVsRestClassifier \u00b6 One-vs-the-rest (OvR) multiclass strategy. This strategy consists in fitting one binary classifier per class. Because we are in a streaming context, the number of classes isn't known from the start. Hence, new classifiers are instantiated on the fly. Likewise, the predicted probabilities will only include the classes seen up to a given point in time. Note that this classifier supports mini-batches as well as single instances. The computational complexity for both learning and predicting grows linearly with the number of classes. If you have a very large number of classes, then you might want to consider using an multiclass.OutputCodeClassifier instead. Parameters \u00b6 classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too. Attributes \u00b6 classifiers ( dict ) A mapping between classes and classifiers. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovr = multiclass . OneVsRestClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovr >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 77.46 % This estimator also also supports mini-batching. >>> for X in pd . read_csv ( dataset . path , chunksize = 64 ): ... y = X . pop ( 'category' ) ... y_pred = model . predict_many ( X ) ... model = model . learn_many ( X , y ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"OneVsRestClassifier"},{"location":"api/multiclass/OneVsRestClassifier/#onevsrestclassifier","text":"One-vs-the-rest (OvR) multiclass strategy. This strategy consists in fitting one binary classifier per class. Because we are in a streaming context, the number of classes isn't known from the start. Hence, new classifiers are instantiated on the fly. Likewise, the predicted probabilities will only include the classes seen up to a given point in time. Note that this classifier supports mini-batches as well as single instances. The computational complexity for both learning and predicting grows linearly with the number of classes. If you have a very large number of classes, then you might want to consider using an multiclass.OutputCodeClassifier instead.","title":"OneVsRestClassifier"},{"location":"api/multiclass/OneVsRestClassifier/#parameters","text":"classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too.","title":"Parameters"},{"location":"api/multiclass/OneVsRestClassifier/#attributes","text":"classifiers ( dict ) A mapping between classes and classifiers.","title":"Attributes"},{"location":"api/multiclass/OneVsRestClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ovr = multiclass . OneVsRestClassifier ( linear_model . LogisticRegression ()) >>> model = scaler | ovr >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 77.46 % This estimator also also supports mini-batching. >>> for X in pd . read_csv ( dataset . path , chunksize = 64 ): ... y = X . pop ( 'category' ) ... y_pred = model . predict_many ( X ) ... model = model . learn_many ( X , y )","title":"Examples"},{"location":"api/multiclass/OneVsRestClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_many predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/multiclass/OutputCodeClassifier/","text":"OutputCodeClassifier \u00b6 Output-code multiclass strategy. This also referred to as \"error-correcting output codes\". This class allows to learn a multi-class classification problem with a binary classifier. Each class is converted to a code of 0s and 1s. The length of the code is called the code size. A copy of the classifier made for code. The codes associated with the classes are stored in a code book. When a new sample arrives, the label's code is retrieved from the code book. Then, each classifier is trained on the relevant part of code, which is either a 0 or a 1. For predicting, each classifier outputs a probability. These are then compared to each code in the code book, and the label which is the \"closest\" is chosen as the most likely class. Closeness is determined in terms of Manhattan distance. One specificity of online learning is that we don't how many classes there are initially. Therefore, a random procedure generates random codes on the fly whenever a previously unseed label appears. Parameters \u00b6 classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too. code_size ( int ) The code size, which dictates how many copies of the provided classifiers to train. Must be strictly positive. seed ( int ) \u2013 defaults to None A random seed number that can be set for reproducibility. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ooc = OutputCodeClassifier ( ... classifier = linear_model . LogisticRegression (), ... code_size = 10 , ... seed = 24 ... ) >>> model = scaler | ooc >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 79.71 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. References \u00b6 Dietterich, T.G. and Bakiri, G., 1994. Solving multiclass learning problems via error-correcting output codes. Journal of artificial intelligence research, 2, pp.263-286. \u21a9 Allwein, E.L., Schapire, R.E. and Singer, Y., 2000. Reducing multiclass to binary: A unifying approach for margin classifiers. Journal of machine learning research, 1(Dec), pp.113-141. \u21a9","title":"OutputCodeClassifier"},{"location":"api/multiclass/OutputCodeClassifier/#outputcodeclassifier","text":"Output-code multiclass strategy. This also referred to as \"error-correcting output codes\". This class allows to learn a multi-class classification problem with a binary classifier. Each class is converted to a code of 0s and 1s. The length of the code is called the code size. A copy of the classifier made for code. The codes associated with the classes are stored in a code book. When a new sample arrives, the label's code is retrieved from the code book. Then, each classifier is trained on the relevant part of code, which is either a 0 or a 1. For predicting, each classifier outputs a probability. These are then compared to each code in the code book, and the label which is the \"closest\" is chosen as the most likely class. Closeness is determined in terms of Manhattan distance. One specificity of online learning is that we don't how many classes there are initially. Therefore, a random procedure generates random codes on the fly whenever a previously unseed label appears.","title":"OutputCodeClassifier"},{"location":"api/multiclass/OutputCodeClassifier/#parameters","text":"classifier ( base.Classifier ) A binary classifier, although a multi-class classifier will work too. code_size ( int ) The code size, which dictates how many copies of the provided classifiers to train. Must be strictly positive. seed ( int ) \u2013 defaults to None A random seed number that can be set for reproducibility.","title":"Parameters"},{"location":"api/multiclass/OutputCodeClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multiclass >>> from river import preprocessing >>> dataset = datasets . ImageSegments () >>> scaler = preprocessing . StandardScaler () >>> ooc = OutputCodeClassifier ( ... classifier = linear_model . LogisticRegression (), ... code_size = 10 , ... seed = 24 ... ) >>> model = scaler | ooc >>> metric = metrics . MacroF1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) MacroF1 : 79.71 %","title":"Examples"},{"location":"api/multiclass/OutputCodeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/multiclass/OutputCodeClassifier/#references","text":"Dietterich, T.G. and Bakiri, G., 1994. Solving multiclass learning problems via error-correcting output codes. Journal of artificial intelligence research, 2, pp.263-286. \u21a9 Allwein, E.L., Schapire, R.E. and Singer, Y., 2000. Reducing multiclass to binary: A unifying approach for margin classifiers. Journal of machine learning research, 1(Dec), pp.113-141. \u21a9","title":"References"},{"location":"api/multioutput/ClassifierChain/","text":"ClassifierChain \u00b6 A multi-output model that arranges classifiers into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second model. The prediction for the second output will be used as a feature for the third model, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs. Parameters \u00b6 model ( base.Classifier ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target. Examples \u00b6 >>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . fetch_openml ( 'yeast' , version = 4 , as_frame = False ), ... shuffle = True , ... seed = 42 ... ) >>> model = feature_selection . VarianceThreshold ( threshold = 0.01 ) >>> model |= preprocessing . StandardScaler () >>> model |= multioutput . ClassifierChain ( ... model = linear_model . LogisticRegression (), ... order = list ( range ( 14 )) ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Jaccard ()) >>> for x , y in dataset : ... # Convert y values to booleans ... y = { i : yi == 'TRUE' for i , yi in y . items ()} ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric MicroAverage ( Jaccard ): 41.95 % Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values References \u00b6 Multi-Output Chain Models and their Application in Data Streams \u21a9","title":"ClassifierChain"},{"location":"api/multioutput/ClassifierChain/#classifierchain","text":"A multi-output model that arranges classifiers into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second model. The prediction for the second output will be used as a feature for the third model, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.","title":"ClassifierChain"},{"location":"api/multioutput/ClassifierChain/#parameters","text":"model ( base.Classifier ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target.","title":"Parameters"},{"location":"api/multioutput/ClassifierChain/#examples","text":">>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . fetch_openml ( 'yeast' , version = 4 , as_frame = False ), ... shuffle = True , ... seed = 42 ... ) >>> model = feature_selection . VarianceThreshold ( threshold = 0.01 ) >>> model |= preprocessing . StandardScaler () >>> model |= multioutput . ClassifierChain ( ... model = linear_model . LogisticRegression (), ... order = list ( range ( 14 )) ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Jaccard ()) >>> for x , y in dataset : ... # Convert y values to booleans ... y = { i : yi == 'TRUE' for i , yi in y . items ()} ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric MicroAverage ( Jaccard ): 41.95 %","title":"Examples"},{"location":"api/multioutput/ClassifierChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/multioutput/ClassifierChain/#references","text":"Multi-Output Chain Models and their Application in Data Streams \u21a9","title":"References"},{"location":"api/multioutput/MonteCarloClassifierChain/","text":"MonteCarloClassifierChain \u00b6 Monte Carlo Sampling Classifier Chains. Probabilistic Classifier Chains using Monte Carlo sampling, as described in 1 . m samples are taken from the posterior distribution. Therefore we need a probabilistic interpretation of the output, and thus, this is a particular variety of ProbabilisticClassifierChain. Parameters \u00b6 model ( base.Classifier ) m ( int ) \u2013 defaults to 10 Number of samples to take from the posterior distribution. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility. Examples \u00b6 >>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . MonteCarloClassifierChain ( ... model = linear_model . LogisticRegression (), ... m = 10 , ... seed = 42 ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Jaccard ()) >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric MicroAverage ( Jaccard ): 54.75 % Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values References \u00b6 Read, J., Martino, L., & Luengo, D. (2014). Efficient monte carlo methods for multi-dimensional learning with classifier chains. Pattern Recognition, 47(3), 1535-1546. \u21a9","title":"MonteCarloClassifierChain"},{"location":"api/multioutput/MonteCarloClassifierChain/#montecarloclassifierchain","text":"Monte Carlo Sampling Classifier Chains. Probabilistic Classifier Chains using Monte Carlo sampling, as described in 1 . m samples are taken from the posterior distribution. Therefore we need a probabilistic interpretation of the output, and thus, this is a particular variety of ProbabilisticClassifierChain.","title":"MonteCarloClassifierChain"},{"location":"api/multioutput/MonteCarloClassifierChain/#parameters","text":"model ( base.Classifier ) m ( int ) \u2013 defaults to 10 Number of samples to take from the posterior distribution. seed ( int ) \u2013 defaults to None Random number generator seed for reproducibility.","title":"Parameters"},{"location":"api/multioutput/MonteCarloClassifierChain/#examples","text":">>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . MonteCarloClassifierChain ( ... model = linear_model . LogisticRegression (), ... m = 10 , ... seed = 42 ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Jaccard ()) >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric MicroAverage ( Jaccard ): 54.75 %","title":"Examples"},{"location":"api/multioutput/MonteCarloClassifierChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/multioutput/MonteCarloClassifierChain/#references","text":"Read, J., Martino, L., & Luengo, D. (2014). Efficient monte carlo methods for multi-dimensional learning with classifier chains. Pattern Recognition, 47(3), 1535-1546. \u21a9","title":"References"},{"location":"api/multioutput/ProbabilisticClassifierChain/","text":"ProbabilisticClassifierChain \u00b6 Probabilistic Classifier Chains. The Probabilistic Classifier Chains (PCC) 1 is a Bayes-optimal method based on the Classifier Chains (CC). Consider the concept of chaining classifiers as searching a path in a binary tree whose leaf nodes are associated with a label \\(y \\in Y\\) . While CC searches only a single path in the aforementioned binary tree, PCC looks at each of the \\(2^l\\) paths, where \\(l\\) is the number of labels. This limits the applicability of the method to data sets with a small to moderate number of labels. The authors recommend no more than about 15 labels for real-world applications. Parameters \u00b6 model ( base.Classifier ) Examples \u00b6 >>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . ProbabilisticClassifierChain ( ... model = linear_model . LogisticRegression () ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Jaccard ()) >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric MicroAverage ( Jaccard ): 54.83 % Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values References \u00b6 Cheng, W., H\u00fcllermeier, E., & Dembczynski, K. J. (2010). Bayes optimal multilabel classification via probabilistic classifier chains. In Proceedings of the 27th international conference on machine learning (ICML-10) (pp. 279-286). \u21a9","title":"ProbabilisticClassifierChain"},{"location":"api/multioutput/ProbabilisticClassifierChain/#probabilisticclassifierchain","text":"Probabilistic Classifier Chains. The Probabilistic Classifier Chains (PCC) 1 is a Bayes-optimal method based on the Classifier Chains (CC). Consider the concept of chaining classifiers as searching a path in a binary tree whose leaf nodes are associated with a label \\(y \\in Y\\) . While CC searches only a single path in the aforementioned binary tree, PCC looks at each of the \\(2^l\\) paths, where \\(l\\) is the number of labels. This limits the applicability of the method to data sets with a small to moderate number of labels. The authors recommend no more than about 15 labels for real-world applications.","title":"ProbabilisticClassifierChain"},{"location":"api/multioutput/ProbabilisticClassifierChain/#parameters","text":"model ( base.Classifier )","title":"Parameters"},{"location":"api/multioutput/ProbabilisticClassifierChain/#examples","text":">>> from river import feature_selection >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import synth >>> dataset = synth . Logical ( seed = 42 , n_tiles = 100 ) >>> model = multioutput . ProbabilisticClassifierChain ( ... model = linear_model . LogisticRegression () ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Jaccard ()) >>> for x , y in dataset : ... y_pred = model . predict_one ( x ) ... metric = metric . update ( y , y_pred ) ... model = model . learn_one ( x , y ) >>> metric MicroAverage ( Jaccard ): 54.83 %","title":"Examples"},{"location":"api/multioutput/ProbabilisticClassifierChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Update the model with a set of features x and a label y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predict the label of a set of features x . Parameters x Returns The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/multioutput/ProbabilisticClassifierChain/#references","text":"Cheng, W., H\u00fcllermeier, E., & Dembczynski, K. J. (2010). Bayes optimal multilabel classification via probabilistic classifier chains. In Proceedings of the 27th international conference on machine learning (ICML-10) (pp. 279-286). \u21a9","title":"References"},{"location":"api/multioutput/RegressorChain/","text":"RegressorChain \u00b6 A multi-output model that arranges regressor into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second output. The prediction for the second output will be used as a feature for the third, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs. Parameters \u00b6 model ( base.Regressor ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target. Examples \u00b6 >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_linnerud (), ... shuffle = True , ... seed = 42 ... ) >>> model = multioutput . RegressorChain ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = 0.3 ) ... ), ... order = [ 0 , 1 , 2 ] ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , model , metric ) MicroAverage ( MAE ): 12.649592 Methods \u00b6 clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"RegressorChain"},{"location":"api/multioutput/RegressorChain/#regressorchain","text":"A multi-output model that arranges regressor into a chain. This will create one model per output. The prediction of the first output will be used as a feature in the second output. The prediction for the second output will be used as a feature for the third, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.","title":"RegressorChain"},{"location":"api/multioutput/RegressorChain/#parameters","text":"model ( base.Regressor ) order ( list ) \u2013 defaults to None A list with the targets order in which to construct the chain. If None then the order will be inferred from the order of the keys in the target.","title":"Parameters"},{"location":"api/multioutput/RegressorChain/#examples","text":">>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import multioutput >>> from river import preprocessing >>> from river import stream >>> from sklearn import datasets >>> dataset = stream . iter_sklearn_dataset ( ... dataset = datasets . load_linnerud (), ... shuffle = True , ... seed = 42 ... ) >>> model = multioutput . RegressorChain ( ... model = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( intercept_lr = 0.3 ) ... ), ... order = [ 0 , 1 , 2 ] ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , model , metric ) MicroAverage ( MAE ): 12.649592","title":"Examples"},{"location":"api/multioutput/RegressorChain/#methods","text":"clear D.clear() -> None. Remove all items from D. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. copy fromkeys get D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Parameters key default \u2013 defaults to None items D.items() -> a set-like object providing a view on D's items keys D.keys() -> a set-like object providing a view on D's keys learn_one Fits to a set of features x and a real-valued target y . Parameters x y Returns self pop D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Parameters key default \u2013 defaults to <object object at 0x7f7e6a885150> popitem D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. predict_one Predicts the target value of a set of features x . Parameters x Returns The prediction. setdefault D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Parameters key default \u2013 defaults to None update D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Parameters other \u2013 defaults to () kwds values D.values() -> an object providing a view on D's values","title":"Methods"},{"location":"api/naive-bayes/BernoulliNB/","text":"BernoulliNB \u00b6 Bernoulli Naive Bayes. Bernoulli Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values. Parameters \u00b6 alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). true_threshold \u2013 defaults to 0.0 Threshold for binarizing (mapping to booleans) features. Attributes \u00b6 class_counts ( collections.Counter ) Number of times each class has been seen. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. Examples \u00b6 >>> import pandas as pd >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( \"Chinese Beijing Chinese\" , \"yes\" ), ... ( \"Chinese Chinese Shanghai\" , \"yes\" ), ... ( \"Chinese Macao\" , \"yes\" ), ... ( \"Tokyo Japan Chinese\" , \"no\" ) ... ] >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ \"nb\" ] . p_class ( \"yes\" ) 0.75 >>> model [ \"nb\" ] . p_class ( \"no\" ) 0.25 >>> model . predict_proba_one ( \"test\" ) { 'yes' : 0.8831539823829913 , 'no' : 0.11684601761700895 } >>> model . predict_one ( \"test\" ) 'yes' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> df_docs = pd . DataFrame ( docs , columns = [ \"docs\" , \"y\" ]) >>> X = pd . Series ([ ... \"Chinese Beijing Chinese\" , ... \"Chinese Chinese Shanghai\" , ... \"Chinese Macao\" , ... \"Tokyo Japan Chinese\" ... ]) >>> y = pd . Series ([ \"yes\" , \"yes\" , \"yes\" , \"no\" ]) >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> unseen = pd . Series ([ \"Taiwanese Taipei\" , \"Chinese Shanghai\" ]) >>> model . predict_proba_many ( unseen ) no yes 0 0.116846 0.883154 1 0.047269 0.952731 >>> model . predict_many ( unseen ) 0 yes 1 yes dtype : object Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Learn from a batch of count vectors. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns MiniBatchClassifier : self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict ) References \u00b6 The Bernoulli model \u21a9","title":"BernoulliNB"},{"location":"api/naive-bayes/BernoulliNB/#bernoullinb","text":"Bernoulli Naive Bayes. Bernoulli Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.","title":"BernoulliNB"},{"location":"api/naive-bayes/BernoulliNB/#parameters","text":"alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). true_threshold \u2013 defaults to 0.0 Threshold for binarizing (mapping to booleans) features.","title":"Parameters"},{"location":"api/naive-bayes/BernoulliNB/#attributes","text":"class_counts ( collections.Counter ) Number of times each class has been seen. feature_counts ( collections.defaultdict ) Total frequencies per feature and class.","title":"Attributes"},{"location":"api/naive-bayes/BernoulliNB/#examples","text":">>> import pandas as pd >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( \"Chinese Beijing Chinese\" , \"yes\" ), ... ( \"Chinese Chinese Shanghai\" , \"yes\" ), ... ( \"Chinese Macao\" , \"yes\" ), ... ( \"Tokyo Japan Chinese\" , \"no\" ) ... ] >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ \"nb\" ] . p_class ( \"yes\" ) 0.75 >>> model [ \"nb\" ] . p_class ( \"no\" ) 0.25 >>> model . predict_proba_one ( \"test\" ) { 'yes' : 0.8831539823829913 , 'no' : 0.11684601761700895 } >>> model . predict_one ( \"test\" ) 'yes' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> df_docs = pd . DataFrame ( docs , columns = [ \"docs\" , \"y\" ]) >>> X = pd . Series ([ ... \"Chinese Beijing Chinese\" , ... \"Chinese Chinese Shanghai\" , ... \"Chinese Macao\" , ... \"Tokyo Japan Chinese\" ... ]) >>> y = pd . Series ([ \"yes\" , \"yes\" , \"yes\" , \"no\" ]) >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . BernoulliNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> unseen = pd . Series ([ \"Taiwanese Taipei\" , \"Chinese Shanghai\" ]) >>> model . predict_proba_many ( unseen ) no yes 0 0.116846 0.883154 1 0.047269 0.952731 >>> model . predict_many ( unseen ) 0 yes 1 yes dtype : object","title":"Examples"},{"location":"api/naive-bayes/BernoulliNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Learn from a batch of count vectors. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns MiniBatchClassifier : self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/BernoulliNB/#references","text":"The Bernoulli model \u21a9","title":"References"},{"location":"api/naive-bayes/ComplementNB/","text":"ComplementNB \u00b6 Naive Bayes classifier for multinomial models. Complement Naive Bayes model learns from occurrences between features such as word counts and discrete classes. ComplementNB is suitable for imbalance dataset. The input vector must contain positive values, such as counts or TF-IDF values. Parameters \u00b6 alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). Attributes \u00b6 class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class. Examples \u00b6 >>> import pandas as pd >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( \"Chinese Beijing Chinese\" , \"yes\" ), ... ( \"Chinese Chinese Shanghai\" , \"yes\" ), ... ( \"Chinese Macao\" , \"maybe\" ), ... ( \"Tokyo Japan Chinese\" , \"no\" ) ... ] >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . ComplementNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ \"nb\" ] . p_class ( \"yes\" ) 0.5 >>> model [ \"nb\" ] . p_class ( \"no\" ) 0.25 >>> model [ \"nb\" ] . p_class ( \"maybe\" ) 0.25 >>> model . predict_proba_one ( \"test\" ) { 'yes' : 0.275 , 'maybe' : 0.375 , 'no' : 0.35 } >>> model . predict_one ( \"test\" ) 'maybe' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> df_docs = pd . DataFrame ( docs , columns = [ \"docs\" , \"y\" ]) >>> X = pd . Series ([ ... \"Chinese Beijing Chinese\" , ... \"Chinese Chinese Shanghai\" , ... \"Chinese Macao\" , ... \"Tokyo Japan Chinese\" ... ]) >>> y = pd . Series ([ \"yes\" , \"yes\" , \"maybe\" , \"no\" ]) >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . ComplementNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> unseen = pd . Series ([ \"Taiwanese Taipei\" , \"Chinese Shanghai\" ]) >>> model . predict_proba_many ( unseen ) maybe no yes 0 0.415129 0.361624 0.223247 1 0.248619 0.216575 0.534807 >>> model . predict_many ( unseen ) 0 maybe 1 yes dtype : object Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Learn from a batch of count vectors. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns MiniBatchClassifier : self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict ) References \u00b6 Rennie, J.D., Shih, L., Teevan, J. and Karger, D.R., 2003. Tackling the poor assumptions of naive bayes text classifiers. In Proceedings of the 20th international conference on machine learning (ICML-03) (pp. 616-623) \u21a9 StackExchange discussion \u21a9","title":"ComplementNB"},{"location":"api/naive-bayes/ComplementNB/#complementnb","text":"Naive Bayes classifier for multinomial models. Complement Naive Bayes model learns from occurrences between features such as word counts and discrete classes. ComplementNB is suitable for imbalance dataset. The input vector must contain positive values, such as counts or TF-IDF values.","title":"ComplementNB"},{"location":"api/naive-bayes/ComplementNB/#parameters","text":"alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).","title":"Parameters"},{"location":"api/naive-bayes/ComplementNB/#attributes","text":"class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class.","title":"Attributes"},{"location":"api/naive-bayes/ComplementNB/#examples","text":">>> import pandas as pd >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( \"Chinese Beijing Chinese\" , \"yes\" ), ... ( \"Chinese Chinese Shanghai\" , \"yes\" ), ... ( \"Chinese Macao\" , \"maybe\" ), ... ( \"Tokyo Japan Chinese\" , \"no\" ) ... ] >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . ComplementNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ \"nb\" ] . p_class ( \"yes\" ) 0.5 >>> model [ \"nb\" ] . p_class ( \"no\" ) 0.25 >>> model [ \"nb\" ] . p_class ( \"maybe\" ) 0.25 >>> model . predict_proba_one ( \"test\" ) { 'yes' : 0.275 , 'maybe' : 0.375 , 'no' : 0.35 } >>> model . predict_one ( \"test\" ) 'maybe' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> df_docs = pd . DataFrame ( docs , columns = [ \"docs\" , \"y\" ]) >>> X = pd . Series ([ ... \"Chinese Beijing Chinese\" , ... \"Chinese Chinese Shanghai\" , ... \"Chinese Macao\" , ... \"Tokyo Japan Chinese\" ... ]) >>> y = pd . Series ([ \"yes\" , \"yes\" , \"maybe\" , \"no\" ]) >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . ComplementNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> unseen = pd . Series ([ \"Taiwanese Taipei\" , \"Chinese Shanghai\" ]) >>> model . predict_proba_many ( unseen ) maybe no yes 0 0.415129 0.361624 0.223247 1 0.248619 0.216575 0.534807 >>> model . predict_many ( unseen ) 0 maybe 1 yes dtype : object","title":"Examples"},{"location":"api/naive-bayes/ComplementNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Learn from a batch of count vectors. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns MiniBatchClassifier : self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/ComplementNB/#references","text":"Rennie, J.D., Shih, L., Teevan, J. and Karger, D.R., 2003. Tackling the poor assumptions of naive bayes text classifiers. In Proceedings of the 20th international conference on machine learning (ICML-03) (pp. 616-623) \u21a9 StackExchange discussion \u21a9","title":"References"},{"location":"api/naive-bayes/GaussianNB/","text":"GaussianNB \u00b6 Gaussian Naive Bayes. A Gaussian distribution \\(G_{cf}\\) is maintained for each class \\(c\\) and each feature \\(f\\) . Each Gaussian is updated using the amount associated with each feature; the details can be be found in proba.Gaussian . The joint log-likelihood is then obtained by summing the log probabilities of each feature associated with each class. Examples \u00b6 >>> from river import naive_bayes >>> from river import stream >>> import numpy as np >>> X = np . array ([[ - 1 , - 1 ], [ - 2 , - 1 ], [ - 3 , - 2 ], [ 1 , 1 ], [ 2 , 1 ], [ 3 , 2 ]]) >>> Y = np . array ([ 1 , 1 , 1 , 2 , 2 , 2 ]) >>> model = naive_bayes . GaussianNB () >>> for x , y in stream . iter_array ( X , Y ): ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 0 : - 0.8 , 1 : - 1 }) 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood joint_log_likelihood_many learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"GaussianNB"},{"location":"api/naive-bayes/GaussianNB/#gaussiannb","text":"Gaussian Naive Bayes. A Gaussian distribution \\(G_{cf}\\) is maintained for each class \\(c\\) and each feature \\(f\\) . Each Gaussian is updated using the amount associated with each feature; the details can be be found in proba.Gaussian . The joint log-likelihood is then obtained by summing the log probabilities of each feature associated with each class.","title":"GaussianNB"},{"location":"api/naive-bayes/GaussianNB/#examples","text":">>> from river import naive_bayes >>> from river import stream >>> import numpy as np >>> X = np . array ([[ - 1 , - 1 ], [ - 2 , - 1 ], [ - 3 , - 2 ], [ 1 , 1 ], [ 2 , 1 ], [ 3 , 2 ]]) >>> Y = np . array ([ 1 , 1 , 1 , 2 , 2 , 2 ]) >>> model = naive_bayes . GaussianNB () >>> for x , y in stream . iter_array ( X , Y ): ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 0 : - 0.8 , 1 : - 1 }) 1","title":"Examples"},{"location":"api/naive-bayes/GaussianNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood joint_log_likelihood_many learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/MultinomialNB/","text":"MultinomialNB \u00b6 Naive Bayes classifier for multinomial models. Multinomial Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values. Parameters \u00b6 alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing). Attributes \u00b6 class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class. Examples \u00b6 >>> import pandas as pd >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( \"Chinese Beijing Chinese\" , \"yes\" ), ... ( \"Chinese Chinese Shanghai\" , \"yes\" ), ... ( \"Chinese Macao\" , \"maybe\" ), ... ( \"Tokyo Japan Chinese\" , \"no\" ) ... ] >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ \"nb\" ] . p_class ( \"yes\" ) 0.5 >>> model [ \"nb\" ] . p_class ( \"no\" ) 0.25 >>> model [ \"nb\" ] . p_class ( \"maybe\" ) 0.25 >>> model . predict_proba_one ( \"test\" ) { 'yes' : 0.413 , 'maybe' : 0.310 , 'no' : 0.275 } >>> model . predict_one ( \"test\" ) 'yes' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> df_docs = pd . DataFrame ( docs , columns = [ \"docs\" , \"y\" ]) >>> X = pd . Series ([ ... \"Chinese Beijing Chinese\" , ... \"Chinese Chinese Shanghai\" , ... \"Chinese Macao\" , ... \"Tokyo Japan Chinese\" ... ]) >>> y = pd . Series ([ \"yes\" , \"yes\" , \"maybe\" , \"no\" ]) >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> unseen = pd . Series ([ \"Taiwanese Taipei\" , \"Chinese Shanghai\" ]) >>> model . predict_proba_many ( unseen ) maybe no yes 0 0.373272 0.294931 0.331797 1 0.160396 0.126733 0.712871 >>> model . predict_many ( unseen ) 0 maybe 1 yes dtype : object Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Learn from a batch of count vectors. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns MiniBatchClassifier : self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict ) References \u00b6 Naive Bayes text classification \u21a9","title":"MultinomialNB"},{"location":"api/naive-bayes/MultinomialNB/#multinomialnb","text":"Naive Bayes classifier for multinomial models. Multinomial Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.","title":"MultinomialNB"},{"location":"api/naive-bayes/MultinomialNB/#parameters","text":"alpha \u2013 defaults to 1.0 Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).","title":"Parameters"},{"location":"api/naive-bayes/MultinomialNB/#attributes","text":"class_dist ( proba.Multinomial ) Class prior probability distribution. feature_counts ( collections.defaultdict ) Total frequencies per feature and class. class_totals ( collections.Counter ) Total frequencies per class.","title":"Attributes"},{"location":"api/naive-bayes/MultinomialNB/#examples","text":">>> import pandas as pd >>> from river import compose >>> from river import feature_extraction >>> from river import naive_bayes >>> docs = [ ... ( \"Chinese Beijing Chinese\" , \"yes\" ), ... ( \"Chinese Chinese Shanghai\" , \"yes\" ), ... ( \"Chinese Macao\" , \"maybe\" ), ... ( \"Tokyo Japan Chinese\" , \"no\" ) ... ] >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> for sentence , label in docs : ... model = model . learn_one ( sentence , label ) >>> model [ \"nb\" ] . p_class ( \"yes\" ) 0.5 >>> model [ \"nb\" ] . p_class ( \"no\" ) 0.25 >>> model [ \"nb\" ] . p_class ( \"maybe\" ) 0.25 >>> model . predict_proba_one ( \"test\" ) { 'yes' : 0.413 , 'maybe' : 0.310 , 'no' : 0.275 } >>> model . predict_one ( \"test\" ) 'yes' You can train the model and make predictions in mini-batch mode using the class methods learn_many and predict_many . >>> df_docs = pd . DataFrame ( docs , columns = [ \"docs\" , \"y\" ]) >>> X = pd . Series ([ ... \"Chinese Beijing Chinese\" , ... \"Chinese Chinese Shanghai\" , ... \"Chinese Macao\" , ... \"Tokyo Japan Chinese\" ... ]) >>> y = pd . Series ([ \"yes\" , \"yes\" , \"maybe\" , \"no\" ]) >>> model = compose . Pipeline ( ... ( \"tokenize\" , feature_extraction . BagOfWords ( lowercase = False )), ... ( \"nb\" , naive_bayes . MultinomialNB ( alpha = 1 )) ... ) >>> model = model . learn_many ( X , y ) >>> unseen = pd . Series ([ \"Taiwanese Taipei\" , \"Chinese Shanghai\" ]) >>> model . predict_proba_many ( unseen ) maybe no yes 0 0.373272 0.294931 0.331797 1 0.160396 0.126733 0.712871 >>> model . predict_many ( unseen ) 0 maybe 1 yes dtype : object","title":"Examples"},{"location":"api/naive-bayes/MultinomialNB/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. joint_log_likelihood Computes the joint log likelihood of input features. Parameters x ( dict ) Returns float : Mapping between classes and joint log likelihood. joint_log_likelihood_many Computes the joint log likelihood of input features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : Input samples joint log likelihood. learn_many Learn from a batch of count vectors. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.series.Series ) Returns MiniBatchClassifier : self learn_one Updates the model with a single observation. Parameters x ( dict ) y ( Union[bool, str, int] ) Returns Classifier : self p_class p_class_many p_feature_given_class predict_many Predict the outcome for each given sample. Parameters X ( pandas.core.frame.DataFrame ) Returns Series : The predicted labels. predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_many Return probabilities using the log-likelihoods in mini-batchs setting. Parameters X ( pandas.core.frame.DataFrame ) predict_proba_one Return probabilities using the log-likelihoods. Parameters x ( dict )","title":"Methods"},{"location":"api/naive-bayes/MultinomialNB/#references","text":"Naive Bayes text classification \u21a9","title":"References"},{"location":"api/neighbors/KNNClassifier/","text":"KNNClassifier \u00b6 K-Nearest Neighbors (KNN) for classification. This works by storing a buffer with the window_size most recent observations. A brute-force search is used to find the n_neighbors nearest observations in the buffer to make a prediction. See the NearestNeighbors parent class for model details. Parameters \u00b6 n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. min_distance_keep ( float ) \u2013 defaults to 0.0 The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates. Default is 0.05 to add similar but not exactly the same points. weighted ( bool ) \u2013 defaults to True Weight the contribution of each neighbor by it's inverse distance. cleanup_every ( int ) \u2013 defaults to 0 This determines at which rate old classes are cleaned up. Classes that have been seen in the past but that are not present in the current window are dropped. Classes are never dropped when this is set to 0. distance_func ( Callable[[Any, Any], float] ) \u2013 defaults to None An optional distance function that should accept an a=, b=, and any custom set of kwargs (defined in distance_func_kwargs). If not defined, the default Minkowski distance is used. softmax ( bool ) \u2013 defaults to False Whether or not to use softmax normalization to normalize the neighbors contributions. Votes are divided by the total number of votes if this is False . Examples \u00b6 >>> from river import datasets , neighbors , preprocessing >>> from river import evaluate , metrics >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... neighbors . KNNClassifier () ... ) >>> for x , y in dataset . take ( 100 ): ... model = model . learn_one ( x , y ) >>> for x , y in dataset . take ( 1 ): ... model . predict_one ( x ) True Methods \u00b6 clean_up_classes Clean up classes added to the window. Classes that are added (and removed) from the window may no longer be valid. This method cleans up the window and and ensures only known classes are added, and we do not consider \"None\" a class. It is called every cleanup_every step, or can be called manually. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. Notes \u00b6 See the NearestNeighbors documentation for details about the base model, along with KNNBase for an example of providing your own distance function. Note that since the window is moving and we keep track of all classes that are added at some point, a class might be returned in a result (with a value of 0) if it is no longer in the window. You can call model.clean_up_classes(), or set cleanup_every to a non-zero value.","title":"KNNClassifier"},{"location":"api/neighbors/KNNClassifier/#knnclassifier","text":"K-Nearest Neighbors (KNN) for classification. This works by storing a buffer with the window_size most recent observations. A brute-force search is used to find the n_neighbors nearest observations in the buffer to make a prediction. See the NearestNeighbors parent class for model details.","title":"KNNClassifier"},{"location":"api/neighbors/KNNClassifier/#parameters","text":"n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. min_distance_keep ( float ) \u2013 defaults to 0.0 The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates. Default is 0.05 to add similar but not exactly the same points. weighted ( bool ) \u2013 defaults to True Weight the contribution of each neighbor by it's inverse distance. cleanup_every ( int ) \u2013 defaults to 0 This determines at which rate old classes are cleaned up. Classes that have been seen in the past but that are not present in the current window are dropped. Classes are never dropped when this is set to 0. distance_func ( Callable[[Any, Any], float] ) \u2013 defaults to None An optional distance function that should accept an a=, b=, and any custom set of kwargs (defined in distance_func_kwargs). If not defined, the default Minkowski distance is used. softmax ( bool ) \u2013 defaults to False Whether or not to use softmax normalization to normalize the neighbors contributions. Votes are divided by the total number of votes if this is False .","title":"Parameters"},{"location":"api/neighbors/KNNClassifier/#examples","text":">>> from river import datasets , neighbors , preprocessing >>> from river import evaluate , metrics >>> dataset = datasets . Phishing () >>> model = ( ... preprocessing . StandardScaler () | ... neighbors . KNNClassifier () ... ) >>> for x , y in dataset . take ( 100 ): ... model = model . learn_one ( x , y ) >>> for x , y in dataset . take ( 1 ): ... model . predict_one ( x ) True","title":"Examples"},{"location":"api/neighbors/KNNClassifier/#methods","text":"clean_up_classes Clean up classes added to the window. Classes that are added (and removed) from the window may no longer be valid. This method cleans up the window and and ensures only known classes are added, and we do not consider \"None\" a class. It is called every cleanup_every step, or can be called manually. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x y Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/neighbors/KNNClassifier/#notes","text":"See the NearestNeighbors documentation for details about the base model, along with KNNBase for an example of providing your own distance function. Note that since the window is moving and we keep track of all classes that are added at some point, a class might be returned in a result (with a value of 0) if it is no longer in the window. You can call model.clean_up_classes(), or set cleanup_every to a non-zero value.","title":"Notes"},{"location":"api/neighbors/KNNRegressor/","text":"KNNRegressor \u00b6 K-Nearest Neighbors regressor. This non-parametric regression method keeps track of the last window_size training samples. Predictions are obtained by aggregating the values of the closest n_neighbors stored-samples with respect to a query sample. Parameters \u00b6 n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. aggregation_method ( str ) \u2013 defaults to mean The method to aggregate the target values of neighbors. | 'mean' | 'median' | 'weighted_mean' min_distance_keep ( float ) \u2013 defaults to 0.0 The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates. Default is 0.05 to add similar but not exactly the same points. distance_func ( Callable[[Any, Any], float] ) \u2013 defaults to None An optional distance function that should accept an a=, b=, and any custom set of kwargs (defined in distance_func_kwargs). If not defined, the default Minkowski distance is used. Examples \u00b6 >>> from river import datasets , neighbors >>> from river import evaluate , metrics >>> dataset = datasets . TrumpApproval () >>> model = neighbors . KNNRegressor ( window_size = 50 ) >>> for x , y in dataset . take ( 100 ): ... model = model . learn_one ( x , y ) >>> for x , y in dataset . take ( 1 ): ... model . predict_one ( x ) 41.839342 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Learn a set of features x and optional class y . Parameters: x: A dictionary of features. y: A class (optional if known). extra: an optional list or tuple of features to store Returns: self Parameters x y \u2013 defaults to None extra ( [typing.Tuple, ] ) \u2013 defaults to None predict_one Predict the target value of a set of features x . Search the window for the n_neighbors nearest neighbors. Return a default prediction if the size of the window is 0 (no neighbors yet) Parameters x Returns The prediction. Notes \u00b6 See the NearestNeighbors documentation for details about the base model, along with KNNBase for an example of providing your own distance function.","title":"KNNRegressor"},{"location":"api/neighbors/KNNRegressor/#knnregressor","text":"K-Nearest Neighbors regressor. This non-parametric regression method keeps track of the last window_size training samples. Predictions are obtained by aggregating the values of the closest n_neighbors stored-samples with respect to a query sample.","title":"KNNRegressor"},{"location":"api/neighbors/KNNRegressor/#parameters","text":"n_neighbors ( int ) \u2013 defaults to 5 The number of nearest neighbors to search for. window_size ( int ) \u2013 defaults to 1000 The maximum size of the window storing the last observed samples. aggregation_method ( str ) \u2013 defaults to mean The method to aggregate the target values of neighbors. | 'mean' | 'median' | 'weighted_mean' min_distance_keep ( float ) \u2013 defaults to 0.0 The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates. Default is 0.05 to add similar but not exactly the same points. distance_func ( Callable[[Any, Any], float] ) \u2013 defaults to None An optional distance function that should accept an a=, b=, and any custom set of kwargs (defined in distance_func_kwargs). If not defined, the default Minkowski distance is used.","title":"Parameters"},{"location":"api/neighbors/KNNRegressor/#examples","text":">>> from river import datasets , neighbors >>> from river import evaluate , metrics >>> dataset = datasets . TrumpApproval () >>> model = neighbors . KNNRegressor ( window_size = 50 ) >>> for x , y in dataset . take ( 100 ): ... model = model . learn_one ( x , y ) >>> for x , y in dataset . take ( 1 ): ... model . predict_one ( x ) 41.839342","title":"Examples"},{"location":"api/neighbors/KNNRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Learn a set of features x and optional class y . Parameters: x: A dictionary of features. y: A class (optional if known). extra: an optional list or tuple of features to store Returns: self Parameters x y \u2013 defaults to None extra ( [typing.Tuple, ] ) \u2013 defaults to None predict_one Predict the target value of a set of features x . Search the window for the n_neighbors nearest neighbors. Return a default prediction if the size of the window is 0 (no neighbors yet) Parameters x Returns The prediction.","title":"Methods"},{"location":"api/neighbors/KNNRegressor/#notes","text":"See the NearestNeighbors documentation for details about the base model, along with KNNBase for an example of providing your own distance function.","title":"Notes"},{"location":"api/neighbors/NearestNeighbors/","text":"NearestNeighbors \u00b6 A basic data structure to hold nearest neighbors. Parameters \u00b6 n_neighbors ( int ) \u2013 defaults to 5 Number of neighbors to use. window_size ( int ) \u2013 defaults to 1000 Size of the sliding window use to search neighbors with. min_distance_keep ( float ) \u2013 defaults to 0.0 The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates. Default is 0.05 to add similar but not exactly the same points. distance_func ( Callable[[Any, Any], float] ) \u2013 defaults to None An required distance function that accept two input items to compare and optional parameters. It's recommended to use functools.partial. Methods \u00b6 append Add a point to the window, optionally with extra metadata. Parameters item ( Any ) extra ( [typing.Tuple, ] ) \u2013 defaults to None find_nearest Find the n_neighbors closest points to x , along with their distances. This function assumes the x is a tuple or list with x[0] having relevant data for the distance calculation. Parameters item ( Any ) n_neighbors \u2013 defaults to 1 Number of neighbors to use. reset Reset window update Update the window with a new point, only added if > min distance. If min distance is 0, we do not need to do the calculation. The item (and extra metadata) will not be added to the window if it is too close to an existing point. Parameters item ( Any ) n_neighbors \u2013 defaults to 1 Number of neighbors to use. extra ( [typing.Tuple, ] ) \u2013 defaults to None Returns A boolean (true/false) to indicate if the point was added. Notes \u00b6 Updates are by default stored by the FIFO (first in first out) method, which means that when the size limit is reached, old samples are dumped to give room for new samples. This is circular, meaning that older points are dumped first. This also gives the implementation a temporal aspect, because older samples are replaced with newer ones. The parameter min_dinstance_keep controls the addition of new items to the window - items that are far enough away (> min_distance_keep) are added to the window. Thus a value of 0 indicates that we add all points, and increasing from 0 makes it less likely we will keep a new item.","title":"NearestNeighbors"},{"location":"api/neighbors/NearestNeighbors/#nearestneighbors","text":"A basic data structure to hold nearest neighbors.","title":"NearestNeighbors"},{"location":"api/neighbors/NearestNeighbors/#parameters","text":"n_neighbors ( int ) \u2013 defaults to 5 Number of neighbors to use. window_size ( int ) \u2013 defaults to 1000 Size of the sliding window use to search neighbors with. min_distance_keep ( float ) \u2013 defaults to 0.0 The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates. Default is 0.05 to add similar but not exactly the same points. distance_func ( Callable[[Any, Any], float] ) \u2013 defaults to None An required distance function that accept two input items to compare and optional parameters. It's recommended to use functools.partial.","title":"Parameters"},{"location":"api/neighbors/NearestNeighbors/#methods","text":"append Add a point to the window, optionally with extra metadata. Parameters item ( Any ) extra ( [typing.Tuple, ] ) \u2013 defaults to None find_nearest Find the n_neighbors closest points to x , along with their distances. This function assumes the x is a tuple or list with x[0] having relevant data for the distance calculation. Parameters item ( Any ) n_neighbors \u2013 defaults to 1 Number of neighbors to use. reset Reset window update Update the window with a new point, only added if > min distance. If min distance is 0, we do not need to do the calculation. The item (and extra metadata) will not be added to the window if it is too close to an existing point. Parameters item ( Any ) n_neighbors \u2013 defaults to 1 Number of neighbors to use. extra ( [typing.Tuple, ] ) \u2013 defaults to None Returns A boolean (true/false) to indicate if the point was added.","title":"Methods"},{"location":"api/neighbors/NearestNeighbors/#notes","text":"Updates are by default stored by the FIFO (first in first out) method, which means that when the size limit is reached, old samples are dumped to give room for new samples. This is circular, meaning that older points are dumped first. This also gives the implementation a temporal aspect, because older samples are replaced with newer ones. The parameter min_dinstance_keep controls the addition of new items to the window - items that are far enough away (> min_distance_keep) are added to the window. Thus a value of 0 indicates that we add all points, and increasing from 0 makes it less likely we will keep a new item.","title":"Notes"},{"location":"api/neural-net/MLPRegressor/","text":"MLPRegressor \u00b6 Multi-layer Perceptron for regression. This model is still work in progress. Here are some features that still need implementing: learn_one and predict_one just cast the input dict to a single row dataframe and then call learn_many and predict_many respectively. This is very inefficient. - Not all of the optimizers in the optim module can be used as they are not all vectorised. - Emerging and disappearing features are not supported. Each instance/batch has to have the same features. - The gradient haven't been numerically checked. Parameters \u00b6 hidden_dims The dimensions of the hidden layers. For example, specifying (10, 20) means that there are two hidden layers with 10 and 20 neurons, respectively. Note that the number of layers the network contains is equal to the number of hidden layers plus two (to account for the input and output layers). activations The activation functions to use at each layer, including the input and output layers. Therefore you need to specify three activation if you specify one hidden layer. loss ( optim.base.Loss ) \u2013 defaults to None Loss function. Defaults to optim.losses.Squared . optimizer ( optim.base.Optimizer ) \u2013 defaults to None Optimizer. Defaults to optim.SGD(.01) . seed ( int ) \u2013 defaults to None Random number generation seed. Set this for reproducibility. Attributes \u00b6 n_layers Return the number of layers in the network. The number of layers is equal to the number of hidden layers plus 2. The 2 accounts for the input layer and the output layer. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import neural_net as nn >>> from river import optim >>> from river import preprocessing as pp >>> from river import metrics >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 5 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . Identity ... ), ... optimizer = optim . SGD ( 1e-3 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.589827 You can also use this to process mini-batches of data. >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 10 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . ReLU ... ), ... optimizer = optim . SGD ( 1e-4 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> batch_size = 32 >>> for epoch in range ( 10 ): ... for xb in pd . read_csv ( dataset . path , chunksize = batch_size ): ... yb = xb . pop ( 'five_thirty_eight' ) ... y_pred = model . predict_many ( xb ) ... model = model . learn_many ( xb , yb ) >>> model . predict_many ( xb ) five_thirty_eight 992 39.361609 993 46.398536 994 42.094086 995 40.195802 996 40.782954 997 40.839678 998 40.896403 999 48.362659 1000 42.021849 Methods \u00b6 call Make predictions. Parameters X ( pandas.core.frame.DataFrame ) clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Train the network. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.frame.DataFrame ) learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_many predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"MLPRegressor"},{"location":"api/neural-net/MLPRegressor/#mlpregressor","text":"Multi-layer Perceptron for regression. This model is still work in progress. Here are some features that still need implementing: learn_one and predict_one just cast the input dict to a single row dataframe and then call learn_many and predict_many respectively. This is very inefficient. - Not all of the optimizers in the optim module can be used as they are not all vectorised. - Emerging and disappearing features are not supported. Each instance/batch has to have the same features. - The gradient haven't been numerically checked.","title":"MLPRegressor"},{"location":"api/neural-net/MLPRegressor/#parameters","text":"hidden_dims The dimensions of the hidden layers. For example, specifying (10, 20) means that there are two hidden layers with 10 and 20 neurons, respectively. Note that the number of layers the network contains is equal to the number of hidden layers plus two (to account for the input and output layers). activations The activation functions to use at each layer, including the input and output layers. Therefore you need to specify three activation if you specify one hidden layer. loss ( optim.base.Loss ) \u2013 defaults to None Loss function. Defaults to optim.losses.Squared . optimizer ( optim.base.Optimizer ) \u2013 defaults to None Optimizer. Defaults to optim.SGD(.01) . seed ( int ) \u2013 defaults to None Random number generation seed. Set this for reproducibility.","title":"Parameters"},{"location":"api/neural-net/MLPRegressor/#attributes","text":"n_layers Return the number of layers in the network. The number of layers is equal to the number of hidden layers plus 2. The 2 accounts for the input layer and the output layer.","title":"Attributes"},{"location":"api/neural-net/MLPRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import neural_net as nn >>> from river import optim >>> from river import preprocessing as pp >>> from river import metrics >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 5 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . Identity ... ), ... optimizer = optim . SGD ( 1e-3 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.589827 You can also use this to process mini-batches of data. >>> model = ( ... pp . StandardScaler () | ... nn . MLPRegressor ( ... hidden_dims = ( 10 ,), ... activations = ( ... nn . activations . ReLU , ... nn . activations . ReLU , ... nn . activations . ReLU ... ), ... optimizer = optim . SGD ( 1e-4 ), ... seed = 42 ... ) ... ) >>> dataset = datasets . TrumpApproval () >>> batch_size = 32 >>> for epoch in range ( 10 ): ... for xb in pd . read_csv ( dataset . path , chunksize = batch_size ): ... yb = xb . pop ( 'five_thirty_eight' ) ... y_pred = model . predict_many ( xb ) ... model = model . learn_many ( xb , yb ) >>> model . predict_many ( xb ) five_thirty_eight 992 39.361609 993 46.398536 994 42.094086 995 40.195802 996 40.782954 997 40.839678 998 40.896403 999 48.362659 1000 42.021849","title":"Examples"},{"location":"api/neural-net/MLPRegressor/#methods","text":"call Make predictions. Parameters X ( pandas.core.frame.DataFrame ) clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Train the network. Parameters X ( pandas.core.frame.DataFrame ) y ( pandas.core.frame.DataFrame ) learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_many predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/neural-net/activations/Identity/","text":"Identity \u00b6 Identity activation function. Methods \u00b6 apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Identity"},{"location":"api/neural-net/activations/Identity/#identity","text":"Identity activation function.","title":"Identity"},{"location":"api/neural-net/activations/Identity/#methods","text":"apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Methods"},{"location":"api/neural-net/activations/ReLU/","text":"ReLU \u00b6 Rectified Linear Unit (ReLU) activation function. Methods \u00b6 apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"ReLU"},{"location":"api/neural-net/activations/ReLU/#relu","text":"Rectified Linear Unit (ReLU) activation function.","title":"ReLU"},{"location":"api/neural-net/activations/ReLU/#methods","text":"apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Methods"},{"location":"api/neural-net/activations/Sigmoid/","text":"Sigmoid \u00b6 Sigmoid activation function. Methods \u00b6 apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Sigmoid"},{"location":"api/neural-net/activations/Sigmoid/#sigmoid","text":"Sigmoid activation function.","title":"Sigmoid"},{"location":"api/neural-net/activations/Sigmoid/#methods","text":"apply Apply the activation function to a layer output z. z gradient Return the gradient with respect to a layer output z. z","title":"Methods"},{"location":"api/optim/AMSGrad/","text":"AMSGrad \u00b6 AMSGrad optimizer. Parameters \u00b6 lr ( Union[float, optim.base.Scheduler ] ) \u2013 defaults to 0.1 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 correct_bias \u2013 defaults to True Attributes \u00b6 m ( collections.defaultdict ) v ( collections.defaultdict ) v_hat ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AMSGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 86.57 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Reddi, S.J., Kale, S. and Kumar, S., 2019. On the convergence of adam and beyond. arXiv preprint arXiv:1904.09237 \u21a9","title":"AMSGrad"},{"location":"api/optim/AMSGrad/#amsgrad","text":"AMSGrad optimizer.","title":"AMSGrad"},{"location":"api/optim/AMSGrad/#parameters","text":"lr ( Union[float, optim.base.Scheduler ] ) \u2013 defaults to 0.1 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 correct_bias \u2013 defaults to True","title":"Parameters"},{"location":"api/optim/AMSGrad/#attributes","text":"m ( collections.defaultdict ) v ( collections.defaultdict ) v_hat ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AMSGrad/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AMSGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 86.57 %","title":"Examples"},{"location":"api/optim/AMSGrad/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/AMSGrad/#references","text":"Reddi, S.J., Kale, S. and Kumar, S., 2019. On the convergence of adam and beyond. arXiv preprint arXiv:1904.09237 \u21a9","title":"References"},{"location":"api/optim/AdaBound/","text":"AdaBound \u00b6 AdaBound optimizer. Parameters \u00b6 lr \u2013 defaults to 0.001 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 gamma \u2013 defaults to 0.001 final_lr \u2013 defaults to 0.1 Attributes \u00b6 m ( collections.defaultdict ) s ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaBound () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.90 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Luo, L., Xiong, Y., Liu, Y. and Sun, X., 2019. Adaptive gradient methods with dynamic bound of learning rate. arXiv preprint arXiv:1902.09843 \u21a9","title":"AdaBound"},{"location":"api/optim/AdaBound/#adabound","text":"AdaBound optimizer.","title":"AdaBound"},{"location":"api/optim/AdaBound/#parameters","text":"lr \u2013 defaults to 0.001 The learning rate. beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 gamma \u2013 defaults to 0.001 final_lr \u2013 defaults to 0.1","title":"Parameters"},{"location":"api/optim/AdaBound/#attributes","text":"m ( collections.defaultdict ) s ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaBound/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaBound () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.90 %","title":"Examples"},{"location":"api/optim/AdaBound/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/AdaBound/#references","text":"Luo, L., Xiong, Y., Liu, Y. and Sun, X., 2019. Adaptive gradient methods with dynamic bound of learning rate. arXiv preprint arXiv:1902.09843 \u21a9","title":"References"},{"location":"api/optim/AdaDelta/","text":"AdaDelta \u00b6 AdaDelta optimizer. Parameters \u00b6 rho \u2013 defaults to 0.95 eps \u2013 defaults to 1e-08 Attributes \u00b6 g2 ( collections.defaultdict ) s2 ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaDelta () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 80.56 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Zeiler, M.D., 2012. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701. \u21a9","title":"AdaDelta"},{"location":"api/optim/AdaDelta/#adadelta","text":"AdaDelta optimizer.","title":"AdaDelta"},{"location":"api/optim/AdaDelta/#parameters","text":"rho \u2013 defaults to 0.95 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/AdaDelta/#attributes","text":"g2 ( collections.defaultdict ) s2 ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaDelta/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaDelta () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 80.56 %","title":"Examples"},{"location":"api/optim/AdaDelta/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/AdaDelta/#references","text":"Zeiler, M.D., 2012. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701. \u21a9","title":"References"},{"location":"api/optim/AdaGrad/","text":"AdaGrad \u00b6 AdaGrad optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 eps \u2013 defaults to 1e-08 Attributes \u00b6 g2 ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 88.01 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Duchi, J., Hazan, E. and Singer, Y., 2011. Adaptive subgradient methods for online learning and stochastic optimization. Journal of machine learning research, 12(Jul), pp.2121-2159. \u21a9","title":"AdaGrad"},{"location":"api/optim/AdaGrad/#adagrad","text":"AdaGrad optimizer.","title":"AdaGrad"},{"location":"api/optim/AdaGrad/#parameters","text":"lr \u2013 defaults to 0.1 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/AdaGrad/#attributes","text":"g2 ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaGrad/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaGrad () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 88.01 %","title":"Examples"},{"location":"api/optim/AdaGrad/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/AdaGrad/#references","text":"Duchi, J., Hazan, E. and Singer, Y., 2011. Adaptive subgradient methods for online learning and stochastic optimization. Journal of machine learning research, 12(Jul), pp.2121-2159. \u21a9","title":"References"},{"location":"api/optim/AdaMax/","text":"AdaMax \u00b6 AdaMax optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 Attributes \u00b6 m ( collections.defaultdict ) v ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaMax () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.53 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9 Ruder, S., 2016. An overview of gradient descent optimization algorithms. arXiv preprint arXiv:1609.04747. \u21a9","title":"AdaMax"},{"location":"api/optim/AdaMax/#adamax","text":"AdaMax optimizer.","title":"AdaMax"},{"location":"api/optim/AdaMax/#parameters","text":"lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/AdaMax/#attributes","text":"m ( collections.defaultdict ) v ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/AdaMax/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . AdaMax () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.53 %","title":"Examples"},{"location":"api/optim/AdaMax/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/AdaMax/#references","text":"Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9 Ruder, S., 2016. An overview of gradient descent optimization algorithms. arXiv preprint arXiv:1609.04747. \u21a9","title":"References"},{"location":"api/optim/Adam/","text":"Adam \u00b6 Adam optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 Attributes \u00b6 m ( collections.defaultdict ) v ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Adam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 86.50 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9","title":"Adam"},{"location":"api/optim/Adam/#adam","text":"Adam optimizer.","title":"Adam"},{"location":"api/optim/Adam/#parameters","text":"lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/Adam/#attributes","text":"m ( collections.defaultdict ) v ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/Adam/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Adam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 86.50 %","title":"Examples"},{"location":"api/optim/Adam/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/Adam/#references","text":"Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9","title":"References"},{"location":"api/optim/Averager/","text":"Averager \u00b6 Averaged stochastic gradient descent. This is a wrapper that can be applied to any stochastic gradient descent optimiser. Note that this implementation differs than what may be found elsewhere. Essentially, the average of the weights is usually only used at the end of the optimisation, once all the data has been seen. However, in this implementation the optimiser returns the current averaged weights. Parameters \u00b6 optimizer ( optim.base.Optimizer ) An optimizer for which the produced weights will be averaged. start ( int ) \u2013 defaults to 0 Indicates the number of iterations to wait before starting the average. Essentially, nothing happens differently before the number of iterations reaches this value. Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Averager ( optim . SGD ( 0.01 ), 100 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.89 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Bottou, L., 2010. Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT'2010 (pp. 177-186). Physica-Verlag HD. \u21a9 Stochastic Algorithms for One-Pass Learning slides by L\u00e9on Bottou \u21a9 Xu, W., 2011. Towards optimal one pass large scale learning with averaged stochastic gradient descent. arXiv preprint arXiv:1107.2490. \u21a9","title":"Averager"},{"location":"api/optim/Averager/#averager","text":"Averaged stochastic gradient descent. This is a wrapper that can be applied to any stochastic gradient descent optimiser. Note that this implementation differs than what may be found elsewhere. Essentially, the average of the weights is usually only used at the end of the optimisation, once all the data has been seen. However, in this implementation the optimiser returns the current averaged weights.","title":"Averager"},{"location":"api/optim/Averager/#parameters","text":"optimizer ( optim.base.Optimizer ) An optimizer for which the produced weights will be averaged. start ( int ) \u2013 defaults to 0 Indicates the number of iterations to wait before starting the average. Essentially, nothing happens differently before the number of iterations reaches this value.","title":"Parameters"},{"location":"api/optim/Averager/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/Averager/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Averager ( optim . SGD ( 0.01 ), 100 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.89 %","title":"Examples"},{"location":"api/optim/Averager/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/Averager/#references","text":"Bottou, L., 2010. Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT'2010 (pp. 177-186). Physica-Verlag HD. \u21a9 Stochastic Algorithms for One-Pass Learning slides by L\u00e9on Bottou \u21a9 Xu, W., 2011. Towards optimal one pass large scale learning with averaged stochastic gradient descent. arXiv preprint arXiv:1107.2490. \u21a9","title":"References"},{"location":"api/optim/FTRLProximal/","text":"FTRLProximal \u00b6 FTRL-Proximal optimizer. Parameters \u00b6 alpha \u2013 defaults to 0.05 beta \u2013 defaults to 1.0 l1 \u2013 defaults to 0.0 l2 \u2013 defaults to 1.0 Attributes \u00b6 z ( collections.defaultdict ) n ( collections.defaultdict ) Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . FTRLProximal () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.66 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9 Tensorflow's FtrlOptimizer \u21a9","title":"FTRLProximal"},{"location":"api/optim/FTRLProximal/#ftrlproximal","text":"FTRL-Proximal optimizer.","title":"FTRLProximal"},{"location":"api/optim/FTRLProximal/#parameters","text":"alpha \u2013 defaults to 0.05 beta \u2013 defaults to 1.0 l1 \u2013 defaults to 0.0 l2 \u2013 defaults to 1.0","title":"Parameters"},{"location":"api/optim/FTRLProximal/#attributes","text":"z ( collections.defaultdict ) n ( collections.defaultdict )","title":"Attributes"},{"location":"api/optim/FTRLProximal/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . FTRLProximal () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.66 %","title":"Examples"},{"location":"api/optim/FTRLProximal/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/FTRLProximal/#references","text":"McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9 Tensorflow's FtrlOptimizer \u21a9","title":"References"},{"location":"api/optim/Momentum/","text":"Momentum \u00b6 Momentum optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Momentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 84.16 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Momentum"},{"location":"api/optim/Momentum/#momentum","text":"Momentum optimizer.","title":"Momentum"},{"location":"api/optim/Momentum/#parameters","text":"lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9","title":"Parameters"},{"location":"api/optim/Momentum/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/Momentum/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Momentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 84.16 %","title":"Examples"},{"location":"api/optim/Momentum/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/Nadam/","text":"Nadam \u00b6 Nadam optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Nadam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 86.60 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Nadam: A combination of adam and nesterov \u21a9","title":"Nadam"},{"location":"api/optim/Nadam/#nadam","text":"Nadam optimizer.","title":"Nadam"},{"location":"api/optim/Nadam/#parameters","text":"lr \u2013 defaults to 0.1 beta_1 \u2013 defaults to 0.9 beta_2 \u2013 defaults to 0.999 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/Nadam/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/Nadam/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . Nadam () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 86.60 %","title":"Examples"},{"location":"api/optim/Nadam/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/Nadam/#references","text":"Nadam: A combination of adam and nesterov \u21a9","title":"References"},{"location":"api/optim/NesterovMomentum/","text":"NesterovMomentum \u00b6 Nesterov Momentum optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . NesterovMomentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 84.29 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"NesterovMomentum"},{"location":"api/optim/NesterovMomentum/#nesterovmomentum","text":"Nesterov Momentum optimizer.","title":"NesterovMomentum"},{"location":"api/optim/NesterovMomentum/#parameters","text":"lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9","title":"Parameters"},{"location":"api/optim/NesterovMomentum/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/NesterovMomentum/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . NesterovMomentum () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 84.29 %","title":"Examples"},{"location":"api/optim/NesterovMomentum/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/RMSProp/","text":"RMSProp \u00b6 RMSProp optimizer. Parameters \u00b6 lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 eps \u2013 defaults to 1e-08 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . RMSProp () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.24 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Divide the gradient by a running average of itsrecent magnitude \u21a9","title":"RMSProp"},{"location":"api/optim/RMSProp/#rmsprop","text":"RMSProp optimizer.","title":"RMSProp"},{"location":"api/optim/RMSProp/#parameters","text":"lr \u2013 defaults to 0.1 rho \u2013 defaults to 0.9 eps \u2013 defaults to 1e-08","title":"Parameters"},{"location":"api/optim/RMSProp/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/RMSProp/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . RMSProp () >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.24 %","title":"Examples"},{"location":"api/optim/RMSProp/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/RMSProp/#references","text":"Divide the gradient by a running average of itsrecent magnitude \u21a9","title":"References"},{"location":"api/optim/SGD/","text":"SGD \u00b6 Plain stochastic gradient descent. Parameters \u00b6 lr \u2013 defaults to 0.01 Attributes \u00b6 learning_rate Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . SGD ( 0.1 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.85 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights. References \u00b6 Robbins, H. and Monro, S., 1951. A stochastic approximation method. The annals of mathematical statistics, pp.400-407 \u21a9","title":"SGD"},{"location":"api/optim/SGD/#sgd","text":"Plain stochastic gradient descent.","title":"SGD"},{"location":"api/optim/SGD/#parameters","text":"lr \u2013 defaults to 0.01","title":"Parameters"},{"location":"api/optim/SGD/#attributes","text":"learning_rate","title":"Attributes"},{"location":"api/optim/SGD/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> dataset = datasets . Phishing () >>> optimizer = optim . SGD ( 0.1 ) >>> model = ( ... preprocessing . StandardScaler () | ... linear_model . LogisticRegression ( optimizer ) ... ) >>> metric = metrics . F1 () >>> evaluate . progressive_val_score ( dataset , model , metric ) F1 : 87.85 %","title":"Examples"},{"location":"api/optim/SGD/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/SGD/#references","text":"Robbins, H. and Monro, S., 1951. A stochastic approximation method. The annals of mathematical statistics, pp.400-407 \u21a9","title":"References"},{"location":"api/optim/base/Initializer/","text":"Initializer \u00b6 An initializer is used to set initial weights in a model. Methods \u00b6 call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Initializer"},{"location":"api/optim/base/Initializer/#initializer","text":"An initializer is used to set initial weights in a model.","title":"Initializer"},{"location":"api/optim/base/Initializer/#methods","text":"call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/optim/base/Loss/","text":"Loss \u00b6 Base class for all loss functions. Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Loss"},{"location":"api/optim/base/Loss/#loss","text":"Base class for all loss functions.","title":"Loss"},{"location":"api/optim/base/Loss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/base/Optimizer/","text":"Optimizer \u00b6 Optimizer interface. Every optimizer inherits from this base interface. Parameters \u00b6 lr ( Union[ optim.base.Scheduler , float] ) Attributes \u00b6 learning_rate ( float ) Returns the current learning rate value. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Optimizer"},{"location":"api/optim/base/Optimizer/#optimizer","text":"Optimizer interface. Every optimizer inherits from this base interface.","title":"Optimizer"},{"location":"api/optim/base/Optimizer/#parameters","text":"lr ( Union[ optim.base.Scheduler , float] )","title":"Parameters"},{"location":"api/optim/base/Optimizer/#attributes","text":"learning_rate ( float ) Returns the current learning rate value.","title":"Attributes"},{"location":"api/optim/base/Optimizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. look_ahead Updates a weight vector before a prediction is made. Parameters: w (dict): A dictionary of weight parameters. The weights are modified in-place. Returns: The updated weights. Parameters w ( dict ) step Updates a weight vector given a gradient. Parameters w ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) g ( Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] ) Returns typing.Union[dict, river.utils.vectordict.VectorDict, numpy.ndarray] : The updated weights.","title":"Methods"},{"location":"api/optim/base/Scheduler/","text":"Scheduler \u00b6 Can be used to program the learning rate schedule of an optim.base.Optimizer . Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Scheduler"},{"location":"api/optim/base/Scheduler/#scheduler","text":"Can be used to program the learning rate schedule of an optim.base.Optimizer .","title":"Scheduler"},{"location":"api/optim/base/Scheduler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/optim/initializers/Constant/","text":"Constant \u00b6 Constant initializer which always returns the same value. Parameters \u00b6 value ( float ) Examples \u00b6 >>> from river import optim >>> init = optim . initializers . Constant ( value = 3.14 ) >>> init ( shape = 1 ) 3.14 >>> init ( shape = 2 ) array ([ 3.14 , 3.14 ]) Methods \u00b6 call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Constant"},{"location":"api/optim/initializers/Constant/#constant","text":"Constant initializer which always returns the same value.","title":"Constant"},{"location":"api/optim/initializers/Constant/#parameters","text":"value ( float )","title":"Parameters"},{"location":"api/optim/initializers/Constant/#examples","text":">>> from river import optim >>> init = optim . initializers . Constant ( value = 3.14 ) >>> init ( shape = 1 ) 3.14 >>> init ( shape = 2 ) array ([ 3.14 , 3.14 ])","title":"Examples"},{"location":"api/optim/initializers/Constant/#methods","text":"call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/optim/initializers/Normal/","text":"Normal \u00b6 Random normal initializer which simulate a normal distribution with specified parameters. Parameters \u00b6 mu \u2013 defaults to 0.0 The mean of the normal distribution sigma \u2013 defaults to 1.0 The standard deviation of the normal distribution seed \u2013 defaults to None Random number generation seed that can be set for reproducibility. Examples \u00b6 >>> from river import optim >>> init = optim . initializers . Normal ( mu = 0 , sigma = 1 , seed = 42 ) >>> init ( shape = 1 ) 0.496714 >>> init ( shape = 2 ) array ([ - 0.1382643 , 0.64768854 ]) Methods \u00b6 call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Normal"},{"location":"api/optim/initializers/Normal/#normal","text":"Random normal initializer which simulate a normal distribution with specified parameters.","title":"Normal"},{"location":"api/optim/initializers/Normal/#parameters","text":"mu \u2013 defaults to 0.0 The mean of the normal distribution sigma \u2013 defaults to 1.0 The standard deviation of the normal distribution seed \u2013 defaults to None Random number generation seed that can be set for reproducibility.","title":"Parameters"},{"location":"api/optim/initializers/Normal/#examples","text":">>> from river import optim >>> init = optim . initializers . Normal ( mu = 0 , sigma = 1 , seed = 42 ) >>> init ( shape = 1 ) 0.496714 >>> init ( shape = 2 ) array ([ - 0.1382643 , 0.64768854 ])","title":"Examples"},{"location":"api/optim/initializers/Normal/#methods","text":"call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/optim/initializers/Zeros/","text":"Zeros \u00b6 Constant initializer which always returns zeros. Examples \u00b6 >>> from river import optim >>> init = optim . initializers . Zeros () >>> init ( shape = 1 ) 0.0 >>> init ( shape = 2 ) array ([ 0. , 0. ]) Methods \u00b6 call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Zeros"},{"location":"api/optim/initializers/Zeros/#zeros","text":"Constant initializer which always returns zeros.","title":"Zeros"},{"location":"api/optim/initializers/Zeros/#examples","text":">>> from river import optim >>> init = optim . initializers . Zeros () >>> init ( shape = 1 ) 0.0 >>> init ( shape = 2 ) array ([ 0. , 0. ])","title":"Examples"},{"location":"api/optim/initializers/Zeros/#methods","text":"call Returns a fresh set of weights. Parameters shape \u2013 defaults to 1 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.","title":"Methods"},{"location":"api/optim/losses/Absolute/","text":"Absolute \u00b6 Absolute loss, also known as the mean absolute error or L1 loss. Mathematically, it is defined as \\[L = |p_i - y_i|\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = sgn(p_i - y_i)\\] Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Absolute () >>> loss ( - 42 , 42 ) 84 >>> loss . gradient ( 1 , 2 ) 1 >>> loss . gradient ( 2 , 1 ) - 1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Absolute"},{"location":"api/optim/losses/Absolute/#absolute","text":"Absolute loss, also known as the mean absolute error or L1 loss. Mathematically, it is defined as \\[L = |p_i - y_i|\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = sgn(p_i - y_i)\\]","title":"Absolute"},{"location":"api/optim/losses/Absolute/#examples","text":">>> from river import optim >>> loss = optim . losses . Absolute () >>> loss ( - 42 , 42 ) 84 >>> loss . gradient ( 1 , 2 ) 1 >>> loss . gradient ( 2 , 1 ) - 1","title":"Examples"},{"location":"api/optim/losses/Absolute/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/BinaryFocalLoss/","text":"BinaryFocalLoss \u00b6 Binary focal loss. This implements the \"star\" algorithm from the appendix of the focal loss paper. Parameters \u00b6 gamma \u2013 defaults to 2 beta \u2013 defaults to 1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 Lin, T.Y., Goyal, P., Girshick, R., He, K. and Doll\u00e1r, P., 2017. Focal loss for dense object detection. In Proceedings of the IEEE international conference on computer vision (pp. 2980-2988)","title":"BinaryFocalLoss"},{"location":"api/optim/losses/BinaryFocalLoss/#binaryfocalloss","text":"Binary focal loss. This implements the \"star\" algorithm from the appendix of the focal loss paper.","title":"BinaryFocalLoss"},{"location":"api/optim/losses/BinaryFocalLoss/#parameters","text":"gamma \u2013 defaults to 2 beta \u2013 defaults to 1","title":"Parameters"},{"location":"api/optim/losses/BinaryFocalLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/BinaryFocalLoss/#references","text":"Lin, T.Y., Goyal, P., Girshick, R., He, K. and Doll\u00e1r, P., 2017. Focal loss for dense object detection. In Proceedings of the IEEE international conference on computer vision (pp. 2980-2988)","title":"References"},{"location":"api/optim/losses/BinaryLoss/","text":"BinaryLoss \u00b6 A loss appropriate for binary classification tasks. Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"BinaryLoss"},{"location":"api/optim/losses/BinaryLoss/#binaryloss","text":"A loss appropriate for binary classification tasks.","title":"BinaryLoss"},{"location":"api/optim/losses/BinaryLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Cauchy/","text":"Cauchy \u00b6 Cauchy loss function. Parameters \u00b6 C \u2013 defaults to 80 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 \"Effect of MAE\" Kaggle discussion \u21a9 Paris Madness Kaggle kernel \u21a9","title":"Cauchy"},{"location":"api/optim/losses/Cauchy/#cauchy","text":"Cauchy loss function.","title":"Cauchy"},{"location":"api/optim/losses/Cauchy/#parameters","text":"C \u2013 defaults to 80","title":"Parameters"},{"location":"api/optim/losses/Cauchy/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Cauchy/#references","text":"\"Effect of MAE\" Kaggle discussion \u21a9 Paris Madness Kaggle kernel \u21a9","title":"References"},{"location":"api/optim/losses/CrossEntropy/","text":"CrossEntropy \u00b6 Cross entropy loss. This is a generalization of logistic loss to multiple classes. Parameters \u00b6 class_weight ( Dict[Union[bool, str, int], float] ) \u2013 defaults to None A dictionary that indicates what weight to associate with each class. Examples \u00b6 >>> from river import optim >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> loss = optim . losses . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss ( yt , yp )) 1.222454 1.116929 1.437209 1.509797 >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss . gradient ( yt , yp )) { 0 : - 0.70549363 , 1 : 0.34216758 , 2 : 0.36332605 } { 0 : 0.21290077 , 1 : - 0.67271668 , 2 : 0.45981591 } { 0 : 0.42860913 , 1 : 0.33380113 , 2 : - 0.76241026 } { 0 : 0.44941979 , 1 : 0.32962558 , 2 : - 0.77904537 } Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 What is Softmax regression and how is it related to Logistic regression? \u21a9","title":"CrossEntropy"},{"location":"api/optim/losses/CrossEntropy/#crossentropy","text":"Cross entropy loss. This is a generalization of logistic loss to multiple classes.","title":"CrossEntropy"},{"location":"api/optim/losses/CrossEntropy/#parameters","text":"class_weight ( Dict[Union[bool, str, int], float] ) \u2013 defaults to None A dictionary that indicates what weight to associate with each class.","title":"Parameters"},{"location":"api/optim/losses/CrossEntropy/#examples","text":">>> from river import optim >>> y_true = [ 0 , 1 , 2 , 2 ] >>> y_pred = [ ... { 0 : 0.29450637 , 1 : 0.34216758 , 2 : 0.36332605 }, ... { 0 : 0.21290077 , 1 : 0.32728332 , 2 : 0.45981591 }, ... { 0 : 0.42860913 , 1 : 0.33380113 , 2 : 0.23758974 }, ... { 0 : 0.44941979 , 1 : 0.32962558 , 2 : 0.22095463 } ... ] >>> loss = optim . losses . CrossEntropy () >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss ( yt , yp )) 1.222454 1.116929 1.437209 1.509797 >>> for yt , yp in zip ( y_true , y_pred ): ... print ( loss . gradient ( yt , yp )) { 0 : - 0.70549363 , 1 : 0.34216758 , 2 : 0.36332605 } { 0 : 0.21290077 , 1 : - 0.67271668 , 2 : 0.45981591 } { 0 : 0.42860913 , 1 : 0.33380113 , 2 : - 0.76241026 } { 0 : 0.44941979 , 1 : 0.32962558 , 2 : - 0.77904537 }","title":"Examples"},{"location":"api/optim/losses/CrossEntropy/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/CrossEntropy/#references","text":"What is Softmax regression and how is it related to Logistic regression? \u21a9","title":"References"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/","text":"EpsilonInsensitiveHinge \u00b6 Epsilon-insensitive hinge loss. Parameters \u00b6 eps \u2013 defaults to 0.1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"EpsilonInsensitiveHinge"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#epsiloninsensitivehinge","text":"Epsilon-insensitive hinge loss.","title":"EpsilonInsensitiveHinge"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#parameters","text":"eps \u2013 defaults to 0.1","title":"Parameters"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Hinge/","text":"Hinge \u00b6 Computes the hinge loss. Mathematically, it is defined as \\[L = max(0, 1 - p_i * y_i)\\] It's gradient w.r.t. to \\(p_i\\) is \\[ \\\\frac{\\\\partial L}{\\\\partial y_i} = \\\\left\\{ \\\\begin{array}{ll} \\\\ 0 & p_iy_i \\geqslant 1 \\\\\\\\ \\\\ - y_i & p_iy_i < 1 \\\\end{array} \\\\right. \\] Parameters \u00b6 threshold \u2013 defaults to 1.0 Margin threshold. 1 yield the loss used in SVMs, whilst 0 is equivalent to the loss used in the Perceptron algorithm. Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Hinge ( threshold = 1 ) >>> loss ( 1 , .2 ) 0.8 >>> loss . gradient ( 1 , .2 ) - 1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Hinge"},{"location":"api/optim/losses/Hinge/#hinge","text":"Computes the hinge loss. Mathematically, it is defined as \\[L = max(0, 1 - p_i * y_i)\\] It's gradient w.r.t. to \\(p_i\\) is \\[ \\\\frac{\\\\partial L}{\\\\partial y_i} = \\\\left\\{ \\\\begin{array}{ll} \\\\ 0 & p_iy_i \\geqslant 1 \\\\\\\\ \\\\ - y_i & p_iy_i < 1 \\\\end{array} \\\\right. \\]","title":"Hinge"},{"location":"api/optim/losses/Hinge/#parameters","text":"threshold \u2013 defaults to 1.0 Margin threshold. 1 yield the loss used in SVMs, whilst 0 is equivalent to the loss used in the Perceptron algorithm.","title":"Parameters"},{"location":"api/optim/losses/Hinge/#examples","text":">>> from river import optim >>> loss = optim . losses . Hinge ( threshold = 1 ) >>> loss ( 1 , .2 ) 0.8 >>> loss . gradient ( 1 , .2 ) - 1","title":"Examples"},{"location":"api/optim/losses/Hinge/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Huber/","text":"Huber \u00b6 Huber loss. Variant of the squared loss that is robust to outliers. Parameters \u00b6 epsilon \u2013 defaults to 0.1 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 Huber loss function - Wikipedia","title":"Huber"},{"location":"api/optim/losses/Huber/#huber","text":"Huber loss. Variant of the squared loss that is robust to outliers.","title":"Huber"},{"location":"api/optim/losses/Huber/#parameters","text":"epsilon \u2013 defaults to 0.1","title":"Parameters"},{"location":"api/optim/losses/Huber/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Huber/#references","text":"Huber loss function - Wikipedia","title":"References"},{"location":"api/optim/losses/Log/","text":"Log \u00b6 Logarithmic loss. This loss function expects each provided y_pred to be a logit. In other words if must be the raw output of a linear model or a neural network. Parameters \u00b6 weight_pos \u2013 defaults to 1.0 weight_neg \u2013 defaults to 1.0 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 Logit Wikipedia page \u21a9","title":"Log"},{"location":"api/optim/losses/Log/#log","text":"Logarithmic loss. This loss function expects each provided y_pred to be a logit. In other words if must be the raw output of a linear model or a neural network.","title":"Log"},{"location":"api/optim/losses/Log/#parameters","text":"weight_pos \u2013 defaults to 1.0 weight_neg \u2013 defaults to 1.0","title":"Parameters"},{"location":"api/optim/losses/Log/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Log/#references","text":"Logit Wikipedia page \u21a9","title":"References"},{"location":"api/optim/losses/MultiClassLoss/","text":"MultiClassLoss \u00b6 A loss appropriate for multi-class classification tasks. Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"MultiClassLoss"},{"location":"api/optim/losses/MultiClassLoss/#multiclassloss","text":"A loss appropriate for multi-class classification tasks.","title":"MultiClassLoss"},{"location":"api/optim/losses/MultiClassLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Poisson/","text":"Poisson \u00b6 Poisson loss. The Poisson loss is usually more suited for regression with count data than the squared loss. Mathematically, it is defined as \\[L = exp(p_i) - y_i \\times p_i\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = exp(p_i) - y_i\\] Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Poisson"},{"location":"api/optim/losses/Poisson/#poisson","text":"Poisson loss. The Poisson loss is usually more suited for regression with count data than the squared loss. Mathematically, it is defined as \\[L = exp(p_i) - y_i \\times p_i\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = exp(p_i) - y_i\\]","title":"Poisson"},{"location":"api/optim/losses/Poisson/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Quantile/","text":"Quantile \u00b6 Quantile loss. Parameters \u00b6 alpha \u2013 defaults to 0.5 Desired quantile to attain. Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Quantile ( 0.5 ) >>> loss ( 1 , 3 ) 1.0 >>> loss . gradient ( 1 , 3 ) 0.5 >>> loss . gradient ( 3 , 1 ) - 0.5 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s). References \u00b6 Wikipedia article on quantile regression \u21a9 Derivative from WolframAlpha \u21a9","title":"Quantile"},{"location":"api/optim/losses/Quantile/#quantile","text":"Quantile loss.","title":"Quantile"},{"location":"api/optim/losses/Quantile/#parameters","text":"alpha \u2013 defaults to 0.5 Desired quantile to attain.","title":"Parameters"},{"location":"api/optim/losses/Quantile/#examples","text":">>> from river import optim >>> loss = optim . losses . Quantile ( 0.5 ) >>> loss ( 1 , 3 ) 1.0 >>> loss . gradient ( 1 , 3 ) 0.5 >>> loss . gradient ( 3 , 1 ) - 0.5","title":"Examples"},{"location":"api/optim/losses/Quantile/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Quantile/#references","text":"Wikipedia article on quantile regression \u21a9 Derivative from WolframAlpha \u21a9","title":"References"},{"location":"api/optim/losses/RegressionLoss/","text":"RegressionLoss \u00b6 A loss appropriate for regression tasks. Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"RegressionLoss"},{"location":"api/optim/losses/RegressionLoss/#regressionloss","text":"A loss appropriate for regression tasks.","title":"RegressionLoss"},{"location":"api/optim/losses/RegressionLoss/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/losses/Squared/","text":"Squared \u00b6 Squared loss, also known as the L2 loss. Mathematically, it is defined as \\[L = (p_i - y_i) ^ 2\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = 2 imes (p_i - y_i)\\] One thing to note is that this convention is consistent with Vowpal Wabbit and PyTorch, but not with scikit-learn. Indeed, scikit-learn divides the loss by 2, making the 2 disappear in the gradient. Examples \u00b6 >>> from river import optim >>> loss = optim . losses . Squared () >>> loss ( - 4 , 5 ) 81 >>> loss . gradient ( - 4 , 5 ) 18 >>> loss . gradient ( 5 , - 4 ) - 18 Methods \u00b6 call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Squared"},{"location":"api/optim/losses/Squared/#squared","text":"Squared loss, also known as the L2 loss. Mathematically, it is defined as \\[L = (p_i - y_i) ^ 2\\] It's gradient w.r.t. to \\(p_i\\) is \\[\\frac{\\partial L}{\\partial p_i} = 2 imes (p_i - y_i)\\] One thing to note is that this convention is consistent with Vowpal Wabbit and PyTorch, but not with scikit-learn. Indeed, scikit-learn divides the loss by 2, making the 2 disappear in the gradient.","title":"Squared"},{"location":"api/optim/losses/Squared/#examples","text":">>> from river import optim >>> loss = optim . losses . Squared () >>> loss ( - 4 , 5 ) 81 >>> loss . gradient ( - 4 , 5 ) 18 >>> loss . gradient ( 5 , - 4 ) - 18","title":"Examples"},{"location":"api/optim/losses/Squared/#methods","text":"call Returns the loss. Parameters y_true y_pred Returns The loss(es). clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. gradient Return the gradient with respect to y_pred. Parameters y_true y_pred Returns The gradient(s). mean_func Mean function. This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability. Parameters y_pred Returns The adjusted prediction(s).","title":"Methods"},{"location":"api/optim/schedulers/Constant/","text":"Constant \u00b6 Always uses the same learning rate. Parameters \u00b6 learning_rate ( float ) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Constant"},{"location":"api/optim/schedulers/Constant/#constant","text":"Always uses the same learning rate.","title":"Constant"},{"location":"api/optim/schedulers/Constant/#parameters","text":"learning_rate ( float )","title":"Parameters"},{"location":"api/optim/schedulers/Constant/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/optim/schedulers/InverseScaling/","text":"InverseScaling \u00b6 Reduces the learning rate using a power schedule. Assuming an initial learning rate \\(\\eta\\) , the learning rate at step \\(t\\) is: \\[\\\\frac{eta}{(t + 1) ^ p}\\] where \\(p\\) is a user-defined parameter. Parameters \u00b6 learning_rate ( float ) power \u2013 defaults to 0.5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"InverseScaling"},{"location":"api/optim/schedulers/InverseScaling/#inversescaling","text":"Reduces the learning rate using a power schedule. Assuming an initial learning rate \\(\\eta\\) , the learning rate at step \\(t\\) is: \\[\\\\frac{eta}{(t + 1) ^ p}\\] where \\(p\\) is a user-defined parameter.","title":"InverseScaling"},{"location":"api/optim/schedulers/InverseScaling/#parameters","text":"learning_rate ( float ) power \u2013 defaults to 0.5","title":"Parameters"},{"location":"api/optim/schedulers/InverseScaling/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/optim/schedulers/Optimal/","text":"Optimal \u00b6 Optimal learning schedule as proposed by L\u00e9on Bottou. Parameters \u00b6 loss ( optim.base.Loss ) alpha \u2013 defaults to 0.0001 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int ) References \u00b6 Bottou, L., 2012. Stochastic gradient descent tricks. In Neural networks: Tricks of the trade (pp. 421-436). Springer, Berlin, Heidelberg. \u21a9","title":"Optimal"},{"location":"api/optim/schedulers/Optimal/#optimal","text":"Optimal learning schedule as proposed by L\u00e9on Bottou.","title":"Optimal"},{"location":"api/optim/schedulers/Optimal/#parameters","text":"loss ( optim.base.Loss ) alpha \u2013 defaults to 0.0001","title":"Parameters"},{"location":"api/optim/schedulers/Optimal/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Returns the learning rate at a given iteration. Parameters t ( int )","title":"Methods"},{"location":"api/optim/schedulers/Optimal/#references","text":"Bottou, L., 2012. Stochastic gradient descent tricks. In Neural networks: Tricks of the trade (pp. 421-436). Springer, Berlin, Heidelberg. \u21a9","title":"References"},{"location":"api/preprocessing/AdaptiveStandardScaler/","text":"AdaptiveStandardScaler \u00b6 Scales data using exponentially weighted moving average and variance. Under the hood, a exponentially weighted running mean and variance are maintained for each feature. This can potentially provide better results for drifting data in comparison to preprocessing.StandardScaler . Indeed, the latter computes a global mean and variance for each feature, whereas this scaler weights data in proportion to their recency. Parameters \u00b6 alpha \u2013 defaults to 0.3 This parameter is passed to stats.EWVar . It is expected to be in [0, 1]. More weight is assigned to recent samples the closer alpha is to 1. Examples \u00b6 Consider the following series which contains a positive trend. >>> import random >>> random . seed ( 42 ) >>> X = [ ... { 'x' : random . uniform ( 4 + i , 6 + i )} ... for i in range ( 8 ) ... ] >>> for x in X : ... print ( x ) { 'x' : 5.278 } { 'x' : 5.050 } { 'x' : 6.550 } { 'x' : 7.446 } { 'x' : 9.472 } { 'x' : 10.353 } { 'x' : 11.784 } { 'x' : 11.173 } This scaler works well with this kind of data because it uses statistics that assign higher weight to more recent data. >>> from river import preprocessing >>> scaler = preprocessing . AdaptiveStandardScaler ( alpha = .6 ) >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 0.816 } { 'x' : 0.812 } { 'x' : 0.695 } { 'x' : 0.754 } { 'x' : 0.598 } { 'x' : 0.651 } { 'x' : 0.124 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"AdaptiveStandardScaler"},{"location":"api/preprocessing/AdaptiveStandardScaler/#adaptivestandardscaler","text":"Scales data using exponentially weighted moving average and variance. Under the hood, a exponentially weighted running mean and variance are maintained for each feature. This can potentially provide better results for drifting data in comparison to preprocessing.StandardScaler . Indeed, the latter computes a global mean and variance for each feature, whereas this scaler weights data in proportion to their recency.","title":"AdaptiveStandardScaler"},{"location":"api/preprocessing/AdaptiveStandardScaler/#parameters","text":"alpha \u2013 defaults to 0.3 This parameter is passed to stats.EWVar . It is expected to be in [0, 1]. More weight is assigned to recent samples the closer alpha is to 1.","title":"Parameters"},{"location":"api/preprocessing/AdaptiveStandardScaler/#examples","text":"Consider the following series which contains a positive trend. >>> import random >>> random . seed ( 42 ) >>> X = [ ... { 'x' : random . uniform ( 4 + i , 6 + i )} ... for i in range ( 8 ) ... ] >>> for x in X : ... print ( x ) { 'x' : 5.278 } { 'x' : 5.050 } { 'x' : 6.550 } { 'x' : 7.446 } { 'x' : 9.472 } { 'x' : 10.353 } { 'x' : 11.784 } { 'x' : 11.173 } This scaler works well with this kind of data because it uses statistics that assign higher weight to more recent data. >>> from river import preprocessing >>> scaler = preprocessing . AdaptiveStandardScaler ( alpha = .6 ) >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 0.816 } { 'x' : 0.812 } { 'x' : 0.695 } { 'x' : 0.754 } { 'x' : 0.598 } { 'x' : 0.651 } { 'x' : 0.124 }","title":"Examples"},{"location":"api/preprocessing/AdaptiveStandardScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/Binarizer/","text":"Binarizer \u00b6 Binarizes the data to 0 or 1 according to a threshold. Parameters \u00b6 threshold \u2013 defaults to 0.0 Values above this are replaced by 1 and the others by 0. dtype \u2013 defaults to <class 'bool'> The desired data type to apply. Examples \u00b6 >>> import river >>> import numpy as np >>> rng = np . random . RandomState ( 42 ) >>> X = [{ 'x1' : v , 'x2' : int ( v )} for v in rng . uniform ( low =- 4 , high = 4 , size = 6 )] >>> binarizer = river . preprocessing . Binarizer () >>> for x in X : ... print ( binarizer . learn_one ( x ) . transform_one ( x )) { 'x1' : False , 'x2' : False } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : False } { 'x1' : False , 'x2' : False } { 'x1' : False , 'x2' : False } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Binarizer"},{"location":"api/preprocessing/Binarizer/#binarizer","text":"Binarizes the data to 0 or 1 according to a threshold.","title":"Binarizer"},{"location":"api/preprocessing/Binarizer/#parameters","text":"threshold \u2013 defaults to 0.0 Values above this are replaced by 1 and the others by 0. dtype \u2013 defaults to <class 'bool'> The desired data type to apply.","title":"Parameters"},{"location":"api/preprocessing/Binarizer/#examples","text":">>> import river >>> import numpy as np >>> rng = np . random . RandomState ( 42 ) >>> X = [{ 'x1' : v , 'x2' : int ( v )} for v in rng . uniform ( low =- 4 , high = 4 , size = 6 )] >>> binarizer = river . preprocessing . Binarizer () >>> for x in X : ... print ( binarizer . learn_one ( x ) . transform_one ( x )) { 'x1' : False , 'x2' : False } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : True } { 'x1' : True , 'x2' : False } { 'x1' : False , 'x2' : False } { 'x1' : False , 'x2' : False }","title":"Examples"},{"location":"api/preprocessing/Binarizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/FeatureHasher/","text":"FeatureHasher \u00b6 Implements the hashing trick. Each pair of (name, value) features is hashed into a random integer. A module operator is then used to make sure the hash is in a certain range. We use the Murmurhash implementation from scikit-learn. Parameters \u00b6 n_features \u2013 defaults to 1048576 The number by which each hash will be moduloed by. seed ( int ) \u2013 defaults to None Set the seed to produce identical results. Examples \u00b6 >>> import river >>> hasher = river . preprocessing . FeatureHasher ( n_features = 10 , seed = 42 ) >>> X = [ ... { 'dog' : 1 , 'cat' : 2 , 'elephant' : 4 }, ... { 'dog' : 2 , 'run' : 5 } ... ] >>> for x in X : ... print ( hasher . transform_one ( x )) Counter ({ 1 : 4 , 9 : 2 , 8 : 1 }) Counter ({ 4 : 5 , 8 : 2 }) Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Wikipedia article on feature vectorization using the hashing trick \u21a9","title":"FeatureHasher"},{"location":"api/preprocessing/FeatureHasher/#featurehasher","text":"Implements the hashing trick. Each pair of (name, value) features is hashed into a random integer. A module operator is then used to make sure the hash is in a certain range. We use the Murmurhash implementation from scikit-learn.","title":"FeatureHasher"},{"location":"api/preprocessing/FeatureHasher/#parameters","text":"n_features \u2013 defaults to 1048576 The number by which each hash will be moduloed by. seed ( int ) \u2013 defaults to None Set the seed to produce identical results.","title":"Parameters"},{"location":"api/preprocessing/FeatureHasher/#examples","text":">>> import river >>> hasher = river . preprocessing . FeatureHasher ( n_features = 10 , seed = 42 ) >>> X = [ ... { 'dog' : 1 , 'cat' : 2 , 'elephant' : 4 }, ... { 'dog' : 2 , 'run' : 5 } ... ] >>> for x in X : ... print ( hasher . transform_one ( x )) Counter ({ 1 : 4 , 9 : 2 , 8 : 1 }) Counter ({ 4 : 5 , 8 : 2 })","title":"Examples"},{"location":"api/preprocessing/FeatureHasher/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/FeatureHasher/#references","text":"Wikipedia article on feature vectorization using the hashing trick \u21a9","title":"References"},{"location":"api/preprocessing/LDA/","text":"LDA \u00b6 Online Latent Dirichlet Allocation with Infinite Vocabulary. Latent Dirichlet allocation (LDA) is a probabilistic approach for exploring topics in document collections. The key advantage of this variant is that it assumes an infinite vocabulary, meaning that the set of tokens does not have to known in advance, as opposed to the implementation from sklearn The results produced by this implementation are identical to those from the original implementation proposed by the method's authors. This class takes as input token counts. Therefore, it requires you to tokenize beforehand. You can do so by using a feature_extraction.BagOfWords instance, as shown in the example below. Parameters \u00b6 n_components \u2013 defaults to 10 Number of topics of the latent Drichlet allocation. number_of_documents \u2013 defaults to 1000000.0 Estimated number of documents. alpha_theta \u2013 defaults to 0.5 Hyper-parameter of the Dirichlet distribution of topics. alpha_beta \u2013 defaults to 100.0 Hyper-parameter of the Dirichlet process of distribution over words. tau \u2013 defaults to 64.0 Learning inertia to prevent premature convergence. kappa \u2013 defaults to 0.75 The learning rate kappa controls how quickly new parameters estimates replace the old ones. kappa \u2208 (0.5, 1] is required for convergence. vocab_prune_interval \u2013 defaults to 10 Interval at which to refresh the words topics distribution. number_of_samples \u2013 defaults to 10 Number of iteration to computes documents topics distribution. ranking_smooth_factor \u2013 defaults to 1e-12 burn_in_sweeps \u2013 defaults to 5 Number of iteration necessaries while analyzing a document before updating document topics distribution. maximum_size_vocabulary \u2013 defaults to 4000 Maximum size of the stored vocabulary. seed ( int ) \u2013 defaults to None Random number seed used for reproducibility. Attributes \u00b6 counter ( int ) The current number of observed documents. truncation_size_prime ( int ) Number of distincts words stored in the vocabulary. Updated before processing a document. truncation_size ( int ) Number of distincts words stored in the vocabulary. Updated after processing a document. word_to_index ( dict ) Words as keys and indexes as values. index_to_word ( dict ) Indexes as keys and words as values. nu_1 ( dict ) Weights of the words. Component of the variational inference. nu_2 ( dict ) Weights of the words. Component of the variational inference. Examples \u00b6 >>> from river import compose >>> from river import feature_extraction >>> from river import preprocessing >>> X = [ ... 'weather cold' , ... 'weather hot dry' , ... 'weather cold rainy' , ... 'weather hot' , ... 'weather cold humid' , ... ] >>> lda = compose . Pipeline ( ... feature_extraction . BagOfWords (), ... preprocessing . LDA ( ... n_components = 2 , ... number_of_documents = 60 , ... seed = 42 ... ) ... ) >>> for x in X : ... lda = lda . learn_one ( x ) ... topics = lda . transform_one ( x ) ... print ( topics ) { 0 : 0.5 , 1 : 2.5 } { 0 : 1.5 , 1 : 2.5 } { 0 : 3.5 , 1 : 0.5 } { 0 : 1.5 , 1 : 1.5 } { 0 : 2.5 , 1 : 1.5 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self learn_transform_one Equivalent to lda.learn_one(x).transform_one(x) s, but faster. Parameters x ( dict ) Returns dict : Component attributions for the input document. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Zhai, K. and Boyd-Graber, J., 2013, February. Online latent Dirichlet allocation with infinite vocabulary. In International Conference on Machine Learning (pp. 561-569). \u21a9 PyInfVoc on GitHub \u21a9","title":"LDA"},{"location":"api/preprocessing/LDA/#lda","text":"Online Latent Dirichlet Allocation with Infinite Vocabulary. Latent Dirichlet allocation (LDA) is a probabilistic approach for exploring topics in document collections. The key advantage of this variant is that it assumes an infinite vocabulary, meaning that the set of tokens does not have to known in advance, as opposed to the implementation from sklearn The results produced by this implementation are identical to those from the original implementation proposed by the method's authors. This class takes as input token counts. Therefore, it requires you to tokenize beforehand. You can do so by using a feature_extraction.BagOfWords instance, as shown in the example below.","title":"LDA"},{"location":"api/preprocessing/LDA/#parameters","text":"n_components \u2013 defaults to 10 Number of topics of the latent Drichlet allocation. number_of_documents \u2013 defaults to 1000000.0 Estimated number of documents. alpha_theta \u2013 defaults to 0.5 Hyper-parameter of the Dirichlet distribution of topics. alpha_beta \u2013 defaults to 100.0 Hyper-parameter of the Dirichlet process of distribution over words. tau \u2013 defaults to 64.0 Learning inertia to prevent premature convergence. kappa \u2013 defaults to 0.75 The learning rate kappa controls how quickly new parameters estimates replace the old ones. kappa \u2208 (0.5, 1] is required for convergence. vocab_prune_interval \u2013 defaults to 10 Interval at which to refresh the words topics distribution. number_of_samples \u2013 defaults to 10 Number of iteration to computes documents topics distribution. ranking_smooth_factor \u2013 defaults to 1e-12 burn_in_sweeps \u2013 defaults to 5 Number of iteration necessaries while analyzing a document before updating document topics distribution. maximum_size_vocabulary \u2013 defaults to 4000 Maximum size of the stored vocabulary. seed ( int ) \u2013 defaults to None Random number seed used for reproducibility.","title":"Parameters"},{"location":"api/preprocessing/LDA/#attributes","text":"counter ( int ) The current number of observed documents. truncation_size_prime ( int ) Number of distincts words stored in the vocabulary. Updated before processing a document. truncation_size ( int ) Number of distincts words stored in the vocabulary. Updated after processing a document. word_to_index ( dict ) Words as keys and indexes as values. index_to_word ( dict ) Indexes as keys and words as values. nu_1 ( dict ) Weights of the words. Component of the variational inference. nu_2 ( dict ) Weights of the words. Component of the variational inference.","title":"Attributes"},{"location":"api/preprocessing/LDA/#examples","text":">>> from river import compose >>> from river import feature_extraction >>> from river import preprocessing >>> X = [ ... 'weather cold' , ... 'weather hot dry' , ... 'weather cold rainy' , ... 'weather hot' , ... 'weather cold humid' , ... ] >>> lda = compose . Pipeline ( ... feature_extraction . BagOfWords (), ... preprocessing . LDA ( ... n_components = 2 , ... number_of_documents = 60 , ... seed = 42 ... ) ... ) >>> for x in X : ... lda = lda . learn_one ( x ) ... topics = lda . transform_one ( x ) ... print ( topics ) { 0 : 0.5 , 1 : 2.5 } { 0 : 1.5 , 1 : 2.5 } { 0 : 3.5 , 1 : 0.5 } { 0 : 1.5 , 1 : 1.5 } { 0 : 2.5 , 1 : 1.5 }","title":"Examples"},{"location":"api/preprocessing/LDA/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self learn_transform_one Equivalent to lda.learn_one(x).transform_one(x) s, but faster. Parameters x ( dict ) Returns dict : Component attributions for the input document. transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/LDA/#references","text":"Zhai, K. and Boyd-Graber, J., 2013, February. Online latent Dirichlet allocation with infinite vocabulary. In International Conference on Machine Learning (pp. 561-569). \u21a9 PyInfVoc on GitHub \u21a9","title":"References"},{"location":"api/preprocessing/MaxAbsScaler/","text":"MaxAbsScaler \u00b6 Scales the data to a [-1, 1] range based on absolute maximum. Under the hood a running absolute max is maintained. This scaler is meant for data that is already centered at zero or sparse data. It does not shift/center the data, and thus does not destroy any sparsity. Attributes \u00b6 abs_max ( dict ) Mapping between features and instances of stats.AbsMax . Examples \u00b6 >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MaxAbsScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 1.0 } { 'x' : 0.767216 } { 'x' : 0.861940 } { 'x' : 0.842308 } { 'x' : 1.0 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"MaxAbsScaler"},{"location":"api/preprocessing/MaxAbsScaler/#maxabsscaler","text":"Scales the data to a [-1, 1] range based on absolute maximum. Under the hood a running absolute max is maintained. This scaler is meant for data that is already centered at zero or sparse data. It does not shift/center the data, and thus does not destroy any sparsity.","title":"MaxAbsScaler"},{"location":"api/preprocessing/MaxAbsScaler/#attributes","text":"abs_max ( dict ) Mapping between features and instances of stats.AbsMax .","title":"Attributes"},{"location":"api/preprocessing/MaxAbsScaler/#examples","text":">>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MaxAbsScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 1.0 } { 'x' : 0.767216 } { 'x' : 0.861940 } { 'x' : 0.842308 } { 'x' : 1.0 }","title":"Examples"},{"location":"api/preprocessing/MaxAbsScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/MinMaxScaler/","text":"MinMaxScaler \u00b6 Scales the data to a fixed range from 0 to 1. Under the hood a running min and a running peak to peak (max - min) are maintained. Attributes \u00b6 min ( dict ) Mapping between features and instances of stats.Min . max ( dict ) Mapping between features and instances of stats.Max . Examples \u00b6 >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MinMaxScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : 0.0 } { 'x' : 0.406920 } { 'x' : 0.322582 } { 'x' : 1.0 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"MinMaxScaler"},{"location":"api/preprocessing/MinMaxScaler/#minmaxscaler","text":"Scales the data to a fixed range from 0 to 1. Under the hood a running min and a running peak to peak (max - min) are maintained.","title":"MinMaxScaler"},{"location":"api/preprocessing/MinMaxScaler/#attributes","text":"min ( dict ) Mapping between features and instances of stats.Min . max ( dict ) Mapping between features and instances of stats.Max .","title":"Attributes"},{"location":"api/preprocessing/MinMaxScaler/#examples","text":">>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> for x in X : ... print ( x ) { 'x' : 10.557707 } { 'x' : 8.100043 } { 'x' : 9.100117 } { 'x' : 8.892842 } { 'x' : 10.945884 } >>> scaler = preprocessing . MinMaxScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : 0.0 } { 'x' : 0.406920 } { 'x' : 0.322582 } { 'x' : 1.0 }","title":"Examples"},{"location":"api/preprocessing/MinMaxScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/Normalizer/","text":"Normalizer \u00b6 Scales a set of features so that it has unit norm. This is particularly useful when used after a feature_extraction.TFIDF . Parameters \u00b6 order \u2013 defaults to 2 Order of the norm (e.g. 2 corresponds to the \\(L^2\\) norm). Examples \u00b6 >>> from river import preprocessing >>> from river import stream >>> scaler = preprocessing . Normalizer ( order = 2 ) >>> X = [[ 4 , 1 , 2 , 2 ], ... [ 1 , 3 , 9 , 3 ], ... [ 5 , 7 , 5 , 1 ]] >>> for x , _ in stream . iter_array ( X ): ... print ( scaler . transform_one ( x )) { 0 : 0.8 , 1 : 0.2 , 2 : 0.4 , 3 : 0.4 } { 0 : 0.1 , 1 : 0.3 , 2 : 0.9 , 3 : 0.3 } { 0 : 0.5 , 1 : 0.7 , 2 : 0.5 , 3 : 0.1 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Normalizer"},{"location":"api/preprocessing/Normalizer/#normalizer","text":"Scales a set of features so that it has unit norm. This is particularly useful when used after a feature_extraction.TFIDF .","title":"Normalizer"},{"location":"api/preprocessing/Normalizer/#parameters","text":"order \u2013 defaults to 2 Order of the norm (e.g. 2 corresponds to the \\(L^2\\) norm).","title":"Parameters"},{"location":"api/preprocessing/Normalizer/#examples","text":">>> from river import preprocessing >>> from river import stream >>> scaler = preprocessing . Normalizer ( order = 2 ) >>> X = [[ 4 , 1 , 2 , 2 ], ... [ 1 , 3 , 9 , 3 ], ... [ 5 , 7 , 5 , 1 ]] >>> for x , _ in stream . iter_array ( X ): ... print ( scaler . transform_one ( x )) { 0 : 0.8 , 1 : 0.2 , 2 : 0.4 , 3 : 0.4 } { 0 : 0.1 , 1 : 0.3 , 2 : 0.9 , 3 : 0.3 } { 0 : 0.5 , 1 : 0.7 , 2 : 0.5 , 3 : 0.1 }","title":"Examples"},{"location":"api/preprocessing/Normalizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) kwargs Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/OneHotEncoder/","text":"OneHotEncoder \u00b6 One-hot encoding. This transformer will encode every feature it is provided with. If a list or set is provided, this transformer will encode every entry in the list/set. You can apply it to a subset of features by composing it with compose.Select or compose.SelectType . Parameters \u00b6 sparse \u2013 defaults to False Whether or not 0s should be made explicit or not. Examples \u00b6 Let us first create an example dataset. >>> from pprint import pprint >>> import random >>> import string >>> random . seed ( 42 ) >>> alphabet = list ( string . ascii_lowercase ) >>> X = [ ... { ... 'c1' : random . choice ( alphabet ), ... 'c2' : random . choice ( alphabet ), ... } ... for _ in range ( 4 ) ... ] >>> pprint ( X ) [{ 'c1' : 'u' , 'c2' : 'd' }, { 'c1' : 'a' , 'c2' : 'x' }, { 'c1' : 'i' , 'c2' : 'h' }, { 'c1' : 'h' , 'c2' : 'e' }] We can now apply one-hot encoding. All the provided are one-hot encoded, there is therefore no need to specify which features to encode. >>> from river import preprocessing >>> oh = preprocessing . OneHotEncoder ( sparse = True ) >>> for x in X : ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c2_x' : 1 } { 'c1_i' : 1 , 'c2_h' : 1 } { 'c1_h' : 1 , 'c2_e' : 1 } The sparse parameter can be set to False in order to include the values that are not present in the output. >>> oh = preprocessing . OneHotEncoder ( sparse = False ) >>> for x in X [: 2 ]: ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2_d' : 0 , 'c2_x' : 1 } A subset of the features can be one-hot encoded by using an instance of compose.Select . >>> from river import compose >>> pp = compose . Select ( 'c1' ) | preprocessing . OneHotEncoder () >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 } You can preserve the c2 feature by using a union: >>> pp = compose . Select ( 'c1' ) | preprocessing . OneHotEncoder () >>> pp += compose . Select ( 'c2' ) >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 , 'c2' : 'd' } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2' : 'x' } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 , 'c2' : 'h' } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 , 'c2' : 'e' } Similar to the above examples, we can also pass values as a list. This will one-hot encode all of the entries individually. >>> X = [{ 'c1' : [ 'u' , 'a' ], 'c2' : [ 'd' ]}, ... { 'c1' : [ 'a' , 'b' ], 'c2' : [ 'x' ]}, ... { 'c1' : [ 'i' ], 'c2' : [ 'h' , 'z' ]}, ... { 'c1' : [ 'h' , 'b' ], 'c2' : [ 'e' ]}] >>> oh = preprocessing . OneHotEncoder ( sparse = True ) >>> for x in X : ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_a' : 1 , 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c1_b' : 1 , 'c2_x' : 1 } { 'c1_i' : 1 , 'c2_h' : 1 , 'c2_z' : 1 } { 'c1_b' : 1 , 'c1_h' : 1 , 'c2_e' : 1 } Processing mini-batches is also possible. >>> from pprint import pprint >>> import random >>> import string >>> random . seed ( 42 ) >>> alphabet = list ( string . ascii_lowercase ) >>> X = pd . DataFrame ( ... { ... 'c1' : random . choice ( alphabet ), ... 'c2' : random . choice ( alphabet ), ... } ... for _ in range ( 4 ) ... ) >>> X c1 c2 0 u d 1 a x 2 i h 3 h e >>> oh = preprocessing . OneHotEncoder ( sparse = True ) >>> oh = oh . learn_many ( X ) >>> df = oh . transform_many ( X ) >>> df . loc [:, sorted ( df . columns )] c1_a c1_h c1_i c1_u c2_d c2_e c2_h c2_x 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 1 2 0 0 1 0 0 0 1 0 3 0 1 0 0 0 1 0 0 Keep in mind that ability for sparse transformations is limited in mini-batch case, which might affect speed/memory footprint of your training loop. Here's a non-sparse example: >>> oh = preprocessing . OneHotEncoder ( sparse = False ) >>> X_init = pd . DataFrame ([{ 'c1' : \"Oranges\" , 'c2' : \"Apples\" }]) >>> oh = oh . learn_many ( X_init ) >>> oh = oh . learn_many ( X ) >>> df = oh . transform_many ( X ) >>> df . loc [:, sorted ( df . columns )] c1_Oranges c1_a c1_h c1_i c1_u c2_Apples c2_d c2_e c2_h c2_x 0 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0 1 0 3 0 0 1 0 0 0 0 1 0 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. A lot of transformers don't actually have to do anything during the learn_many step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_many can override this method. Parameters X ( pandas.core.frame.DataFrame ) Returns Transformer : self learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_many Transform a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A new DataFrame. transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values.","title":"OneHotEncoder"},{"location":"api/preprocessing/OneHotEncoder/#onehotencoder","text":"One-hot encoding. This transformer will encode every feature it is provided with. If a list or set is provided, this transformer will encode every entry in the list/set. You can apply it to a subset of features by composing it with compose.Select or compose.SelectType .","title":"OneHotEncoder"},{"location":"api/preprocessing/OneHotEncoder/#parameters","text":"sparse \u2013 defaults to False Whether or not 0s should be made explicit or not.","title":"Parameters"},{"location":"api/preprocessing/OneHotEncoder/#examples","text":"Let us first create an example dataset. >>> from pprint import pprint >>> import random >>> import string >>> random . seed ( 42 ) >>> alphabet = list ( string . ascii_lowercase ) >>> X = [ ... { ... 'c1' : random . choice ( alphabet ), ... 'c2' : random . choice ( alphabet ), ... } ... for _ in range ( 4 ) ... ] >>> pprint ( X ) [{ 'c1' : 'u' , 'c2' : 'd' }, { 'c1' : 'a' , 'c2' : 'x' }, { 'c1' : 'i' , 'c2' : 'h' }, { 'c1' : 'h' , 'c2' : 'e' }] We can now apply one-hot encoding. All the provided are one-hot encoded, there is therefore no need to specify which features to encode. >>> from river import preprocessing >>> oh = preprocessing . OneHotEncoder ( sparse = True ) >>> for x in X : ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c2_x' : 1 } { 'c1_i' : 1 , 'c2_h' : 1 } { 'c1_h' : 1 , 'c2_e' : 1 } The sparse parameter can be set to False in order to include the values that are not present in the output. >>> oh = preprocessing . OneHotEncoder ( sparse = False ) >>> for x in X [: 2 ]: ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2_d' : 0 , 'c2_x' : 1 } A subset of the features can be one-hot encoded by using an instance of compose.Select . >>> from river import compose >>> pp = compose . Select ( 'c1' ) | preprocessing . OneHotEncoder () >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 } { 'c1_a' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 } You can preserve the c2 feature by using a union: >>> pp = compose . Select ( 'c1' ) | preprocessing . OneHotEncoder () >>> pp += compose . Select ( 'c2' ) >>> for x in X : ... pp = pp . learn_one ( x ) ... pprint ( pp . transform_one ( x )) { 'c1_u' : 1 , 'c2' : 'd' } { 'c1_a' : 1 , 'c1_u' : 0 , 'c2' : 'x' } { 'c1_a' : 0 , 'c1_i' : 1 , 'c1_u' : 0 , 'c2' : 'h' } { 'c1_a' : 0 , 'c1_h' : 1 , 'c1_i' : 0 , 'c1_u' : 0 , 'c2' : 'e' } Similar to the above examples, we can also pass values as a list. This will one-hot encode all of the entries individually. >>> X = [{ 'c1' : [ 'u' , 'a' ], 'c2' : [ 'd' ]}, ... { 'c1' : [ 'a' , 'b' ], 'c2' : [ 'x' ]}, ... { 'c1' : [ 'i' ], 'c2' : [ 'h' , 'z' ]}, ... { 'c1' : [ 'h' , 'b' ], 'c2' : [ 'e' ]}] >>> oh = preprocessing . OneHotEncoder ( sparse = True ) >>> for x in X : ... oh = oh . learn_one ( x ) ... pprint ( oh . transform_one ( x )) { 'c1_a' : 1 , 'c1_u' : 1 , 'c2_d' : 1 } { 'c1_a' : 1 , 'c1_b' : 1 , 'c2_x' : 1 } { 'c1_i' : 1 , 'c2_h' : 1 , 'c2_z' : 1 } { 'c1_b' : 1 , 'c1_h' : 1 , 'c2_e' : 1 } Processing mini-batches is also possible. >>> from pprint import pprint >>> import random >>> import string >>> random . seed ( 42 ) >>> alphabet = list ( string . ascii_lowercase ) >>> X = pd . DataFrame ( ... { ... 'c1' : random . choice ( alphabet ), ... 'c2' : random . choice ( alphabet ), ... } ... for _ in range ( 4 ) ... ) >>> X c1 c2 0 u d 1 a x 2 i h 3 h e >>> oh = preprocessing . OneHotEncoder ( sparse = True ) >>> oh = oh . learn_many ( X ) >>> df = oh . transform_many ( X ) >>> df . loc [:, sorted ( df . columns )] c1_a c1_h c1_i c1_u c2_d c2_e c2_h c2_x 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 0 1 2 0 0 1 0 0 0 1 0 3 0 1 0 0 0 1 0 0 Keep in mind that ability for sparse transformations is limited in mini-batch case, which might affect speed/memory footprint of your training loop. Here's a non-sparse example: >>> oh = preprocessing . OneHotEncoder ( sparse = False ) >>> X_init = pd . DataFrame ([{ 'c1' : \"Oranges\" , 'c2' : \"Apples\" }]) >>> oh = oh . learn_many ( X_init ) >>> oh = oh . learn_many ( X ) >>> df = oh . transform_many ( X ) >>> df . loc [:, sorted ( df . columns )] c1_Oranges c1_a c1_h c1_i c1_u c2_Apples c2_d c2_e c2_h c2_x 0 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 2 0 0 0 1 0 0 0 0 1 0 3 0 0 1 0 0 0 0 1 0 0","title":"Examples"},{"location":"api/preprocessing/OneHotEncoder/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. A lot of transformers don't actually have to do anything during the learn_many step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_many can override this method. Parameters X ( pandas.core.frame.DataFrame ) Returns Transformer : self learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_many Transform a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) Returns DataFrame : A new DataFrame. transform_one Transform a set of features x . Parameters x ( dict ) y \u2013 defaults to None Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/PredClipper/","text":"PredClipper \u00b6 Clips the target after predicting. Parameters \u00b6 regressor ( base.Regressor ) Regressor model for which to clip the predictions. y_min ( float ) minimum value. y_max ( float ) maximum value. Examples \u00b6 >>> from river import linear_model >>> from river import preprocessing >>> dataset = ( ... ({ 'a' : 2 , 'b' : 4 }, 80 ), ... ({ 'a' : 3 , 'b' : 5 }, 100 ), ... ({ 'a' : 4 , 'b' : 6 }, 120 ) ... ) >>> model = preprocessing . PredClipper ( ... regressor = linear_model . LinearRegression (), ... y_min = 0 , ... y_max = 200 ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'a' : - 100 , 'b' : - 200 }) 0 >>> model . predict_one ({ 'a' : 50 , 'b' : 60 }) 200 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) kwargs Returns Number : The prediction.","title":"PredClipper"},{"location":"api/preprocessing/PredClipper/#predclipper","text":"Clips the target after predicting.","title":"PredClipper"},{"location":"api/preprocessing/PredClipper/#parameters","text":"regressor ( base.Regressor ) Regressor model for which to clip the predictions. y_min ( float ) minimum value. y_max ( float ) maximum value.","title":"Parameters"},{"location":"api/preprocessing/PredClipper/#examples","text":">>> from river import linear_model >>> from river import preprocessing >>> dataset = ( ... ({ 'a' : 2 , 'b' : 4 }, 80 ), ... ({ 'a' : 3 , 'b' : 5 }, 100 ), ... ({ 'a' : 4 , 'b' : 6 }, 120 ) ... ) >>> model = preprocessing . PredClipper ( ... regressor = linear_model . LinearRegression (), ... y_min = 0 , ... y_max = 200 ... ) >>> for x , y in dataset : ... _ = model . learn_one ( x , y ) >>> model . predict_one ({ 'a' : - 100 , 'b' : - 200 }) 0 >>> model . predict_one ({ 'a' : 50 , 'b' : 60 }) 200","title":"Examples"},{"location":"api/preprocessing/PredClipper/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) kwargs Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) kwargs Returns Number : The prediction.","title":"Methods"},{"location":"api/preprocessing/PreviousImputer/","text":"PreviousImputer \u00b6 Imputes missing values by using the most recent value. Examples \u00b6 >>> from river import preprocessing >>> imputer = preprocessing . PreviousImputer () >>> imputer = imputer . learn_one ({ 'x' : 1 , 'y' : 2 }) >>> imputer . transform_one ({ 'y' : None }) { 'y' : 2 } >>> imputer . transform_one ({ 'x' : None }) { 'x' : 1 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"PreviousImputer"},{"location":"api/preprocessing/PreviousImputer/#previousimputer","text":"Imputes missing values by using the most recent value.","title":"PreviousImputer"},{"location":"api/preprocessing/PreviousImputer/#examples","text":">>> from river import preprocessing >>> imputer = preprocessing . PreviousImputer () >>> imputer = imputer . learn_one ({ 'x' : 1 , 'y' : 2 }) >>> imputer . transform_one ({ 'y' : None }) { 'y' : 2 } >>> imputer . transform_one ({ 'x' : None }) { 'x' : 1 }","title":"Examples"},{"location":"api/preprocessing/PreviousImputer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/RobustScaler/","text":"RobustScaler \u00b6 Scale features using statistics that are robust to outliers. This Scaler removes the median and scales the data according to the interquantile range. Parameters \u00b6 with_centering \u2013 defaults to True Whether to centre the data before scaling. with_scaling \u2013 defaults to True Whether to scale data to IQR. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Attributes \u00b6 median ( dict ) Mapping between features and instances of stats.Quantile(0.5) . iqr ( dict ) Mapping between features and instances of stats.IQR . Examples \u00b6 >>> from pprint import pprint >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> pprint ( X ) [{ 'x' : 10.557707 }, { 'x' : 8.100043 }, { 'x' : 9.100117 }, { 'x' : 8.892842 }, { 'x' : 10.945884 }] >>> scaler = preprocessing . RobustScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 1.0 } { 'x' : 0.0 } { 'x' : - 0.124499 } { 'x' : 1.108659 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"RobustScaler"},{"location":"api/preprocessing/RobustScaler/#robustscaler","text":"Scale features using statistics that are robust to outliers. This Scaler removes the median and scales the data according to the interquantile range.","title":"RobustScaler"},{"location":"api/preprocessing/RobustScaler/#parameters","text":"with_centering \u2013 defaults to True Whether to centre the data before scaling. with_scaling \u2013 defaults to True Whether to scale data to IQR. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1.","title":"Parameters"},{"location":"api/preprocessing/RobustScaler/#attributes","text":"median ( dict ) Mapping between features and instances of stats.Quantile(0.5) . iqr ( dict ) Mapping between features and instances of stats.IQR .","title":"Attributes"},{"location":"api/preprocessing/RobustScaler/#examples","text":">>> from pprint import pprint >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 )} for _ in range ( 5 )] >>> pprint ( X ) [{ 'x' : 10.557707 }, { 'x' : 8.100043 }, { 'x' : 9.100117 }, { 'x' : 8.892842 }, { 'x' : 10.945884 }] >>> scaler = preprocessing . RobustScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 } { 'x' : - 1.0 } { 'x' : 0.0 } { 'x' : - 0.124499 } { 'x' : 1.108659 }","title":"Examples"},{"location":"api/preprocessing/RobustScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/StandardScaler/","text":"StandardScaler \u00b6 Scales the data so that it has zero mean and unit variance. Under the hood, a running mean and a running variance are maintained. The scaling is slightly different than when scaling the data in batch because the exact means and variances are not known in advance. However, this doesn't have a detrimental impact on performance in the long run. This transformer supports mini-batches as well as single instances. In the mini-batch case, the number of columns and the ordering of the columns are allowed to change between subsequent calls. In other words, this transformer will keep working even if you add and/or remove features every time you call learn_many and transform_many . Parameters \u00b6 with_std \u2013 defaults to True Whether or not each feature should be divided by its standard deviation. Examples \u00b6 >>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 ), 'y' : random . uniform ( 8 , 12 )} for _ in range ( 6 )] >>> for x in X : ... print ( x ) { 'x' : 10.557 , 'y' : 8.100 } { 'x' : 9.100 , 'y' : 8.892 } { 'x' : 10.945 , 'y' : 10.706 } { 'x' : 11.568 , 'y' : 8.347 } { 'x' : 9.687 , 'y' : 8.119 } { 'x' : 8.874 , 'y' : 10.021 } >>> scaler = preprocessing . StandardScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 , 'y' : 0.0 } { 'x' : - 0.999 , 'y' : 0.999 } { 'x' : 0.937 , 'y' : 1.350 } { 'x' : 1.129 , 'y' : - 0.651 } { 'x' : - 0.776 , 'y' : - 0.729 } { 'x' : - 1.274 , 'y' : 0.992 } This transformer also supports mini-batch updates. You can call learn_many and provide a pandas.DataFrame : >>> import pandas as pd >>> X = pd . DataFrame . from_dict ( X ) >>> scaler = preprocessing . StandardScaler () >>> scaler = scaler . learn_many ( X [: 3 ]) >>> scaler = scaler . learn_many ( X [ 3 :]) You can then call transform_many to scale a mini-batch of features: >>> scaler . transform_many ( X ) x y 0 0.444600 - 0.933384 1 - 1.044259 - 0.138809 2 0.841106 1.679208 3 1.477301 - 0.685117 4 - 0.444084 - 0.914195 5 - 1.274664 0.992296 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. Note that the update formulas for mean and variance are slightly different than in the single instance case, but they produce exactly the same result. Parameters X ( pandas.core.frame.DataFrame ) learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_many Scale a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values. References \u00b6 Welford's Method (and Friends) \u21a9 Batch updates for simple statistics \u21a9","title":"StandardScaler"},{"location":"api/preprocessing/StandardScaler/#standardscaler","text":"Scales the data so that it has zero mean and unit variance. Under the hood, a running mean and a running variance are maintained. The scaling is slightly different than when scaling the data in batch because the exact means and variances are not known in advance. However, this doesn't have a detrimental impact on performance in the long run. This transformer supports mini-batches as well as single instances. In the mini-batch case, the number of columns and the ordering of the columns are allowed to change between subsequent calls. In other words, this transformer will keep working even if you add and/or remove features every time you call learn_many and transform_many .","title":"StandardScaler"},{"location":"api/preprocessing/StandardScaler/#parameters","text":"with_std \u2013 defaults to True Whether or not each feature should be divided by its standard deviation.","title":"Parameters"},{"location":"api/preprocessing/StandardScaler/#examples","text":">>> import random >>> from river import preprocessing >>> random . seed ( 42 ) >>> X = [{ 'x' : random . uniform ( 8 , 12 ), 'y' : random . uniform ( 8 , 12 )} for _ in range ( 6 )] >>> for x in X : ... print ( x ) { 'x' : 10.557 , 'y' : 8.100 } { 'x' : 9.100 , 'y' : 8.892 } { 'x' : 10.945 , 'y' : 10.706 } { 'x' : 11.568 , 'y' : 8.347 } { 'x' : 9.687 , 'y' : 8.119 } { 'x' : 8.874 , 'y' : 10.021 } >>> scaler = preprocessing . StandardScaler () >>> for x in X : ... print ( scaler . learn_one ( x ) . transform_one ( x )) { 'x' : 0.0 , 'y' : 0.0 } { 'x' : - 0.999 , 'y' : 0.999 } { 'x' : 0.937 , 'y' : 1.350 } { 'x' : 1.129 , 'y' : - 0.651 } { 'x' : - 0.776 , 'y' : - 0.729 } { 'x' : - 1.274 , 'y' : 0.992 } This transformer also supports mini-batch updates. You can call learn_many and provide a pandas.DataFrame : >>> import pandas as pd >>> X = pd . DataFrame . from_dict ( X ) >>> scaler = preprocessing . StandardScaler () >>> scaler = scaler . learn_many ( X [: 3 ]) >>> scaler = scaler . learn_many ( X [ 3 :]) You can then call transform_many to scale a mini-batch of features: >>> scaler . transform_many ( X ) x y 0 0.444600 - 0.933384 1 - 1.044259 - 0.138809 2 0.841106 1.679208 3 1.477301 - 0.685117 4 - 0.444084 - 0.914195 5 - 1.274664 0.992296","title":"Examples"},{"location":"api/preprocessing/StandardScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_many Update with a mini-batch of features. Note that the update formulas for mean and variance are slightly different than in the single instance case, but they produce exactly the same result. Parameters X ( pandas.core.frame.DataFrame ) learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_many Scale a mini-batch of features. Parameters X ( pandas.core.frame.DataFrame ) transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/StandardScaler/#references","text":"Welford's Method (and Friends) \u21a9 Batch updates for simple statistics \u21a9","title":"References"},{"location":"api/preprocessing/StatImputer/","text":"StatImputer \u00b6 Replaces missing values with a statistic. This transformer allows you to replace missing values with the value of a running statistic. During a call to learn_one , for each feature, a statistic is updated whenever a numeric feature is observed. When transform_one is called, each feature with a None value is replaced with the current value of the corresponding statistic. Parameters \u00b6 imputers A list of tuples where each tuple has two elements. The first elements is a feature name and the second value is an instance of stats.base.Univariate . The second value can also be an arbitrary value, such as -1, in which case the missing values will be replaced with it. Examples \u00b6 >>> from river import preprocessing >>> from river import stats For numeric data, we can use a stats.Mean() to replace missing values by the running average of the previously seen values: >>> X = [ ... { 'temperature' : 1 }, ... { 'temperature' : 8 }, ... { 'temperature' : 3 }, ... { 'temperature' : None }, ... { 'temperature' : 4 } ... ] >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'temperature' : 1 } { 'temperature' : 8 } { 'temperature' : 3 } { 'temperature' : 4.0 } { 'temperature' : 4 } For discrete/categorical data, a common practice is to stats.Mode to replace missing values by the most commonly seen value: >>> X = [ ... { 'weather' : 'sunny' }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'sunny' }, ... { 'weather' : None }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'rainy' }, ... { 'weather' : None } ... ] >>> imp = preprocessing . StatImputer (( 'weather' , stats . Mode ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } You can also choose to replace missing values with a constant value, as so: >>> imp = preprocessing . StatImputer (( 'weather' , 'missing' )) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'missing' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'missing' } Multiple imputers can be defined by providing a tuple for each feature which you want to impute: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : None , 'temperature' : 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : None , 'temperature' : None } ... ] >>> imp = preprocessing . StatImputer ( ... ( 'temperature' , stats . Mean ()), ... ( 'weather' , stats . Mode ()) ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 5.5 } { 'weather' : 'sunny' , 'temperature' : 4 } { 'weather' : 'snowy' , 'temperature' : - 4 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : 0.8333 } A sophisticated way to go about imputation is condition the statistics on a given feature. For instance, we might want to replace a missing temperature with the average temperature of a particular weather condition. As an example, consider the following dataset where the temperature is missing, but not the weather condition: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'rainy' , 'temperature' : 4 }, ... { 'weather' : 'sunny' , 'temperature' : 10 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'sunny' , 'temperature' : 12 }, ... { 'weather' : 'rainy' , 'temperature' : None } ... ] Each missing temperature can be replaced with the average temperature of the corresponding weather condition as so: >>> from river import compose >>> imp = compose . Grouper ( ... preprocessing . StatImputer (( 'temperature' , stats . Mean ())), ... by = 'weather' ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 8.0 } { 'weather' : 'rainy' , 'temperature' : 4 } { 'weather' : 'sunny' , 'temperature' : 10 } { 'weather' : 'sunny' , 'temperature' : 9.0 } { 'weather' : 'sunny' , 'temperature' : 12 } { 'weather' : 'rainy' , 'temperature' : 3.5 } Note that you can also create a Grouper with the * operator: >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) * 'weather' Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"StatImputer"},{"location":"api/preprocessing/StatImputer/#statimputer","text":"Replaces missing values with a statistic. This transformer allows you to replace missing values with the value of a running statistic. During a call to learn_one , for each feature, a statistic is updated whenever a numeric feature is observed. When transform_one is called, each feature with a None value is replaced with the current value of the corresponding statistic.","title":"StatImputer"},{"location":"api/preprocessing/StatImputer/#parameters","text":"imputers A list of tuples where each tuple has two elements. The first elements is a feature name and the second value is an instance of stats.base.Univariate . The second value can also be an arbitrary value, such as -1, in which case the missing values will be replaced with it.","title":"Parameters"},{"location":"api/preprocessing/StatImputer/#examples","text":">>> from river import preprocessing >>> from river import stats For numeric data, we can use a stats.Mean() to replace missing values by the running average of the previously seen values: >>> X = [ ... { 'temperature' : 1 }, ... { 'temperature' : 8 }, ... { 'temperature' : 3 }, ... { 'temperature' : None }, ... { 'temperature' : 4 } ... ] >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'temperature' : 1 } { 'temperature' : 8 } { 'temperature' : 3 } { 'temperature' : 4.0 } { 'temperature' : 4 } For discrete/categorical data, a common practice is to stats.Mode to replace missing values by the most commonly seen value: >>> X = [ ... { 'weather' : 'sunny' }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'sunny' }, ... { 'weather' : None }, ... { 'weather' : 'rainy' }, ... { 'weather' : 'rainy' }, ... { 'weather' : None } ... ] >>> imp = preprocessing . StatImputer (( 'weather' , stats . Mode ())) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } You can also choose to replace missing values with a constant value, as so: >>> imp = preprocessing . StatImputer (( 'weather' , 'missing' )) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' } { 'weather' : 'rainy' } { 'weather' : 'sunny' } { 'weather' : 'missing' } { 'weather' : 'rainy' } { 'weather' : 'rainy' } { 'weather' : 'missing' } Multiple imputers can be defined by providing a tuple for each feature which you want to impute: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : None , 'temperature' : 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 4 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : 'snowy' , 'temperature' : - 3 }, ... { 'weather' : None , 'temperature' : None } ... ] >>> imp = preprocessing . StatImputer ( ... ( 'temperature' , stats . Mean ()), ... ( 'weather' , stats . Mode ()) ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 5.5 } { 'weather' : 'sunny' , 'temperature' : 4 } { 'weather' : 'snowy' , 'temperature' : - 4 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : - 3 } { 'weather' : 'snowy' , 'temperature' : 0.8333 } A sophisticated way to go about imputation is condition the statistics on a given feature. For instance, we might want to replace a missing temperature with the average temperature of a particular weather condition. As an example, consider the following dataset where the temperature is missing, but not the weather condition: >>> X = [ ... { 'weather' : 'sunny' , 'temperature' : 8 }, ... { 'weather' : 'rainy' , 'temperature' : 3 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'rainy' , 'temperature' : 4 }, ... { 'weather' : 'sunny' , 'temperature' : 10 }, ... { 'weather' : 'sunny' , 'temperature' : None }, ... { 'weather' : 'sunny' , 'temperature' : 12 }, ... { 'weather' : 'rainy' , 'temperature' : None } ... ] Each missing temperature can be replaced with the average temperature of the corresponding weather condition as so: >>> from river import compose >>> imp = compose . Grouper ( ... preprocessing . StatImputer (( 'temperature' , stats . Mean ())), ... by = 'weather' ... ) >>> for x in X : ... imp = imp . learn_one ( x ) ... print ( imp . transform_one ( x )) { 'weather' : 'sunny' , 'temperature' : 8 } { 'weather' : 'rainy' , 'temperature' : 3 } { 'weather' : 'sunny' , 'temperature' : 8.0 } { 'weather' : 'rainy' , 'temperature' : 4 } { 'weather' : 'sunny' , 'temperature' : 10 } { 'weather' : 'sunny' , 'temperature' : 9.0 } { 'weather' : 'sunny' , 'temperature' : 12 } { 'weather' : 'rainy' , 'temperature' : 3.5 } Note that you can also create a Grouper with the * operator: >>> imp = preprocessing . StatImputer (( 'temperature' , stats . Mean ())) * 'weather'","title":"Examples"},{"location":"api/preprocessing/StatImputer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update with a set of features x . A lot of transformers don't actually have to do anything during the learn_one step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the learn_one can override this method. Parameters x ( dict ) Returns Transformer : self transform_one Transform a set of features x . Parameters x ( dict ) Returns dict : The transformed values.","title":"Methods"},{"location":"api/preprocessing/TargetStandardScaler/","text":"TargetStandardScaler \u00b6 Applies standard scaling to the target. Parameters \u00b6 regressor ( base.Regressor ) Regression model to wrap. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... preprocessing . TargetStandardScaler ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.15 ) ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 2.003724 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"TargetStandardScaler"},{"location":"api/preprocessing/TargetStandardScaler/#targetstandardscaler","text":"Applies standard scaling to the target.","title":"TargetStandardScaler"},{"location":"api/preprocessing/TargetStandardScaler/#parameters","text":"regressor ( base.Regressor ) Regression model to wrap.","title":"Parameters"},{"location":"api/preprocessing/TargetStandardScaler/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... preprocessing . TargetStandardScaler ( ... regressor = linear_model . LinearRegression ( intercept_lr = 0.15 ) ... ) ... ) >>> metric = metrics . MSE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MSE : 2.003724","title":"Examples"},{"location":"api/preprocessing/TargetStandardScaler/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/proba/Gaussian/","text":"Gaussian \u00b6 Normal distribution with parameters mu and sigma. Attributes \u00b6 mode Most likely value. mu n_samples The number of observed samples. sigma Examples \u00b6 >>> from river import proba >>> p = proba . Gaussian () . update ( 6 ) . update ( 7 ) >>> p \ud835\udca9 ( \u03bc = 6.500 , \u03c3 = 0.707 ) >>> p . pdf ( 6.5 ) 0.564189 >>> p . revert ( 7 ) \ud835\udca9 ( \u03bc = 6.000 , \u03c3 = 0.000 ) Methods \u00b6 cdf Cumulative density function, i.e. P(X <= x). Parameters x pdf Probability density function, i.e. P(x <= X < x+dx) / dx. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x w \u2013 defaults to 1.0 update Updates the parameters of the distribution given a new observation. Parameters x w \u2013 defaults to 1.0","title":"Gaussian"},{"location":"api/proba/Gaussian/#gaussian","text":"Normal distribution with parameters mu and sigma.","title":"Gaussian"},{"location":"api/proba/Gaussian/#attributes","text":"mode Most likely value. mu n_samples The number of observed samples. sigma","title":"Attributes"},{"location":"api/proba/Gaussian/#examples","text":">>> from river import proba >>> p = proba . Gaussian () . update ( 6 ) . update ( 7 ) >>> p \ud835\udca9 ( \u03bc = 6.500 , \u03c3 = 0.707 ) >>> p . pdf ( 6.5 ) 0.564189 >>> p . revert ( 7 ) \ud835\udca9 ( \u03bc = 6.000 , \u03c3 = 0.000 )","title":"Examples"},{"location":"api/proba/Gaussian/#methods","text":"cdf Cumulative density function, i.e. P(X <= x). Parameters x pdf Probability density function, i.e. P(x <= X < x+dx) / dx. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x w \u2013 defaults to 1.0 update Updates the parameters of the distribution given a new observation. Parameters x w \u2013 defaults to 1.0","title":"Methods"},{"location":"api/proba/Multinomial/","text":"Multinomial \u00b6 Multinomial distribution for categorical data. Parameters \u00b6 events ( Union[dict, list] ) \u2013 defaults to None An optional list of events that already occurred. Attributes \u00b6 mode n_samples The number of observed samples. Examples \u00b6 >>> from river import proba >>> p = proba . Multinomial ([ 'green' ] * 3 ) >>> p = p . update ( 'red' ) >>> p . pmf ( 'red' ) 0.25 >>> p . update ( 'red' ) . update ( 'red' ) . pmf ( 'green' ) 0.5 >>> p . revert ( 'red' ) . revert ( 'red' ) . pmf ( 'red' ) 0.25 Methods \u00b6 pmf Probability mass function. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"Multinomial"},{"location":"api/proba/Multinomial/#multinomial","text":"Multinomial distribution for categorical data.","title":"Multinomial"},{"location":"api/proba/Multinomial/#parameters","text":"events ( Union[dict, list] ) \u2013 defaults to None An optional list of events that already occurred.","title":"Parameters"},{"location":"api/proba/Multinomial/#attributes","text":"mode n_samples The number of observed samples.","title":"Attributes"},{"location":"api/proba/Multinomial/#examples","text":">>> from river import proba >>> p = proba . Multinomial ([ 'green' ] * 3 ) >>> p = p . update ( 'red' ) >>> p . pmf ( 'red' ) 0.25 >>> p . update ( 'red' ) . update ( 'red' ) . pmf ( 'green' ) 0.5 >>> p . revert ( 'red' ) . revert ( 'red' ) . pmf ( 'red' ) 0.25","title":"Examples"},{"location":"api/proba/Multinomial/#methods","text":"pmf Probability mass function. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"Methods"},{"location":"api/proba/Rolling/","text":"Rolling \u00b6 Wrapper for measuring probability distributions over a window. Parameters \u00b6 dist ( river.proba.base.Distribution ) A distribution. window_size ( int ) A window size. Attributes \u00b6 n_samples The number of observed samples. Examples \u00b6 >>> import datetime as dt >>> from river import proba >>> X = [ 'red' , 'green' , 'green' , 'blue' , 'blue' ] >>> dist = proba . Rolling ( ... proba . Multinomial (), ... window_size = 3 ... ) >>> for x in X : ... dist = dist . update ( x ) ... print ( dist ) ... print () P ( red ) = 1.000 < BLANKLINE > P ( red ) = 0.500 P ( green ) = 0.500 < BLANKLINE > P ( green ) = 0.667 P ( red ) = 0.333 < BLANKLINE > P ( green ) = 0.667 P ( blue ) = 0.333 P ( red ) = 0.000 < BLANKLINE > P ( blue ) = 0.667 P ( green ) = 0.333 P ( red ) = 0.000 < BLANKLINE > Methods \u00b6 revert Reverts the parameters of the distribution for a given observation. Parameters x w \u2013 defaults to 1 update Updates the parameters of the distribution given a new observation. Parameters x","title":"Rolling"},{"location":"api/proba/Rolling/#rolling","text":"Wrapper for measuring probability distributions over a window.","title":"Rolling"},{"location":"api/proba/Rolling/#parameters","text":"dist ( river.proba.base.Distribution ) A distribution. window_size ( int ) A window size.","title":"Parameters"},{"location":"api/proba/Rolling/#attributes","text":"n_samples The number of observed samples.","title":"Attributes"},{"location":"api/proba/Rolling/#examples","text":">>> import datetime as dt >>> from river import proba >>> X = [ 'red' , 'green' , 'green' , 'blue' , 'blue' ] >>> dist = proba . Rolling ( ... proba . Multinomial (), ... window_size = 3 ... ) >>> for x in X : ... dist = dist . update ( x ) ... print ( dist ) ... print () P ( red ) = 1.000 < BLANKLINE > P ( red ) = 0.500 P ( green ) = 0.500 < BLANKLINE > P ( green ) = 0.667 P ( red ) = 0.333 < BLANKLINE > P ( green ) = 0.667 P ( blue ) = 0.333 P ( red ) = 0.000 < BLANKLINE > P ( blue ) = 0.667 P ( green ) = 0.333 P ( red ) = 0.000 < BLANKLINE >","title":"Examples"},{"location":"api/proba/Rolling/#methods","text":"revert Reverts the parameters of the distribution for a given observation. Parameters x w \u2013 defaults to 1 update Updates the parameters of the distribution given a new observation. Parameters x","title":"Methods"},{"location":"api/proba/TimeRolling/","text":"TimeRolling \u00b6 Wrapper for measuring probability distributions over a period of time. Parameters \u00b6 dist ( river.proba.base.Distribution ) A distribution. period ( datetime.timedelta ) A period of time. Attributes \u00b6 n_samples The number of observed samples. Examples \u00b6 >>> import datetime as dt >>> from river import proba >>> X = [ 'red' , 'green' , 'green' , 'blue' ] >>> days = [ 1 , 2 , 3 , 4 ] >>> dist = proba . TimeRolling ( ... proba . Multinomial (), ... period = dt . timedelta ( days = 2 ) ... ) >>> for x , day in zip ( X , days ): ... dist = dist . update ( x , dt . datetime ( 2019 , 1 , day )) ... print ( dist ) ... print () P ( red ) = 1.000 < BLANKLINE > P ( red ) = 0.500 P ( green ) = 0.500 < BLANKLINE > P ( green ) = 1.000 P ( red ) = 0.000 < BLANKLINE > P ( green ) = 0.500 P ( blue ) = 0.500 P ( red ) = 0.000 < BLANKLINE > Methods \u00b6 revert Reverts the parameters of the distribution for a given observation. Parameters x w \u2013 defaults to 1 update Updates the parameters of the distribution given a new observation. Parameters x t ( datetime.datetime )","title":"TimeRolling"},{"location":"api/proba/TimeRolling/#timerolling","text":"Wrapper for measuring probability distributions over a period of time.","title":"TimeRolling"},{"location":"api/proba/TimeRolling/#parameters","text":"dist ( river.proba.base.Distribution ) A distribution. period ( datetime.timedelta ) A period of time.","title":"Parameters"},{"location":"api/proba/TimeRolling/#attributes","text":"n_samples The number of observed samples.","title":"Attributes"},{"location":"api/proba/TimeRolling/#examples","text":">>> import datetime as dt >>> from river import proba >>> X = [ 'red' , 'green' , 'green' , 'blue' ] >>> days = [ 1 , 2 , 3 , 4 ] >>> dist = proba . TimeRolling ( ... proba . Multinomial (), ... period = dt . timedelta ( days = 2 ) ... ) >>> for x , day in zip ( X , days ): ... dist = dist . update ( x , dt . datetime ( 2019 , 1 , day )) ... print ( dist ) ... print () P ( red ) = 1.000 < BLANKLINE > P ( red ) = 0.500 P ( green ) = 0.500 < BLANKLINE > P ( green ) = 1.000 P ( red ) = 0.000 < BLANKLINE > P ( green ) = 0.500 P ( blue ) = 0.500 P ( red ) = 0.000 < BLANKLINE >","title":"Examples"},{"location":"api/proba/TimeRolling/#methods","text":"revert Reverts the parameters of the distribution for a given observation. Parameters x w \u2013 defaults to 1 update Updates the parameters of the distribution given a new observation. Parameters x t ( datetime.datetime )","title":"Methods"},{"location":"api/proba/base/ContinuousDistribution/","text":"ContinuousDistribution \u00b6 A probability distribution for continuous values. Attributes \u00b6 mode Most likely value. n_samples The number of observed samples. Methods \u00b6 cdf Cumulative density function, i.e. P(X <= x). Parameters x pdf Probability density function, i.e. P(x <= X < x+dx) / dx. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"ContinuousDistribution"},{"location":"api/proba/base/ContinuousDistribution/#continuousdistribution","text":"A probability distribution for continuous values.","title":"ContinuousDistribution"},{"location":"api/proba/base/ContinuousDistribution/#attributes","text":"mode Most likely value. n_samples The number of observed samples.","title":"Attributes"},{"location":"api/proba/base/ContinuousDistribution/#methods","text":"cdf Cumulative density function, i.e. P(X <= x). Parameters x pdf Probability density function, i.e. P(x <= X < x+dx) / dx. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"Methods"},{"location":"api/proba/base/DiscreteDistribution/","text":"DiscreteDistribution \u00b6 A probability distribution for discrete values. Attributes \u00b6 n_samples The number of observed samples. Methods \u00b6 pmf Probability mass function. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"DiscreteDistribution"},{"location":"api/proba/base/DiscreteDistribution/#discretedistribution","text":"A probability distribution for discrete values.","title":"DiscreteDistribution"},{"location":"api/proba/base/DiscreteDistribution/#attributes","text":"n_samples The number of observed samples.","title":"Attributes"},{"location":"api/proba/base/DiscreteDistribution/#methods","text":"pmf Probability mass function. Parameters x revert Reverts the parameters of the distribution for a given observation. Parameters x update Updates the parameters of the distribution given a new observation. Parameters x","title":"Methods"},{"location":"api/reco/Baseline/","text":"Baseline \u00b6 Baseline for recommender systems. A first-order approximation of the bias involved in target. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i}\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored. Parameters \u00b6 optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. loss ( optim.base.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 regularization amount used to push weights towards 0. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed \u2013 defaults to None Random number generation seed. Set this for reproducibility. Attributes \u00b6 global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user bias weights. i_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item bias weights. Examples \u00b6 >>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . Baseline ( optimizer = optim . SGD ( 0.005 )) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 6.538120 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None References \u00b6 Matrix factorization techniques for recommender systems \u21a9","title":"Baseline"},{"location":"api/reco/Baseline/#baseline","text":"Baseline for recommender systems. A first-order approximation of the bias involved in target. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i}\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.","title":"Baseline"},{"location":"api/reco/Baseline/#parameters","text":"optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the weights. loss ( optim.base.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 regularization amount used to push weights towards 0. initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed \u2013 defaults to None Random number generation seed. Set this for reproducibility.","title":"Parameters"},{"location":"api/reco/Baseline/#attributes","text":"global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user bias weights. i_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item bias weights.","title":"Attributes"},{"location":"api/reco/Baseline/#examples","text":">>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . Baseline ( optimizer = optim . SGD ( 0.005 )) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 6.538120","title":"Examples"},{"location":"api/reco/Baseline/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/reco/Baseline/#references","text":"Matrix factorization techniques for recommender systems \u21a9","title":"References"},{"location":"api/reco/BiasedMF/","text":"BiasedMF \u00b6 Biased Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. The last term being simply the dot product between the latent vectors of the given user-item pair: \\[\\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. bias_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the bias weights. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent weights. loss ( optim.base.Loss ) \u2013 defaults to None The loss function to optimize for. l2_bias \u2013 defaults to 0.0 Amount of L2 regularization used to push bias weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed \u2013 defaults to None Random number generation seed. Set this for reproducibility. Attributes \u00b6 global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_bias_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user bias weights. i_bias_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item bias weights. u_latent_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user latent weights. i_latent_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item latent weights. Examples \u00b6 >>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . BiasedMF ( ... n_factors = 10 , ... bias_optimizer = optim . SGD ( 0.025 ), ... latent_optimizer = optim . SGD ( 0.025 ), ... latent_initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 71 ) ... ) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 6.489025 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None References \u00b6 Paterek, A., 2007, August. Improving regularized singular value decomposition for collaborative filtering. In Proceedings of KDD cup and workshop (Vol. 2007, pp. 5-8) \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"BiasedMF"},{"location":"api/reco/BiasedMF/#biasedmf","text":"Biased Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle\\] Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. The last term being simply the dot product between the latent vectors of the given user-item pair: \\[\\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.","title":"BiasedMF"},{"location":"api/reco/BiasedMF/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. bias_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the bias weights. latent_optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent weights. loss ( optim.base.Loss ) \u2013 defaults to None The loss function to optimize for. l2_bias \u2013 defaults to 0.0 Amount of L2 regularization used to push bias weights towards 0. l2_latent \u2013 defaults to 0.0 Amount of L2 regularization used to push latent weights towards 0. weight_initializer ( optim.base.Initializer ) \u2013 defaults to None Weights initialization scheme. latent_initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed \u2013 defaults to None Random number generation seed. Set this for reproducibility.","title":"Parameters"},{"location":"api/reco/BiasedMF/#attributes","text":"global_mean ( stats.Mean ) The target arithmetic mean. u_biases ( collections.defaultdict ) The user bias weights. i_biases ( collections.defaultdict ) The item bias weights. u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_bias_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user bias weights. i_bias_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item bias weights. u_latent_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user latent weights. i_latent_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item latent weights.","title":"Attributes"},{"location":"api/reco/BiasedMF/#examples","text":">>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . BiasedMF ( ... n_factors = 10 , ... bias_optimizer = optim . SGD ( 0.025 ), ... latent_optimizer = optim . SGD ( 0.025 ), ... latent_initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 71 ) ... ) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 6.489025","title":"Examples"},{"location":"api/reco/BiasedMF/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/reco/BiasedMF/#references","text":"Paterek, A., 2007, August. Improving regularized singular value decomposition for collaborative filtering. In Proceedings of KDD cup and workshop (Vol. 2007, pp. 5-8) \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"References"},{"location":"api/reco/FunkMF/","text":"FunkMF \u00b6 Funk Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored. Parameters \u00b6 n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.base.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed \u2013 defaults to None Random number generation seed. Set this for reproducibility. Attributes \u00b6 u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user latent weights. i_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item latent weights. Examples \u00b6 >>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . FunkMF ( ... n_factors = 10 , ... optimizer = optim . SGD ( 0.1 ), ... initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 11 ), ... ) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 1.866272 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None References \u00b6 Netflix update: Try this at home \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"FunkMF"},{"location":"api/reco/FunkMF/#funkmf","text":"Funk Matrix Factorization for recommender systems. The model equation is defined as: \\[\\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] where \\(k\\) is the number of latent factors. This model expects a dict input with a user and an item entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.","title":"FunkMF"},{"location":"api/reco/FunkMF/#parameters","text":"n_factors \u2013 defaults to 10 Dimensionality of the factorization or number of latent factors. optimizer ( optim.base.Optimizer ) \u2013 defaults to None The sequential optimizer used for updating the latent factors. loss ( optim.base.Loss ) \u2013 defaults to None The loss function to optimize for. l2 \u2013 defaults to 0.0 Amount of L2 regularization used to push weights towards 0. initializer ( optim.base.Initializer ) \u2013 defaults to None Latent factors initialization scheme. clip_gradient \u2013 defaults to 1000000000000.0 Clips the absolute value of each gradient value. seed \u2013 defaults to None Random number generation seed. Set this for reproducibility.","title":"Parameters"},{"location":"api/reco/FunkMF/#attributes","text":"u_latents ( collections.defaultdict ) The user latent vectors randomly initialized. i_latents ( collections.defaultdict ) The item latent vectors randomly initialized. u_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the user latent weights. i_optimizer ( optim.base.Optimizer ) The sequential optimizer used for updating the item latent weights.","title":"Attributes"},{"location":"api/reco/FunkMF/#examples","text":">>> from river import optim >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . FunkMF ( ... n_factors = 10 , ... optimizer = optim . SGD ( 0.1 ), ... initializer = optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 11 ), ... ) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 1.866272","title":"Examples"},{"location":"api/reco/FunkMF/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/reco/FunkMF/#references","text":"Netflix update: Try this at home \u21a9 Matrix factorization techniques for recommender systems \u21a9","title":"References"},{"location":"api/reco/RandomNormal/","text":"RandomNormal \u00b6 Predicts random values sampled from a normal distribution. The parameters of the normal distribution are fitted with running statistics. They parameters are independent of the user, the item, or the context, and are instead fitted globally. This recommender therefore acts as a dummy model that any serious model should easily outperform. Parameters \u00b6 seed \u2013 defaults to None Random number generation seed. Set this for reproducibility. Attributes \u00b6 mean stats.Mean variance stats.Var Examples \u00b6 >>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . RandomNormal ( seed = 42 ) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 6.147299621751425 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None","title":"RandomNormal"},{"location":"api/reco/RandomNormal/#randomnormal","text":"Predicts random values sampled from a normal distribution. The parameters of the normal distribution are fitted with running statistics. They parameters are independent of the user, the item, or the context, and are instead fitted globally. This recommender therefore acts as a dummy model that any serious model should easily outperform.","title":"RandomNormal"},{"location":"api/reco/RandomNormal/#parameters","text":"seed \u2013 defaults to None Random number generation seed. Set this for reproducibility.","title":"Parameters"},{"location":"api/reco/RandomNormal/#attributes","text":"mean stats.Mean variance stats.Var","title":"Attributes"},{"location":"api/reco/RandomNormal/#examples","text":">>> from river import reco >>> dataset = ( ... ({ 'user' : 'Alice' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Alice' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Alice' , 'item' : 'Notting Hill' }, 2 ), ... ({ 'user' : 'Alice' , 'item' : 'Harry Potter' }, 5 ), ... ({ 'user' : 'Bob' , 'item' : 'Superman' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Terminator' }, 9 ), ... ({ 'user' : 'Bob' , 'item' : 'Star Wars' }, 8 ), ... ({ 'user' : 'Bob' , 'item' : 'Notting Hill' }, 2 ) ... ) >>> model = reco . RandomNormal ( seed = 42 ) >>> for x , y in dataset : ... _ = model . learn_one ( ** x , y = y ) >>> model . predict_one ( user = 'Bob' , item = 'Harry Potter' ) 6.147299621751425","title":"Examples"},{"location":"api/reco/RandomNormal/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/reco/base/Ranker/","text":"Ranker \u00b6 Base class for ranking models. Parameters \u00b6 seed ( int ) \u2013 defaults to None Random number generation seed. Set this for reproducibility. Attributes \u00b6 is_contextual Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None","title":"Ranker"},{"location":"api/reco/base/Ranker/#ranker","text":"Base class for ranking models.","title":"Ranker"},{"location":"api/reco/base/Ranker/#parameters","text":"seed ( int ) \u2013 defaults to None Random number generation seed. Set this for reproducibility.","title":"Parameters"},{"location":"api/reco/base/Ranker/#attributes","text":"is_contextual","title":"Attributes"},{"location":"api/reco/base/Ranker/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits a user - item pair and a real-valued target y . Parameters user ( Union[str, int] ) item ( Union[str, int] ) y ( Union[numbers.Number, bool] ) x ( dict ) \u2013 defaults to None predict_one Predicts the target value of a set of features x . Parameters user ( Union[str, int] ) item ( Union[str, int] ) x ( dict ) \u2013 defaults to None Returns typing.Union[numbers.Number, bool] : The predicted preference from the user for the item. rank Rank models by decreasing order of preference for a given user. Parameters user ( Union[str, int] ) items ( Set[Union[str, int]] ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/rules/AMRules/","text":"AMRules \u00b6 Adaptive Model Rules. AMRules 1 is a rule-based algorithm for incremental regression tasks. AMRules relies on the Hoeffding bound to build its rule set, similarly to Hoeffding Trees. The Variance-Ratio heuristic is used to evaluate rules' splits. Moreover, this rule-based regressor has additional capacities not usually found in decision trees. Firstly, each created decision rule has a built-in drift detection mechanism. Every time a drift is detected, the affected decision rule is removed. In addition, AMRules' rules also have anomaly detection capabilities. After a warm-up period, each rule tests whether or not the incoming instances are anomalies. Anomalous instances are not used for training. Every time no rule is covering an incoming example, a default rule is used to learn from it. A rule covers an instance when all of the rule's literals (tests joined by the logical operation and ) match the input case. The default rule is also applied for predicting examples not covered by any rules from the rule set. Parameters \u00b6 n_min ( int ) \u2013 defaults to 200 The total weight that must be observed by a rule between expansion attempts. delta ( float ) \u2013 defaults to 1e-07 The split test significance. The split confidence is given by 1 - delta . tau ( float ) \u2013 defaults to 0.05 The tie-breaking threshold. pred_type ( str ) \u2013 defaults to adaptive The prediction strategy used by the decision rules. Can be either: - \"mean\" : outputs the target mean within the partitions defined by the decision rules. - \"model\" : always use instances of the model passed pred_model to make predictions. - \"adaptive\" : dynamically selects between \"mean\" and \"model\" for each incoming example. The most accurate option at the moment will be used. pred_model ( base.Regressor ) \u2013 defaults to None The regression model that will be replicated for every rule when pred_type is either \"model\" or \"adaptive\" . splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . drift_detector ( base.DriftDetector ) \u2013 defaults to None The drift detection model that is used by each rule. Care must be taken to avoid the triggering of too many false alarms or delaying too much the concept drift detection. By default, drift.PageHinckley is used if drift_detector is None . alpha ( float ) \u2013 defaults to 0.99 The exponential decaying factor applied to the learning models' absolute errors, that are monitored if pred_type='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. anomaly_threshold ( float ) \u2013 defaults to -0.75 The threshold below which instances will be considered anomalies by the rules. m_min ( int ) \u2013 defaults to 30 The minimum total weight a rule must observe before it starts to skip anomalous instances during training. ordered_rule_set ( bool ) \u2013 defaults to True If True , only the first rule that covers an instance will be used for training or prediction. If False , all the rules covering an instance will be updated during training, and the predictions for an instance will be the average prediction of all rules covering that example. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples each partition of a binary split candidate must have to be considered valid. Attributes \u00b6 n_drifts_detected The number of detected concept drifts. Examples \u00b6 >>> from river import datasets >>> from river import drift >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import rules >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... rules . AMRules ( ... delta = 0.01 , ... n_min = 50 , ... drift_detector = drift . ADWIN () ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.930966 Methods \u00b6 anomaly_score Aggregated anomaly score computed using all the rules that cover the input instance. Returns the mean anomaly score, the standard deviation of the score, and the proportion of rules that cover the instance (support). If the support is zero, it means that the default rule was used (not other rule covered x ). Parameters x Returns typing.Tuple[float, float, float] : mean_anomaly_score, std_anomaly_score, support clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Return an explanation of how x is predicted Parameters x Returns str : A representation of the rules that cover the input and their prediction. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w ( int ) \u2013 defaults to 1 Returns AMRules : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. Notes \u00b6 AMRules treats all the non-numerical inputs as nominal features. All instances of numbers.Number will be treated as continuous, even if they represent integer categories. When using nominal features, pred_type should be set to \"mean\", otherwise errors will be thrown while trying to update the underlying rules' prediction models. Prediction strategies other than \"mean\" can be used, as long as the prediction model passed to pred_model supports nominal features. References \u00b6 Duarte, J., Gama, J. and Bifet, A., 2016. Adaptive model rules from high-speed data streams. ACM Transactions on Knowledge Discovery from Data (TKDD), 10(3), pp.1-22. \u21a9","title":"AMRules"},{"location":"api/rules/AMRules/#amrules","text":"Adaptive Model Rules. AMRules 1 is a rule-based algorithm for incremental regression tasks. AMRules relies on the Hoeffding bound to build its rule set, similarly to Hoeffding Trees. The Variance-Ratio heuristic is used to evaluate rules' splits. Moreover, this rule-based regressor has additional capacities not usually found in decision trees. Firstly, each created decision rule has a built-in drift detection mechanism. Every time a drift is detected, the affected decision rule is removed. In addition, AMRules' rules also have anomaly detection capabilities. After a warm-up period, each rule tests whether or not the incoming instances are anomalies. Anomalous instances are not used for training. Every time no rule is covering an incoming example, a default rule is used to learn from it. A rule covers an instance when all of the rule's literals (tests joined by the logical operation and ) match the input case. The default rule is also applied for predicting examples not covered by any rules from the rule set.","title":"AMRules"},{"location":"api/rules/AMRules/#parameters","text":"n_min ( int ) \u2013 defaults to 200 The total weight that must be observed by a rule between expansion attempts. delta ( float ) \u2013 defaults to 1e-07 The split test significance. The split confidence is given by 1 - delta . tau ( float ) \u2013 defaults to 0.05 The tie-breaking threshold. pred_type ( str ) \u2013 defaults to adaptive The prediction strategy used by the decision rules. Can be either: - \"mean\" : outputs the target mean within the partitions defined by the decision rules. - \"model\" : always use instances of the model passed pred_model to make predictions. - \"adaptive\" : dynamically selects between \"mean\" and \"model\" for each incoming example. The most accurate option at the moment will be used. pred_model ( base.Regressor ) \u2013 defaults to None The regression model that will be replicated for every rule when pred_type is either \"model\" or \"adaptive\" . splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . drift_detector ( base.DriftDetector ) \u2013 defaults to None The drift detection model that is used by each rule. Care must be taken to avoid the triggering of too many false alarms or delaying too much the concept drift detection. By default, drift.PageHinckley is used if drift_detector is None . alpha ( float ) \u2013 defaults to 0.99 The exponential decaying factor applied to the learning models' absolute errors, that are monitored if pred_type='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. anomaly_threshold ( float ) \u2013 defaults to -0.75 The threshold below which instances will be considered anomalies by the rules. m_min ( int ) \u2013 defaults to 30 The minimum total weight a rule must observe before it starts to skip anomalous instances during training. ordered_rule_set ( bool ) \u2013 defaults to True If True , only the first rule that covers an instance will be used for training or prediction. If False , all the rules covering an instance will be updated during training, and the predictions for an instance will be the average prediction of all rules covering that example. min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples each partition of a binary split candidate must have to be considered valid.","title":"Parameters"},{"location":"api/rules/AMRules/#attributes","text":"n_drifts_detected The number of detected concept drifts.","title":"Attributes"},{"location":"api/rules/AMRules/#examples","text":">>> from river import datasets >>> from river import drift >>> from river import evaluate >>> from river import metrics >>> from river import preprocessing >>> from river import rules >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... rules . AMRules ( ... delta = 0.01 , ... n_min = 50 , ... drift_detector = drift . ADWIN () ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.930966","title":"Examples"},{"location":"api/rules/AMRules/#methods","text":"anomaly_score Aggregated anomaly score computed using all the rules that cover the input instance. Returns the mean anomaly score, the standard deviation of the score, and the proportion of rules that cover the instance (support). If the support is zero, it means that the default rule was used (not other rule covered x ). Parameters x Returns typing.Tuple[float, float, float] : mean_anomaly_score, std_anomaly_score, support clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Return an explanation of how x is predicted Parameters x Returns str : A representation of the rules that cover the input and their prediction. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w ( int ) \u2013 defaults to 1 Returns AMRules : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/rules/AMRules/#notes","text":"AMRules treats all the non-numerical inputs as nominal features. All instances of numbers.Number will be treated as continuous, even if they represent integer categories. When using nominal features, pred_type should be set to \"mean\", otherwise errors will be thrown while trying to update the underlying rules' prediction models. Prediction strategies other than \"mean\" can be used, as long as the prediction model passed to pred_model supports nominal features.","title":"Notes"},{"location":"api/rules/AMRules/#references","text":"Duarte, J., Gama, J. and Bifet, A., 2016. Adaptive model rules from high-speed data streams. ACM Transactions on Knowledge Discovery from Data (TKDD), 10(3), pp.1-22. \u21a9","title":"References"},{"location":"api/stats/AbsMax/","text":"AbsMax \u00b6 Running absolute max. Attributes \u00b6 abs_max ( float ) The current absolute max. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> abs_max = stats . AbsMax () >>> for x in X : ... print ( abs_max . update ( x ) . get ()) 1 4 4 4 5 6 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"AbsMax"},{"location":"api/stats/AbsMax/#absmax","text":"Running absolute max.","title":"AbsMax"},{"location":"api/stats/AbsMax/#attributes","text":"abs_max ( float ) The current absolute max.","title":"Attributes"},{"location":"api/stats/AbsMax/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> abs_max = stats . AbsMax () >>> for x in X : ... print ( abs_max . update ( x ) . get ()) 1 4 4 4 5 6","title":"Examples"},{"location":"api/stats/AbsMax/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/AutoCorr/","text":"AutoCorr \u00b6 Measures the serial correlation. This method computes the Pearson correlation between the current value and the value seen n steps before. Parameters \u00b6 lag ( int ) Attributes \u00b6 name Examples \u00b6 The following examples are taken from the pandas documentation . >>> from river import stats >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 - 1.0 0.103552 >>> auto_corr = stats . AutoCorr ( lag = 2 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 - 1.0 >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 1 , 0 , 0 , 0 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"AutoCorr"},{"location":"api/stats/AutoCorr/#autocorr","text":"Measures the serial correlation. This method computes the Pearson correlation between the current value and the value seen n steps before.","title":"AutoCorr"},{"location":"api/stats/AutoCorr/#parameters","text":"lag ( int )","title":"Parameters"},{"location":"api/stats/AutoCorr/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/AutoCorr/#examples","text":"The following examples are taken from the pandas documentation . >>> from river import stats >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 - 1.0 0.103552 >>> auto_corr = stats . AutoCorr ( lag = 2 ) >>> for x in [ 0.25 , 0.5 , 0.2 , - 0.05 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 - 1.0 >>> auto_corr = stats . AutoCorr ( lag = 1 ) >>> for x in [ 1 , 0 , 0 , 0 ]: ... print ( auto_corr . update ( x ) . get ()) 0 0 0 0","title":"Examples"},{"location":"api/stats/AutoCorr/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/BayesianMean/","text":"BayesianMean \u00b6 Estimates a mean using outside information. Parameters \u00b6 prior ( float ) prior_weight ( float ) Attributes \u00b6 name Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Additive smoothing \u21a9 Bayesian average \u21a9 Practical example of Bayes estimators \u21a9","title":"BayesianMean"},{"location":"api/stats/BayesianMean/#bayesianmean","text":"Estimates a mean using outside information.","title":"BayesianMean"},{"location":"api/stats/BayesianMean/#parameters","text":"prior ( float ) prior_weight ( float )","title":"Parameters"},{"location":"api/stats/BayesianMean/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/BayesianMean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/BayesianMean/#references","text":"Additive smoothing \u21a9 Bayesian average \u21a9 Practical example of Bayes estimators \u21a9","title":"References"},{"location":"api/stats/Count/","text":"Count \u00b6 A simple counter. Attributes \u00b6 n ( int ) The current number of observations. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x \u2013 defaults to None","title":"Count"},{"location":"api/stats/Count/#count","text":"A simple counter.","title":"Count"},{"location":"api/stats/Count/#attributes","text":"n ( int ) The current number of observations.","title":"Attributes"},{"location":"api/stats/Count/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x \u2013 defaults to None","title":"Methods"},{"location":"api/stats/Cov/","text":"Cov \u00b6 Covariance. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. Examples \u00b6 >>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , 0.12 ] >>> cov = stats . Cov () >>> for xi , yi in zip ( x , y ): ... print ( cov . update ( xi , yi ) . get ()) 0.0 - 1.044999 - 4.286 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y w \u2013 defaults to 1.0 update_many Notes \u00b6 The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\) . References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9 Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-) variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12). \u21a9","title":"Cov"},{"location":"api/stats/Cov/#cov","text":"Covariance.","title":"Cov"},{"location":"api/stats/Cov/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/Cov/#examples","text":">>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , 0.12 ] >>> cov = stats . Cov () >>> for xi , yi in zip ( x , y ): ... print ( cov . update ( xi , yi ) . get ()) 0.0 - 1.044999 - 4.286","title":"Examples"},{"location":"api/stats/Cov/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y w \u2013 defaults to 1.0 update_many","title":"Methods"},{"location":"api/stats/Cov/#notes","text":"The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\) .","title":"Notes"},{"location":"api/stats/Cov/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9 Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-) variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12). \u21a9","title":"References"},{"location":"api/stats/EWMean/","text":"EWMean \u00b6 Exponentially weighted mean. Parameters \u00b6 alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values. Attributes \u00b6 mean ( float ) The running exponentially weighted mean. Examples \u00b6 >>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewm = stats . EWMean ( alpha = 0.5 ) >>> for x in X : ... print ( ewm . update ( x ) . get ()) 1 2.0 3.5 3.75 4.875 6.4375 6.71875 7.859375 9.4296875 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"EWMean"},{"location":"api/stats/EWMean/#ewmean","text":"Exponentially weighted mean.","title":"EWMean"},{"location":"api/stats/EWMean/#parameters","text":"alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values.","title":"Parameters"},{"location":"api/stats/EWMean/#attributes","text":"mean ( float ) The running exponentially weighted mean.","title":"Attributes"},{"location":"api/stats/EWMean/#examples","text":">>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewm = stats . EWMean ( alpha = 0.5 ) >>> for x in X : ... print ( ewm . update ( x ) . get ()) 1 2.0 3.5 3.75 4.875 6.4375 6.71875 7.859375 9.4296875","title":"Examples"},{"location":"api/stats/EWMean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/EWMean/#references","text":"Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"References"},{"location":"api/stats/EWVar/","text":"EWVar \u00b6 Exponentially weighted variance. To calculate the variance we use the fact that Var(X) = Mean(x^2) - Mean(x)^2 and internally we use the exponentially weighted mean of x/x^2 to calculate this. Parameters \u00b6 alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values. Attributes \u00b6 variance ( float ) The running exponentially weighted variance. Examples \u00b6 >>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewv = stats . EWVar ( alpha = 0.5 ) >>> for x in X : ... print ( ewv . update ( x ) . get ()) 0 1.0 2.75 1.4375 1.984375 3.43359375 1.7958984375 2.198974609375 3.56536865234375 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"EWVar"},{"location":"api/stats/EWVar/#ewvar","text":"Exponentially weighted variance. To calculate the variance we use the fact that Var(X) = Mean(x^2) - Mean(x)^2 and internally we use the exponentially weighted mean of x/x^2 to calculate this.","title":"EWVar"},{"location":"api/stats/EWVar/#parameters","text":"alpha \u2013 defaults to 0.5 The closer alpha is to 1 the more the statistic will adapt to recent values.","title":"Parameters"},{"location":"api/stats/EWVar/#attributes","text":"variance ( float ) The running exponentially weighted variance.","title":"Attributes"},{"location":"api/stats/EWVar/#examples","text":">>> from river import stats >>> X = [ 1 , 3 , 5 , 4 , 6 , 8 , 7 , 9 , 11 ] >>> ewv = stats . EWVar ( alpha = 0.5 ) >>> for x in X : ... print ( ewv . update ( x ) . get ()) 0 1.0 2.75 1.4375 1.984375 3.43359375 1.7958984375 2.198974609375 3.56536865234375","title":"Examples"},{"location":"api/stats/EWVar/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/EWVar/#references","text":"Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Exponential Moving Average on Streaming Data \u21a9","title":"References"},{"location":"api/stats/Entropy/","text":"Entropy \u00b6 Running entropy. Parameters \u00b6 alpha \u2013 defaults to 1 Fading factor. eps \u2013 defaults to 1e-08 Small value that will be added to the denominator to avoid division by zero. Attributes \u00b6 entropy ( float ) The running entropy. n ( int ) The current number of observations. counter ( collections.Counter ) Count the number of times the values have occurred Examples \u00b6 >>> import math >>> import random >>> import numpy as np >>> from scipy.stats import entropy >>> from river import stats >>> def entropy_list ( labels , base = None ): ... value , counts = np . unique ( labels , return_counts = True ) ... return entropy ( counts , base = base ) >>> SEED = 42 * 1337 >>> random . seed ( SEED ) >>> entro = stats . Entropy ( alpha = 1 ) >>> list_animal = [] >>> for animal , num_val in zip ([ 'cat' , 'dog' , 'bird' ],[ 301 , 401 , 601 ]): ... list_animal += [ animal for i in range ( num_val )] >>> random . shuffle ( list_animal ) >>> for animal in list_animal : ... _ = entro . update ( animal ) >>> print ( f ' { entro . get () : .6f } ' ) 1.058093 >>> print ( f ' { entropy_list ( list_animal ) : .6f } ' ) 1.058093 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Sovdat, B., 2014. Updating Formulas and Algorithms for Computing Entropy and Gini Index from Time-Changing Data Streams. arXiv preprint arXiv:1403.6348. \u21a9","title":"Entropy"},{"location":"api/stats/Entropy/#entropy","text":"Running entropy.","title":"Entropy"},{"location":"api/stats/Entropy/#parameters","text":"alpha \u2013 defaults to 1 Fading factor. eps \u2013 defaults to 1e-08 Small value that will be added to the denominator to avoid division by zero.","title":"Parameters"},{"location":"api/stats/Entropy/#attributes","text":"entropy ( float ) The running entropy. n ( int ) The current number of observations. counter ( collections.Counter ) Count the number of times the values have occurred","title":"Attributes"},{"location":"api/stats/Entropy/#examples","text":">>> import math >>> import random >>> import numpy as np >>> from scipy.stats import entropy >>> from river import stats >>> def entropy_list ( labels , base = None ): ... value , counts = np . unique ( labels , return_counts = True ) ... return entropy ( counts , base = base ) >>> SEED = 42 * 1337 >>> random . seed ( SEED ) >>> entro = stats . Entropy ( alpha = 1 ) >>> list_animal = [] >>> for animal , num_val in zip ([ 'cat' , 'dog' , 'bird' ],[ 301 , 401 , 601 ]): ... list_animal += [ animal for i in range ( num_val )] >>> random . shuffle ( list_animal ) >>> for animal in list_animal : ... _ = entro . update ( animal ) >>> print ( f ' { entro . get () : .6f } ' ) 1.058093 >>> print ( f ' { entropy_list ( list_animal ) : .6f } ' ) 1.058093","title":"Examples"},{"location":"api/stats/Entropy/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Entropy/#references","text":"Sovdat, B., 2014. Updating Formulas and Algorithms for Computing Entropy and Gini Index from Time-Changing Data Streams. arXiv preprint arXiv:1403.6348. \u21a9","title":"References"},{"location":"api/stats/IQR/","text":"IQR \u00b6 Computes the interquartile range. Parameters \u00b6 q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 . Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> iqr = stats . IQR ( q_inf = 0.25 , q_sup = 0.75 ) >>> for i in range ( 0 , 1001 ): ... iqr = iqr . update ( i ) ... if i % 100 == 0 : ... print ( iqr . get ()) 0 50.0 100.0 150.0 200.0 250.0 300.0 350.0 400.0 450.0 500.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"IQR"},{"location":"api/stats/IQR/#iqr","text":"Computes the interquartile range.","title":"IQR"},{"location":"api/stats/IQR/#parameters","text":"q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 .","title":"Parameters"},{"location":"api/stats/IQR/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/IQR/#examples","text":">>> from river import stats >>> iqr = stats . IQR ( q_inf = 0.25 , q_sup = 0.75 ) >>> for i in range ( 0 , 1001 ): ... iqr = iqr . update ( i ) ... if i % 100 == 0 : ... print ( iqr . get ()) 0 50.0 100.0 150.0 200.0 250.0 300.0 350.0 400.0 450.0 500.0","title":"Examples"},{"location":"api/stats/IQR/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Kurtosis/","text":"Kurtosis \u00b6 Running kurtosis using Welford's algorithm. Parameters \u00b6 bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias. Attributes \u00b6 name Examples \u00b6 >>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> kurtosis = river . stats . Kurtosis ( bias = False ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 1.4130027920707047 0.15367976585756438 0.46142633246812653 - 1.620647789230658 - 1.3540178492487054 - 1.2310268787102745 - 0.9490372374384453 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = False )) - 3.0 - 2.0 - 1.4999999999999998 1.4130027920707082 0.15367976585756082 0.46142633246812403 - 1.620647789230658 - 1.3540178492487063 - 1.2310268787102738 - 0.9490372374384459 >>> kurtosis = river . stats . Kurtosis ( bias = True ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 - 1.011599627723906 - 0.9615800585356089 - 0.6989395431537853 - 1.4252699121794408 - 1.311437071070812 - 1.246289111322894 - 1.082283689864171 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = True )) - 3.0 - 2.0 - 1.4999999999999998 - 1.0115996277239057 - 0.9615800585356098 - 0.6989395431537861 - 1.425269912179441 - 1.3114370710708125 - 1.2462891113228936 - 1.0822836898641714 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9","title":"Kurtosis"},{"location":"api/stats/Kurtosis/#kurtosis","text":"Running kurtosis using Welford's algorithm.","title":"Kurtosis"},{"location":"api/stats/Kurtosis/#parameters","text":"bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias.","title":"Parameters"},{"location":"api/stats/Kurtosis/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Kurtosis/#examples","text":">>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> kurtosis = river . stats . Kurtosis ( bias = False ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 1.4130027920707047 0.15367976585756438 0.46142633246812653 - 1.620647789230658 - 1.3540178492487054 - 1.2310268787102745 - 0.9490372374384453 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = False )) - 3.0 - 2.0 - 1.4999999999999998 1.4130027920707082 0.15367976585756082 0.46142633246812403 - 1.620647789230658 - 1.3540178492487063 - 1.2310268787102738 - 0.9490372374384459 >>> kurtosis = river . stats . Kurtosis ( bias = True ) >>> for x in X : ... print ( kurtosis . update ( x ) . get ()) - 3 - 2.0 - 1.5 - 1.011599627723906 - 0.9615800585356089 - 0.6989395431537853 - 1.4252699121794408 - 1.311437071070812 - 1.246289111322894 - 1.082283689864171 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . kurtosis ( X [: i ], bias = True )) - 3.0 - 2.0 - 1.4999999999999998 - 1.0115996277239057 - 0.9615800585356098 - 0.6989395431537861 - 1.425269912179441 - 1.3114370710708125 - 1.2462891113228936 - 1.0822836898641714","title":"Examples"},{"location":"api/stats/Kurtosis/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Kurtosis/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9","title":"References"},{"location":"api/stats/Link/","text":"Link \u00b6 A link joins two univariate statistics as a sequence. This can be used to pipe the output of one statistic to the input of another. This can be used, for instance, to calculate the mean of the variance of a variable. It can also be used to compute shifted statistics by piping statistics with an instance of stats.Shift . Note that a link is not meant to be instantiated via this class definition. Instead, users can link statistics together via the | operator. Parameters \u00b6 left ( river.stats.base.Univariate ) right ( river.stats.base.Univariate ) The output from left 's get method is passed to right 's update method if left 's get method doesn't produce None. Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () No values have been seen, therefore get defaults to the initial value of stats.Mean , which is 0. >>> stat . get () 0. Let us now call update . >>> stat = stat . update ( 1 ) The output from get will still be 0. The reason is that stats.Shift has not enough values, and therefore outputs it's default value, which is None . The stats.Mean instance is therefore not updated. >>> stat . get () 0.0 On the next call to update , the stats.Shift instance has seen enough values, and therefore the mean can be updated. The mean is therefore equal to 1, because that's the only value from the past. >>> stat = stat . update ( 3 ) >>> stat . get () 1.0 On the subsequent call to update, the mean will be updated with the value 3. >>> stat = stat . update ( 4 ) >>> stat . get () 2.0 Note that composing statistics returns a new statistic with it's own name. >>> stat . name 'mean_of_shift_1' Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Link"},{"location":"api/stats/Link/#link","text":"A link joins two univariate statistics as a sequence. This can be used to pipe the output of one statistic to the input of another. This can be used, for instance, to calculate the mean of the variance of a variable. It can also be used to compute shifted statistics by piping statistics with an instance of stats.Shift . Note that a link is not meant to be instantiated via this class definition. Instead, users can link statistics together via the | operator.","title":"Link"},{"location":"api/stats/Link/#parameters","text":"left ( river.stats.base.Univariate ) right ( river.stats.base.Univariate ) The output from left 's get method is passed to right 's update method if left 's get method doesn't produce None.","title":"Parameters"},{"location":"api/stats/Link/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Link/#examples","text":">>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () No values have been seen, therefore get defaults to the initial value of stats.Mean , which is 0. >>> stat . get () 0. Let us now call update . >>> stat = stat . update ( 1 ) The output from get will still be 0. The reason is that stats.Shift has not enough values, and therefore outputs it's default value, which is None . The stats.Mean instance is therefore not updated. >>> stat . get () 0.0 On the next call to update , the stats.Shift instance has seen enough values, and therefore the mean can be updated. The mean is therefore equal to 1, because that's the only value from the past. >>> stat = stat . update ( 3 ) >>> stat . get () 1.0 On the subsequent call to update, the mean will be updated with the value 3. >>> stat = stat . update ( 4 ) >>> stat . get () 2.0 Note that composing statistics returns a new statistic with it's own name. >>> stat . name 'mean_of_shift_1'","title":"Examples"},{"location":"api/stats/Link/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/MAD/","text":"MAD \u00b6 Median Absolute Deviation (MAD). The median absolute deviation is the median of the absolute differences between each data point and the data's overall median. In an online setting, the median of the data is unknown beforehand. Therefore, both the median of the data and the median of the differences of the data with respect to the latter are updated online. To be precise, the median of the data is updated before the median of the differences. As a consequence, this online version of the MAD does not coincide exactly with its batch counterpart. Attributes \u00b6 median ( stats.Median ) The median of the data. Examples \u00b6 >>> from river import stats >>> X = [ 4 , 2 , 5 , 3 , 0 , 4 ] >>> mad = stats . MAD () >>> for x in X : ... print ( mad . update ( x ) . get ()) 0 2 1 1 1 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Median absolute deviation article on Wikipedia \u21a9","title":"MAD"},{"location":"api/stats/MAD/#mad","text":"Median Absolute Deviation (MAD). The median absolute deviation is the median of the absolute differences between each data point and the data's overall median. In an online setting, the median of the data is unknown beforehand. Therefore, both the median of the data and the median of the differences of the data with respect to the latter are updated online. To be precise, the median of the data is updated before the median of the differences. As a consequence, this online version of the MAD does not coincide exactly with its batch counterpart.","title":"MAD"},{"location":"api/stats/MAD/#attributes","text":"median ( stats.Median ) The median of the data.","title":"Attributes"},{"location":"api/stats/MAD/#examples","text":">>> from river import stats >>> X = [ 4 , 2 , 5 , 3 , 0 , 4 ] >>> mad = stats . MAD () >>> for x in X : ... print ( mad . update ( x ) . get ()) 0 2 1 1 1 1","title":"Examples"},{"location":"api/stats/MAD/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/MAD/#references","text":"Median absolute deviation article on Wikipedia \u21a9","title":"References"},{"location":"api/stats/Max/","text":"Max \u00b6 Running max. Attributes \u00b6 max ( float ) The current max. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> _max = stats . Max () >>> for x in X : ... print ( _max . update ( x ) . get ()) 1 1 3 3 5 5 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Max"},{"location":"api/stats/Max/#max","text":"Running max.","title":"Max"},{"location":"api/stats/Max/#attributes","text":"max ( float ) The current max.","title":"Attributes"},{"location":"api/stats/Max/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 5 , - 6 ] >>> _max = stats . Max () >>> for x in X : ... print ( _max . update ( x ) . get ()) 1 1 3 3 5 5","title":"Examples"},{"location":"api/stats/Max/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Mean/","text":"Mean \u00b6 Running mean. Attributes \u00b6 n ( float ) The current sum of weights. If each passed weight was 1, then this is equal to the number of seen observations. Examples \u00b6 >>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Mean () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 4.0 - 3.0 - 2.0 - 1.0 0.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 update_many References \u00b6 West, D. H. D. (1979). Updating mean and variance estimates: An improved method. Communications of the ACM, 22(9), 532-535. \u21a9 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"Mean"},{"location":"api/stats/Mean/#mean","text":"Running mean.","title":"Mean"},{"location":"api/stats/Mean/#attributes","text":"n ( float ) The current sum of weights. If each passed weight was 1, then this is equal to the number of seen observations.","title":"Attributes"},{"location":"api/stats/Mean/#examples","text":">>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Mean () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 4.0 - 3.0 - 2.0 - 1.0 0.0","title":"Examples"},{"location":"api/stats/Mean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 update_many","title":"Methods"},{"location":"api/stats/Mean/#references","text":"West, D. H. D. (1979). Updating mean and variance estimates: An improved method. Communications of the ACM, 22(9), 532-535. \u21a9 Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"References"},{"location":"api/stats/Min/","text":"Min \u00b6 Running min. Attributes \u00b6 min ( float ) The current min. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Min"},{"location":"api/stats/Min/#min","text":"Running min.","title":"Min"},{"location":"api/stats/Min/#attributes","text":"min ( float ) The current min.","title":"Attributes"},{"location":"api/stats/Min/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Mode/","text":"Mode \u00b6 Running mode. The mode is simply the most common value. An approximate mode can be computed by setting the number of first unique values to count. Parameters \u00b6 k \u2013 defaults to 25 Only the first k unique values will be included. If k equals -1, the exact mode is computed. Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> X = [ 'sunny' , 'cloudy' , 'cloudy' , 'rainy' , 'rainy' , 'rainy' ] >>> mode = stats . Mode ( k = 2 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy cloudy >>> mode = stats . Mode ( k =- 1 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy rainy Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Mode"},{"location":"api/stats/Mode/#mode","text":"Running mode. The mode is simply the most common value. An approximate mode can be computed by setting the number of first unique values to count.","title":"Mode"},{"location":"api/stats/Mode/#parameters","text":"k \u2013 defaults to 25 Only the first k unique values will be included. If k equals -1, the exact mode is computed.","title":"Parameters"},{"location":"api/stats/Mode/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Mode/#examples","text":">>> from river import stats >>> X = [ 'sunny' , 'cloudy' , 'cloudy' , 'rainy' , 'rainy' , 'rainy' ] >>> mode = stats . Mode ( k = 2 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy cloudy >>> mode = stats . Mode ( k =- 1 ) >>> for x in X : ... print ( mode . update ( x ) . get ()) sunny sunny cloudy cloudy cloudy rainy","title":"Examples"},{"location":"api/stats/Mode/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/NUnique/","text":"NUnique \u00b6 Approximate number of unique values counter. This is basically an implementation of the HyperLogLog algorithm. Adapted from hypy . The code is a bit too terse but it will do for now. Parameters \u00b6 error_rate \u2013 defaults to 0.01 Desired error rate. Memory usage is inversely proportional to this value. seed ( int ) \u2013 defaults to None Set the seed to produce identical results. Attributes \u00b6 n_bits ( int ) n_buckets ( int ) buckets ( list ) Examples \u00b6 >>> import string >>> from river import stats >>> alphabet = string . ascii_lowercase >>> n_unique = stats . NUnique ( error_rate = 0.2 , seed = 42 ) >>> n_unique . update ( 'a' ) . get () 1 >>> n_unique . update ( 'b' ) . get () 2 >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 31 Lowering the error_rate parameter will increase the precision. >>> n_unique = stats . NUnique ( error_rate = 0.01 , seed = 42 ) >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 26 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 My favorite algorithm (and data structure): HyperLogLog \u21a9 Flajolet, P., Fusy, \u00c9., Gandouet, O. and Meunier, F., 2007, June. Hyperloglog: the analysis of a near-optimal cardinality estimation algorithm. \u21a9","title":"NUnique"},{"location":"api/stats/NUnique/#nunique","text":"Approximate number of unique values counter. This is basically an implementation of the HyperLogLog algorithm. Adapted from hypy . The code is a bit too terse but it will do for now.","title":"NUnique"},{"location":"api/stats/NUnique/#parameters","text":"error_rate \u2013 defaults to 0.01 Desired error rate. Memory usage is inversely proportional to this value. seed ( int ) \u2013 defaults to None Set the seed to produce identical results.","title":"Parameters"},{"location":"api/stats/NUnique/#attributes","text":"n_bits ( int ) n_buckets ( int ) buckets ( list )","title":"Attributes"},{"location":"api/stats/NUnique/#examples","text":">>> import string >>> from river import stats >>> alphabet = string . ascii_lowercase >>> n_unique = stats . NUnique ( error_rate = 0.2 , seed = 42 ) >>> n_unique . update ( 'a' ) . get () 1 >>> n_unique . update ( 'b' ) . get () 2 >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 31 Lowering the error_rate parameter will increase the precision. >>> n_unique = stats . NUnique ( error_rate = 0.01 , seed = 42 ) >>> for letter in alphabet : ... n_unique = n_unique . update ( letter ) >>> n_unique . get () 26","title":"Examples"},{"location":"api/stats/NUnique/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/NUnique/#references","text":"My favorite algorithm (and data structure): HyperLogLog \u21a9 Flajolet, P., Fusy, \u00c9., Gandouet, O. and Meunier, F., 2007, June. Hyperloglog: the analysis of a near-optimal cardinality estimation algorithm. \u21a9","title":"References"},{"location":"api/stats/PeakToPeak/","text":"PeakToPeak \u00b6 Running peak to peak (max - min). Attributes \u00b6 max ( stats.Max ) The running max. min ( stats.Min ) The running min. p2p ( float ) The running peak to peak. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 4 ] >>> ptp = stats . PeakToPeak () >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 7 7 8 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"PeakToPeak"},{"location":"api/stats/PeakToPeak/#peaktopeak","text":"Running peak to peak (max - min).","title":"PeakToPeak"},{"location":"api/stats/PeakToPeak/#attributes","text":"max ( stats.Max ) The running max. min ( stats.Min ) The running min. p2p ( float ) The running peak to peak.","title":"Attributes"},{"location":"api/stats/PeakToPeak/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 4 ] >>> ptp = stats . PeakToPeak () >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 7 7 8","title":"Examples"},{"location":"api/stats/PeakToPeak/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/PearsonCorr/","text":"PearsonCorr \u00b6 Online Pearson correlation. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. Attributes \u00b6 var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y . Examples \u00b6 >>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . PearsonCorr () >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.774596 0.866025 0.878310 0.866025 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"PearsonCorr"},{"location":"api/stats/PearsonCorr/#pearsoncorr","text":"Online Pearson correlation.","title":"PearsonCorr"},{"location":"api/stats/PearsonCorr/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/PearsonCorr/#attributes","text":"var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y .","title":"Attributes"},{"location":"api/stats/PearsonCorr/#examples","text":">>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . PearsonCorr () >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.774596 0.866025 0.878310 0.866025","title":"Examples"},{"location":"api/stats/PearsonCorr/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/Quantile/","text":"Quantile \u00b6 Running quantile. Uses the P\u00b2 algorithm, which is also known as the \"Piecewise-Parabolic quantile estimator\". The code is inspired by LiveStat's implementation 2 . Parameters \u00b6 q \u2013 defaults to 0.5 Determines which quantile to compute, must be comprised between 0 and 1. Attributes \u00b6 name Examples \u00b6 >>> from river import stats >>> import numpy as np >>> np . random . seed ( 42 * 1337 ) >>> mu , sigma = 0 , 1 >>> s = np . random . normal ( mu , sigma , 500 ) >>> median = stats . Quantile ( 0.5 ) >>> for x in s : ... _ = median . update ( x ) >>> print ( f 'The estimated value of the 50th (median) quantile is { median . get () : .4f } ' ) The estimated value of the 50 th ( median ) quantile is - 0.0275 >>> print ( f 'The real value of the 50th (median) quantile is { np . median ( s ) : .4f } ' ) The real value of the 50 th ( median ) quantile is - 0.0135 >>> percentile_17 = stats . Quantile ( 0.17 ) >>> for x in s : ... _ = percentile_17 . update ( x ) >>> print ( f 'The estimated value of the 17th quantile is { percentile_17 . get () : .4f } ' ) The estimated value of the 17 th quantile is - 0.8652 >>> print ( f 'The real value of the 17th quantile is { np . percentile ( s , 17 ) : .4f } ' ) The real value of the 17 th quantile is - 0.9072 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 The P\u00b2 Algorithm for Dynamic Univariateal Computing Calculation of Quantiles and Editor Histograms Without Storing Observations \u21a9 LiveStats \u21a9 P\u00b2 quantile estimator: estimating the median without storing values \u21a9","title":"Quantile"},{"location":"api/stats/Quantile/#quantile","text":"Running quantile. Uses the P\u00b2 algorithm, which is also known as the \"Piecewise-Parabolic quantile estimator\". The code is inspired by LiveStat's implementation 2 .","title":"Quantile"},{"location":"api/stats/Quantile/#parameters","text":"q \u2013 defaults to 0.5 Determines which quantile to compute, must be comprised between 0 and 1.","title":"Parameters"},{"location":"api/stats/Quantile/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Quantile/#examples","text":">>> from river import stats >>> import numpy as np >>> np . random . seed ( 42 * 1337 ) >>> mu , sigma = 0 , 1 >>> s = np . random . normal ( mu , sigma , 500 ) >>> median = stats . Quantile ( 0.5 ) >>> for x in s : ... _ = median . update ( x ) >>> print ( f 'The estimated value of the 50th (median) quantile is { median . get () : .4f } ' ) The estimated value of the 50 th ( median ) quantile is - 0.0275 >>> print ( f 'The real value of the 50th (median) quantile is { np . median ( s ) : .4f } ' ) The real value of the 50 th ( median ) quantile is - 0.0135 >>> percentile_17 = stats . Quantile ( 0.17 ) >>> for x in s : ... _ = percentile_17 . update ( x ) >>> print ( f 'The estimated value of the 17th quantile is { percentile_17 . get () : .4f } ' ) The estimated value of the 17 th quantile is - 0.8652 >>> print ( f 'The real value of the 17th quantile is { np . percentile ( s , 17 ) : .4f } ' ) The real value of the 17 th quantile is - 0.9072","title":"Examples"},{"location":"api/stats/Quantile/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Quantile/#references","text":"The P\u00b2 Algorithm for Dynamic Univariateal Computing Calculation of Quantiles and Editor Histograms Without Storing Observations \u21a9 LiveStats \u21a9 P\u00b2 quantile estimator: estimating the median without storing values \u21a9","title":"References"},{"location":"api/stats/RollingAbsMax/","text":"RollingAbsMax \u00b6 Running absolute max over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_absmax = stats . RollingAbsMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_absmax . update ( x ) . get ()) 1 4 4 3 2 2 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingAbsMax"},{"location":"api/stats/RollingAbsMax/#rollingabsmax","text":"Running absolute max over a window.","title":"RollingAbsMax"},{"location":"api/stats/RollingAbsMax/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingAbsMax/#attributes","text":"name window_size","title":"Attributes"},{"location":"api/stats/RollingAbsMax/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_absmax = stats . RollingAbsMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_absmax . update ( x ) . get ()) 1 4 4 3 2 2","title":"Examples"},{"location":"api/stats/RollingAbsMax/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingCov/","text":"RollingCov \u00b6 Rolling covariance. Parameters \u00b6 window_size Size of the window over which to compute the covariance. ddof \u2013 defaults to 1 Delta Degrees of Freedom. Attributes \u00b6 window_size Examples \u00b6 >>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 , 1 , - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , .12 , 1 , 3 , 1.1 , .12 ] >>> rcov = stats . RollingCov ( 3 ) >>> for xi , yi in zip ( x , y ): ... print ( rcov . update ( xi , yi ) . get ()) 0.0 - 1.045 - 4.286 - 1.382 - 4.589 - 1.415 - 4.286 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"RollingCov"},{"location":"api/stats/RollingCov/#rollingcov","text":"Rolling covariance.","title":"RollingCov"},{"location":"api/stats/RollingCov/#parameters","text":"window_size Size of the window over which to compute the covariance. ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/RollingCov/#attributes","text":"window_size","title":"Attributes"},{"location":"api/stats/RollingCov/#examples","text":">>> from river import stats >>> x = [ - 2.1 , - 1 , 4.3 , 1 , - 2.1 , - 1 , 4.3 ] >>> y = [ 3 , 1.1 , .12 , 1 , 3 , 1.1 , .12 ] >>> rcov = stats . RollingCov ( 3 ) >>> for xi , yi in zip ( x , y ): ... print ( rcov . update ( xi , yi ) . get ()) 0.0 - 1.045 - 4.286 - 1.382 - 4.589 - 1.415 - 4.286","title":"Examples"},{"location":"api/stats/RollingCov/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/RollingIQR/","text":"RollingIQR \u00b6 Computes the rolling interquartile range. Parameters \u00b6 window_size ( int ) Size of the window. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 . Attributes \u00b6 name window_size Examples \u00b6 >>> from river import stats >>> rolling_iqr = stats . RollingIQR ( ... q_inf = 0.25 , ... q_sup = 0.75 , ... window_size = 101 ... ) >>> for i in range ( 0 , 1001 ): ... rolling_iqr = rolling_iqr . update ( i ) ... if i % 100 == 0 : ... print ( rolling_iqr . get ()) 0.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingIQR"},{"location":"api/stats/RollingIQR/#rollingiqr","text":"Computes the rolling interquartile range.","title":"RollingIQR"},{"location":"api/stats/RollingIQR/#parameters","text":"window_size ( int ) Size of the window. q_inf \u2013 defaults to 0.25 Desired inferior quantile, must be between 0 and 1. Defaults to 0.25 . q_sup \u2013 defaults to 0.75 Desired superior quantile, must be between 0 and 1. Defaults to 0.75 .","title":"Parameters"},{"location":"api/stats/RollingIQR/#attributes","text":"name window_size","title":"Attributes"},{"location":"api/stats/RollingIQR/#examples","text":">>> from river import stats >>> rolling_iqr = stats . RollingIQR ( ... q_inf = 0.25 , ... q_sup = 0.75 , ... window_size = 101 ... ) >>> for i in range ( 0 , 1001 ): ... rolling_iqr = rolling_iqr . update ( i ) ... if i % 100 == 0 : ... print ( rolling_iqr . get ()) 0.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0 50.0","title":"Examples"},{"location":"api/stats/RollingIQR/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMax/","text":"RollingMax \u00b6 Running max over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_max = stats . RollingMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_max . update ( x ) . get ()) 1 1 3 3 2 2 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingMax"},{"location":"api/stats/RollingMax/#rollingmax","text":"Running max over a window.","title":"RollingMax"},{"location":"api/stats/RollingMax/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMax/#attributes","text":"name window_size","title":"Attributes"},{"location":"api/stats/RollingMax/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_max = stats . RollingMax ( window_size = 2 ) >>> for x in X : ... print ( rolling_max . update ( x ) . get ()) 1 1 3 3 2 2","title":"Examples"},{"location":"api/stats/RollingMax/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMean/","text":"RollingMean \u00b6 Running average over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> rmean = stats . RollingMean ( window_size = 2 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.5 3.5 4.5 5.5 >>> rmean = stats . RollingMean ( window_size = 3 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.0 3.0 4.0 5.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingMean"},{"location":"api/stats/RollingMean/#rollingmean","text":"Running average over a window.","title":"RollingMean"},{"location":"api/stats/RollingMean/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMean/#attributes","text":"name window_size","title":"Attributes"},{"location":"api/stats/RollingMean/#examples","text":">>> from river import stats >>> X = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> rmean = stats . RollingMean ( window_size = 2 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.5 3.5 4.5 5.5 >>> rmean = stats . RollingMean ( window_size = 3 ) >>> for x in X : ... print ( rmean . update ( x ) . get ()) 1.0 1.5 2.0 3.0 4.0 5.0","title":"Examples"},{"location":"api/stats/RollingMean/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMin/","text":"RollingMin \u00b6 Running min over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 name window_size Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_min = stats . RollingMin ( 2 ) >>> for x in X : ... print ( rolling_min . update ( x ) . get ()) 1 - 4 - 4 - 2 - 2 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingMin"},{"location":"api/stats/RollingMin/#rollingmin","text":"Running min over a window.","title":"RollingMin"},{"location":"api/stats/RollingMin/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMin/#attributes","text":"name window_size","title":"Attributes"},{"location":"api/stats/RollingMin/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_min = stats . RollingMin ( 2 ) >>> for x in X : ... print ( rolling_min . update ( x ) . get ()) 1 - 4 - 4 - 2 - 2 1","title":"Examples"},{"location":"api/stats/RollingMin/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingMode/","text":"RollingMode \u00b6 Running mode over a window. The mode is the most common value. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 counts ( collections.defaultdict ) Value counts. Examples \u00b6 >>> from river import stats >>> X = [ 'sunny' , 'sunny' , 'sunny' , 'rainy' , 'rainy' , 'rainy' , 'rainy' ] >>> rolling_mode = stats . RollingMode ( window_size = 2 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny rainy rainy rainy >>> rolling_mode = stats . RollingMode ( window_size = 5 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny sunny rainy rainy Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingMode"},{"location":"api/stats/RollingMode/#rollingmode","text":"Running mode over a window. The mode is the most common value.","title":"RollingMode"},{"location":"api/stats/RollingMode/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingMode/#attributes","text":"counts ( collections.defaultdict ) Value counts.","title":"Attributes"},{"location":"api/stats/RollingMode/#examples","text":">>> from river import stats >>> X = [ 'sunny' , 'sunny' , 'sunny' , 'rainy' , 'rainy' , 'rainy' , 'rainy' ] >>> rolling_mode = stats . RollingMode ( window_size = 2 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny rainy rainy rainy >>> rolling_mode = stats . RollingMode ( window_size = 5 ) >>> for x in X : ... print ( rolling_mode . update ( x ) . get ()) sunny sunny sunny sunny sunny rainy rainy","title":"Examples"},{"location":"api/stats/RollingMode/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingPeakToPeak/","text":"RollingPeakToPeak \u00b6 Running peak to peak (max - min) over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 max ( stats.RollingMax ) The running rolling max. min ( stats.RollingMin ) The running rolling min. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> ptp = stats . RollingPeakToPeak ( window_size = 2 ) >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 5 4 1 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingPeakToPeak"},{"location":"api/stats/RollingPeakToPeak/#rollingpeaktopeak","text":"Running peak to peak (max - min) over a window.","title":"RollingPeakToPeak"},{"location":"api/stats/RollingPeakToPeak/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingPeakToPeak/#attributes","text":"max ( stats.RollingMax ) The running rolling max. min ( stats.RollingMin ) The running rolling min.","title":"Attributes"},{"location":"api/stats/RollingPeakToPeak/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> ptp = stats . RollingPeakToPeak ( window_size = 2 ) >>> for x in X : ... print ( ptp . update ( x ) . get ()) 0 5 7 5 4 1","title":"Examples"},{"location":"api/stats/RollingPeakToPeak/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingPearsonCorr/","text":"RollingPearsonCorr \u00b6 Rolling Pearson correlation. Parameters \u00b6 window_size Amount of samples over which to compute the correlation. ddof \u2013 defaults to 1 Delta Degrees of Freedom. Attributes \u00b6 var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y . Examples \u00b6 >>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . RollingPearsonCorr ( window_size = 4 ) >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.7745966692414834 0.894427190999916 0.7745966692414834 0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"RollingPearsonCorr"},{"location":"api/stats/RollingPearsonCorr/#rollingpearsoncorr","text":"Rolling Pearson correlation.","title":"RollingPearsonCorr"},{"location":"api/stats/RollingPearsonCorr/#parameters","text":"window_size Amount of samples over which to compute the correlation. ddof \u2013 defaults to 1 Delta Degrees of Freedom.","title":"Parameters"},{"location":"api/stats/RollingPearsonCorr/#attributes","text":"var_x ( stats.Var ) Running variance of x . var_y ( stats.Var ) Running variance of y . cov_xy ( stats.Cov ) Running covariance of x and y .","title":"Attributes"},{"location":"api/stats/RollingPearsonCorr/#examples","text":">>> from river import stats >>> x = [ 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> y = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] >>> pearson = stats . RollingPearsonCorr ( window_size = 4 ) >>> for xi , yi in zip ( x , y ): ... print ( pearson . update ( xi , yi ) . get ()) 0 0 0 0.7745966692414834 0.894427190999916 0.7745966692414834 0","title":"Examples"},{"location":"api/stats/RollingPearsonCorr/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/RollingQuantile/","text":"RollingQuantile \u00b6 Running quantile over a window. Parameters \u00b6 q Determines which quantile to compute, must be comprised between 0 and 1. window_size Size of the window. Attributes \u00b6 name window_size Examples \u00b6 >>> from river import stats >>> rolling_quantile = stats . RollingQuantile ( ... q = .5 , ... window_size = 101 , ... ) >>> for i in range ( 1001 ): ... rolling_quantile = rolling_quantile . update ( i ) ... if i % 100 == 0 : ... print ( rolling_quantile . get ()) 0.0 50.0 150.0 250.0 350.0 450.0 550.0 650.0 750.0 850.0 950.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Left sorted \u21a9","title":"RollingQuantile"},{"location":"api/stats/RollingQuantile/#rollingquantile","text":"Running quantile over a window.","title":"RollingQuantile"},{"location":"api/stats/RollingQuantile/#parameters","text":"q Determines which quantile to compute, must be comprised between 0 and 1. window_size Size of the window.","title":"Parameters"},{"location":"api/stats/RollingQuantile/#attributes","text":"name window_size","title":"Attributes"},{"location":"api/stats/RollingQuantile/#examples","text":">>> from river import stats >>> rolling_quantile = stats . RollingQuantile ( ... q = .5 , ... window_size = 101 , ... ) >>> for i in range ( 1001 ): ... rolling_quantile = rolling_quantile . update ( i ) ... if i % 100 == 0 : ... print ( rolling_quantile . get ()) 0.0 50.0 150.0 250.0 350.0 450.0 550.0 650.0 750.0 850.0 950.0","title":"Examples"},{"location":"api/stats/RollingQuantile/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingQuantile/#references","text":"Left sorted \u21a9","title":"References"},{"location":"api/stats/RollingSEM/","text":"RollingSEM \u00b6 Running standard error of the mean over a window. Parameters \u00b6 window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom for the variance. Attributes \u00b6 correction_factor name window_size Examples \u00b6 >>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 1.0 3.0 2.0 4.0 >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 0.881917 2.403700 2.905932 2.309401 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingSEM"},{"location":"api/stats/RollingSEM/#rollingsem","text":"Running standard error of the mean over a window.","title":"RollingSEM"},{"location":"api/stats/RollingSEM/#parameters","text":"window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom for the variance.","title":"Parameters"},{"location":"api/stats/RollingSEM/#attributes","text":"correction_factor name window_size","title":"Attributes"},{"location":"api/stats/RollingSEM/#examples","text":">>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 1.0 3.0 2.0 4.0 >>> rolling_sem = river . stats . RollingSEM ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rolling_sem . update ( x ) . get ()) 0.0 1.5 0.881917 2.403700 2.905932 2.309401","title":"Examples"},{"location":"api/stats/RollingSEM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingSum/","text":"RollingSum \u00b6 Running sum over a window. Parameters \u00b6 window_size ( int ) Size of the rolling window. Attributes \u00b6 sum ( int ) The running rolling sum. Examples \u00b6 >>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_sum = stats . RollingSum ( 2 ) >>> for x in X : ... print ( rolling_sum . update ( x ) . get ()) 1 - 3 - 1 1 0 3 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingSum"},{"location":"api/stats/RollingSum/#rollingsum","text":"Running sum over a window.","title":"RollingSum"},{"location":"api/stats/RollingSum/#parameters","text":"window_size ( int ) Size of the rolling window.","title":"Parameters"},{"location":"api/stats/RollingSum/#attributes","text":"sum ( int ) The running rolling sum.","title":"Attributes"},{"location":"api/stats/RollingSum/#examples","text":">>> from river import stats >>> X = [ 1 , - 4 , 3 , - 2 , 2 , 1 ] >>> rolling_sum = stats . RollingSum ( 2 ) >>> for x in X : ... print ( rolling_sum . update ( x ) . get ()) 1 - 3 - 1 1 0 3","title":"Examples"},{"location":"api/stats/RollingSum/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/RollingVar/","text":"RollingVar \u00b6 Running variance over a window. Parameters \u00b6 window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n represents the number of seen elements. Attributes \u00b6 correction_factor name window_size Examples \u00b6 >>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.0 18.0 8.0 32.0 >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.333333 17.333333 25.333333 16.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"RollingVar"},{"location":"api/stats/RollingVar/#rollingvar","text":"Running variance over a window.","title":"RollingVar"},{"location":"api/stats/RollingVar/#parameters","text":"window_size Size of the rolling window. ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n represents the number of seen elements.","title":"Parameters"},{"location":"api/stats/RollingVar/#attributes","text":"correction_factor name window_size","title":"Attributes"},{"location":"api/stats/RollingVar/#examples","text":">>> import river >>> X = [ 1 , 4 , 2 , - 4 , - 8 , 0 ] >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 2 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.0 18.0 8.0 32.0 >>> rvar = river . stats . RollingVar ( ddof = 1 , window_size = 3 ) >>> for x in X : ... print ( rvar . update ( x ) . get ()) 0.0 4.5 2.333333 17.333333 25.333333 16.0","title":"Examples"},{"location":"api/stats/RollingVar/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/SEM/","text":"SEM \u00b6 Running standard error of the mean using Welford's algorithm. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n is the number of seen elements. Attributes \u00b6 n ( int ) Number of observations. Examples \u00b6 >>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> sem = river . stats . SEM () >>> for x in X : ... print ( sem . update ( x ) . get ()) 0.0 1.0 0.577350 0.853912 1.240967 1.447219 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 update_many References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9","title":"SEM"},{"location":"api/stats/SEM/#sem","text":"Running standard error of the mean using Welford's algorithm.","title":"SEM"},{"location":"api/stats/SEM/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n is the number of seen elements.","title":"Parameters"},{"location":"api/stats/SEM/#attributes","text":"n ( int ) Number of observations.","title":"Attributes"},{"location":"api/stats/SEM/#examples","text":">>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> sem = river . stats . SEM () >>> for x in X : ... print ( sem . update ( x ) . get ()) 0.0 1.0 0.577350 0.853912 1.240967 1.447219","title":"Examples"},{"location":"api/stats/SEM/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 update_many","title":"Methods"},{"location":"api/stats/SEM/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9","title":"References"},{"location":"api/stats/Shift/","text":"Shift \u00b6 Shifts a data stream by returning past values. This can be used to compute statistics over past data. For instance, if you're computing daily averages, then shifting by 7 will be equivalent to computing averages from a week ago. Shifting values is useful when you're calculating an average over a target value. Indeed, in this case it's important to shift the values in order not to introduce leakage. The recommended way to do this is to feature_extraction.TargetAgg , which already takes care of shifting the target values once. Parameters \u00b6 amount \u2013 defaults to 1 Shift amount. The get method will return the t - amount value, where t is the current moment. fill_value \u2013 defaults to None This value will be returned by the get method if not enough values have been observed. Attributes \u00b6 name Examples \u00b6 It is rare to have to use Shift by itself. A more common usage is to compose it with other statistics. This can be done via the | operator. >>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () >>> for i in range ( 5 ): ... stat = stat . update ( i ) ... print ( stat . get ()) 0.0 0.0 0.5 1.0 1.5 A common usecase for using Shift is when computing statistics on shifted data. For instance, say you have a dataset which records the amount of sales for a set of shops. You might then have a shop field and a sales field. Let's say you want to look at the average amount of sales per shop. You can do this by using a feature_extraction.Agg . When you call transform_one , you're expecting it to return the average amount of sales, without including today's sales. You can do this by prepending an instance of stats.Mean with an instance of stats.Shift . >>> from river import feature_extraction >>> agg = feature_extraction . Agg ( ... on = 'sales' , ... how = stats . Shift ( 1 ) | stats . Mean (), ... by = 'shop' ... ) Let's define a little example dataset. >>> X = iter ([ ... { 'shop' : 'Ikea' , 'sales' : 10 }, ... { 'shop' : 'Ikea' , 'sales' : 15 }, ... { 'shop' : 'Ikea' , 'sales' : 20 } ... ]) Now let's call the learn_one method to update our feature extractor. >>> x = next ( X ) >>> agg = agg . learn_one ( x ) At this point, the average defaults to the initial value of stats.Mean , which is 0. >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 0.0 } We can now update our feature extractor with the next data point and check the output. >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 10.0 } >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 12.5 } Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Shift"},{"location":"api/stats/Shift/#shift","text":"Shifts a data stream by returning past values. This can be used to compute statistics over past data. For instance, if you're computing daily averages, then shifting by 7 will be equivalent to computing averages from a week ago. Shifting values is useful when you're calculating an average over a target value. Indeed, in this case it's important to shift the values in order not to introduce leakage. The recommended way to do this is to feature_extraction.TargetAgg , which already takes care of shifting the target values once.","title":"Shift"},{"location":"api/stats/Shift/#parameters","text":"amount \u2013 defaults to 1 Shift amount. The get method will return the t - amount value, where t is the current moment. fill_value \u2013 defaults to None This value will be returned by the get method if not enough values have been observed.","title":"Parameters"},{"location":"api/stats/Shift/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Shift/#examples","text":"It is rare to have to use Shift by itself. A more common usage is to compose it with other statistics. This can be done via the | operator. >>> from river import stats >>> stat = stats . Shift ( 1 ) | stats . Mean () >>> for i in range ( 5 ): ... stat = stat . update ( i ) ... print ( stat . get ()) 0.0 0.0 0.5 1.0 1.5 A common usecase for using Shift is when computing statistics on shifted data. For instance, say you have a dataset which records the amount of sales for a set of shops. You might then have a shop field and a sales field. Let's say you want to look at the average amount of sales per shop. You can do this by using a feature_extraction.Agg . When you call transform_one , you're expecting it to return the average amount of sales, without including today's sales. You can do this by prepending an instance of stats.Mean with an instance of stats.Shift . >>> from river import feature_extraction >>> agg = feature_extraction . Agg ( ... on = 'sales' , ... how = stats . Shift ( 1 ) | stats . Mean (), ... by = 'shop' ... ) Let's define a little example dataset. >>> X = iter ([ ... { 'shop' : 'Ikea' , 'sales' : 10 }, ... { 'shop' : 'Ikea' , 'sales' : 15 }, ... { 'shop' : 'Ikea' , 'sales' : 20 } ... ]) Now let's call the learn_one method to update our feature extractor. >>> x = next ( X ) >>> agg = agg . learn_one ( x ) At this point, the average defaults to the initial value of stats.Mean , which is 0. >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 0.0 } We can now update our feature extractor with the next data point and check the output. >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 10.0 } >>> agg = agg . learn_one ( next ( X )) >>> agg . transform_one ( x ) { 'sales_mean_of_shift_1_by_shop' : 12.5 }","title":"Examples"},{"location":"api/stats/Shift/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Skew/","text":"Skew \u00b6 Running skew using Welford's algorithm. Parameters \u00b6 bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias. Attributes \u00b6 name Examples \u00b6 >>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> skew = river . stats . Skew ( bias = False ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 1.4802398132849872 0.5127437186677888 0.7803466510704751 1.056115628922055 0.5057840774320389 0.3478402420400934 0.4536710660918704 0.4123070197493227 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = False )) 0.0 0.0 - 1.4802398132849874 0.5127437186677893 0.7803466510704746 1.056115628922055 0.5057840774320389 0.3478402420400927 0.4536710660918703 0.4123070197493223 >>> skew = river . stats . Skew ( bias = True ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 0.6043053732501439 0.2960327239981376 0.5234724473423674 0.7712778043924866 0.39022088752624845 0.278892645224261 0.37425953513864063 0.3476878073823696 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = True )) 0.0 0.0 - 0.604305373250144 0.29603272399813796 0.5234724473423671 0.7712778043924865 0.39022088752624845 0.2788926452242604 0.3742595351386406 0.34768780738236926 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9","title":"Skew"},{"location":"api/stats/Skew/#skew","text":"Running skew using Welford's algorithm.","title":"Skew"},{"location":"api/stats/Skew/#parameters","text":"bias \u2013 defaults to False If False , then the calculations are corrected for statistical bias.","title":"Parameters"},{"location":"api/stats/Skew/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/Skew/#examples","text":">>> import river.stats >>> import scipy.stats >>> import numpy as np >>> np . random . seed ( 42 ) >>> X = np . random . normal ( loc = 0 , scale = 1 , size = 10 ) >>> skew = river . stats . Skew ( bias = False ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 1.4802398132849872 0.5127437186677888 0.7803466510704751 1.056115628922055 0.5057840774320389 0.3478402420400934 0.4536710660918704 0.4123070197493227 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = False )) 0.0 0.0 - 1.4802398132849874 0.5127437186677893 0.7803466510704746 1.056115628922055 0.5057840774320389 0.3478402420400927 0.4536710660918703 0.4123070197493223 >>> skew = river . stats . Skew ( bias = True ) >>> for x in X : ... print ( skew . update ( x ) . get ()) 0 0.0 - 0.6043053732501439 0.2960327239981376 0.5234724473423674 0.7712778043924866 0.39022088752624845 0.278892645224261 0.37425953513864063 0.3476878073823696 >>> for i in range ( 1 , len ( X ) + 1 ): ... print ( scipy . stats . skew ( X [: i ], bias = True )) 0.0 0.0 - 0.604305373250144 0.29603272399813796 0.5234724473423671 0.7712778043924865 0.39022088752624845 0.2788926452242604 0.3742595351386406 0.34768780738236926","title":"Examples"},{"location":"api/stats/Skew/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Skew/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9","title":"References"},{"location":"api/stats/Sum/","text":"Sum \u00b6 Running sum. Attributes \u00b6 sum ( float ) The running sum. Examples \u00b6 >>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Sum () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 8.0 - 9.0 - 8.0 - 5.0 0.0 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Sum"},{"location":"api/stats/Sum/#sum","text":"Running sum.","title":"Sum"},{"location":"api/stats/Sum/#attributes","text":"sum ( float ) The running sum.","title":"Attributes"},{"location":"api/stats/Sum/#examples","text":">>> from river import stats >>> X = [ - 5 , - 3 , - 1 , 1 , 3 , 5 ] >>> mean = stats . Sum () >>> for x in X : ... print ( mean . update ( x ) . get ()) - 5.0 - 8.0 - 9.0 - 8.0 - 5.0 0.0","title":"Examples"},{"location":"api/stats/Sum/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stats/Var/","text":"Var \u00b6 Running variance using Welford's algorithm. Parameters \u00b6 ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n represents the number of seen elements. Attributes \u00b6 mean It is necessary to calculate the mean of the data in order to calculate its variance. Examples \u00b6 >>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> var = river . stats . Var () >>> for x in X : ... print ( var . update ( x ) . get ()) 0.0 2.0 1.0 2.916666 7.7 12.56666 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 update_many Notes \u00b6 The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\) . References \u00b6 Wikipedia article on algorithms for calculating variance \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"Var"},{"location":"api/stats/Var/#var","text":"Running variance using Welford's algorithm.","title":"Var"},{"location":"api/stats/Var/#parameters","text":"ddof \u2013 defaults to 1 Delta Degrees of Freedom. The divisor used in calculations is n - ddof , where n represents the number of seen elements.","title":"Parameters"},{"location":"api/stats/Var/#attributes","text":"mean It is necessary to calculate the mean of the data in order to calculate its variance.","title":"Attributes"},{"location":"api/stats/Var/#examples","text":">>> import river.stats >>> X = [ 3 , 5 , 4 , 7 , 10 , 12 ] >>> var = river . stats . Var () >>> for x in X : ... print ( var . update ( x ) . get ()) 0.0 2.0 1.0 2.916666 7.7 12.56666","title":"Examples"},{"location":"api/stats/Var/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x w \u2013 defaults to 1.0 update Update and return the called instance. Parameters x w \u2013 defaults to 1.0 update_many","title":"Methods"},{"location":"api/stats/Var/#notes","text":"The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\) .","title":"Notes"},{"location":"api/stats/Var/#references","text":"Wikipedia article on algorithms for calculating variance \u21a9 Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9","title":"References"},{"location":"api/stats/base/Bivariate/","text":"Bivariate \u00b6 A bivariate statistic measures a relationship between two variables. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Bivariate"},{"location":"api/stats/base/Bivariate/#bivariate","text":"A bivariate statistic measures a relationship between two variables.","title":"Bivariate"},{"location":"api/stats/base/Bivariate/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. update Update and return the called instance. Parameters x y","title":"Methods"},{"location":"api/stats/base/Univariate/","text":"Univariate \u00b6 A univariate statistic measures a property of a variable. Attributes \u00b6 name Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Univariate"},{"location":"api/stats/base/Univariate/#univariate","text":"A univariate statistic measures a property of a variable.","title":"Univariate"},{"location":"api/stats/base/Univariate/#attributes","text":"name","title":"Attributes"},{"location":"api/stats/base/Univariate/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current value of the statistic. revert Revert and return the called instance. Parameters x update Update and return the called instance. Parameters x","title":"Methods"},{"location":"api/stream/Cache/","text":"Cache \u00b6 Utility for caching iterables. This can be used to save a stream of data to the disk in order to iterate over it faster the following time. This can save time depending on the nature of stream. The more processing happens in a stream, the more time will be saved. Even in the case where no processing is done apart from reading the data, the cache will save some time because it is using the pickle binary protocol. It can thus improve the speed in common cases such as reading from a CSV file. Parameters \u00b6 directory \u2013 defaults to None The path where to store the pickled data streams. If not provided, then it will be automatically inferred whenever possible, if not an exception will be raised. Attributes \u00b6 keys ( set ) The set of keys that are being cached. Examples \u00b6 >>> import time >>> from river import datasets >>> from river import stream >>> dataset = datasets . Phishing () >>> cache = stream . Cache () The cache can be used by wrapping it around an iterable. Because this is the first time are iterating over the data, nothing is cached. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.012813 If we do the same thing again, we can see the loop is now faster. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.001927 We can see an overview of the cache. The first line indicates the location of the cache. >>> cache # doctest: +SKIP / tmp phishing - 125.2 KiB Finally, we can clear the stream from the cache. >>> cache . clear ( 'phishing' ) >>> cache # doctest: +SKIP / tmp There is also a clear_all method to remove all the items in the cache. >>> cache . clear_all () Methods \u00b6 call Call self as a function. Parameters stream key \u2013 defaults to None clear Delete the cached stream associated with the given key. Parameters key ( str ) clear_all Delete all the cached streams.","title":"Cache"},{"location":"api/stream/Cache/#cache","text":"Utility for caching iterables. This can be used to save a stream of data to the disk in order to iterate over it faster the following time. This can save time depending on the nature of stream. The more processing happens in a stream, the more time will be saved. Even in the case where no processing is done apart from reading the data, the cache will save some time because it is using the pickle binary protocol. It can thus improve the speed in common cases such as reading from a CSV file.","title":"Cache"},{"location":"api/stream/Cache/#parameters","text":"directory \u2013 defaults to None The path where to store the pickled data streams. If not provided, then it will be automatically inferred whenever possible, if not an exception will be raised.","title":"Parameters"},{"location":"api/stream/Cache/#attributes","text":"keys ( set ) The set of keys that are being cached.","title":"Attributes"},{"location":"api/stream/Cache/#examples","text":">>> import time >>> from river import datasets >>> from river import stream >>> dataset = datasets . Phishing () >>> cache = stream . Cache () The cache can be used by wrapping it around an iterable. Because this is the first time are iterating over the data, nothing is cached. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.012813 If we do the same thing again, we can see the loop is now faster. >>> tic = time . time () >>> for x , y in cache ( dataset , key = 'phishing' ): ... pass >>> toc = time . time () >>> print ( toc - tic ) # doctest: +SKIP 0.001927 We can see an overview of the cache. The first line indicates the location of the cache. >>> cache # doctest: +SKIP / tmp phishing - 125.2 KiB Finally, we can clear the stream from the cache. >>> cache . clear ( 'phishing' ) >>> cache # doctest: +SKIP / tmp There is also a clear_all method to remove all the items in the cache. >>> cache . clear_all ()","title":"Examples"},{"location":"api/stream/Cache/#methods","text":"call Call self as a function. Parameters stream key \u2013 defaults to None clear Delete the cached stream associated with the given key. Parameters key ( str ) clear_all Delete all the cached streams.","title":"Methods"},{"location":"api/stream/iter-arff/","text":"iter_arff \u00b6 Iterates over rows from an ARFF file. Parameters \u00b6 filepath_or_buffer Either a string indicating the location of a file, or a buffer object that has a read method. target ( str ) \u2013 defaults to None Name of the target field. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.","title":"iter_arff"},{"location":"api/stream/iter-arff/#iter_arff","text":"Iterates over rows from an ARFF file.","title":"iter_arff"},{"location":"api/stream/iter-arff/#parameters","text":"filepath_or_buffer Either a string indicating the location of a file, or a buffer object that has a read method. target ( str ) \u2013 defaults to None Name of the target field. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.","title":"Parameters"},{"location":"api/stream/iter-array/","text":"iter_array \u00b6 Iterates over the rows from an array of features and an array of targets. This method is intended to work with numpy arrays, but should also work with Python lists. Parameters \u00b6 X ( numpy.ndarray ) A 2D array of features. y ( numpy.ndarray ) \u2013 defaults to None An optional array of targets. feature_names ( List[Hashable] ) \u2013 defaults to None An optional list of feature names. The features will be labeled with integers if no names are provided. target_names ( List[Hashable] ) \u2013 defaults to None An optional list of output names. The outputs will be labeled with integers if no names are provided. Only applies if there are multiple outputs, i.e. if y is a 2D array. shuffle ( bool ) \u2013 defaults to False Indicates whether or not to shuffle the input arrays before iterating over them. seed ( int ) \u2013 defaults to None Random seed used for shuffling the data. Examples \u00b6 >>> from river import stream >>> import numpy as np >>> X = np . array ([[ 1 , 2 , 3 ], [ 11 , 12 , 13 ]]) >>> Y = np . array ([ True , False ]) >>> dataset = stream . iter_array ( ... X , Y , ... feature_names = [ 'x1' , 'x2' , 'x3' ] ... ) >>> for x , y in dataset : ... print ( x , y ) { 'x1' : 1 , 'x2' : 2 , 'x3' : 3 } True { 'x1' : 11 , 'x2' : 12 , 'x3' : 13 } False","title":"iter_array"},{"location":"api/stream/iter-array/#iter_array","text":"Iterates over the rows from an array of features and an array of targets. This method is intended to work with numpy arrays, but should also work with Python lists.","title":"iter_array"},{"location":"api/stream/iter-array/#parameters","text":"X ( numpy.ndarray ) A 2D array of features. y ( numpy.ndarray ) \u2013 defaults to None An optional array of targets. feature_names ( List[Hashable] ) \u2013 defaults to None An optional list of feature names. The features will be labeled with integers if no names are provided. target_names ( List[Hashable] ) \u2013 defaults to None An optional list of output names. The outputs will be labeled with integers if no names are provided. Only applies if there are multiple outputs, i.e. if y is a 2D array. shuffle ( bool ) \u2013 defaults to False Indicates whether or not to shuffle the input arrays before iterating over them. seed ( int ) \u2013 defaults to None Random seed used for shuffling the data.","title":"Parameters"},{"location":"api/stream/iter-array/#examples","text":">>> from river import stream >>> import numpy as np >>> X = np . array ([[ 1 , 2 , 3 ], [ 11 , 12 , 13 ]]) >>> Y = np . array ([ True , False ]) >>> dataset = stream . iter_array ( ... X , Y , ... feature_names = [ 'x1' , 'x2' , 'x3' ] ... ) >>> for x , y in dataset : ... print ( x , y ) { 'x1' : 1 , 'x2' : 2 , 'x3' : 3 } True { 'x1' : 11 , 'x2' : 12 , 'x3' : 13 } False","title":"Examples"},{"location":"api/stream/iter-csv/","text":"iter_csv \u00b6 Iterates over rows from a CSV file. Reading CSV files can be quite slow. If, for whatever reason, you're going to loop through the same file multiple times, then we recommend that you to use the stream.Cache utility. Parameters \u00b6 filepath_or_buffer Either a string indicating the location of a file, or a buffer object that has a read method. target ( Union[str, List[str]] ) \u2013 defaults to None A single target column is assumed if a string is passed. A multiple output scenario is assumed if a list of strings is passed. A None value will be assigned to each y if this parameter is omitted. converters ( dict ) \u2013 defaults to None All values in the CSV are interpreted as strings by default. You can use this parameter to cast values to the desired type. This should be a dict mapping feature names to callables used to parse their associated values. Note that a callable may be a type, such as float and int . parse_dates ( dict ) \u2013 defaults to None A dict mapping feature names to a format passed to the datetime.datetime.strptime method. drop ( List[str] ) \u2013 defaults to None Fields to ignore. drop_nones \u2013 defaults to False Whether or not to drop fields where the value is a None . fraction \u2013 defaults to 1.0 Sampling fraction. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'. seed ( int ) \u2013 defaults to None If specified, the sampling will be deterministic. field_size_limit ( int ) \u2013 defaults to None If not None , this will be passed to the csv.field_size_limit function. kwargs All other keyword arguments are passed to the underlying csv.DictReader . Examples \u00b6 Although this function is designed to handle different kinds of inputs, the most common use case is to read a file on the disk. We'll first create a little CSV file to illustrate. >>> tv_shows = '''name,year,rating ... Planet Earth II,2016,9.5 ... Planet Earth,2006,9.4 ... Band of Brothers,2001,9.4 ... Breaking Bad,2008,9.4 ... Chernobyl,2019,9.4 ... ''' >>> with open ( 'tv_shows.csv' , mode = 'w' ) as f : ... _ = f . write ( tv_shows ) We can now go through the rows one by one. We can use the converters parameter to cast the rating field value as a float . We can also convert the year to a datetime via the parse_dates parameter. >>> from river import stream >>> params = { ... 'converters' : { 'rating' : float }, ... 'parse_dates' : { 'year' : '%Y' } ... } >>> for x , y in stream . iter_csv ( 'tv_shows.csv' , ** params ): ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 ), 'rating' : 9.5 } None { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None The value of y is always None because we haven't provided a value for the target parameter. Here is an example where a target is provided: >>> dataset = stream . iter_csv ( 'tv_shows.csv' , target = 'rating' , ** params ) >>> for x , y in dataset : ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 )} 9.5 { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 )} 9.4 Finally, let's delete the example file. >>> import os ; os . remove ( 'tv_shows.csv' )","title":"iter_csv"},{"location":"api/stream/iter-csv/#iter_csv","text":"Iterates over rows from a CSV file. Reading CSV files can be quite slow. If, for whatever reason, you're going to loop through the same file multiple times, then we recommend that you to use the stream.Cache utility.","title":"iter_csv"},{"location":"api/stream/iter-csv/#parameters","text":"filepath_or_buffer Either a string indicating the location of a file, or a buffer object that has a read method. target ( Union[str, List[str]] ) \u2013 defaults to None A single target column is assumed if a string is passed. A multiple output scenario is assumed if a list of strings is passed. A None value will be assigned to each y if this parameter is omitted. converters ( dict ) \u2013 defaults to None All values in the CSV are interpreted as strings by default. You can use this parameter to cast values to the desired type. This should be a dict mapping feature names to callables used to parse their associated values. Note that a callable may be a type, such as float and int . parse_dates ( dict ) \u2013 defaults to None A dict mapping feature names to a format passed to the datetime.datetime.strptime method. drop ( List[str] ) \u2013 defaults to None Fields to ignore. drop_nones \u2013 defaults to False Whether or not to drop fields where the value is a None . fraction \u2013 defaults to 1.0 Sampling fraction. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'. seed ( int ) \u2013 defaults to None If specified, the sampling will be deterministic. field_size_limit ( int ) \u2013 defaults to None If not None , this will be passed to the csv.field_size_limit function. kwargs All other keyword arguments are passed to the underlying csv.DictReader .","title":"Parameters"},{"location":"api/stream/iter-csv/#examples","text":"Although this function is designed to handle different kinds of inputs, the most common use case is to read a file on the disk. We'll first create a little CSV file to illustrate. >>> tv_shows = '''name,year,rating ... Planet Earth II,2016,9.5 ... Planet Earth,2006,9.4 ... Band of Brothers,2001,9.4 ... Breaking Bad,2008,9.4 ... Chernobyl,2019,9.4 ... ''' >>> with open ( 'tv_shows.csv' , mode = 'w' ) as f : ... _ = f . write ( tv_shows ) We can now go through the rows one by one. We can use the converters parameter to cast the rating field value as a float . We can also convert the year to a datetime via the parse_dates parameter. >>> from river import stream >>> params = { ... 'converters' : { 'rating' : float }, ... 'parse_dates' : { 'year' : '%Y' } ... } >>> for x , y in stream . iter_csv ( 'tv_shows.csv' , ** params ): ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 ), 'rating' : 9.5 } None { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 ), 'rating' : 9.4 } None The value of y is always None because we haven't provided a value for the target parameter. Here is an example where a target is provided: >>> dataset = stream . iter_csv ( 'tv_shows.csv' , target = 'rating' , ** params ) >>> for x , y in dataset : ... print ( x , y ) { 'name' : 'Planet Earth II' , 'year' : datetime . datetime ( 2016 , 1 , 1 , 0 , 0 )} 9.5 { 'name' : 'Planet Earth' , 'year' : datetime . datetime ( 2006 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Band of Brothers' , 'year' : datetime . datetime ( 2001 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Breaking Bad' , 'year' : datetime . datetime ( 2008 , 1 , 1 , 0 , 0 )} 9.4 { 'name' : 'Chernobyl' , 'year' : datetime . datetime ( 2019 , 1 , 1 , 0 , 0 )} 9.4 Finally, let's delete the example file. >>> import os ; os . remove ( 'tv_shows.csv' )","title":"Examples"},{"location":"api/stream/iter-libsvm/","text":"iter_libsvm \u00b6 Iterates over a dataset in LIBSVM format. The LIBSVM format is a popular way in the machine learning community to store sparse datasets. Only numerical feature values are supported. The feature names will be considered as strings. Parameters \u00b6 filepath_or_buffer ( str ) Either a string indicating the location of a file, or a buffer object that has a read method. target_type \u2013 defaults to <class 'float'> The type of the target value. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'. Examples \u00b6 >>> import io >>> from river import stream >>> data = io . StringIO ( '''+1 x:-134.26 y:0.2563 ... 1 x:-12 z:0.3 ... -1 y:.25 ... ''' ) >>> for x , y in stream . iter_libsvm ( data , target_type = int ): ... print ( y , x ) 1 { 'x' : - 134.26 , 'y' : 0.2563 } 1 { 'x' : - 12.0 , 'z' : 0.3 } - 1 { 'y' : 0.25 } References \u00b6 LIBSVM documentation \u21a9","title":"iter_libsvm"},{"location":"api/stream/iter-libsvm/#iter_libsvm","text":"Iterates over a dataset in LIBSVM format. The LIBSVM format is a popular way in the machine learning community to store sparse datasets. Only numerical feature values are supported. The feature names will be considered as strings.","title":"iter_libsvm"},{"location":"api/stream/iter-libsvm/#parameters","text":"filepath_or_buffer ( str ) Either a string indicating the location of a file, or a buffer object that has a read method. target_type \u2013 defaults to <class 'float'> The type of the target value. compression \u2013 defaults to infer For on-the-fly decompression of on-disk data. If this is set to 'infer' and filepath_or_buffer is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.","title":"Parameters"},{"location":"api/stream/iter-libsvm/#examples","text":">>> import io >>> from river import stream >>> data = io . StringIO ( '''+1 x:-134.26 y:0.2563 ... 1 x:-12 z:0.3 ... -1 y:.25 ... ''' ) >>> for x , y in stream . iter_libsvm ( data , target_type = int ): ... print ( y , x ) 1 { 'x' : - 134.26 , 'y' : 0.2563 } 1 { 'x' : - 12.0 , 'z' : 0.3 } - 1 { 'y' : 0.25 }","title":"Examples"},{"location":"api/stream/iter-libsvm/#references","text":"LIBSVM documentation \u21a9","title":"References"},{"location":"api/stream/iter-pandas/","text":"iter_pandas \u00b6 Iterates over the rows of a pandas.DataFrame . Parameters \u00b6 X ( pandas.core.frame.DataFrame ) A dataframe of features. y ( Union[pandas.core.series.Series, pandas.core.frame.DataFrame] ) \u2013 defaults to None A series or a dataframe with one column per target. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array . Examples \u00b6 >>> import pandas as pd >>> from river import stream >>> X = pd . DataFrame ({ ... 'x1' : [ 1 , 2 , 3 , 4 ], ... 'x2' : [ 'blue' , 'yellow' , 'yellow' , 'blue' ], ... 'y' : [ True , False , False , True ] ... }) >>> y = X . pop ( 'y' ) >>> for xi , yi in stream . iter_pandas ( X , y ): ... print ( xi , yi ) { 'x1' : 1 , 'x2' : 'blue' } True { 'x1' : 2 , 'x2' : 'yellow' } False { 'x1' : 3 , 'x2' : 'yellow' } False { 'x1' : 4 , 'x2' : 'blue' } True","title":"iter_pandas"},{"location":"api/stream/iter-pandas/#iter_pandas","text":"Iterates over the rows of a pandas.DataFrame .","title":"iter_pandas"},{"location":"api/stream/iter-pandas/#parameters","text":"X ( pandas.core.frame.DataFrame ) A dataframe of features. y ( Union[pandas.core.series.Series, pandas.core.frame.DataFrame] ) \u2013 defaults to None A series or a dataframe with one column per target. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array .","title":"Parameters"},{"location":"api/stream/iter-pandas/#examples","text":">>> import pandas as pd >>> from river import stream >>> X = pd . DataFrame ({ ... 'x1' : [ 1 , 2 , 3 , 4 ], ... 'x2' : [ 'blue' , 'yellow' , 'yellow' , 'blue' ], ... 'y' : [ True , False , False , True ] ... }) >>> y = X . pop ( 'y' ) >>> for xi , yi in stream . iter_pandas ( X , y ): ... print ( xi , yi ) { 'x1' : 1 , 'x2' : 'blue' } True { 'x1' : 2 , 'x2' : 'yellow' } False { 'x1' : 3 , 'x2' : 'yellow' } False { 'x1' : 4 , 'x2' : 'blue' } True","title":"Examples"},{"location":"api/stream/iter-sklearn-dataset/","text":"iter_sklearn_dataset \u00b6 Iterates rows from one of the datasets provided by scikit-learn. This allows you to use any dataset from scikit-learn's datasets module . For instance, you can use the fetch_openml function to get access to all of the datasets from the OpenML website. Parameters \u00b6 dataset ( 'sklearn.utils.Bunch' ) A scikit-learn dataset. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array . Examples \u00b6 >>> import pprint >>> from sklearn import datasets >>> from river import stream >>> dataset = datasets . load_diabetes () >>> for xi , yi in stream . iter_sklearn_dataset ( dataset ): ... pprint . pprint ( xi ) ... print ( yi ) ... break { 'age' : 0.038075906433423026 , 'bmi' : 0.061696206518683294 , 'bp' : 0.0218723855140367 , 's1' : - 0.04422349842444599 , 's2' : - 0.03482076283769895 , 's3' : - 0.04340084565202491 , 's4' : - 0.002592261998183278 , 's5' : 0.019907486170462722 , 's6' : - 0.01764612515980379 , 'sex' : 0.05068011873981862 } 151.0","title":"iter_sklearn_dataset"},{"location":"api/stream/iter-sklearn-dataset/#iter_sklearn_dataset","text":"Iterates rows from one of the datasets provided by scikit-learn. This allows you to use any dataset from scikit-learn's datasets module . For instance, you can use the fetch_openml function to get access to all of the datasets from the OpenML website.","title":"iter_sklearn_dataset"},{"location":"api/stream/iter-sklearn-dataset/#parameters","text":"dataset ( 'sklearn.utils.Bunch' ) A scikit-learn dataset. kwargs Extra keyword arguments are passed to the underlying call to stream.iter_array .","title":"Parameters"},{"location":"api/stream/iter-sklearn-dataset/#examples","text":">>> import pprint >>> from sklearn import datasets >>> from river import stream >>> dataset = datasets . load_diabetes () >>> for xi , yi in stream . iter_sklearn_dataset ( dataset ): ... pprint . pprint ( xi ) ... print ( yi ) ... break { 'age' : 0.038075906433423026 , 'bmi' : 0.061696206518683294 , 'bp' : 0.0218723855140367 , 's1' : - 0.04422349842444599 , 's2' : - 0.03482076283769895 , 's3' : - 0.04340084565202491 , 's4' : - 0.002592261998183278 , 's5' : 0.019907486170462722 , 's6' : - 0.01764612515980379 , 'sex' : 0.05068011873981862 } 151.0","title":"Examples"},{"location":"api/stream/iter-sql/","text":"iter_sql \u00b6 Iterates over the results from an SQL query. By default, SQLAlchemy prefetches results. Therefore, even though you can iterate over the resulting rows one by one, the results are in fact loaded in batch. You can modify this behavior by configuring the connection you pass to iter_sql . For instance, you can set the stream_results parameter to True , as explained in SQLAlchemy's documentation . Note, however, that this isn't available for all database engines. Parameters \u00b6 query ( Union[str, sqlalchemy.sql.selectable.Selectable] ) SQL query to be executed. conn ( sqlalchemy.engine.interfaces.Connectable ) An SQLAlchemy construct which has an execute method. In other words you can pass an engine, a connection, or a session. target_name ( str ) \u2013 defaults to None The name of the target field. If this is None , then y will also be None . Examples \u00b6 As an example we'll create an in-memory database with SQLAlchemy. >>> import datetime as dt >>> import sqlalchemy >>> engine = sqlalchemy . create_engine ( 'sqlite://' ) >>> metadata = sqlalchemy . MetaData () >>> t_sales = sqlalchemy . Table ( 'sales' , metadata , ... sqlalchemy . Column ( 'shop' , sqlalchemy . String , primary_key = True ), ... sqlalchemy . Column ( 'date' , sqlalchemy . Date , primary_key = True ), ... sqlalchemy . Column ( 'amount' , sqlalchemy . Integer ) ... ) >>> metadata . create_all ( engine ) >>> sales = [ ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 20 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 18 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 22 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 14 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 12 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 16 } ... ] >>> with engine . connect () as conn : ... _ = conn . execute ( t_sales . insert (), sales ) We can now query the database. We will set amount to be the target field. >>> from river import stream >>> with engine . connect () as conn : ... query = 'SELECT * FROM sales;' ... dataset = stream . iter_sql ( query , conn , target_name = 'amount' ) ... for x , y in dataset : ... print ( x , y ) { 'shop' : 'Hema' , 'date' : '2016-08-02' } 20 { 'shop' : 'Ikea' , 'date' : '2016-08-02' } 18 { 'shop' : 'Hema' , 'date' : '2016-08-03' } 22 { 'shop' : 'Ikea' , 'date' : '2016-08-03' } 14 { 'shop' : 'Hema' , 'date' : '2016-08-04' } 12 { 'shop' : 'Ikea' , 'date' : '2016-08-04' } 16","title":"iter_sql"},{"location":"api/stream/iter-sql/#iter_sql","text":"Iterates over the results from an SQL query. By default, SQLAlchemy prefetches results. Therefore, even though you can iterate over the resulting rows one by one, the results are in fact loaded in batch. You can modify this behavior by configuring the connection you pass to iter_sql . For instance, you can set the stream_results parameter to True , as explained in SQLAlchemy's documentation . Note, however, that this isn't available for all database engines.","title":"iter_sql"},{"location":"api/stream/iter-sql/#parameters","text":"query ( Union[str, sqlalchemy.sql.selectable.Selectable] ) SQL query to be executed. conn ( sqlalchemy.engine.interfaces.Connectable ) An SQLAlchemy construct which has an execute method. In other words you can pass an engine, a connection, or a session. target_name ( str ) \u2013 defaults to None The name of the target field. If this is None , then y will also be None .","title":"Parameters"},{"location":"api/stream/iter-sql/#examples","text":"As an example we'll create an in-memory database with SQLAlchemy. >>> import datetime as dt >>> import sqlalchemy >>> engine = sqlalchemy . create_engine ( 'sqlite://' ) >>> metadata = sqlalchemy . MetaData () >>> t_sales = sqlalchemy . Table ( 'sales' , metadata , ... sqlalchemy . Column ( 'shop' , sqlalchemy . String , primary_key = True ), ... sqlalchemy . Column ( 'date' , sqlalchemy . Date , primary_key = True ), ... sqlalchemy . Column ( 'amount' , sqlalchemy . Integer ) ... ) >>> metadata . create_all ( engine ) >>> sales = [ ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 20 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 2 ), 'amount' : 18 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 22 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 3 ), 'amount' : 14 }, ... { 'shop' : 'Hema' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 12 }, ... { 'shop' : 'Ikea' , 'date' : dt . date ( 2016 , 8 , 4 ), 'amount' : 16 } ... ] >>> with engine . connect () as conn : ... _ = conn . execute ( t_sales . insert (), sales ) We can now query the database. We will set amount to be the target field. >>> from river import stream >>> with engine . connect () as conn : ... query = 'SELECT * FROM sales;' ... dataset = stream . iter_sql ( query , conn , target_name = 'amount' ) ... for x , y in dataset : ... print ( x , y ) { 'shop' : 'Hema' , 'date' : '2016-08-02' } 20 { 'shop' : 'Ikea' , 'date' : '2016-08-02' } 18 { 'shop' : 'Hema' , 'date' : '2016-08-03' } 22 { 'shop' : 'Ikea' , 'date' : '2016-08-03' } 14 { 'shop' : 'Hema' , 'date' : '2016-08-04' } 12 { 'shop' : 'Ikea' , 'date' : '2016-08-04' } 16","title":"Examples"},{"location":"api/stream/shuffle/","text":"shuffle \u00b6 Shuffles a stream of data. This works by maintaining a buffer of elements. The first buffer_size elements are stored in memory. Once the buffer is full, a random element inside the buffer is yielded. Every time an element is yielded, the next element in the stream replaces it and the buffer is sampled again. Increasing buffer_size will improve the quality of the shuffling. If you really want to stream over your dataset in a \"good\" random order, the best way is to split your dataset into smaller datasets and loop over them in a round-robin fashion. You may do this by using the roundrobin recipe from the itertools module. Parameters \u00b6 stream ( Iterator ) The stream to shuffle. buffer_size ( int ) The size of the buffer which contains the elements help in memory. Increasing this will increase randomness but will incur more memory usage. seed ( int ) \u2013 defaults to None Random seed used for sampling. Examples \u00b6 >>> from river import stream >>> for i in stream . shuffle ( range ( 15 ), buffer_size = 5 , seed = 42 ): ... print ( i ) 0 5 2 1 8 9 6 4 11 12 10 7 14 13 3 References \u00b6 Visualizing TensorFlow's streaming shufflers \u21a9","title":"shuffle"},{"location":"api/stream/shuffle/#shuffle","text":"Shuffles a stream of data. This works by maintaining a buffer of elements. The first buffer_size elements are stored in memory. Once the buffer is full, a random element inside the buffer is yielded. Every time an element is yielded, the next element in the stream replaces it and the buffer is sampled again. Increasing buffer_size will improve the quality of the shuffling. If you really want to stream over your dataset in a \"good\" random order, the best way is to split your dataset into smaller datasets and loop over them in a round-robin fashion. You may do this by using the roundrobin recipe from the itertools module.","title":"shuffle"},{"location":"api/stream/shuffle/#parameters","text":"stream ( Iterator ) The stream to shuffle. buffer_size ( int ) The size of the buffer which contains the elements help in memory. Increasing this will increase randomness but will incur more memory usage. seed ( int ) \u2013 defaults to None Random seed used for sampling.","title":"Parameters"},{"location":"api/stream/shuffle/#examples","text":">>> from river import stream >>> for i in stream . shuffle ( range ( 15 ), buffer_size = 5 , seed = 42 ): ... print ( i ) 0 5 2 1 8 9 6 4 11 12 10 7 14 13 3","title":"Examples"},{"location":"api/stream/shuffle/#references","text":"Visualizing TensorFlow's streaming shufflers \u21a9","title":"References"},{"location":"api/stream/simulate-qa/","text":"simulate_qa \u00b6 Simulate a time-ordered question and answer session. This method allows looping through a dataset in the order in which it arrived. Indeed, it usually is the case that labels arrive after features. Being able to go through a dataset in arrival order enables assessing a model's performance in a reliable manner. For instance, the evaluate.progressive_val_score is a high-level method that can be used to score a model on a dataset. Under the hood it uses this method to determine the correct arrival order. Parameters \u00b6 dataset ( Iterable[Tuple[dict, Any]] ) A stream of (features, target) tuples. moment ( Union[str, Callable] ) The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. If a str is passed, then it will be used to obtain the time from the input features. delay ( Union[str, int, datetime.timedelta, Callable] ) The amount of time to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. If a scalar is passed, such an int or a datetime.timedelta , then the delay is constant. copy ( bool ) \u2013 defaults to True If True , then a separate copy of the features are yielded the second time around. This ensures that inadvertent modifications in downstream code don't have any effect. Examples \u00b6 The arrival delay isn't usually indicated in a dataset, but it might be able to be inferred from the features. As an example, we'll simulate the departure and arrival time of taxi trips. Let's first create a time table which records the departure time and the duration of seconds of several taxi trips. >>> import datetime as dt >>> time_table = [ ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 0 , 0 ), 900 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 10 , 0 ), 1800 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 20 , 0 ), 300 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 45 , 0 ), 400 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 50 , 0 ), 240 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 55 , 0 ), 450 ) ... ] We can now create a streaming dataset where the features are the departure dates and the targets are the durations. >>> dataset = ( ... ({ 'date' : date }, duration ) ... for date , duration in time_table ... ) Now, we can use simulate_qa to iterate over the events in the order in which they are meant to occur. >>> delay = lambda _ , y : dt . timedelta ( seconds = y ) >>> for i , x , y in simulate_qa ( dataset , moment = 'date' , delay = delay ): ... if y is None : ... print ( f ' { x [ \"date\" ] } - trip # { i } departs' ) ... else : ... arrival_date = x [ 'date' ] + dt . timedelta ( seconds = y ) ... print ( f ' { arrival_date } - trip # { i } arrives after { y } seconds' ) 2020 - 01 - 01 20 : 00 : 00 - trip #0 departs 2020 - 01 - 01 20 : 10 : 00 - trip #1 departs 2020 - 01 - 01 20 : 15 : 00 - trip #0 arrives after 900 seconds 2020 - 01 - 01 20 : 20 : 00 - trip #2 departs 2020 - 01 - 01 20 : 25 : 00 - trip #2 arrives after 300 seconds 2020 - 01 - 01 20 : 40 : 00 - trip #1 arrives after 1800 seconds 2020 - 01 - 01 20 : 45 : 00 - trip #3 departs 2020 - 01 - 01 20 : 50 : 00 - trip #4 departs 2020 - 01 - 01 20 : 51 : 40 - trip #3 arrives after 400 seconds 2020 - 01 - 01 20 : 54 : 00 - trip #4 arrives after 240 seconds 2020 - 01 - 01 20 : 55 : 00 - trip #5 departs 2020 - 01 - 01 21 : 02 : 30 - trip #5 arrives after 450 seconds This function is extremely practical because it provides a reliable way to evaluate the performance of a model in a real scenario. Indeed, it allows to make predictions and perform model updates in exactly the same manner that would happen live. For instance, it is used in evaluate.progressive_val_score , which is a higher level function for evaluating models in an online manner.","title":"simulate_qa"},{"location":"api/stream/simulate-qa/#simulate_qa","text":"Simulate a time-ordered question and answer session. This method allows looping through a dataset in the order in which it arrived. Indeed, it usually is the case that labels arrive after features. Being able to go through a dataset in arrival order enables assessing a model's performance in a reliable manner. For instance, the evaluate.progressive_val_score is a high-level method that can be used to score a model on a dataset. Under the hood it uses this method to determine the correct arrival order.","title":"simulate_qa"},{"location":"api/stream/simulate-qa/#parameters","text":"dataset ( Iterable[Tuple[dict, Any]] ) A stream of (features, target) tuples. moment ( Union[str, Callable] ) The attribute used for measuring time. If a callable is passed, then it is expected to take as input a dict of features. If None , then the observations are implicitly timestamped in the order in which they arrive. If a str is passed, then it will be used to obtain the time from the input features. delay ( Union[str, int, datetime.timedelta, Callable] ) The amount of time to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the moment value. For instance, if moment is a datetime.date , then delay is expected to be a datetime.timedelta . If a callable is passed, then it is expected to take as input a dict of features and the target. If a str is passed, then it will be used to access the relevant field from the features. If None is passed, then no delay will be used, which leads to doing standard online validation. If a scalar is passed, such an int or a datetime.timedelta , then the delay is constant. copy ( bool ) \u2013 defaults to True If True , then a separate copy of the features are yielded the second time around. This ensures that inadvertent modifications in downstream code don't have any effect.","title":"Parameters"},{"location":"api/stream/simulate-qa/#examples","text":"The arrival delay isn't usually indicated in a dataset, but it might be able to be inferred from the features. As an example, we'll simulate the departure and arrival time of taxi trips. Let's first create a time table which records the departure time and the duration of seconds of several taxi trips. >>> import datetime as dt >>> time_table = [ ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 0 , 0 ), 900 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 10 , 0 ), 1800 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 20 , 0 ), 300 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 45 , 0 ), 400 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 50 , 0 ), 240 ), ... ( dt . datetime ( 2020 , 1 , 1 , 20 , 55 , 0 ), 450 ) ... ] We can now create a streaming dataset where the features are the departure dates and the targets are the durations. >>> dataset = ( ... ({ 'date' : date }, duration ) ... for date , duration in time_table ... ) Now, we can use simulate_qa to iterate over the events in the order in which they are meant to occur. >>> delay = lambda _ , y : dt . timedelta ( seconds = y ) >>> for i , x , y in simulate_qa ( dataset , moment = 'date' , delay = delay ): ... if y is None : ... print ( f ' { x [ \"date\" ] } - trip # { i } departs' ) ... else : ... arrival_date = x [ 'date' ] + dt . timedelta ( seconds = y ) ... print ( f ' { arrival_date } - trip # { i } arrives after { y } seconds' ) 2020 - 01 - 01 20 : 00 : 00 - trip #0 departs 2020 - 01 - 01 20 : 10 : 00 - trip #1 departs 2020 - 01 - 01 20 : 15 : 00 - trip #0 arrives after 900 seconds 2020 - 01 - 01 20 : 20 : 00 - trip #2 departs 2020 - 01 - 01 20 : 25 : 00 - trip #2 arrives after 300 seconds 2020 - 01 - 01 20 : 40 : 00 - trip #1 arrives after 1800 seconds 2020 - 01 - 01 20 : 45 : 00 - trip #3 departs 2020 - 01 - 01 20 : 50 : 00 - trip #4 departs 2020 - 01 - 01 20 : 51 : 40 - trip #3 arrives after 400 seconds 2020 - 01 - 01 20 : 54 : 00 - trip #4 arrives after 240 seconds 2020 - 01 - 01 20 : 55 : 00 - trip #5 departs 2020 - 01 - 01 21 : 02 : 30 - trip #5 arrives after 450 seconds This function is extremely practical because it provides a reliable way to evaluate the performance of a model in a real scenario. Indeed, it allows to make predictions and perform model updates in exactly the same manner that would happen live. For instance, it is used in evaluate.progressive_val_score , which is a higher level function for evaluating models in an online manner.","title":"Examples"},{"location":"api/synth/Agrawal/","text":"Agrawal \u00b6 Agrawal stream generator. The generator was introduced by Agrawal et al. 1 , and was a common source of data for early work on scaling up decision tree learners. The generator produces a stream containing nine features, six numeric and three categorical. There are 10 functions defined for generating binary class labels from the features. Presumably these determine whether the loan should be approved. Classification functions are listed in the original paper 1 . Feature | Description | Values salary | salary | uniformly distributed from 20k to 150k commission | commission | 0 if salary < 75k else uniformly distributed from 10k to 75k age | age | uniformly distributed from 20 to 80 elevel | education level | uniformly chosen from 0 to 4 car | car maker | uniformly chosen from 1 to 20 zipcode | zip code of the town | uniformly chosen from 0 to 8 hvalue | house value | uniformly distributed from 50k x zipcode to 100k x zipcode hyears | years house owned | uniformly distributed from 1 to 30 loan | total loan amount | uniformly distributed from 0 to 500k Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 The classification function to use for the generation. Valid values are from 0 to 9. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False If True, the class distribution will converge to a uniform distribution. perturbation ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. Each new sample will be perturbed by the magnitude of perturbation . Valid values are in the range [0.0 to 1.0]. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Agrawal ( ... classification_function = 0 , ... seed = 42 ... ) >>> dataset Synthetic data generator < BLANKLINE > Name Agrawal Task Binary classification Samples \u221e Features 9 Outputs 1 Classes 2 Sparse False < BLANKLINE > Configuration ------------- classification_function 0 seed 42 balance_classes False perturbation 0.0 >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 68690.2154 , 81303.5729 , 62 , 4 , 6 , 2 , 419982.4410 , 11 , 433088.0728 ] 1 [ 98144.9515 , 0 , 43 , 2 , 1 , 7 , 266488.5281 , 6 , 389.3829 ] 0 [ 148987.502 , 0 , 52 , 3 , 11 , 8 , 79122.9140 , 27 , 199930.4858 ] 0 [ 26066.5362 , 83031.6639 , 34 , 2 , 11 , 6 , 444969.2657 , 25 , 23225.2063 ] 1 [ 98980.8307 , 0 , 40 , 0 , 6 , 1 , 1159108.4298 , 28 , 281644.1089 ] 0 Methods \u00b6 generate_drift Generate drift by switching the classification function randomly. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The 9 features are generated with the random generator, initialized with the seed passed by the user. Then, the classification function decides, as a function of all the attributes, whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. Finally, add noise if perturbation > 0.0. References \u00b6 Rakesh Agrawal, Tomasz Imielinksi, and Arun Swami. \"Database Mining: A Performance Perspective\", IEEE Transactions on Knowledge and Data Engineering, 5(6), December 1993. \u21a9 \u21a9","title":"Agrawal"},{"location":"api/synth/Agrawal/#agrawal","text":"Agrawal stream generator. The generator was introduced by Agrawal et al. 1 , and was a common source of data for early work on scaling up decision tree learners. The generator produces a stream containing nine features, six numeric and three categorical. There are 10 functions defined for generating binary class labels from the features. Presumably these determine whether the loan should be approved. Classification functions are listed in the original paper 1 . Feature | Description | Values salary | salary | uniformly distributed from 20k to 150k commission | commission | 0 if salary < 75k else uniformly distributed from 10k to 75k age | age | uniformly distributed from 20 to 80 elevel | education level | uniformly chosen from 0 to 4 car | car maker | uniformly chosen from 1 to 20 zipcode | zip code of the town | uniformly chosen from 0 to 8 hvalue | house value | uniformly distributed from 50k x zipcode to 100k x zipcode hyears | years house owned | uniformly distributed from 1 to 30 loan | total loan amount | uniformly distributed from 0 to 500k","title":"Agrawal"},{"location":"api/synth/Agrawal/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 The classification function to use for the generation. Valid values are from 0 to 9. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False If True, the class distribution will converge to a uniform distribution. perturbation ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. Each new sample will be perturbed by the magnitude of perturbation . Valid values are in the range [0.0 to 1.0].","title":"Parameters"},{"location":"api/synth/Agrawal/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Agrawal/#examples","text":">>> from river import synth >>> dataset = synth . Agrawal ( ... classification_function = 0 , ... seed = 42 ... ) >>> dataset Synthetic data generator < BLANKLINE > Name Agrawal Task Binary classification Samples \u221e Features 9 Outputs 1 Classes 2 Sparse False < BLANKLINE > Configuration ------------- classification_function 0 seed 42 balance_classes False perturbation 0.0 >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 68690.2154 , 81303.5729 , 62 , 4 , 6 , 2 , 419982.4410 , 11 , 433088.0728 ] 1 [ 98144.9515 , 0 , 43 , 2 , 1 , 7 , 266488.5281 , 6 , 389.3829 ] 0 [ 148987.502 , 0 , 52 , 3 , 11 , 8 , 79122.9140 , 27 , 199930.4858 ] 0 [ 26066.5362 , 83031.6639 , 34 , 2 , 11 , 6 , 444969.2657 , 25 , 23225.2063 ] 1 [ 98980.8307 , 0 , 40 , 0 , 6 , 1 , 1159108.4298 , 28 , 281644.1089 ] 0","title":"Examples"},{"location":"api/synth/Agrawal/#methods","text":"generate_drift Generate drift by switching the classification function randomly. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Agrawal/#notes","text":"The sample generation works as follows: The 9 features are generated with the random generator, initialized with the seed passed by the user. Then, the classification function decides, as a function of all the attributes, whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. Finally, add noise if perturbation > 0.0.","title":"Notes"},{"location":"api/synth/Agrawal/#references","text":"Rakesh Agrawal, Tomasz Imielinksi, and Arun Swami. \"Database Mining: A Performance Perspective\", IEEE Transactions on Knowledge and Data Engineering, 5(6), December 1993. \u21a9 \u21a9","title":"References"},{"location":"api/synth/AnomalySine/","text":"AnomalySine \u00b6 Simulate a stream with anomalies in sine waves The data generated corresponds to sine ( attribute 1 ) and cosine ( attribute 2 ) functions. Anomalies are induced by replacing values from attribute 2 with values from a sine function different to the one used in attribute 1 . The contextual flag can be used to introduce contextual anomalies which are values in the normal global range, but abnormal compared to the seasonal pattern. Contextual attributes are introduced by replacing values in attribute 2 with values from attribute 1 . Parameters \u00b6 n_samples ( int ) \u2013 defaults to 10000 Number of samples n_anomalies ( int ) \u2013 defaults to 2500 Number of anomalies. Can't be larger than n_samples . contextual ( bool ) \u2013 defaults to False If True, will add contextual anomalies n_contextual ( int ) \u2013 defaults to 2500 Number of contextual anomalies. Can't be larger than n_samples . shift ( int ) \u2013 defaults to 4 Shift in number of samples applied when retrieving contextual anomalies noise ( float ) \u2013 defaults to 0.5 Amount of noise replace ( bool ) \u2013 defaults to True If True, anomalies are randomly sampled with replacement seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . AnomalySine ( seed = 12345 , ... n_samples = 100 , ... n_anomalies = 25 , ... contextual = True , ... n_contextual = 10 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'sine' : - 0.1023 , 'cosine' : 0.2171 } 0.0 { 'sine' : 0.4868 , 'cosine' : 0.6876 } 0.0 { 'sine' : 0.2197 , 'cosine' : 0.8612 } 0.0 { 'sine' : 0.4037 , 'cosine' : 0.2671 } 0.0 { 'sine' : 1.8243 , 'cosine' : 1.8268 } 1.0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"AnomalySine"},{"location":"api/synth/AnomalySine/#anomalysine","text":"Simulate a stream with anomalies in sine waves The data generated corresponds to sine ( attribute 1 ) and cosine ( attribute 2 ) functions. Anomalies are induced by replacing values from attribute 2 with values from a sine function different to the one used in attribute 1 . The contextual flag can be used to introduce contextual anomalies which are values in the normal global range, but abnormal compared to the seasonal pattern. Contextual attributes are introduced by replacing values in attribute 2 with values from attribute 1 .","title":"AnomalySine"},{"location":"api/synth/AnomalySine/#parameters","text":"n_samples ( int ) \u2013 defaults to 10000 Number of samples n_anomalies ( int ) \u2013 defaults to 2500 Number of anomalies. Can't be larger than n_samples . contextual ( bool ) \u2013 defaults to False If True, will add contextual anomalies n_contextual ( int ) \u2013 defaults to 2500 Number of contextual anomalies. Can't be larger than n_samples . shift ( int ) \u2013 defaults to 4 Shift in number of samples applied when retrieving contextual anomalies noise ( float ) \u2013 defaults to 0.5 Amount of noise replace ( bool ) \u2013 defaults to True If True, anomalies are randomly sampled with replacement seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random .","title":"Parameters"},{"location":"api/synth/AnomalySine/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/AnomalySine/#examples","text":">>> from river import synth >>> dataset = synth . AnomalySine ( seed = 12345 , ... n_samples = 100 , ... n_anomalies = 25 , ... contextual = True , ... n_contextual = 10 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'sine' : - 0.1023 , 'cosine' : 0.2171 } 0.0 { 'sine' : 0.4868 , 'cosine' : 0.6876 } 0.0 { 'sine' : 0.2197 , 'cosine' : 0.8612 } 0.0 { 'sine' : 0.4037 , 'cosine' : 0.2671 } 0.0 { 'sine' : 1.8243 , 'cosine' : 1.8268 } 1.0","title":"Examples"},{"location":"api/synth/AnomalySine/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/ConceptDriftStream/","text":"ConceptDriftStream \u00b6 Generates a stream with concept drift. A stream generator that adds concept drift or change by joining two streams. This is done by building a weighted combination of two pure distributions that characterizes the target concepts before and after the change. The sigmoid function is an elegant and practical solution to define the probability that each new instance of the stream belongs to the new concept after the drift. The sigmoid function introduces a gradual, smooth transition whose duration is controlled with two parameters: \\(p\\) , the position of the change. \\(w\\) , the width of the transition. The sigmoid function at sample \\(t\\) is \\[f(t) = 1/(1+e^{-4(t-p)/w})\\] Parameters \u00b6 stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Original stream drift_stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Drift stream position ( int ) \u2013 defaults to 5000 Central position of the concept drift change. width ( int ) \u2013 defaults to 1000 Width of concept drift change. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . alpha ( float ) \u2013 defaults to None Angle of change used to estimate the width of concept drift change. If set, it will override the width parameter. Valid values are in the range (0.0, 90.0]. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 5 , width = 2 ) >>> for x , y in dataset . take ( 10 ): ... print ( x , y ) { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 0.2979 , 1 : 2.1863 , 2 : 5.0535 } False { 0 : 0.2653 , 1 : 1.9883 , 2 : 6.4988 } False { 0 : 5.4494 , 1 : 2.2044 , 2 : 5.8926 } False { 0 : 8.0943 , 1 : 0.0649 , 2 : 8.0581 } False Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An optional way to estimate the width of the transition \\(w\\) is based on the angle \\(\u0007lpha\\) , \\(w = 1/ tan(\u0007lpha)\\) . Since width corresponds to the number of samples for the transition, the width is rounded to the nearest smaller integer. Notice that larger values of \\(\u0007lpha\\) result in smaller widths. For \\(\u0007lpha > 45.0\\) , the width is smaller than 1 so values are rounded to 1 to avoid division by zero errors.","title":"ConceptDriftStream"},{"location":"api/synth/ConceptDriftStream/#conceptdriftstream","text":"Generates a stream with concept drift. A stream generator that adds concept drift or change by joining two streams. This is done by building a weighted combination of two pure distributions that characterizes the target concepts before and after the change. The sigmoid function is an elegant and practical solution to define the probability that each new instance of the stream belongs to the new concept after the drift. The sigmoid function introduces a gradual, smooth transition whose duration is controlled with two parameters: \\(p\\) , the position of the change. \\(w\\) , the width of the transition. The sigmoid function at sample \\(t\\) is \\[f(t) = 1/(1+e^{-4(t-p)/w})\\]","title":"ConceptDriftStream"},{"location":"api/synth/ConceptDriftStream/#parameters","text":"stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Original stream drift_stream ( river.datasets.base.SyntheticDataset ) \u2013 defaults to None Drift stream position ( int ) \u2013 defaults to 5000 Central position of the concept drift change. width ( int ) \u2013 defaults to 1000 Width of concept drift change. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . alpha ( float ) \u2013 defaults to None Angle of change used to estimate the width of concept drift change. If set, it will override the width parameter. Valid values are in the range (0.0, 90.0].","title":"Parameters"},{"location":"api/synth/ConceptDriftStream/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/ConceptDriftStream/#examples","text":">>> from river import synth >>> dataset = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 5 , width = 2 ) >>> for x , y in dataset . take ( 10 ): ... print ( x , y ) { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 6.3942 , 1 : 0.2501 , 2 : 2.7502 } False { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 2.2321 , 1 : 7.3647 , 2 : 6.7669 } True { 0 : 8.9217 , 1 : 0.8693 , 2 : 4.2192 } True { 0 : 0.2979 , 1 : 2.1863 , 2 : 5.0535 } False { 0 : 0.2653 , 1 : 1.9883 , 2 : 6.4988 } False { 0 : 5.4494 , 1 : 2.2044 , 2 : 5.8926 } False { 0 : 8.0943 , 1 : 0.0649 , 2 : 8.0581 } False","title":"Examples"},{"location":"api/synth/ConceptDriftStream/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/ConceptDriftStream/#notes","text":"An optional way to estimate the width of the transition \\(w\\) is based on the angle \\(\u0007lpha\\) , \\(w = 1/ tan(\u0007lpha)\\) . Since width corresponds to the number of samples for the transition, the width is rounded to the nearest smaller integer. Notice that larger values of \\(\u0007lpha\\) result in smaller widths. For \\(\u0007lpha > 45.0\\) , the width is smaller than 1 so values are rounded to 1 to avoid division by zero errors.","title":"Notes"},{"location":"api/synth/Friedman/","text":"Friedman \u00b6 Friedman synthetic dataset. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. The target is defined by the following function: \\[y = 10 sin(\\pi x_0 x_1) + 20 (x_2 - 0.5)^2 + 10 x_3 + 5 x_4 + \\epsilon\\] In the last expression, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise. Therefore, only the first 5 features are relevant. Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Friedman ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Friedman, J.H., 1991. Multivariate adaptive regression splines. The annals of statistics, pp.1-67. \u21a9","title":"Friedman"},{"location":"api/synth/Friedman/#friedman","text":"Friedman synthetic dataset. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. The target is defined by the following function: \\[y = 10 sin(\\pi x_0 x_1) + 20 (x_2 - 0.5)^2 + 10 x_3 + 5 x_4 + \\epsilon\\] In the last expression, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise. Therefore, only the first 5 features are relevant.","title":"Friedman"},{"location":"api/synth/Friedman/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/Friedman/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Friedman/#examples","text":">>> from river import synth >>> dataset = synth . Friedman ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90","title":"Examples"},{"location":"api/synth/Friedman/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Friedman/#references","text":"Friedman, J.H., 1991. Multivariate adaptive regression splines. The annals of statistics, pp.1-67. \u21a9","title":"References"},{"location":"api/synth/FriedmanDrift/","text":"FriedmanDrift \u00b6 Friedman synthetic dataset with concept drifts. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. Only the first 5 features are relevant. The target is defined by different functions depending on the type of the drift. The three available modes of operation of the data generator are described in 1 . Parameters \u00b6 drift_type ( str ) \u2013 defaults to lea The variant of concept drift. - 'lea' : Local Expanding Abrupt drift. The concept drift appears in two distinct regions of the instance space, while the remaining regions are left unaltered. There are three points of abrupt change in the training dataset. At every consecutive change the regions of drift are expanded. - 'gra' : Global Recurring Abrupt drift. The concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs. - 'gsg' : Global and Slow Gradual drift. The concept drift affects all the instance space. However, the change is gradual and not abrupt. After each one of the two change points covered by this variant, and during a window of length transition_window , examples from both old and the new concepts are generated with equal probability. After the transition period, only the examples from the new concept are generated. position ( Tuple[int, ...] ) \u2013 defaults to (50000, 100000, 150000) The amount of monitored instances after which each concept drift occurs. A tuple with at least two element must be passed, where each number is greater than the preceding one. If drift_type='lea' , then the tuple must have three elements. transition_window ( int ) \u2013 defaults to 10000 The length of the transition window between two concepts. Only applicable when drift_type='gsg' . If set to zero, the drifts will be abrupt. Anytime transition_window > 0 , it defines a window in which instances of the new concept are gradually introduced among the examples from the old concept. During this transition phase, both old and new concepts appear with equal probability. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . FriedmanDrift ( ... drift_type = 'lea' , ... position = ( 1 , 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] - 2.65 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gra' , ... position = ( 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.96 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gsg' , ... position = ( 1 , 4 ), ... transition_window = 2 , ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.92 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 17.32 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 6.05 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Ikonomovska, E., Gama, J. and D\u017eeroski, S., 2011. Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), pp.128-168. \u21a9","title":"FriedmanDrift"},{"location":"api/synth/FriedmanDrift/#friedmandrift","text":"Friedman synthetic dataset with concept drifts. Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. Only the first 5 features are relevant. The target is defined by different functions depending on the type of the drift. The three available modes of operation of the data generator are described in 1 .","title":"FriedmanDrift"},{"location":"api/synth/FriedmanDrift/#parameters","text":"drift_type ( str ) \u2013 defaults to lea The variant of concept drift. - 'lea' : Local Expanding Abrupt drift. The concept drift appears in two distinct regions of the instance space, while the remaining regions are left unaltered. There are three points of abrupt change in the training dataset. At every consecutive change the regions of drift are expanded. - 'gra' : Global Recurring Abrupt drift. The concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs. - 'gsg' : Global and Slow Gradual drift. The concept drift affects all the instance space. However, the change is gradual and not abrupt. After each one of the two change points covered by this variant, and during a window of length transition_window , examples from both old and the new concepts are generated with equal probability. After the transition period, only the examples from the new concept are generated. position ( Tuple[int, ...] ) \u2013 defaults to (50000, 100000, 150000) The amount of monitored instances after which each concept drift occurs. A tuple with at least two element must be passed, where each number is greater than the preceding one. If drift_type='lea' , then the tuple must have three elements. transition_window ( int ) \u2013 defaults to 10000 The length of the transition window between two concepts. Only applicable when drift_type='gsg' . If set to zero, the drifts will be abrupt. Anytime transition_window > 0 , it defines a window in which instances of the new concept are gradually introduced among the examples from the old concept. During this transition phase, both old and new concepts appear with equal probability. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/FriedmanDrift/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/FriedmanDrift/#examples","text":">>> from river import synth >>> dataset = synth . FriedmanDrift ( ... drift_type = 'lea' , ... position = ( 1 , 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 7.04 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] - 2.65 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gra' , ... position = ( 2 , 3 ), ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.96 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 18.16 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 8.90 >>> dataset = synth . FriedmanDrift ( ... drift_type = 'gsg' , ... position = ( 1 , 4 ), ... transition_window = 2 , ... seed = 42 ... ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.63 , 0.02 , 0.27 , 0.22 , 0.73 , 0.67 , 0.89 , 0.08 , 0.42 , 0.02 ] 7.66 [ 0.02 , 0.19 , 0.64 , 0.54 , 0.22 , 0.58 , 0.80 , 0.00 , 0.80 , 0.69 ] 8.33 [ 0.34 , 0.15 , 0.95 , 0.33 , 0.09 , 0.09 , 0.84 , 0.60 , 0.80 , 0.72 ] 8.92 [ 0.37 , 0.55 , 0.82 , 0.61 , 0.86 , 0.57 , 0.70 , 0.04 , 0.22 , 0.28 ] 17.32 [ 0.07 , 0.23 , 0.10 , 0.27 , 0.63 , 0.36 , 0.37 , 0.20 , 0.26 , 0.93 ] 6.05","title":"Examples"},{"location":"api/synth/FriedmanDrift/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/FriedmanDrift/#references","text":"Ikonomovska, E., Gama, J. and D\u017eeroski, S., 2011. Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), pp.128-168. \u21a9","title":"References"},{"location":"api/synth/Hyperplane/","text":"Hyperplane \u00b6 Hyperplane stream generator. Generates a problem of prediction class of a rotation hyperplane. It was used as testbed for CVFDT and VFDT in 1 . A hyperplane in d-dimensional space is the set of points \\(x\\) that satisfy \\[\\sum^{d}_{i=1} w_i x_i = w_0 = \\sum^{d}_{i=1} w_i\\] where \\(x_i\\) is the i-th coordinate of \\(x\\) . Examples for which \\(\\sum^{d}_{i=1} w_i x_i > w_0\\) , are labeled positive. Examples for which \\(\\sum^{d}_{i=1} w_i x_i \\leq w_0\\) , are labeled negative. Hyperplanes are useful for simulating time-changing concepts because we can change the orientation and position of the hyperplane in a smooth manner by changing the relative size of the weights. We introduce change to this dataset by adding drift to each weighted feature \\(w_i = w_i + d \\sigma\\) , where \\(\\sigma\\) is the probability that the direction of change is reversed and \\(d\\) is the change applied to each example. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_features ( int ) \u2013 defaults to 10 The number of attributes to generate. Higher than 2. n_drift_features ( int ) \u2013 defaults to 2 The number of attributes with drift. Higher than 2. mag_change ( float ) \u2013 defaults to 0.0 Magnitude of the change for every example. From 0.0 to 1.0. noise_percentage ( float ) \u2013 defaults to 0.05 Percentage of noise to add to the data. From 0.0 to 1.0. sigma ( float ) \u2013 defaults to 0.1 Probability that the direction of change is reversed. From 0.0 to 1.0. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Hyperplane ( seed = 42 , n_features = 2 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.7319 , 1 : 0.5986 } 1 { 0 : 0.8661 , 1 : 0.6011 } 1 { 0 : 0.8324 , 1 : 0.2123 } 0 { 0 : 0.5247 , 1 : 0.4319 } 0 { 0 : 0.2921 , 1 : 0.3663 } 0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The features are generated with the random number generator, initialized with the seed passed by the user. Then the classification function decides, as a function of the sum of the weighted features and the sum of the weights, whether the instance belongs to class 0 or class 1. The last step is to add noise and generate drift. References \u00b6 G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9","title":"Hyperplane"},{"location":"api/synth/Hyperplane/#hyperplane","text":"Hyperplane stream generator. Generates a problem of prediction class of a rotation hyperplane. It was used as testbed for CVFDT and VFDT in 1 . A hyperplane in d-dimensional space is the set of points \\(x\\) that satisfy \\[\\sum^{d}_{i=1} w_i x_i = w_0 = \\sum^{d}_{i=1} w_i\\] where \\(x_i\\) is the i-th coordinate of \\(x\\) . Examples for which \\(\\sum^{d}_{i=1} w_i x_i > w_0\\) , are labeled positive. Examples for which \\(\\sum^{d}_{i=1} w_i x_i \\leq w_0\\) , are labeled negative. Hyperplanes are useful for simulating time-changing concepts because we can change the orientation and position of the hyperplane in a smooth manner by changing the relative size of the weights. We introduce change to this dataset by adding drift to each weighted feature \\(w_i = w_i + d \\sigma\\) , where \\(\\sigma\\) is the probability that the direction of change is reversed and \\(d\\) is the change applied to each example.","title":"Hyperplane"},{"location":"api/synth/Hyperplane/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_features ( int ) \u2013 defaults to 10 The number of attributes to generate. Higher than 2. n_drift_features ( int ) \u2013 defaults to 2 The number of attributes with drift. Higher than 2. mag_change ( float ) \u2013 defaults to 0.0 Magnitude of the change for every example. From 0.0 to 1.0. noise_percentage ( float ) \u2013 defaults to 0.05 Percentage of noise to add to the data. From 0.0 to 1.0. sigma ( float ) \u2013 defaults to 0.1 Probability that the direction of change is reversed. From 0.0 to 1.0.","title":"Parameters"},{"location":"api/synth/Hyperplane/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Hyperplane/#examples","text":">>> from river import synth >>> dataset = synth . Hyperplane ( seed = 42 , n_features = 2 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.7319 , 1 : 0.5986 } 1 { 0 : 0.8661 , 1 : 0.6011 } 1 { 0 : 0.8324 , 1 : 0.2123 } 0 { 0 : 0.5247 , 1 : 0.4319 } 0 { 0 : 0.2921 , 1 : 0.3663 } 0","title":"Examples"},{"location":"api/synth/Hyperplane/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Hyperplane/#notes","text":"The sample generation works as follows: The features are generated with the random number generator, initialized with the seed passed by the user. Then the classification function decides, as a function of the sum of the weighted features and the sum of the weights, whether the instance belongs to class 0 or class 1. The last step is to add noise and generate drift.","title":"Notes"},{"location":"api/synth/Hyperplane/#references","text":"G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9","title":"References"},{"location":"api/synth/LED/","text":"LED \u00b6 LED stream generator. This data source originates from the CART book 1 . An implementation in C was donated to the UCI 2 machine learning repository by David Aha. The goal is to predict the digit displayed on a seven-segment LED display, where each attribute has a 10% chance of being inverted. It has an optimal Bayes classification rate of 74%. The particular configuration of the generator used for experiments (LED) produces 24 binary attributes, 17 of which are irrelevant. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . LED ( seed = 112 , noise_percentage = 0.28 , irrelevant_features = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 0 , 1 : 1 , 2 : 0 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 1 , 1 : 0 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 1 } 3 { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 0 , 4 : 0 , 5 : 1 , 6 : 1 } 0 { 0 : 1 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 1 , 6 : 0 } 4 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes. References \u00b6 Leo Breiman, Jerome Friedman, R. Olshen, and Charles J. Stone. Classification and Regression Trees. Wadsworth and Brooks, Monterey, CA,1984. \u21a9 A. Asuncion and D. J. Newman. UCI Machine Learning Repository [http://www.ics.uci.edu/\u223cmlearn/mlrepository.html]. University of California, Irvine, School of Information and Computer Sciences,2007. \u21a9","title":"LED"},{"location":"api/synth/LED/#led","text":"LED stream generator. This data source originates from the CART book 1 . An implementation in C was donated to the UCI 2 machine learning repository by David Aha. The goal is to predict the digit displayed on a seven-segment LED display, where each attribute has a 10% chance of being inverted. It has an optimal Bayes classification rate of 74%. The particular configuration of the generator used for experiments (LED) produces 24 binary attributes, 17 of which are irrelevant.","title":"LED"},{"location":"api/synth/LED/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream.","title":"Parameters"},{"location":"api/synth/LED/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/LED/#examples","text":">>> from river import synth >>> dataset = synth . LED ( seed = 112 , noise_percentage = 0.28 , irrelevant_features = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 0 , 1 : 1 , 2 : 0 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 0 } 4 { 0 : 1 , 1 : 0 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 0 , 6 : 1 } 3 { 0 : 0 , 1 : 1 , 2 : 1 , 3 : 0 , 4 : 0 , 5 : 1 , 6 : 1 } 0 { 0 : 1 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 0 , 5 : 1 , 6 : 0 } 4","title":"Examples"},{"location":"api/synth/LED/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/LED/#notes","text":"An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes.","title":"Notes"},{"location":"api/synth/LED/#references","text":"Leo Breiman, Jerome Friedman, R. Olshen, and Charles J. Stone. Classification and Regression Trees. Wadsworth and Brooks, Monterey, CA,1984. \u21a9 A. Asuncion and D. J. Newman. UCI Machine Learning Repository [http://www.ics.uci.edu/\u223cmlearn/mlrepository.html]. University of California, Irvine, School of Information and Computer Sciences,2007. \u21a9","title":"References"},{"location":"api/synth/LEDDrift/","text":"LEDDrift \u00b6 LED stream generator with concept drift. This class is an extension of the LED generator whose purpose is to add concept drift to the stream. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream. n_drift_features ( int ) \u2013 defaults to 0 The number of attributes that have drift. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . LEDDrift ( seed = 112 , noise_percentage = 0.28 , ... irrelevant_features = True , n_drift_features = 4 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ] 8 [ 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 5 [ 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 ] 8 [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 ] 3 [ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 ] 5 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes.","title":"LEDDrift"},{"location":"api/synth/LEDDrift/#leddrift","text":"LED stream generator with concept drift. This class is an extension of the LED generator whose purpose is to add concept drift to the stream.","title":"LEDDrift"},{"location":"api/synth/LEDDrift/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . noise_percentage ( float ) \u2013 defaults to 0.0 The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value will be switched irrelevant_features ( bool ) \u2013 defaults to False Adds 17 non-relevant attributes to the stream. n_drift_features ( int ) \u2013 defaults to 0 The number of attributes that have drift.","title":"Parameters"},{"location":"api/synth/LEDDrift/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/LEDDrift/#examples","text":">>> from river import synth >>> dataset = synth . LEDDrift ( seed = 112 , noise_percentage = 0.28 , ... irrelevant_features = True , n_drift_features = 4 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ] 8 [ 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] 5 [ 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 ] 8 [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 ] 3 [ 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 ] 5","title":"Examples"},{"location":"api/synth/LEDDrift/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/LEDDrift/#notes","text":"An instance is generated based on the parameters passed. If has_noise is set then the total number of attributes will be 24, otherwise there will be 7 attributes.","title":"Notes"},{"location":"api/synth/Logical/","text":"Logical \u00b6 Logical functions stream generator. Make a toy dataset with three labels that represent the logical functions: OR , XOR , AND (functions of the 2D input). Data is generated in 'tiles' which contain the complete set of logical operations results. The tiles are repeated n_tiles times. Optionally, the generated data can be shuffled. Parameters \u00b6 n_tiles ( int ) \u2013 defaults to 1 Number of tiles to generate. shuffle ( bool ) \u2013 defaults to True If set, generated data will be shuffled. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Logical ( n_tiles = 2 , shuffle = True , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 0 } { 'OR' : 0 , 'XOR' : 0 , 'AND' : 0 } { 'A' : 1 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 0 , 'AND' : 1 } { 'A' : 1 , 'B' : 0 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"Logical"},{"location":"api/synth/Logical/#logical","text":"Logical functions stream generator. Make a toy dataset with three labels that represent the logical functions: OR , XOR , AND (functions of the 2D input). Data is generated in 'tiles' which contain the complete set of logical operations results. The tiles are repeated n_tiles times. Optionally, the generated data can be shuffled.","title":"Logical"},{"location":"api/synth/Logical/#parameters","text":"n_tiles ( int ) \u2013 defaults to 1 Number of tiles to generate. shuffle ( bool ) \u2013 defaults to True If set, generated data will be shuffled. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random .","title":"Parameters"},{"location":"api/synth/Logical/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Logical/#examples","text":">>> from river import synth >>> dataset = synth . Logical ( n_tiles = 2 , shuffle = True , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 } { 'A' : 0 , 'B' : 0 } { 'OR' : 0 , 'XOR' : 0 , 'AND' : 0 } { 'A' : 1 , 'B' : 1 } { 'OR' : 1 , 'XOR' : 0 , 'AND' : 1 } { 'A' : 1 , 'B' : 0 } { 'OR' : 1 , 'XOR' : 1 , 'AND' : 0 }","title":"Examples"},{"location":"api/synth/Logical/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Mixed/","text":"Mixed \u00b6 Mixed data stream generator. This generator is an implementation of a data stream with abrupt concept drift and boolean noise-free examples as described in 1 . It has four relevant attributes, two boolean attributes \\(v, w\\) and two numeric attributes \\(x, y\\) uniformly distributed from 0 to 1. The examples are labeled depending on the classification function chosen from below. function 0 : if \\(v\\) and \\(w\\) are true or \\(v\\) and \\(z\\) are true or \\(w\\) and \\(z\\) are true then 0 else 1, where \\(z\\) is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) function 1 : The opposite of function 0 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 Which of the two classification functions to use for the generation. Valid options are 0 or 1. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to a uniform distribution. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> >>> dataset = synth . Mixed ( seed = 42 , classification_function = 1 , balance_classes = True ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : False , 1 : True , 2 : 0.7319 , 3 : 0.5986 } 1 { 0 : False , 1 : False , 2 : 0.0580 , 3 : 0.8661 } 0 { 0 : True , 1 : True , 2 : 0.0205 , 3 : 0.9699 } 1 { 0 : False , 1 : True , 2 : 0.4319 , 3 : 0.2912 } 0 { 0 : True , 1 : False , 2 : 0.2921 , 3 : 0.3663 } 1 Methods \u00b6 generate_drift Generate drift by switching the classification function. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The two numeric attributes are generated with the random generator initialized with the seed passed by the user (optional). The boolean attributes are either 0 or 1 based on the comparison of the random number generator and 0.5 , the classification function decides whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. The generated sample will have 4 relevant features and 1 label (it is a binary-classification task). References \u00b6 Gama, Joao, et al. \"Learning with drift detection.\" Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295\" \u21a9","title":"Mixed"},{"location":"api/synth/Mixed/#mixed","text":"Mixed data stream generator. This generator is an implementation of a data stream with abrupt concept drift and boolean noise-free examples as described in 1 . It has four relevant attributes, two boolean attributes \\(v, w\\) and two numeric attributes \\(x, y\\) uniformly distributed from 0 to 1. The examples are labeled depending on the classification function chosen from below. function 0 : if \\(v\\) and \\(w\\) are true or \\(v\\) and \\(z\\) are true or \\(w\\) and \\(z\\) are true then 0 else 1, where \\(z\\) is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) function 1 : The opposite of function 0 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream .","title":"Mixed"},{"location":"api/synth/Mixed/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 Which of the two classification functions to use for the generation. Valid options are 0 or 1. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to a uniform distribution.","title":"Parameters"},{"location":"api/synth/Mixed/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Mixed/#examples","text":">>> from river import synth >>> >>> dataset = synth . Mixed ( seed = 42 , classification_function = 1 , balance_classes = True ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : False , 1 : True , 2 : 0.7319 , 3 : 0.5986 } 1 { 0 : False , 1 : False , 2 : 0.0580 , 3 : 0.8661 } 0 { 0 : True , 1 : True , 2 : 0.0205 , 3 : 0.9699 } 1 { 0 : False , 1 : True , 2 : 0.4319 , 3 : 0.2912 } 0 { 0 : True , 1 : False , 2 : 0.2921 , 3 : 0.3663 } 1","title":"Examples"},{"location":"api/synth/Mixed/#methods","text":"generate_drift Generate drift by switching the classification function. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Mixed/#notes","text":"The sample generation works as follows: The two numeric attributes are generated with the random generator initialized with the seed passed by the user (optional). The boolean attributes are either 0 or 1 based on the comparison of the random number generator and 0.5 , the classification function decides whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. The generated sample will have 4 relevant features and 1 label (it is a binary-classification task).","title":"Notes"},{"location":"api/synth/Mixed/#references","text":"Gama, Joao, et al. \"Learning with drift detection.\" Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295\" \u21a9","title":"References"},{"location":"api/synth/Mv/","text":"Mv \u00b6 Mv artificial dataset. Artificial dataset composed of both nominal and numeric features, whose features present co-dependencies. Originally described in 1 . The features are generated using the following expressions: \\(x_1\\) : uniformly distributed over [-5, 5] . \\(x_2\\) : uniformly distributed over [-15, -10] . \\(x_3\\) : if \\(x_1 > 0\\) , \\(x_3 \\leftarrow\\) 'green' else \\(x_3 \\leftarrow\\) 'red' with probability \\(0.4\\) and \\(x_3 \\leftarrow\\) 'brown' with probability \\(0.6\\) . \\(x_4\\) : if \\(x_3 =\\) 'green' , \\(x_4 \\leftarrow x_1 + 2 x_2\\) else \\(x_4 = \\frac{x_1}{2}\\) with probability \\(0.3\\) and \\(x_4 = \\frac{x_2}{2}\\) with probability \\(0.7\\) . \\(x_5\\) : uniformly distributed over [-1, 1] . \\(x_6 \\leftarrow x_4 \\times \\epsilon\\) , where \\(\\epsilon\\) is uniformly distributed over [0, 5] . \\(x_7\\) : 'yes' with probability \\(0.3\\) , and 'no' with probability \\(0.7\\) . \\(x_8\\) : 'normal' if \\(x_5 < 0.5\\) else 'large' . \\(x_9\\) : uniformly distributed over [100, 500] . \\(x_{10}\\) : uniformly distributed integer over the interval [1000, 1200] . The target value is generated using the following rules: if \\(x_2 > 2\\) , \\(y \\leftarrow 35 - 0.5 x_4\\) else if \\(-2 \\le x_4 \\le 2\\) , \\(y \\leftarrow 10 - 2 x_1\\) else if \\(x_7 =\\) 'yes' , \\(y \\leftarrow 3 - \\frac{x_1}{x_4}\\) else if \\(x_8 =\\) 'normal' , \\(y \\leftarrow x_6 + x_1\\) else \\(y \\leftarrow \\frac{x_1}{2}\\) . Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Mv ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1.39 , - 14.87 , 'green' , - 28.35 , - 0.44 , - 31.64 , 'no' , 'normal' , 370.67 , 1178.43 ] - 30.25 [ - 4.13 , - 12.89 , 'red' , - 2.06 , 0.01 , - 0.27 , 'yes' , 'normal' , 359.95 , 1108.98 ] 1.00 [ - 2.79 , - 12.05 , 'brown' , - 1.39 , 0.61 , - 4.87 , 'no' , 'large' , 162.19 , 1191.44 ] 15.59 [ - 1.63 , - 14.53 , 'red' , - 7.26 , 0.20 , - 29.33 , 'no' , 'normal' , 314.49 , 1194.62 ] - 30.96 [ - 1.21 , - 12.23 , 'brown' , - 6.11 , 0.72 , - 17.66 , 'no' , 'large' , 118.32 , 1045.57 ] - 0.60 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Mv in Lu\u00eds Torgo regression datasets \u21a9","title":"Mv"},{"location":"api/synth/Mv/#mv","text":"Mv artificial dataset. Artificial dataset composed of both nominal and numeric features, whose features present co-dependencies. Originally described in 1 . The features are generated using the following expressions: \\(x_1\\) : uniformly distributed over [-5, 5] . \\(x_2\\) : uniformly distributed over [-15, -10] . \\(x_3\\) : if \\(x_1 > 0\\) , \\(x_3 \\leftarrow\\) 'green' else \\(x_3 \\leftarrow\\) 'red' with probability \\(0.4\\) and \\(x_3 \\leftarrow\\) 'brown' with probability \\(0.6\\) . \\(x_4\\) : if \\(x_3 =\\) 'green' , \\(x_4 \\leftarrow x_1 + 2 x_2\\) else \\(x_4 = \\frac{x_1}{2}\\) with probability \\(0.3\\) and \\(x_4 = \\frac{x_2}{2}\\) with probability \\(0.7\\) . \\(x_5\\) : uniformly distributed over [-1, 1] . \\(x_6 \\leftarrow x_4 \\times \\epsilon\\) , where \\(\\epsilon\\) is uniformly distributed over [0, 5] . \\(x_7\\) : 'yes' with probability \\(0.3\\) , and 'no' with probability \\(0.7\\) . \\(x_8\\) : 'normal' if \\(x_5 < 0.5\\) else 'large' . \\(x_9\\) : uniformly distributed over [100, 500] . \\(x_{10}\\) : uniformly distributed integer over the interval [1000, 1200] . The target value is generated using the following rules: if \\(x_2 > 2\\) , \\(y \\leftarrow 35 - 0.5 x_4\\) else if \\(-2 \\le x_4 \\le 2\\) , \\(y \\leftarrow 10 - 2 x_1\\) else if \\(x_7 =\\) 'yes' , \\(y \\leftarrow 3 - \\frac{x_1}{x_4}\\) else if \\(x_8 =\\) 'normal' , \\(y \\leftarrow x_6 + x_1\\) else \\(y \\leftarrow \\frac{x_1}{2}\\) .","title":"Mv"},{"location":"api/synth/Mv/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/Mv/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Mv/#examples","text":">>> from river import synth >>> dataset = synth . Mv ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 1.39 , - 14.87 , 'green' , - 28.35 , - 0.44 , - 31.64 , 'no' , 'normal' , 370.67 , 1178.43 ] - 30.25 [ - 4.13 , - 12.89 , 'red' , - 2.06 , 0.01 , - 0.27 , 'yes' , 'normal' , 359.95 , 1108.98 ] 1.00 [ - 2.79 , - 12.05 , 'brown' , - 1.39 , 0.61 , - 4.87 , 'no' , 'large' , 162.19 , 1191.44 ] 15.59 [ - 1.63 , - 14.53 , 'red' , - 7.26 , 0.20 , - 29.33 , 'no' , 'normal' , 314.49 , 1194.62 ] - 30.96 [ - 1.21 , - 12.23 , 'brown' , - 6.11 , 0.72 , - 17.66 , 'no' , 'large' , 118.32 , 1045.57 ] - 0.60","title":"Examples"},{"location":"api/synth/Mv/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Mv/#references","text":"Mv in Lu\u00eds Torgo regression datasets \u21a9","title":"References"},{"location":"api/synth/Planes2D/","text":"Planes2D \u00b6 2D Planes synthetic dataset. This dataset is described in 1 and was adapted from 2 . The features are generated using the following probabilities: \\[P(x_1 = -1) = P(x_1 = 1) = \\frac{1}{2}\\] \\[P(x_m = -1) = P(x_m = 0) = P(x_m = 1) = \\frac{1}{3}, m=2,\\ldots, 10\\] The target value is defined by the following rule: \\[\\text{if}~x_1 = 1, y \\leftarrow 3 + 3x_2 + 2x_3 + x_4 + \\epsilon\\] \\[\\text{if}~x_1 = -1, y \\leftarrow -3 + 3x_5 + 2x_6 + x_7 + \\epsilon\\] In the expressions, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise. Parameters \u00b6 seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Planes2D ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ - 1 , - 1 , 1 , 0 , - 1 , - 1 , - 1 , 1 , - 1 , 1 ] - 9.07 [ 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 1 , 1 , - 1 , 1 ] - 4.25 [ - 1 , 1 , 1 , 1 , 1 , 0 , - 1 , 0 , 1 , 0 ] - 0.95 [ - 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , 0 , - 1 , - 1 ] - 6.10 [ 1 , - 1 , 0 , 0 , 1 , 0 , - 1 , 1 , 0 , 1 ] 1.60 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 2DPlanes in Lu\u00eds Torgo regression datasets \u21a9 Breiman, L., Friedman, J., Stone, C.J. and Olshen, R.A., 1984. Classification and regression trees. CRC press. \u21a9","title":"Planes2D"},{"location":"api/synth/Planes2D/#planes2d","text":"2D Planes synthetic dataset. This dataset is described in 1 and was adapted from 2 . The features are generated using the following probabilities: \\[P(x_1 = -1) = P(x_1 = 1) = \\frac{1}{2}\\] \\[P(x_m = -1) = P(x_m = 0) = P(x_m = 1) = \\frac{1}{3}, m=2,\\ldots, 10\\] The target value is defined by the following rule: \\[\\text{if}~x_1 = 1, y \\leftarrow 3 + 3x_2 + 2x_3 + x_4 + \\epsilon\\] \\[\\text{if}~x_1 = -1, y \\leftarrow -3 + 3x_5 + 2x_6 + x_7 + \\epsilon\\] In the expressions, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\) , is the noise.","title":"Planes2D"},{"location":"api/synth/Planes2D/#parameters","text":"seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/Planes2D/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Planes2D/#examples","text":">>> from river import synth >>> dataset = synth . Planes2D ( seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ - 1 , - 1 , 1 , 0 , - 1 , - 1 , - 1 , 1 , - 1 , 1 ] - 9.07 [ 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 1 , 1 , - 1 , 1 ] - 4.25 [ - 1 , 1 , 1 , 1 , 1 , 0 , - 1 , 0 , 1 , 0 ] - 0.95 [ - 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , 0 , - 1 , - 1 ] - 6.10 [ 1 , - 1 , 0 , 0 , 1 , 0 , - 1 , 1 , 0 , 1 ] 1.60","title":"Examples"},{"location":"api/synth/Planes2D/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Planes2D/#references","text":"2DPlanes in Lu\u00eds Torgo regression datasets \u21a9 Breiman, L., Friedman, J., Stone, C.J. and Olshen, R.A., 1984. Classification and regression trees. CRC press. \u21a9","title":"References"},{"location":"api/synth/RandomRBF/","text":"RandomRBF \u00b6 Random Radial Basis Function generator. Produces a radial basis function stream. A number of centroids, having a random central position, a standard deviation, a class label and weight are generated. A new sample is created by choosing one of the centroids at random, taking into account their weights, and offsetting the attributes in a random direction from the centroid's center. The offset length is drawn from a Gaussian distribution. This process will create a normally distributed hypersphere of samples on the surrounds of each centroid. Parameters \u00b6 seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> >>> dataset = synth . RandomRBF ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.9518 , 1 : 0.5263 , 2 : 0.2509 , 3 : 0.4177 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : - 0.2640 , 1 : 0.2275 , 2 : 0.6286 , 3 : - 0.0532 } 2 { 0 : 0.9050 , 1 : 0.6443 , 2 : 0.1270 , 3 : 0.4520 } 2 { 0 : 0.1874 , 1 : 0.4348 , 2 : 0.9819 , 3 : - 0.0459 } 2 Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"RandomRBF"},{"location":"api/synth/RandomRBF/#randomrbf","text":"Random Radial Basis Function generator. Produces a radial basis function stream. A number of centroids, having a random central position, a standard deviation, a class label and weight are generated. A new sample is created by choosing one of the centroids at random, taking into account their weights, and offsetting the attributes in a random direction from the centroid's center. The offset length is drawn from a Gaussian distribution. This process will create a normally distributed hypersphere of samples on the surrounds of each centroid.","title":"RandomRBF"},{"location":"api/synth/RandomRBF/#parameters","text":"seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate.","title":"Parameters"},{"location":"api/synth/RandomRBF/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/RandomRBF/#examples","text":">>> from river import synth >>> >>> dataset = synth . RandomRBF ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.9518 , 1 : 0.5263 , 2 : 0.2509 , 3 : 0.4177 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : - 0.2640 , 1 : 0.2275 , 2 : 0.6286 , 3 : - 0.0532 } 2 { 0 : 0.9050 , 1 : 0.6443 , 2 : 0.1270 , 3 : 0.4520 } 2 { 0 : 0.1874 , 1 : 0.4348 , 2 : 0.9819 , 3 : - 0.0459 } 2","title":"Examples"},{"location":"api/synth/RandomRBF/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/RandomRBFDrift/","text":"RandomRBFDrift \u00b6 Random Radial Basis Function generator with concept drift. This class is an extension from the RandomRBF generator. Concept drift can be introduced in instances of this class. The drift is created by adding a \"speed\" to certain centroids. As the samples are generated each of the moving centroids' centers is changed by an amount determined by its speed. Parameters \u00b6 seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate. change_speed ( float ) \u2013 defaults to 0.0 The concept drift speed. n_drift_centroids ( int ) \u2013 defaults to 50 The number of centroids that will drift. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> >>> dataset = synth . RandomRBFDrift ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 , ... change_speed = 0.87 , n_drift_centroids = 10 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 1.1965 , 1 : 0.5729 , 2 : 0.8607 , 3 : 0.5888 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : 0.5362 , 1 : - 0.2867 , 2 : 0.0962 , 3 : 0.8974 } 2 { 0 : 1.1875 , 1 : 1.0385 , 2 : 0.8323 , 3 : - 0.0553 } 2 { 0 : 0.3256 , 1 : 0.9206 , 2 : 0.8595 , 3 : 0.5907 } 2 Methods \u00b6 take Iterate over the k samples. Parameters k ( int )","title":"RandomRBFDrift"},{"location":"api/synth/RandomRBFDrift/#randomrbfdrift","text":"Random Radial Basis Function generator with concept drift. This class is an extension from the RandomRBF generator. Concept drift can be introduced in instances of this class. The drift is created by adding a \"speed\" to certain centroids. As the samples are generated each of the moving centroids' centers is changed by an amount determined by its speed.","title":"RandomRBFDrift"},{"location":"api/synth/RandomRBFDrift/#parameters","text":"seed_model ( int ) \u2013 defaults to None Model's seed to generate centroids If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . seed_sample ( int ) \u2013 defaults to None Sample's seed If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . n_classes ( int ) \u2013 defaults to 2 The number of class labels to generate. n_features ( int ) \u2013 defaults to 10 The number of numerical features to generate. n_centroids ( int ) \u2013 defaults to 50 The number of centroids to generate. change_speed ( float ) \u2013 defaults to 0.0 The concept drift speed. n_drift_centroids ( int ) \u2013 defaults to 50 The number of centroids that will drift.","title":"Parameters"},{"location":"api/synth/RandomRBFDrift/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/RandomRBFDrift/#examples","text":">>> from river import synth >>> >>> dataset = synth . RandomRBFDrift ( seed_model = 42 , seed_sample = 42 , ... n_classes = 4 , n_features = 4 , n_centroids = 20 , ... change_speed = 0.87 , n_drift_centroids = 10 ) >>> >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 1.1965 , 1 : 0.5729 , 2 : 0.8607 , 3 : 0.5888 } 0 { 0 : 0.3383 , 1 : 0.8072 , 2 : 0.8051 , 3 : 0.4140 } 3 { 0 : 0.5362 , 1 : - 0.2867 , 2 : 0.0962 , 3 : 0.8974 } 2 { 0 : 1.1875 , 1 : 1.0385 , 2 : 0.8323 , 3 : - 0.0553 } 2 { 0 : 0.3256 , 1 : 0.9206 , 2 : 0.8595 , 3 : 0.5907 } 2","title":"Examples"},{"location":"api/synth/RandomRBFDrift/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/RandomTree/","text":"RandomTree \u00b6 Random Tree generator. This generator is based on 1 . The generator creates a random tree by splitting features at random and setting labels at its leaves. The tree structure is composed of node objects, which can be either inner nodes or leaf nodes. The choice comes as a function of the parameters passed to its initializer. Since the concepts are generated and classified according to a tree structure, in theory, it should favor decision tree learners. Parameters \u00b6 seed_tree ( int ) \u2013 defaults to None Seed for random generation of tree. seed_sample ( int ) \u2013 defaults to None Seed for random generation of instances. n_classes ( int ) \u2013 defaults to 2 The number of classes to generate. n_num_features ( int ) \u2013 defaults to 5 The number of numerical features to generate. n_cat_features ( int ) \u2013 defaults to 5 The number of categorical features to generate. n_categories_per_feature ( int ) \u2013 defaults to 5 The number of values to generate per categorical feature. max_tree_depth ( int ) \u2013 defaults to 5 The maximum depth of the tree concept. first_leaf_level ( int ) \u2013 defaults to 3 The first level of the tree above max_tree_depth that can have leaves. fraction_leaves_per_level ( float ) \u2013 defaults to 0.15 The fraction of leaves per level from first_leaf_level onwards. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . RandomTree ( seed_tree = 42 , seed_sample = 42 , n_classes = 2 , ... n_num_features = 2 , n_cat_features = 2 , ... n_categories_per_feature = 2 , max_tree_depth = 6 , ... first_leaf_level = 3 , fraction_leaves_per_level = 0.15 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'x_num_0' : 0.3745 , 'x_num_1' : 0.9507 , 'x_cat_0' : 0 , 'x_cat_1' : 1 } 1 { 'x_num_0' : 0.5986 , 'x_num_1' : 0.1560 , 'x_cat_0' : 0 , 'x_cat_1' : 0 } 1 { 'x_num_0' : 0.0580 , 'x_num_1' : 0.8661 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.7080 , 'x_num_1' : 0.0205 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.8324 , 'x_num_1' : 0.2123 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 Domingos, Pedro, and Geoff Hulten. \"Mining high-speed data streams.\" In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining, pp. 71-80. 2000. \u21a9","title":"RandomTree"},{"location":"api/synth/RandomTree/#randomtree","text":"Random Tree generator. This generator is based on 1 . The generator creates a random tree by splitting features at random and setting labels at its leaves. The tree structure is composed of node objects, which can be either inner nodes or leaf nodes. The choice comes as a function of the parameters passed to its initializer. Since the concepts are generated and classified according to a tree structure, in theory, it should favor decision tree learners.","title":"RandomTree"},{"location":"api/synth/RandomTree/#parameters","text":"seed_tree ( int ) \u2013 defaults to None Seed for random generation of tree. seed_sample ( int ) \u2013 defaults to None Seed for random generation of instances. n_classes ( int ) \u2013 defaults to 2 The number of classes to generate. n_num_features ( int ) \u2013 defaults to 5 The number of numerical features to generate. n_cat_features ( int ) \u2013 defaults to 5 The number of categorical features to generate. n_categories_per_feature ( int ) \u2013 defaults to 5 The number of values to generate per categorical feature. max_tree_depth ( int ) \u2013 defaults to 5 The maximum depth of the tree concept. first_leaf_level ( int ) \u2013 defaults to 3 The first level of the tree above max_tree_depth that can have leaves. fraction_leaves_per_level ( float ) \u2013 defaults to 0.15 The fraction of leaves per level from first_leaf_level onwards.","title":"Parameters"},{"location":"api/synth/RandomTree/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/RandomTree/#examples","text":">>> from river import synth >>> dataset = synth . RandomTree ( seed_tree = 42 , seed_sample = 42 , n_classes = 2 , ... n_num_features = 2 , n_cat_features = 2 , ... n_categories_per_feature = 2 , max_tree_depth = 6 , ... first_leaf_level = 3 , fraction_leaves_per_level = 0.15 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'x_num_0' : 0.3745 , 'x_num_1' : 0.9507 , 'x_cat_0' : 0 , 'x_cat_1' : 1 } 1 { 'x_num_0' : 0.5986 , 'x_num_1' : 0.1560 , 'x_cat_0' : 0 , 'x_cat_1' : 0 } 1 { 'x_num_0' : 0.0580 , 'x_num_1' : 0.8661 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.7080 , 'x_num_1' : 0.0205 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0 { 'x_num_0' : 0.8324 , 'x_num_1' : 0.2123 , 'x_cat_0' : 1 , 'x_cat_1' : 1 } 0","title":"Examples"},{"location":"api/synth/RandomTree/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/RandomTree/#references","text":"Domingos, Pedro, and Geoff Hulten. \"Mining high-speed data streams.\" In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining, pp. 71-80. 2000. \u21a9","title":"References"},{"location":"api/synth/SEA/","text":"SEA \u00b6 SEA synthetic dataset. Implementation of the data stream with abrupt drift described in 1 . Each observation is composed of 3 features. Only the first two features are relevant. The target is binary, and is positive if the sum of the features exceeds a certain threshold. There are 4 thresholds to choose from. Concept drift can be introduced by switching the threshold anytime during the stream. Variant 0 : True if \\(att1 + att2 > 8\\) Variant 1 : True if \\(att1 + att2 > 9\\) Variant 2 : True if \\(att1 + att2 > 7\\) Variant 3 : True if \\(att1 + att2 > 9.5\\) Parameters \u00b6 variant \u2013 defaults to 0 Determines the classification function to use. Possible choices are 0, 1, 2, 3. noise \u2013 defaults to 0.0 Determines the amount of observations for which the target sign will be flipped. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . SEA ( variant = 0 , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 6.39426 , 1 : 0.25010 , 2 : 2.75029 } False { 0 : 2.23210 , 1 : 7.36471 , 2 : 6.76699 } True { 0 : 8.92179 , 1 : 0.86938 , 2 : 4.21921 } True { 0 : 0.29797 , 1 : 2.18637 , 2 : 5.05355 } False { 0 : 0.26535 , 1 : 1.98837 , 2 : 6.49884 } False Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) References \u00b6 A Streaming Ensemble Algorithm (SEA) for Large-Scale Classification \u21a9","title":"SEA"},{"location":"api/synth/SEA/#sea","text":"SEA synthetic dataset. Implementation of the data stream with abrupt drift described in 1 . Each observation is composed of 3 features. Only the first two features are relevant. The target is binary, and is positive if the sum of the features exceeds a certain threshold. There are 4 thresholds to choose from. Concept drift can be introduced by switching the threshold anytime during the stream. Variant 0 : True if \\(att1 + att2 > 8\\) Variant 1 : True if \\(att1 + att2 > 9\\) Variant 2 : True if \\(att1 + att2 > 7\\) Variant 3 : True if \\(att1 + att2 > 9.5\\)","title":"SEA"},{"location":"api/synth/SEA/#parameters","text":"variant \u2013 defaults to 0 Determines the classification function to use. Possible choices are 0, 1, 2, 3. noise \u2013 defaults to 0.0 Determines the amount of observations for which the target sign will be flipped. seed ( int ) \u2013 defaults to None Random seed number used for reproducibility.","title":"Parameters"},{"location":"api/synth/SEA/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/SEA/#examples","text":">>> from river import synth >>> dataset = synth . SEA ( variant = 0 , seed = 42 ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 6.39426 , 1 : 0.25010 , 2 : 2.75029 } False { 0 : 2.23210 , 1 : 7.36471 , 2 : 6.76699 } True { 0 : 8.92179 , 1 : 0.86938 , 2 : 4.21921 } True { 0 : 0.29797 , 1 : 2.18637 , 2 : 5.05355 } False { 0 : 0.26535 , 1 : 1.98837 , 2 : 6.49884 } False","title":"Examples"},{"location":"api/synth/SEA/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/SEA/#references","text":"A Streaming Ensemble Algorithm (SEA) for Large-Scale Classification \u21a9","title":"References"},{"location":"api/synth/STAGGER/","text":"STAGGER \u00b6 STAGGER concepts stream generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in 1 . The STAGGER concepts are boolean functions f with three features describing objects: size (small, medium and large), shape (circle, square and triangle) and colour (red, blue and green). f options: True if the size is small and the color is red. True if the color is green or the shape is a circle. True if the size is medium or large Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . One important feature is the possibility to balance classes, which means the class distribution will tend to a uniform one. Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 2. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . STAGGER ( classification_function = 2 , seed = 112 , ... balance_classes = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'size' : 0 , 'color' : 0 , 'shape' : 2 } 0 { 'size' : 1 , 'color' : 0 , 'shape' : 1 } 1 { 'size' : 0 , 'color' : 0 , 'shape' : 0 } 0 { 'size' : 1 , 'color' : 2 , 'shape' : 0 } 1 { 'size' : 1 , 'color' : 0 , 'shape' : 2 } 1 Methods \u00b6 generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The 3 attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced, if this option is set by the user. References \u00b6 Schlimmer, J. C., & Granger, R. H. (1986). Incremental learning from noisy data. Machine learning, 1(3), 317-354. \u21a9","title":"STAGGER"},{"location":"api/synth/STAGGER/#stagger","text":"STAGGER concepts stream generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in 1 . The STAGGER concepts are boolean functions f with three features describing objects: size (small, medium and large), shape (circle, square and triangle) and colour (red, blue and green). f options: True if the size is small and the color is red. True if the color is green or the shape is a circle. True if the size is medium or large Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . One important feature is the possibility to balance classes, which means the class distribution will tend to a uniform one.","title":"STAGGER"},{"location":"api/synth/STAGGER/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 2. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution.","title":"Parameters"},{"location":"api/synth/STAGGER/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/STAGGER/#examples","text":">>> from river import synth >>> dataset = synth . STAGGER ( classification_function = 2 , seed = 112 , ... balance_classes = False ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 'size' : 0 , 'color' : 0 , 'shape' : 2 } 0 { 'size' : 1 , 'color' : 0 , 'shape' : 1 } 1 { 'size' : 0 , 'color' : 0 , 'shape' : 0 } 0 { 'size' : 1 , 'color' : 2 , 'shape' : 0 } 1 { 'size' : 1 , 'color' : 0 , 'shape' : 2 } 1","title":"Examples"},{"location":"api/synth/STAGGER/#methods","text":"generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/STAGGER/#notes","text":"The sample generation works as follows: The 3 attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced, if this option is set by the user.","title":"Notes"},{"location":"api/synth/STAGGER/#references","text":"Schlimmer, J. C., & Granger, R. H. (1986). Incremental learning from noisy data. Machine learning, 1(3), 317-354. \u21a9","title":"References"},{"location":"api/synth/Sine/","text":"Sine \u00b6 Sine generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in Gama, Joao, et al. 1 . It generates up to 4 relevant numerical features, that vary from 0 to 1, where only 2 of them are relevant to the classification task and the other 2 are optionally added by as noise. A classification function is chosen among four options: SINE1 . Abrupt concept drift, noise-free examples. It has two relevant attributes. Each attributes has values uniformly distributed in [0, 1]. In the first context all points below the curve \\(y = sin(x)\\) are classified as positive. Reversed SINE1 . The reversed classification of SINE1 . SINE2 . The same two relevant attributes. The classification function is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) . Reversed SINE2 . The reversed classification of SINE2 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . Two important features are the possibility to balance classes, which means the class distribution will tend to a uniform one, and the possibility to add noise, which will, add two non relevant attributes. Parameters \u00b6 classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 3. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution. has_noise ( bool ) \u2013 defaults to False Adds 2 non relevant features to the stream. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Sine ( classification_function = 2 , seed = 112 , ... balance_classes = False , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.3750 , 1 : 0.6403 , 2 : 0.9500 , 3 : 0.0756 } 1 { 0 : 0.7769 , 1 : 0.8327 , 2 : 0.0548 , 3 : 0.8176 } 1 { 0 : 0.8853 , 1 : 0.7223 , 2 : 0.0025 , 3 : 0.9811 } 0 { 0 : 0.3434 , 1 : 0.0947 , 2 : 0.3946 , 3 : 0.0049 } 1 { 0 : 0.7367 , 1 : 0.9558 , 2 : 0.8206 , 3 : 0.3449 } 0 Methods \u00b6 generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 The sample generation works as follows: The two attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced and noise is added, if these options are set by the user. The generated sample will have 2 relevant features, and an additional two noise features if has_noise is set. References \u00b6 Gama, Joao, et al.'s 'Learning with drift detection.' Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295.\" \u21a9","title":"Sine"},{"location":"api/synth/Sine/#sine","text":"Sine generator. This generator is an implementation of the dara stream with abrupt concept drift, as described in Gama, Joao, et al. 1 . It generates up to 4 relevant numerical features, that vary from 0 to 1, where only 2 of them are relevant to the classification task and the other 2 are optionally added by as noise. A classification function is chosen among four options: SINE1 . Abrupt concept drift, noise-free examples. It has two relevant attributes. Each attributes has values uniformly distributed in [0, 1]. In the first context all points below the curve \\(y = sin(x)\\) are classified as positive. Reversed SINE1 . The reversed classification of SINE1 . SINE2 . The same two relevant attributes. The classification function is \\(y < 0.5 + 0.3 sin(3 \\pi x)\\) . Reversed SINE2 . The reversed classification of SINE2 . Concept drift can be introduced by changing the classification function. This can be done manually or using ConceptDriftStream . Two important features are the possibility to balance classes, which means the class distribution will tend to a uniform one, and the possibility to add noise, which will, add two non relevant attributes.","title":"Sine"},{"location":"api/synth/Sine/#parameters","text":"classification_function ( int ) \u2013 defaults to 0 Classification functions to use. From 0 to 3. seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . balance_classes ( bool ) \u2013 defaults to False Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution. has_noise ( bool ) \u2013 defaults to False Adds 2 non relevant features to the stream.","title":"Parameters"},{"location":"api/synth/Sine/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Sine/#examples","text":">>> from river import synth >>> dataset = synth . Sine ( classification_function = 2 , seed = 112 , ... balance_classes = False , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( x , y ) { 0 : 0.3750 , 1 : 0.6403 , 2 : 0.9500 , 3 : 0.0756 } 1 { 0 : 0.7769 , 1 : 0.8327 , 2 : 0.0548 , 3 : 0.8176 } 1 { 0 : 0.8853 , 1 : 0.7223 , 2 : 0.0025 , 3 : 0.9811 } 0 { 0 : 0.3434 , 1 : 0.0947 , 2 : 0.3946 , 3 : 0.0049 } 1 { 0 : 0.7367 , 1 : 0.9558 , 2 : 0.8206 , 3 : 0.3449 } 0","title":"Examples"},{"location":"api/synth/Sine/#methods","text":"generate_drift Generate drift by switching the classification function at random. take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Sine/#notes","text":"The sample generation works as follows: The two attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced and noise is added, if these options are set by the user. The generated sample will have 2 relevant features, and an additional two noise features if has_noise is set.","title":"Notes"},{"location":"api/synth/Sine/#references","text":"Gama, Joao, et al.'s 'Learning with drift detection.' Advances in artificial intelligence\u2013SBIA 2004. Springer Berlin Heidelberg, 2004. 286-295.\" \u21a9","title":"References"},{"location":"api/synth/Waveform/","text":"Waveform \u00b6 Waveform stream generator. Generates samples with 21 numeric features and 3 classes, based on a random differentiation of some base waveforms. Supports noise addition, in this case the samples will have 40 features. Parameters \u00b6 seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . has_noise ( bool ) \u2013 defaults to False Adds 19 unrelated features to the stream. Attributes \u00b6 desc Return the description from the docstring. Examples \u00b6 >>> from river import synth >>> dataset = synth . Waveform ( seed = 42 , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.5437 , - 0.6154 , - 1.1978 , 2.1417 , - 0.0946 , - 0.7254 , - 0.4783 , 0.1982 , 0.3312 , 1.9780 , 3.0469 , 3.5249 , 5.4624 , 6.1318 , 2.7471 , 4.7896 , 2.9351 , 2.2258 , 0.1168 , 2.2835 , - 0.0245 , 0.3556 , 0.4170 , 0.8325 , - 0.2934 , - 0.0298 , 0.0951 , 0.6647 , - 0.1402 , - 0.0332 , - 0.7491 , - 0.7784 , 0.9488 , 1.5809 , - 0.3682 , 0.3756 , - 1.1932 , - 0.4091 , - 0.4467 , 1.5242 ] 2 [ 0.2186 , 1.4285 , 0.0843 , 0.0568 , 2.9605 , 2.6487 , 2.8402 , 3.2128 , 2.8694 , 4.0410 , 4.3953 , 3.7009 , 2.7075 , 2.1149 , 0.6994 , - 0.1702 , - 1.5082 , 1.0996 , - 0.1777 , - 0.4104 , 1.1797 , - 0.8982 , 0.8348 , 0.2966 , - 1.0378 , - 0.0758 , 0.9730 , 0.7956 , 1.4954 , 0.3382 , 3.3723 , - 0.9204 , - 0.3986 , - 0.0609 , - 1.4188 , 1.0425 , 0.9035 , 0.0190 , - 0.5344 , - 1.4951 ] 1 [ 0.1358 , 0.6081 , 0.7050 , 0.3609 , - 1.4670 , 1.6896 , 1.4886 , 1.4355 , 2.7730 , 2.7890 , 4.8437 , 5.3447 , 3.6724 , 2.5445 , 2.5541 , 2.2732 , - 0.5371 , - 0.4099 , 0.5331 , - 1.0464 , 1.9451 , - 0.1533 , - 0.9070 , - 0.8174 , - 0.4831 , - 0.5698 , - 2.0916 , 1.2637 , - 0.0155 , - 0.0274 , 0.8179 , - 1.0546 , - 0.7583 , 0.4574 , - 0.0644 , 0.3449 , - 0.0801 , - 0.2414 , 1.4335 , 1.0658 ] 2 [ 1.1428 , 1.2414 , 1.7699 , 0.5590 , 3.3606 , 1.0454 , 3.5236 , 4.6377 , 0.9673 , 1.4126 , 2.0997 , 1.5176 , 0.4915 , 2.6213 , 2.0010 , 3.0263 , 1.1228 , 3.0816 , 0.2378 , 0.1885 , 0.8135 , - 1.2309 , 0.2275 , 1.3071 , - 1.6075 , 0.1846 , 0.2599 , 0.7818 , - 1.2370 , - 1.3205 , 0.5219 , 0.2970 , 0.2505 , 0.3464 , - 0.6800 , 0.2323 , 0.2931 , - 0.7144 , 1.8658 , 0.4738 ] 0 [ - 0.9747 , 1.0114 , 1.6071 , - 0.1479 , 1.8605 , 1.5341 , 2.1677 , 3.0181 , 0.6517 , 0.6948 , 1.1105 , 1.7357 , 3.0258 , 4.2198 , 4.9311 , 4.7058 , 3.1159 , 3.7807 , 1.2868 , 3.4959 , 0.6257 , - 0.8572 , - 1.0709 , 0.4825 , - 0.2235 , 0.7140 , 0.4732 , - 0.0728 , - 0.8468 , - 1.5148 , - 0.4465 , 0.8564 , 0.2141 , - 1.2457 , 0.1732 , 0.3853 , - 0.8839 , 0.1537 , 0.0582 , - 1.1430 ] 0 Methods \u00b6 take Iterate over the k samples. Parameters k ( int ) Notes \u00b6 An instance is generated based on the parameters passed. The generator will randomly choose one of the hard coded waveforms, as well as random multipliers. For each feature, the actual value generated will be a a combination of the hard coded functions, with the multipliers and a random value. If noise is added then the features 21 to 40 will be replaced with a random normal value.","title":"Waveform"},{"location":"api/synth/Waveform/#waveform","text":"Waveform stream generator. Generates samples with 21 numeric features and 3 classes, based on a random differentiation of some base waveforms. Supports noise addition, in this case the samples will have 40 features.","title":"Waveform"},{"location":"api/synth/Waveform/#parameters","text":"seed ( int ) \u2013 defaults to None If int, seed is used to seed the random number generator; If RandomState instance, seed is the random number generator; If None, the random number generator is the RandomState instance used by np.random . has_noise ( bool ) \u2013 defaults to False Adds 19 unrelated features to the stream.","title":"Parameters"},{"location":"api/synth/Waveform/#attributes","text":"desc Return the description from the docstring.","title":"Attributes"},{"location":"api/synth/Waveform/#examples","text":">>> from river import synth >>> dataset = synth . Waveform ( seed = 42 , has_noise = True ) >>> for x , y in dataset . take ( 5 ): ... print ( list ( x . values ()), y ) [ 0.5437 , - 0.6154 , - 1.1978 , 2.1417 , - 0.0946 , - 0.7254 , - 0.4783 , 0.1982 , 0.3312 , 1.9780 , 3.0469 , 3.5249 , 5.4624 , 6.1318 , 2.7471 , 4.7896 , 2.9351 , 2.2258 , 0.1168 , 2.2835 , - 0.0245 , 0.3556 , 0.4170 , 0.8325 , - 0.2934 , - 0.0298 , 0.0951 , 0.6647 , - 0.1402 , - 0.0332 , - 0.7491 , - 0.7784 , 0.9488 , 1.5809 , - 0.3682 , 0.3756 , - 1.1932 , - 0.4091 , - 0.4467 , 1.5242 ] 2 [ 0.2186 , 1.4285 , 0.0843 , 0.0568 , 2.9605 , 2.6487 , 2.8402 , 3.2128 , 2.8694 , 4.0410 , 4.3953 , 3.7009 , 2.7075 , 2.1149 , 0.6994 , - 0.1702 , - 1.5082 , 1.0996 , - 0.1777 , - 0.4104 , 1.1797 , - 0.8982 , 0.8348 , 0.2966 , - 1.0378 , - 0.0758 , 0.9730 , 0.7956 , 1.4954 , 0.3382 , 3.3723 , - 0.9204 , - 0.3986 , - 0.0609 , - 1.4188 , 1.0425 , 0.9035 , 0.0190 , - 0.5344 , - 1.4951 ] 1 [ 0.1358 , 0.6081 , 0.7050 , 0.3609 , - 1.4670 , 1.6896 , 1.4886 , 1.4355 , 2.7730 , 2.7890 , 4.8437 , 5.3447 , 3.6724 , 2.5445 , 2.5541 , 2.2732 , - 0.5371 , - 0.4099 , 0.5331 , - 1.0464 , 1.9451 , - 0.1533 , - 0.9070 , - 0.8174 , - 0.4831 , - 0.5698 , - 2.0916 , 1.2637 , - 0.0155 , - 0.0274 , 0.8179 , - 1.0546 , - 0.7583 , 0.4574 , - 0.0644 , 0.3449 , - 0.0801 , - 0.2414 , 1.4335 , 1.0658 ] 2 [ 1.1428 , 1.2414 , 1.7699 , 0.5590 , 3.3606 , 1.0454 , 3.5236 , 4.6377 , 0.9673 , 1.4126 , 2.0997 , 1.5176 , 0.4915 , 2.6213 , 2.0010 , 3.0263 , 1.1228 , 3.0816 , 0.2378 , 0.1885 , 0.8135 , - 1.2309 , 0.2275 , 1.3071 , - 1.6075 , 0.1846 , 0.2599 , 0.7818 , - 1.2370 , - 1.3205 , 0.5219 , 0.2970 , 0.2505 , 0.3464 , - 0.6800 , 0.2323 , 0.2931 , - 0.7144 , 1.8658 , 0.4738 ] 0 [ - 0.9747 , 1.0114 , 1.6071 , - 0.1479 , 1.8605 , 1.5341 , 2.1677 , 3.0181 , 0.6517 , 0.6948 , 1.1105 , 1.7357 , 3.0258 , 4.2198 , 4.9311 , 4.7058 , 3.1159 , 3.7807 , 1.2868 , 3.4959 , 0.6257 , - 0.8572 , - 1.0709 , 0.4825 , - 0.2235 , 0.7140 , 0.4732 , - 0.0728 , - 0.8468 , - 1.5148 , - 0.4465 , 0.8564 , 0.2141 , - 1.2457 , 0.1732 , 0.3853 , - 0.8839 , 0.1537 , 0.0582 , - 1.1430 ] 0","title":"Examples"},{"location":"api/synth/Waveform/#methods","text":"take Iterate over the k samples. Parameters k ( int )","title":"Methods"},{"location":"api/synth/Waveform/#notes","text":"An instance is generated based on the parameters passed. The generator will randomly choose one of the hard coded waveforms, as well as random multipliers. For each feature, the actual value generated will be a a combination of the hard coded functions, with the multipliers and a random value. If noise is added then the features 21 to 40 will be replaced with a random normal value.","title":"Notes"},{"location":"api/time-series/ForecastingMetric/","text":"ForecastingMetric \u00b6 Base class that is inherited by the majority of classes in River. This base class allows us to handle the following tasks in a uniform manner: Getting and setting parameters. - Displaying information. - Cloning. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current performance along the horizon. Returns typing.List[float] : The current performance. update Update the metric at each step along the horizon. Parameters y_true ( List[numbers.Number] ) y_pred ( List[numbers.Number] ) Returns ForecastingMetric : self","title":"ForecastingMetric"},{"location":"api/time-series/ForecastingMetric/#forecastingmetric","text":"Base class that is inherited by the majority of classes in River. This base class allows us to handle the following tasks in a uniform manner: Getting and setting parameters. - Displaying information. - Cloning.","title":"ForecastingMetric"},{"location":"api/time-series/ForecastingMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current performance along the horizon. Returns typing.List[float] : The current performance. update Update the metric at each step along the horizon. Parameters y_true ( List[numbers.Number] ) y_pred ( List[numbers.Number] ) Returns ForecastingMetric : self","title":"Methods"},{"location":"api/time-series/HoltWinters/","text":"HoltWinters \u00b6 Holt-Winters forecaster. This is a standard implementation of the Holt-Winters forecasting method. Certain parametrisations result in special cases, such as simple exponential smoothing. Optimal parameters and initialisation values can be determined in a batch setting. However, in an online setting, it is necessary to wait and observe enough values. The first k = max(2, seasonality) values are indeed used to initialize the components. Level initialization \\[l = \\frac{1}{k} \\sum_{i=1}{k} y_i\\] Trend initialization \\[t = \\frac{1}{k - 1} \\sum_{i=2}{k} y_i - y_{i-1}\\] Trend initialization \\[s_i = \\frac{y_i}{k}\\] Parameters \u00b6 alpha Smoothing parameter for the level. beta \u2013 defaults to None Smoothing parameter for the trend. gamma \u2013 defaults to None Smoothing parameter for the seasonality. seasonality \u2013 defaults to 0 The number of periods in a season. For instance, this should be 4 for quarterly data, and 12 for yearly data. multiplicative \u2013 defaults to False Whether or not to use a multiplicative formulation. Examples \u00b6 >>> from river import datasets >>> from river import metrics >>> from river import time_series >>> dataset = datasets . AirlinePassengers () >>> model = time_series . HoltWinters ( ... alpha = 0.3 , ... beta = 0.1 , ... gamma = 0.6 , ... seasonality = 12 , ... multiplicative = True ... ) >>> metric = metrics . MAE () >>> time_series . evaluate ( ... dataset , ... model , ... metric , ... horizon = 12 ... ) + 1 MAE : 25.899087 + 2 MAE : 26.26131 + 3 MAE : 25.735903 + 4 MAE : 25.625678 + 5 MAE : 26.093842 + 6 MAE : 26.90249 + 7 MAE : 28.634398 + 8 MAE : 29.284769 + 9 MAE : 31.018351 + 10 MAE : 32.252349 + 11 MAE : 33.518946 + 12 MAE : 33.975057 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None References \u00b6 Exponential smoothing \u2014 Wikipedia \u21a9 Exponential smoothing \u2014 Forecasting: Principles and Practice \u21a9 What is Exponential Smoothing? \u2014 Engineering statistics handbook \u21a9","title":"HoltWinters"},{"location":"api/time-series/HoltWinters/#holtwinters","text":"Holt-Winters forecaster. This is a standard implementation of the Holt-Winters forecasting method. Certain parametrisations result in special cases, such as simple exponential smoothing. Optimal parameters and initialisation values can be determined in a batch setting. However, in an online setting, it is necessary to wait and observe enough values. The first k = max(2, seasonality) values are indeed used to initialize the components. Level initialization \\[l = \\frac{1}{k} \\sum_{i=1}{k} y_i\\] Trend initialization \\[t = \\frac{1}{k - 1} \\sum_{i=2}{k} y_i - y_{i-1}\\] Trend initialization \\[s_i = \\frac{y_i}{k}\\]","title":"HoltWinters"},{"location":"api/time-series/HoltWinters/#parameters","text":"alpha Smoothing parameter for the level. beta \u2013 defaults to None Smoothing parameter for the trend. gamma \u2013 defaults to None Smoothing parameter for the seasonality. seasonality \u2013 defaults to 0 The number of periods in a season. For instance, this should be 4 for quarterly data, and 12 for yearly data. multiplicative \u2013 defaults to False Whether or not to use a multiplicative formulation.","title":"Parameters"},{"location":"api/time-series/HoltWinters/#examples","text":">>> from river import datasets >>> from river import metrics >>> from river import time_series >>> dataset = datasets . AirlinePassengers () >>> model = time_series . HoltWinters ( ... alpha = 0.3 , ... beta = 0.1 , ... gamma = 0.6 , ... seasonality = 12 , ... multiplicative = True ... ) >>> metric = metrics . MAE () >>> time_series . evaluate ( ... dataset , ... model , ... metric , ... horizon = 12 ... ) + 1 MAE : 25.899087 + 2 MAE : 26.26131 + 3 MAE : 25.735903 + 4 MAE : 25.625678 + 5 MAE : 26.093842 + 6 MAE : 26.90249 + 7 MAE : 28.634398 + 8 MAE : 29.284769 + 9 MAE : 31.018351 + 10 MAE : 32.252349 + 11 MAE : 33.518946 + 12 MAE : 33.975057","title":"Examples"},{"location":"api/time-series/HoltWinters/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/time-series/HoltWinters/#references","text":"Exponential smoothing \u2014 Wikipedia \u21a9 Exponential smoothing \u2014 Forecasting: Principles and Practice \u21a9 What is Exponential Smoothing? \u2014 Engineering statistics handbook \u21a9","title":"References"},{"location":"api/time-series/HorizonMetric/","text":"HorizonMetric \u00b6 Measures performance at each time step ahead. This allows to measure the performance of a model at each time step along the horizon. A copy of the provided regression metric is made for each time step. Parameters \u00b6 metric ( river.metrics.base.RegressionMetric ) A regression metric. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current performance along the horizon. Returns typing.List[float] : The current performance. update Update the metric at each step along the horizon. Parameters y_true ( List[numbers.Number] ) y_pred ( List[numbers.Number] ) Returns ForecastingMetric : self","title":"HorizonMetric"},{"location":"api/time-series/HorizonMetric/#horizonmetric","text":"Measures performance at each time step ahead. This allows to measure the performance of a model at each time step along the horizon. A copy of the provided regression metric is made for each time step.","title":"HorizonMetric"},{"location":"api/time-series/HorizonMetric/#parameters","text":"metric ( river.metrics.base.RegressionMetric ) A regression metric.","title":"Parameters"},{"location":"api/time-series/HorizonMetric/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. get Return the current performance along the horizon. Returns typing.List[float] : The current performance. update Update the metric at each step along the horizon. Parameters y_true ( List[numbers.Number] ) y_pred ( List[numbers.Number] ) Returns ForecastingMetric : self","title":"Methods"},{"location":"api/time-series/SNARIMAX/","text":"SNARIMAX \u00b6 SNARIMAX model. SNARIMAX stands for (S)easonal (N)on-linear (A)uto(R)egressive (I)ntegrated (M)oving-(A)verage with e(X)ogenous inputs model. This model generalizes many established time series models in a single interface that can be trained online. It assumes that the provided training data is ordered in time and is uniformly spaced. It is made up of the following components: S (Seasonal) - N (Non-linear): Any online regression model can be used, not necessarily a linear regression as is done in textbooks. - AR (Autoregressive): Lags of the target variable are used as features. - I (Integrated): The model can be fitted on a differenced version of a time series. In this context, integration is the reverse of differencing. - MA (Moving average): Lags of the errors are used as features. - X (Exogenous): Users can provide additional features. Care has to be taken to include features that will be available both at training and prediction time. Each of these components can be switched on and off by specifying the appropriate parameters. Classical time series models such as AR, MA, ARMA, and ARIMA can thus be seen as special parametrizations of the SNARIMAX model. This model is tailored for time series that are homoskedastic. In other words, it might not work well if the variance of the time series varies widely along time. Parameters \u00b6 p ( int ) Order of the autoregressive part. This is the number of past target values that will be included as features. d ( int ) Differencing order. q ( int ) Order of the moving average part. This is the number of past error terms that will be included as features. m ( int ) \u2013 defaults to 1 Season length used for extracting seasonal features. If you believe your data has a seasonal pattern, then set this accordingly. For instance, if the data seems to exhibit a yearly seasonality, and that your data is spaced by month, then you should set this to 12. Note that for this parameter to have any impact you should also set at least one of the p , d , and q parameters. sp ( int ) \u2013 defaults to 0 Seasonal order of the autoregressive part. This is the number of past target values that will be included as features. sd ( int ) \u2013 defaults to 0 Seasonal differencing order. sq ( int ) \u2013 defaults to 0 Seasonal order of the moving average part. This is the number of past error terms that will be included as features. regressor ( base.Regressor ) \u2013 defaults to None The online regression model to use. By default, a preprocessing.StandardScaler piped with a linear_model.LinearRegression will be used. Attributes \u00b6 differencer ( Differencer ) y_trues ( collections.deque ) The p past target values. errors ( collections.deque ) The q past error values. Examples \u00b6 >>> import calendar >>> import datetime as dt >>> import math >>> from river import compose >>> from river import datasets >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import time_series >>> def get_month_distances ( x ): ... return { ... calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) ... for month in range ( 1 , 13 ) ... } >>> def get_ordinal_date ( x ): ... return { 'ordinal_date' : x [ 'month' ] . toordinal ()} >>> extract_features = compose . TransformerUnion ( ... get_ordinal_date , ... get_month_distances ... ) >>> model = ( ... extract_features | ... time_series . SNARIMAX ( ... p = 0 , ... d = 0 , ... q = 0 , ... m = 12 , ... sp = 3 , ... sq = 6 , ... regressor = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... intercept_init = 110 , ... optimizer = optim . SGD ( 0.01 ), ... intercept_lr = 0.3 ... ) ... ) ... ) ... ) >>> metric = metrics . Rolling ( metrics . MAE (), 12 ) >>> for x , y in datasets . AirlinePassengers (): ... y_pred = model . forecast ( horizon = 1 , xs = [ x ]) ... model = model . learn_one ( x , y ) ... metric = metric . update ( y , y_pred [ 0 ]) >>> metric MAE : 11.636563 ( rolling 12 ) >>> horizon = 12 >>> future = [ ... { 'month' : dt . date ( year = 1961 , month = m , day = 1 )} ... for m in range ( 1 , horizon + 1 ) ... ] >>> forecast = model . forecast ( horizon = horizon , xs = future ) >>> for x , y_pred in zip ( future , forecast ): ... print ( x [ 'month' ], f ' { y_pred : .3f } ' ) 1961 - 01 - 01 442.554 1961 - 02 - 01 427.305 1961 - 03 - 01 471.861 1961 - 04 - 01 483.978 1961 - 05 - 01 489.995 1961 - 06 - 01 544.270 1961 - 07 - 01 632.882 1961 - 08 - 01 633.229 1961 - 09 - 01 531.349 1961 - 10 - 01 457.258 1961 - 11 - 01 405.978 1961 - 12 - 01 439.674 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None References \u00b6 ARMA - Wikipedia \u21a9 NARX - Wikipedia \u21a9 ARIMA - Forecasting: Principles and Practice \u21a9 Anava, O., Hazan, E., Mannor, S. and Shamir, O., 2013, June. Online learning for time series prediction. In Conference on learning theory (pp. 172-184) \u21a9","title":"SNARIMAX"},{"location":"api/time-series/SNARIMAX/#snarimax","text":"SNARIMAX model. SNARIMAX stands for (S)easonal (N)on-linear (A)uto(R)egressive (I)ntegrated (M)oving-(A)verage with e(X)ogenous inputs model. This model generalizes many established time series models in a single interface that can be trained online. It assumes that the provided training data is ordered in time and is uniformly spaced. It is made up of the following components: S (Seasonal) - N (Non-linear): Any online regression model can be used, not necessarily a linear regression as is done in textbooks. - AR (Autoregressive): Lags of the target variable are used as features. - I (Integrated): The model can be fitted on a differenced version of a time series. In this context, integration is the reverse of differencing. - MA (Moving average): Lags of the errors are used as features. - X (Exogenous): Users can provide additional features. Care has to be taken to include features that will be available both at training and prediction time. Each of these components can be switched on and off by specifying the appropriate parameters. Classical time series models such as AR, MA, ARMA, and ARIMA can thus be seen as special parametrizations of the SNARIMAX model. This model is tailored for time series that are homoskedastic. In other words, it might not work well if the variance of the time series varies widely along time.","title":"SNARIMAX"},{"location":"api/time-series/SNARIMAX/#parameters","text":"p ( int ) Order of the autoregressive part. This is the number of past target values that will be included as features. d ( int ) Differencing order. q ( int ) Order of the moving average part. This is the number of past error terms that will be included as features. m ( int ) \u2013 defaults to 1 Season length used for extracting seasonal features. If you believe your data has a seasonal pattern, then set this accordingly. For instance, if the data seems to exhibit a yearly seasonality, and that your data is spaced by month, then you should set this to 12. Note that for this parameter to have any impact you should also set at least one of the p , d , and q parameters. sp ( int ) \u2013 defaults to 0 Seasonal order of the autoregressive part. This is the number of past target values that will be included as features. sd ( int ) \u2013 defaults to 0 Seasonal differencing order. sq ( int ) \u2013 defaults to 0 Seasonal order of the moving average part. This is the number of past error terms that will be included as features. regressor ( base.Regressor ) \u2013 defaults to None The online regression model to use. By default, a preprocessing.StandardScaler piped with a linear_model.LinearRegression will be used.","title":"Parameters"},{"location":"api/time-series/SNARIMAX/#attributes","text":"differencer ( Differencer ) y_trues ( collections.deque ) The p past target values. errors ( collections.deque ) The q past error values.","title":"Attributes"},{"location":"api/time-series/SNARIMAX/#examples","text":">>> import calendar >>> import datetime as dt >>> import math >>> from river import compose >>> from river import datasets >>> from river import linear_model >>> from river import metrics >>> from river import optim >>> from river import preprocessing >>> from river import time_series >>> def get_month_distances ( x ): ... return { ... calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) ... for month in range ( 1 , 13 ) ... } >>> def get_ordinal_date ( x ): ... return { 'ordinal_date' : x [ 'month' ] . toordinal ()} >>> extract_features = compose . TransformerUnion ( ... get_ordinal_date , ... get_month_distances ... ) >>> model = ( ... extract_features | ... time_series . SNARIMAX ( ... p = 0 , ... d = 0 , ... q = 0 , ... m = 12 , ... sp = 3 , ... sq = 6 , ... regressor = ( ... preprocessing . StandardScaler () | ... linear_model . LinearRegression ( ... intercept_init = 110 , ... optimizer = optim . SGD ( 0.01 ), ... intercept_lr = 0.3 ... ) ... ) ... ) ... ) >>> metric = metrics . Rolling ( metrics . MAE (), 12 ) >>> for x , y in datasets . AirlinePassengers (): ... y_pred = model . forecast ( horizon = 1 , xs = [ x ]) ... model = model . learn_one ( x , y ) ... metric = metric . update ( y , y_pred [ 0 ]) >>> metric MAE : 11.636563 ( rolling 12 ) >>> horizon = 12 >>> future = [ ... { 'month' : dt . date ( year = 1961 , month = m , day = 1 )} ... for m in range ( 1 , horizon + 1 ) ... ] >>> forecast = model . forecast ( horizon = horizon , xs = future ) >>> for x , y_pred in zip ( future , forecast ): ... print ( x [ 'month' ], f ' { y_pred : .3f } ' ) 1961 - 01 - 01 442.554 1961 - 02 - 01 427.305 1961 - 03 - 01 471.861 1961 - 04 - 01 483.978 1961 - 05 - 01 489.995 1961 - 06 - 01 544.270 1961 - 07 - 01 632.882 1961 - 08 - 01 633.229 1961 - 09 - 01 531.349 1961 - 10 - 01 457.258 1961 - 11 - 01 405.978 1961 - 12 - 01 439.674","title":"Examples"},{"location":"api/time-series/SNARIMAX/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/time-series/SNARIMAX/#references","text":"ARMA - Wikipedia \u21a9 NARX - Wikipedia \u21a9 ARIMA - Forecasting: Principles and Practice \u21a9 Anava, O., Hazan, E., Mannor, S. and Shamir, O., 2013, June. Online learning for time series prediction. In Conference on learning theory (pp. 172-184) \u21a9","title":"References"},{"location":"api/time-series/evaluate/","text":"evaluate \u00b6 Evaluates the performance of a forecaster on a time series dataset. To understand why this method is useful, it's important to understand the difference between nowcasting and forecasting. Nowcasting is about predicting a value at the next time step. This can be seen as a special case of regression, where the value to predict is the value at the next time step. In this case, the evaluate.progressive_val_score function may be used to evaluate a model via progressive validation. Forecasting models can also be evaluated via progressive validation. This is the purpose of this function. At each time step t , the forecaster is asked to predict the values at t + 1 , t + 2 , ..., t + horizon . The performance at each time step is measured and returned. Parameters \u00b6 dataset ( Iterable[Tuple[dict, Any]] ) A sequential time series. model ( river.time_series.base.Forecaster ) A forecaster. metric ( river.metrics.base.RegressionMetric ) A regression metric. horizon ( int ) grace_period ( int ) \u2013 defaults to None Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.","title":"evaluate"},{"location":"api/time-series/evaluate/#evaluate","text":"Evaluates the performance of a forecaster on a time series dataset. To understand why this method is useful, it's important to understand the difference between nowcasting and forecasting. Nowcasting is about predicting a value at the next time step. This can be seen as a special case of regression, where the value to predict is the value at the next time step. In this case, the evaluate.progressive_val_score function may be used to evaluate a model via progressive validation. Forecasting models can also be evaluated via progressive validation. This is the purpose of this function. At each time step t , the forecaster is asked to predict the values at t + 1 , t + 2 , ..., t + horizon . The performance at each time step is measured and returned.","title":"evaluate"},{"location":"api/time-series/evaluate/#parameters","text":"dataset ( Iterable[Tuple[dict, Any]] ) A sequential time series. model ( river.time_series.base.Forecaster ) A forecaster. metric ( river.metrics.base.RegressionMetric ) A regression metric. horizon ( int ) grace_period ( int ) \u2013 defaults to None Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.","title":"Parameters"},{"location":"api/time-series/iter-evaluate/","text":"iter_evaluate \u00b6 Evaluates the performance of a forecaster on a time series dataset and yields results. This does exactly the same as evaluate.progressive_val_score . The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results. Parameters \u00b6 dataset ( Iterable[Tuple[dict, Any]] ) A sequential time series. model ( river.time_series.base.Forecaster ) A forecaster. metric ( river.metrics.base.RegressionMetric ) A regression metric. horizon ( int ) grace_period ( int ) \u2013 defaults to None Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.","title":"iter_evaluate"},{"location":"api/time-series/iter-evaluate/#iter_evaluate","text":"Evaluates the performance of a forecaster on a time series dataset and yields results. This does exactly the same as evaluate.progressive_val_score . The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results.","title":"iter_evaluate"},{"location":"api/time-series/iter-evaluate/#parameters","text":"dataset ( Iterable[Tuple[dict, Any]] ) A sequential time series. model ( river.time_series.base.Forecaster ) A forecaster. metric ( river.metrics.base.RegressionMetric ) A regression metric. horizon ( int ) grace_period ( int ) \u2013 defaults to None Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.","title":"Parameters"},{"location":"api/time-series/base/Forecaster/","text":"Forecaster \u00b6 An estimator. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None","title":"Forecaster"},{"location":"api/time-series/base/Forecaster/#forecaster","text":"An estimator.","title":"Forecaster"},{"location":"api/time-series/base/Forecaster/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. forecast Makes forecast at each step of the given horizon. Parameters horizon ( int ) xs ( list ) \u2013 defaults to None learn_one Updates the model. Parameters y ( float ) x ( dict ) \u2013 defaults to None","title":"Methods"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/","text":"ExtremelyFastDecisionTreeClassifier \u00b6 Extremely Fast Decision Tree classifier. Also referred to as Hoeffding AnyTime Tree (HATT) classifier. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. min_samples_reevaluate ( int ) \u2013 defaults to 20 Number of instances a node should observe before reevaluating the best split. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. Attributes \u00b6 height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer. Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . ExtremelyFastDecisionTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ], ... min_samples_reevaluate = 100 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 87.89 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df Notes \u00b6 The Extremely Fast Decision Tree (EFDT) 1 constructs a tree incrementally. The EFDT seeks to select and deploy a split as soon as it is confident the split is useful, and then revisits that decision, replacing the split if it subsequently becomes evident that a better split is available. The EFDT learns rapidly from a stationary distribution and eventually it learns the asymptotic batch tree if the distribution from which the data are drawn is stationary. References \u00b6 C. Manapragada, G. Webb, and M. Salehi. Extremely Fast Decision Tree. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD '18). ACM, New York, NY, USA, 1953-1962. DOI: https://doi.org/10.1145/3219819.3220005 \u21a9","title":"ExtremelyFastDecisionTreeClassifier"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#extremelyfastdecisiontreeclassifier","text":"Extremely Fast Decision Tree classifier. Also referred to as Hoeffding AnyTime Tree (HATT) classifier.","title":"ExtremelyFastDecisionTreeClassifier"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. min_samples_reevaluate ( int ) \u2013 defaults to 20 Number of instances a node should observe before reevaluating the best split. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning.","title":"Parameters"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#attributes","text":"height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer.","title":"Attributes"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . ExtremelyFastDecisionTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ], ... min_samples_reevaluate = 100 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 87.89 %","title":"Examples"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"Methods"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#notes","text":"The Extremely Fast Decision Tree (EFDT) 1 constructs a tree incrementally. The EFDT seeks to select and deploy a split as soon as it is confident the split is useful, and then revisits that decision, replacing the split if it subsequently becomes evident that a better split is available. The EFDT learns rapidly from a stationary distribution and eventually it learns the asymptotic batch tree if the distribution from which the data are drawn is stationary.","title":"Notes"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#references","text":"C. Manapragada, G. Webb, and M. Salehi. Extremely Fast Decision Tree. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD '18). ACM, New York, NY, USA, 1953-1962. DOI: https://doi.org/10.1145/3219819.3220005 \u21a9","title":"References"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/","text":"HoeffdingAdaptiveTreeClassifier \u00b6 Hoeffding Adaptive Tree classifier. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Attributes \u00b6 height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_alternate_trees n_branches n_inactive_leaves n_leaves n_nodes n_pruned_alternate_trees n_switch_alternate_trees split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer. Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 500 , width = 50 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingAdaptiveTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... leaf_prediction = 'nb' , ... nb_threshold = 10 , ... seed = 0 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 91.49 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df Notes \u00b6 The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance. References \u00b6 Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"HoeffdingAdaptiveTreeClassifier"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#hoeffdingadaptivetreeclassifier","text":"Hoeffding Adaptive Tree classifier.","title":"HoeffdingAdaptiveTreeClassifier"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#attributes","text":"height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_alternate_trees n_branches n_inactive_leaves n_leaves n_nodes n_pruned_alternate_trees n_switch_alternate_trees split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer.","title":"Attributes"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . ConceptDriftStream ( stream = synth . SEA ( seed = 42 , variant = 0 ), ... drift_stream = synth . SEA ( seed = 42 , variant = 1 ), ... seed = 1 , position = 500 , width = 50 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingAdaptiveTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... leaf_prediction = 'nb' , ... nb_threshold = 10 , ... seed = 0 ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 91.49 %","title":"Examples"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"Methods"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#notes","text":"The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance.","title":"Notes"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#references","text":"Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"References"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/","text":"HoeffdingAdaptiveTreeRegressor \u00b6 Hoeffding Adaptive Tree regressor (HATR). This class implements a regression version of the Hoeffding Adaptive Tree Classifier. Hence, it also uses an ADWIN concept-drift detector instance at each decision node to monitor possible changes in the data distribution. If a drift is detected in a node, an alternate tree begins to be induced in the background. When enough information is gathered, HATR swaps the node where the change was detected by its alternate tree. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility. Attributes \u00b6 height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_alternate_trees n_branches n_inactive_leaves n_leaves n_nodes n_pruned_alternate_trees n_switch_alternate_trees split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingAdaptiveTreeRegressor ( ... grace_period = 50 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.3 , ... seed = 0 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.795811 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df Notes \u00b6 The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance. To cope with ADWIN's requirements of bounded input data, HATR uses a novel error normalization strategy based on the empiral rule of Gaussian distributions. We assume the deviations of the predictions from the expected values follow a normal distribution. Hence, we subject these errors to a min-max normalization assuming that most of the data lies in the \\(\\left[-3\\sigma, 3\\sigma\\right]\\) range. These normalized errors are passed to the ADWIN instances. This is the same strategy used by Adaptive Random Forest Regressor. References \u00b6 Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"HoeffdingAdaptiveTreeRegressor"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#hoeffdingadaptivetreeregressor","text":"Hoeffding Adaptive Tree regressor (HATR). This class implements a regression version of the Hoeffding Adaptive Tree Classifier. Hence, it also uses an ADWIN concept-drift detector instance at each decision node to monitor possible changes in the data distribution. If a drift is detected in a node, an alternate tree begins to be induced in the background. When enough information is gathered, HATR swaps the node where the change was detected by its alternate tree.","title":"HoeffdingAdaptiveTreeRegressor"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. bootstrap_sampling ( bool ) \u2013 defaults to True If True, perform bootstrap sampling in the leaf nodes. drift_window_threshold ( int ) \u2013 defaults to 300 Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one. adwin_confidence ( float ) \u2013 defaults to 0.002 The delta parameter used in the nodes' ADWIN drift detectors. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. seed ( int ) \u2013 defaults to None Random seed for reproducibility.","title":"Parameters"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#attributes","text":"height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_alternate_trees n_branches n_inactive_leaves n_leaves n_nodes n_pruned_alternate_trees n_switch_alternate_trees split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer.","title":"Attributes"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingAdaptiveTreeRegressor ( ... grace_period = 50 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.3 , ... seed = 0 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.795811","title":"Examples"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"Methods"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#notes","text":"The Hoeffding Adaptive Tree 1 uses ADWIN 2 to monitor performance of branches on the tree and to replace them with new branches when their accuracy decreases if the new branches are more accurate. The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance. To cope with ADWIN's requirements of bounded input data, HATR uses a novel error normalization strategy based on the empiral rule of Gaussian distributions. We assume the deviations of the predictions from the expected values follow a normal distribution. Hence, we subject these errors to a min-max normalization assuming that most of the data lies in the \\(\\left[-3\\sigma, 3\\sigma\\right]\\) range. These normalized errors are passed to the ADWIN instances. This is the same strategy used by Adaptive Random Forest Regressor.","title":"Notes"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#references","text":"Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009. \u21a9 Bifet, Albert, and Ricard Gavald\u00e0. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007. \u21a9","title":"References"},{"location":"api/tree/HoeffdingTreeClassifier/","text":"HoeffdingTreeClassifier \u00b6 Hoeffding Tree or Very Fast Decision Tree classifier. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. Attributes \u00b6 height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer. Examples \u00b6 >>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ] ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 83.78 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df Notes \u00b6 A Hoeffding Tree 1 is an incremental, anytime decision tree induction algorithm that is capable of learning from massive data streams, assuming that the distribution generating examples does not change over time. Hoeffding trees exploit the fact that a small sample can often be enough to choose an optimal splitting attribute. This idea is supported mathematically by the Hoeffding bound, which quantifies the number of observations (in our case, examples) needed to estimate some statistics within a prescribed precision (in our case, the goodness of an attribute). A theoretically appealing feature of Hoeffding Trees not shared by other incremental decision tree learners is that it has sound guarantees of performance. Using the Hoeffding bound one can show that its output is asymptotically nearly identical to that of a non-incremental learner using infinitely many examples. Implementation based on MOA 2 . References \u00b6 G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"HoeffdingTreeClassifier"},{"location":"api/tree/HoeffdingTreeClassifier/#hoeffdingtreeclassifier","text":"Hoeffding Tree or Very Fast Decision Tree classifier.","title":"HoeffdingTreeClassifier"},{"location":"api/tree/HoeffdingTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning.","title":"Parameters"},{"location":"api/tree/HoeffdingTreeClassifier/#attributes","text":"height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer.","title":"Attributes"},{"location":"api/tree/HoeffdingTreeClassifier/#examples","text":">>> from river import synth >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> gen = synth . Agrawal ( classification_function = 0 , seed = 42 ) >>> # Take 1000 instances from the infinite data generator >>> dataset = iter ( gen . take ( 1000 )) >>> model = tree . HoeffdingTreeClassifier ( ... grace_period = 100 , ... split_confidence = 1e-5 , ... nominal_attributes = [ 'elevel' , 'car' , 'zipcode' ] ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 83.78 %","title":"Examples"},{"location":"api/tree/HoeffdingTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the model on instance x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"Methods"},{"location":"api/tree/HoeffdingTreeClassifier/#notes","text":"A Hoeffding Tree 1 is an incremental, anytime decision tree induction algorithm that is capable of learning from massive data streams, assuming that the distribution generating examples does not change over time. Hoeffding trees exploit the fact that a small sample can often be enough to choose an optimal splitting attribute. This idea is supported mathematically by the Hoeffding bound, which quantifies the number of observations (in our case, examples) needed to estimate some statistics within a prescribed precision (in our case, the goodness of an attribute). A theoretically appealing feature of Hoeffding Trees not shared by other incremental decision tree learners is that it has sound guarantees of performance. Using the Hoeffding bound one can show that its output is asymptotically nearly identical to that of a non-incremental learner using infinitely many examples. Implementation based on MOA 2 .","title":"Notes"},{"location":"api/tree/HoeffdingTreeClassifier/#references","text":"G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams. In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press. \u21a9 Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010. \u21a9","title":"References"},{"location":"api/tree/HoeffdingTreeRegressor/","text":"HoeffdingTreeRegressor \u00b6 Hoeffding Tree regressor. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. Attributes \u00b6 height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.9 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.782258 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df Notes \u00b6 The Hoeffding Tree Regressor (HTR) is an adaptation of the incremental tree algorithm of the same name for classification. Similarly to its classification counterpart, HTR uses the Hoeffding bound to control its split decisions. Differently from the classification algorithm, HTR relies on calculating the reduction of variance in the target space to decide among the split candidates. The smallest the variance at its leaf nodes, the more homogeneous the partitions are. At its leaf nodes, HTR fits either linear models or uses the target average as the predictor.","title":"HoeffdingTreeRegressor"},{"location":"api/tree/HoeffdingTreeRegressor/#hoeffdingtreeregressor","text":"Hoeffding Tree regressor.","title":"HoeffdingTreeRegressor"},{"location":"api/tree/HoeffdingTreeRegressor/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( base.Regressor ) \u2013 defaults to None The regression model used to provide responses if leaf_prediction='model' . If not provided an instance of river.linear_model.LinearRegression with the default hyperparameters is used. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning.","title":"Parameters"},{"location":"api/tree/HoeffdingTreeRegressor/#attributes","text":"height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer.","title":"Attributes"},{"location":"api/tree/HoeffdingTreeRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> from river import preprocessing >>> dataset = datasets . TrumpApproval () >>> model = ( ... preprocessing . StandardScaler () | ... tree . HoeffdingTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'adaptive' , ... model_selector_decay = 0.9 ... ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 0.782258","title":"Examples"},{"location":"api/tree/HoeffdingTreeRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Train the tree model on sample x and corresponding target y. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the target value using one of the leaf prediction strategies. Parameters x Returns Predicted target value. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"Methods"},{"location":"api/tree/HoeffdingTreeRegressor/#notes","text":"The Hoeffding Tree Regressor (HTR) is an adaptation of the incremental tree algorithm of the same name for classification. Similarly to its classification counterpart, HTR uses the Hoeffding bound to control its split decisions. Differently from the classification algorithm, HTR relies on calculating the reduction of variance in the target space to decide among the split candidates. The smallest the variance at its leaf nodes, the more homogeneous the partitions are. At its leaf nodes, HTR fits either linear models or uses the target average as the predictor.","title":"Notes"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/","text":"LabelCombinationHoeffdingTreeClassifier \u00b6 Label Combination Hoeffding Tree for multi-label classification. Label combination transforms the problem from multi-label to multi-class. For each unique combination of labels it assigns a class and proceeds with training the hoeffding tree normally. The transformation is done by changing the label set which could be seen as a binary number to an int which will represent the class, and after the prediction the int is converted back to a binary number which is the predicted label-set. Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. Attributes \u00b6 height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer. Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = iter ( datasets . Music () . take ( 200 )) >>> model = tree . LabelCombinationHoeffdingTreeClassifier ( ... split_confidence = 1e-5 , ... grace_period = 50 ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Accuracy ()) >>> evaluate . progressive_val_score ( dataset , model , metric ) MicroAverage ( Accuracy ): 71.11 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Update the Multi-label Hoeffding Tree Classifier. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the labels of an instance. Parameters x ( dict ) Returns typing.Union[bool, str, int] : Predicted labels. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"LabelCombinationHoeffdingTreeClassifier"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#labelcombinationhoeffdingtreeclassifier","text":"Label Combination Hoeffding Tree for multi-label classification. Label combination transforms the problem from multi-label to multi-class. For each unique combination of labels it assigns a class and proceeds with training the hoeffding tree normally. The transformation is done by changing the label set which could be seen as a binary number to an int which will represent the class, and after the prediction the int is converted back to a binary number which is the predicted label-set.","title":"LabelCombinationHoeffdingTreeClassifier"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_criterion ( str ) \u2013 defaults to info_gain Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to nba Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive nb_threshold ( int ) \u2013 defaults to 0 Number of instances a leaf should observe before allowing Naive Bayes. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.GaussianSplitter is used if splitter is None . binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 100.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning.","title":"Parameters"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#attributes","text":"height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer.","title":"Attributes"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = iter ( datasets . Music () . take ( 200 )) >>> model = tree . LabelCombinationHoeffdingTreeClassifier ( ... split_confidence = 1e-5 , ... grace_period = 50 ... ) >>> metric = metrics . multioutput . MicroAverage ( metrics . Accuracy ()) >>> evaluate . progressive_val_score ( dataset , model , metric ) MicroAverage ( Accuracy ): 71.11 %","title":"Examples"},{"location":"api/tree/LabelCombinationHoeffdingTreeClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Update the Multi-label Hoeffding Tree Classifier. Parameters x y sample_weight \u2013 defaults to 1.0 Returns self predict_one Predict the labels of an instance. Parameters x ( dict ) Returns typing.Union[bool, str, int] : Predicted labels. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x Returns A dictionary that associates a probability which each label. to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"Methods"},{"location":"api/tree/SGTClassifier/","text":"SGTClassifier \u00b6 Stochastic Gradient Tree 1 for binary classification. Binary decision tree classifier that minimizes the binary cross-entropy to guide its growth. Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but data impurity-related heuristics. Parameters \u00b6 delta ( float ) \u2013 defaults to 1e-07 Define the significance level of the F-tests performed to decide upon creating splits or updating predictions. grace_period ( int ) \u2013 defaults to 200 Interval between split attempts or prediction updates. init_pred ( float ) \u2013 defaults to 0.0 Initial value predicted by the tree. max_depth ( Union[int, NoneType] ) \u2013 defaults to None The maximum depth the tree might reach. If set to None , the trees will grow indefinitely. lambda_value ( float ) \u2013 defaults to 0.1 Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions. gamma ( float ) \u2013 defaults to 1.0 Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring. nominal_attributes ( Union[List, NoneType] ) \u2013 defaults to None List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric. feature_quantizer ( river.tree.splitter.base.Quantizer ) \u2013 defaults to None The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of tree.splitter.StaticQuantizer (with default parameters) is used if this parameter is not set. Attributes \u00b6 height n_branches n_leaves n_node_updates n_nodes n_observations n_splits Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . Phishing () >>> model = tree . SGTClassifier ( ... feature_quantizer = tree . splitter . StaticQuantizer ( ... n_bins = 32 , warm_start = 10 ... ) ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 82.24 % Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label. References \u00b6 Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9","title":"SGTClassifier"},{"location":"api/tree/SGTClassifier/#sgtclassifier","text":"Stochastic Gradient Tree 1 for binary classification. Binary decision tree classifier that minimizes the binary cross-entropy to guide its growth. Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but data impurity-related heuristics.","title":"SGTClassifier"},{"location":"api/tree/SGTClassifier/#parameters","text":"delta ( float ) \u2013 defaults to 1e-07 Define the significance level of the F-tests performed to decide upon creating splits or updating predictions. grace_period ( int ) \u2013 defaults to 200 Interval between split attempts or prediction updates. init_pred ( float ) \u2013 defaults to 0.0 Initial value predicted by the tree. max_depth ( Union[int, NoneType] ) \u2013 defaults to None The maximum depth the tree might reach. If set to None , the trees will grow indefinitely. lambda_value ( float ) \u2013 defaults to 0.1 Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions. gamma ( float ) \u2013 defaults to 1.0 Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring. nominal_attributes ( Union[List, NoneType] ) \u2013 defaults to None List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric. feature_quantizer ( river.tree.splitter.base.Quantizer ) \u2013 defaults to None The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of tree.splitter.StaticQuantizer (with default parameters) is used if this parameter is not set.","title":"Parameters"},{"location":"api/tree/SGTClassifier/#attributes","text":"height n_branches n_leaves n_node_updates n_nodes n_observations n_splits","title":"Attributes"},{"location":"api/tree/SGTClassifier/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . Phishing () >>> model = tree . SGTClassifier ( ... feature_quantizer = tree . splitter . StaticQuantizer ( ... n_bins = 32 , warm_start = 10 ... ) ... ) >>> metric = metrics . Accuracy () >>> evaluate . progressive_val_score ( dataset , model , metric ) Accuracy : 82.24 %","title":"Examples"},{"location":"api/tree/SGTClassifier/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Update the model with a set of features x and a label y . Parameters x ( dict ) y ( Union[bool, str, int] ) w \u2013 defaults to 1.0 Returns Classifier : self predict_one Predict the label of a set of features x . Parameters x ( dict ) Returns typing.Union[bool, str, int] : The predicted label. predict_proba_one Predict the probability of each label for a dictionary of features x . Parameters x ( dict ) Returns typing.Dict[typing.Union[bool, str, int], float] : A dictionary that associates a probability which each label.","title":"Methods"},{"location":"api/tree/SGTClassifier/#references","text":"Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9","title":"References"},{"location":"api/tree/SGTRegressor/","text":"SGTRegressor \u00b6 Stochastic Gradient Tree for regression. Incremental decision tree regressor that minimizes the mean square error to guide its growth. Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but a data impurity-related heuristic. Parameters \u00b6 delta ( float ) \u2013 defaults to 1e-07 Define the significance level of the F-tests performed to decide upon creating splits or updating predictions. grace_period ( int ) \u2013 defaults to 200 Interval between split attempts or prediction updates. init_pred ( float ) \u2013 defaults to 0.0 Initial value predicted by the tree. max_depth ( Union[int, NoneType] ) \u2013 defaults to None The maximum depth the tree might reach. If set to None , the trees will grow indefinitely. lambda_value ( float ) \u2013 defaults to 0.1 Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions. gamma ( float ) \u2013 defaults to 1.0 Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring. nominal_attributes ( Union[List, NoneType] ) \u2013 defaults to None List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric. feature_quantizer ( river.tree.splitter.base.Quantizer ) \u2013 defaults to None The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of tree.splitter.StaticQuantizer (with default parameters) is used if this parameter is not set. Attributes \u00b6 height n_branches n_leaves n_node_updates n_nodes n_observations n_splits Examples \u00b6 >>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . TrumpApproval () >>> model = tree . SGTRegressor ( ... delta = 0.01 , ... lambda_value = 0.01 , ... grace_period = 20 , ... feature_quantizer = tree . splitter . DynamicQuantizer ( std_prop = 0.1 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.721818 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction. Notes \u00b6 This implementation enhances the original proposal 1 by using an incremental strategy to discretize numerical features dynamically, rather than relying on a calibration set and parameterized number of bins. The strategy used is an adaptation of the Quantization Observer (QO) 2 . Different bin size setting policies are available for selection. They directly related to number of split candidates the tree is going to explore, and thus, how accurate its split decisions are going to be. Besides, the number of stored bins per feature is directly related to the tree's memory usage and runtime. References \u00b6 Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9 Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters. \u21a9","title":"SGTRegressor"},{"location":"api/tree/SGTRegressor/#sgtregressor","text":"Stochastic Gradient Tree for regression. Incremental decision tree regressor that minimizes the mean square error to guide its growth. Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but a data impurity-related heuristic.","title":"SGTRegressor"},{"location":"api/tree/SGTRegressor/#parameters","text":"delta ( float ) \u2013 defaults to 1e-07 Define the significance level of the F-tests performed to decide upon creating splits or updating predictions. grace_period ( int ) \u2013 defaults to 200 Interval between split attempts or prediction updates. init_pred ( float ) \u2013 defaults to 0.0 Initial value predicted by the tree. max_depth ( Union[int, NoneType] ) \u2013 defaults to None The maximum depth the tree might reach. If set to None , the trees will grow indefinitely. lambda_value ( float ) \u2013 defaults to 0.1 Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions. gamma ( float ) \u2013 defaults to 1.0 Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring. nominal_attributes ( Union[List, NoneType] ) \u2013 defaults to None List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric. feature_quantizer ( river.tree.splitter.base.Quantizer ) \u2013 defaults to None The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of tree.splitter.StaticQuantizer (with default parameters) is used if this parameter is not set.","title":"Parameters"},{"location":"api/tree/SGTRegressor/#attributes","text":"height n_branches n_leaves n_node_updates n_nodes n_observations n_splits","title":"Attributes"},{"location":"api/tree/SGTRegressor/#examples","text":">>> from river import datasets >>> from river import evaluate >>> from river import metrics >>> from river import tree >>> dataset = datasets . TrumpApproval () >>> model = tree . SGTRegressor ( ... delta = 0.01 , ... lambda_value = 0.01 , ... grace_period = 20 , ... feature_quantizer = tree . splitter . DynamicQuantizer ( std_prop = 0.1 ) ... ) >>> metric = metrics . MAE () >>> evaluate . progressive_val_score ( dataset , model , metric ) MAE : 1.721818","title":"Examples"},{"location":"api/tree/SGTRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. learn_one Fits to a set of features x and a real-valued target y . Parameters x ( dict ) y ( numbers.Number ) w \u2013 defaults to 1.0 Returns Regressor : self predict_one Predicts the target value of a set of features x . Parameters x ( dict ) Returns Number : The prediction.","title":"Methods"},{"location":"api/tree/SGTRegressor/#notes","text":"This implementation enhances the original proposal 1 by using an incremental strategy to discretize numerical features dynamically, rather than relying on a calibration set and parameterized number of bins. The strategy used is an adaptation of the Quantization Observer (QO) 2 . Different bin size setting policies are available for selection. They directly related to number of split candidates the tree is going to explore, and thus, how accurate its split decisions are going to be. Besides, the number of stored bins per feature is directly related to the tree's memory usage and runtime.","title":"Notes"},{"location":"api/tree/SGTRegressor/#references","text":"Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9 Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters. \u21a9","title":"References"},{"location":"api/tree/iSOUPTreeRegressor/","text":"iSOUPTreeRegressor \u00b6 Incremental Structured Output Prediction Tree (iSOUP-Tree) for multi-target regression. This is an implementation of the iSOUP-Tree proposed by A. Osojnik, P. Panov, and S. D\u017eeroski 1 . Parameters \u00b6 grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( Union[ base.Regressor , Dict] ) \u2013 defaults to None The regression model(s) used to provide responses if leaf_prediction='model' . It can be either a regressor (in which case it is going to be replicated to all the targets) or a dictionary whose keys are target identifiers, and the values are instances of river.base.Regressor. If not provided, instances of river.linear_model.LinearRegression with the default hyperparameters are used for all the targets. If a dictionary is passed and not all target models are specified, copies from the first model match in the dictionary will be used to the remaining targets. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning. Attributes \u00b6 height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer. Examples \u00b6 >>> import numbers >>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> from river import tree >>> dataset = datasets . SolarFlare () >>> num = compose . SelectType ( numbers . Number ) | preprocessing . MinMaxScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder ( sparse = False ) >>> model = tree . iSOUPTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'model' , ... leaf_model = { ... 'c-class-flares' : linear_model . LinearRegression ( l2 = 0.02 ), ... 'm-class-flares' : linear_model . PARegressor (), ... 'x-class-flares' : linear_model . LinearRegression ( l2 = 0.1 ) ... } ... ) >>> pipeline = ( num + cat ) | model >>> metric = metrics . multioutput . MicroAverage ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , pipeline , metric ) MicroAverage ( MAE ): 0.426177 Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model with one sample. Training tasks: * If the tree is empty, create a leaf node as the root. * If the tree is already initialized, find the corresponding leaf for the instance and update the leaf node statistics. * If growth is allowed and the number of instances that the leaf has observed between split attempts exceed the grace period then attempt to split. Parameters x ( dict ) y ( Dict[Hashable, numbers.Number] ) sample_weight ( float ) \u2013 defaults to 1.0 predict_one Predict the target values for a given instance. Parameters x ( dict ) Returns typing.Dict[typing.Hashable, numbers.Number] : dict to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df References \u00b6 Alja\u017e Osojnik, Pan\u010de Panov, and Sa\u0161o D\u017eeroski. \"Tree-based methods for online multi-target regression.\" Journal of Intelligent Information Systems 50.2 (2018): 315-339. \u21a9","title":"iSOUPTreeRegressor"},{"location":"api/tree/iSOUPTreeRegressor/#isouptreeregressor","text":"Incremental Structured Output Prediction Tree (iSOUP-Tree) for multi-target regression. This is an implementation of the iSOUP-Tree proposed by A. Osojnik, P. Panov, and S. D\u017eeroski 1 .","title":"iSOUPTreeRegressor"},{"location":"api/tree/iSOUPTreeRegressor/#parameters","text":"grace_period ( int ) \u2013 defaults to 200 Number of instances a leaf should observe between split attempts. max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. split_confidence ( float ) \u2013 defaults to 1e-07 Allowed error in split decision, a value closer to 0 takes longer to decide. tie_threshold ( float ) \u2013 defaults to 0.05 Threshold below which a split will be forced to break ties. leaf_prediction ( str ) \u2013 defaults to model Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in leaf_model - 'adaptive' - Chooses between 'mean' and 'model' dynamically leaf_model ( Union[ base.Regressor , Dict] ) \u2013 defaults to None The regression model(s) used to provide responses if leaf_prediction='model' . It can be either a regressor (in which case it is going to be replicated to all the targets) or a dictionary whose keys are target identifiers, and the values are instances of river.base.Regressor. If not provided, instances of river.linear_model.LinearRegression with the default hyperparameters are used for all the targets. If a dictionary is passed and not all target models are specified, copies from the first model match in the dictionary will be used to the remaining targets. model_selector_decay ( float ) \u2013 defaults to 0.95 The exponential decaying factor applied to the learning models' squared errors, that are monitored if leaf_prediction='adaptive' . Must be between 0 and 1 . The closer to 1 , the more importance is going to be given to past observations. On the other hand, if its value approaches 0 , the recent observed errors are going to have more influence on the final decision. nominal_attributes ( list ) \u2013 defaults to None List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous. splitter ( river.tree.splitter.base.Splitter ) \u2013 defaults to None The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the tree.splitter module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property is_target_class . This is an advanced option. Special care must be taken when choosing different splitters. By default, tree.splitter.EBSTSplitter is used if splitter is None . min_samples_split ( int ) \u2013 defaults to 5 The minimum number of samples every branch resulting from a split candidate must have to be considered valid. binary_split ( bool ) \u2013 defaults to False If True, only allow binary splits. max_size ( float ) \u2013 defaults to 500.0 The max size of the tree, in Megabytes (MB). memory_estimate_period ( int ) \u2013 defaults to 1000000 Interval (number of processed instances) between memory consumption checks. stop_mem_management ( bool ) \u2013 defaults to False If True, stop growing as soon as memory limit is hit. remove_poor_attrs ( bool ) \u2013 defaults to False If True, disable poor attributes to reduce memory usage. merit_preprune ( bool ) \u2013 defaults to True If True, enable merit-based tree pre-pruning.","title":"Parameters"},{"location":"api/tree/iSOUPTreeRegressor/#attributes","text":"height leaf_prediction Return the prediction strategy used by the tree at its leaves. max_size Max allowed size tree can reach (in MB). n_active_leaves n_branches n_inactive_leaves n_leaves n_nodes split_criterion Return a string with the name of the split criterion being used by the tree. summary Collect metrics corresponding to the current status of the tree in a string buffer.","title":"Attributes"},{"location":"api/tree/iSOUPTreeRegressor/#examples","text":">>> import numbers >>> from river import compose >>> from river import datasets >>> from river import evaluate >>> from river import linear_model >>> from river import metrics >>> from river import preprocessing >>> from river import tree >>> dataset = datasets . SolarFlare () >>> num = compose . SelectType ( numbers . Number ) | preprocessing . MinMaxScaler () >>> cat = compose . SelectType ( str ) | preprocessing . OneHotEncoder ( sparse = False ) >>> model = tree . iSOUPTreeRegressor ( ... grace_period = 100 , ... leaf_prediction = 'model' , ... leaf_model = { ... 'c-class-flares' : linear_model . LinearRegression ( l2 = 0.02 ), ... 'm-class-flares' : linear_model . PARegressor (), ... 'x-class-flares' : linear_model . LinearRegression ( l2 = 0.1 ) ... } ... ) >>> pipeline = ( num + cat ) | model >>> metric = metrics . multioutput . MicroAverage ( metrics . MAE ()) >>> evaluate . progressive_val_score ( dataset , pipeline , metric ) MicroAverage ( MAE ): 0.426177","title":"Examples"},{"location":"api/tree/iSOUPTreeRegressor/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. debug_one Print an explanation of how x is predicted. Parameters x ( dict ) Returns typing.Union[str, NoneType] : A representation of the path followed by the tree to predict x ; None if draw Draw the tree using the graphviz library. Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean. Parameters max_depth ( int ) \u2013 defaults to None The maximum depth a tree can reach. If None , the tree will grow indefinitely. learn_one Incrementally train the model with one sample. Training tasks: * If the tree is empty, create a leaf node as the root. * If the tree is already initialized, find the corresponding leaf for the instance and update the leaf node statistics. * If growth is allowed and the number of instances that the leaf has observed between split attempts exceed the grace period then attempt to split. Parameters x ( dict ) y ( Dict[Hashable, numbers.Number] ) sample_weight ( float ) \u2013 defaults to 1.0 predict_one Predict the target values for a given instance. Parameters x ( dict ) Returns typing.Dict[typing.Hashable, numbers.Number] : dict to_dataframe Return a representation of the current tree structure organized in a pandas.DataFrame object. In case the tree is empty or it only contains a single node (a leaf), None is returned. Returns df","title":"Methods"},{"location":"api/tree/iSOUPTreeRegressor/#references","text":"Alja\u017e Osojnik, Pan\u010de Panov, and Sa\u0161o D\u017eeroski. \"Tree-based methods for online multi-target regression.\" Journal of Intelligent Information Systems 50.2 (2018): 315-339. \u21a9","title":"References"},{"location":"api/tree/base/Branch/","text":"Branch \u00b6 A generic tree branch. Parameters \u00b6 children Child branches and/or leaves. Attributes \u00b6 height Distance to the deepest descendant. n_branches Number of branches, including thyself. n_leaves Number of leaves. n_nodes Number of descendants, including thyself. repr_split String representation of the split. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. iter_bfs Iterate over nodes in breadth-first order. iter_branches Iterate over branches in depth-first order. iter_dfs Iterate over nodes in depth-first order. iter_edges Iterate over edges in depth-first order. iter_leaves Iterate over leaves from the left-most one to the right-most one. most_common_path Return a tuple with the branch index and the child node related to the most traversed path. Used in case the split feature is missing from an instance. next Move to the next node down the tree. Parameters x to_dataframe Build a DataFrame containing one record for each node. traverse Return the leaf corresponding to the given input. Parameters x until_leaf \u2013 defaults to True walk Iterate over the nodes of the path induced by x. Parameters x until_leaf \u2013 defaults to True","title":"Branch"},{"location":"api/tree/base/Branch/#branch","text":"A generic tree branch.","title":"Branch"},{"location":"api/tree/base/Branch/#parameters","text":"children Child branches and/or leaves.","title":"Parameters"},{"location":"api/tree/base/Branch/#attributes","text":"height Distance to the deepest descendant. n_branches Number of branches, including thyself. n_leaves Number of leaves. n_nodes Number of descendants, including thyself. repr_split String representation of the split.","title":"Attributes"},{"location":"api/tree/base/Branch/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. iter_bfs Iterate over nodes in breadth-first order. iter_branches Iterate over branches in depth-first order. iter_dfs Iterate over nodes in depth-first order. iter_edges Iterate over edges in depth-first order. iter_leaves Iterate over leaves from the left-most one to the right-most one. most_common_path Return a tuple with the branch index and the child node related to the most traversed path. Used in case the split feature is missing from an instance. next Move to the next node down the tree. Parameters x to_dataframe Build a DataFrame containing one record for each node. traverse Return the leaf corresponding to the given input. Parameters x until_leaf \u2013 defaults to True walk Iterate over the nodes of the path induced by x. Parameters x until_leaf \u2013 defaults to True","title":"Methods"},{"location":"api/tree/base/Leaf/","text":"Leaf \u00b6 A generic tree node. Parameters \u00b6 kwargs Each provided keyword argument is stored in the leaf as an attribute. Attributes \u00b6 height n_branches n_leaves n_nodes Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. iter_branches iter_dfs iter_edges iter_leaves walk","title":"Leaf"},{"location":"api/tree/base/Leaf/#leaf","text":"A generic tree node.","title":"Leaf"},{"location":"api/tree/base/Leaf/#parameters","text":"kwargs Each provided keyword argument is stored in the leaf as an attribute.","title":"Parameters"},{"location":"api/tree/base/Leaf/#attributes","text":"height n_branches n_leaves n_nodes","title":"Attributes"},{"location":"api/tree/base/Leaf/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. iter_branches iter_dfs iter_edges iter_leaves walk","title":"Methods"},{"location":"api/tree/splitter/DynamicQuantizer/","text":"DynamicQuantizer \u00b6 Adapted version of the Quantizer Observer (QO) 1 that is applied to Stochastic Gradient Trees (SGT). This feature quantizer starts by partitioning the inputs using the passed radius value. As more splits are created in the SGTs, new feature quantizers will use std * std_prop as the quantization radius. In the expression, std represents the standard deviation of the input data, which is calculated incrementally. Parameters \u00b6 radius ( float ) \u2013 defaults to 0.5 The initial quantization radius. std_prop ( float ) \u2013 defaults to 0.25 The proportion of the standard deviation that is going to be used to define the radius value for new quantizer instances following the initial one. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. update References \u00b6 Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters. \u21a9","title":"DynamicQuantizer"},{"location":"api/tree/splitter/DynamicQuantizer/#dynamicquantizer","text":"Adapted version of the Quantizer Observer (QO) 1 that is applied to Stochastic Gradient Trees (SGT). This feature quantizer starts by partitioning the inputs using the passed radius value. As more splits are created in the SGTs, new feature quantizers will use std * std_prop as the quantization radius. In the expression, std represents the standard deviation of the input data, which is calculated incrementally.","title":"DynamicQuantizer"},{"location":"api/tree/splitter/DynamicQuantizer/#parameters","text":"radius ( float ) \u2013 defaults to 0.5 The initial quantization radius. std_prop ( float ) \u2013 defaults to 0.25 The proportion of the standard deviation that is going to be used to define the radius value for new quantizer instances following the initial one.","title":"Parameters"},{"location":"api/tree/splitter/DynamicQuantizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. update","title":"Methods"},{"location":"api/tree/splitter/DynamicQuantizer/#references","text":"Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters. \u21a9","title":"References"},{"location":"api/tree/splitter/EBSTSplitter/","text":"EBSTSplitter \u00b6 iSOUP-Tree's Extended Binary Search Tree (E-BST). This class implements the Extended Binary Search Tree 1 (E-BST) structure, using the variant employed by Osojnik et al. 2 in the iSOUP-Tree algorithm. This structure is employed to observe the target space distribution. Proposed along with Fast Incremental Model Tree with Drift Detection 1 (FIMT-DD), E-BST was the first attribute observer (AO) proposed for incremental Hoeffding Tree regressors. This AO works by storing all observations between splits in an extended binary search tree structure. E-BST stores the input feature realizations and statistics of the target(s) that enable calculating the split heuristic at any time. To alleviate time and memory costs, E-BST implements a memory management routine, where the worst split candidates are pruned from the binary tree. In this variant, only the left branch statistics are stored and the complete split-enabling statistics are calculated with an in-order traversal of the binary search tree. Attributes \u00b6 is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees. Methods \u00b6 best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) \u2013 defaults to True Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Not implemented in regression splitters. Parameters att_val target_val ( Union[bool, str, int] ) remove_bad_splits Remove bad splits. Based on FIMT-DD's 1 procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed). Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound ( \\(\\epsilon\\) ) are used to decide upon creating a split. A split occurs when \\(r < 1 - \\epsilon\\) . A split candidate, with merit \\(m_i\\) , is considered badr if \\(m_i / m_1 < r - 2\\epsilon\\) . The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\) , then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed. To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in 1 . Parameters criterion last_check_ratio ( float ) last_check_vr ( float ) last_check_e ( float ) pre_split_dist ( Union[List, Dict] ) update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float ) References \u00b6 Ikonomovska, E., Gama, J., & D\u017eeroski, S. (2011). Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), 128-168. \u21a9 \u21a9 \u21a9 \u21a9 Osojnik, Alja\u017e. 2017. Structured output prediction on Data Streams (Doctoral Dissertation) \u21a9","title":"EBSTSplitter"},{"location":"api/tree/splitter/EBSTSplitter/#ebstsplitter","text":"iSOUP-Tree's Extended Binary Search Tree (E-BST). This class implements the Extended Binary Search Tree 1 (E-BST) structure, using the variant employed by Osojnik et al. 2 in the iSOUP-Tree algorithm. This structure is employed to observe the target space distribution. Proposed along with Fast Incremental Model Tree with Drift Detection 1 (FIMT-DD), E-BST was the first attribute observer (AO) proposed for incremental Hoeffding Tree regressors. This AO works by storing all observations between splits in an extended binary search tree structure. E-BST stores the input feature realizations and statistics of the target(s) that enable calculating the split heuristic at any time. To alleviate time and memory costs, E-BST implements a memory management routine, where the worst split candidates are pruned from the binary tree. In this variant, only the left branch statistics are stored and the complete split-enabling statistics are calculated with an in-order traversal of the binary search tree.","title":"EBSTSplitter"},{"location":"api/tree/splitter/EBSTSplitter/#attributes","text":"is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees.","title":"Attributes"},{"location":"api/tree/splitter/EBSTSplitter/#methods","text":"best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) \u2013 defaults to True Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Not implemented in regression splitters. Parameters att_val target_val ( Union[bool, str, int] ) remove_bad_splits Remove bad splits. Based on FIMT-DD's 1 procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed). Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound ( \\(\\epsilon\\) ) are used to decide upon creating a split. A split occurs when \\(r < 1 - \\epsilon\\) . A split candidate, with merit \\(m_i\\) , is considered badr if \\(m_i / m_1 < r - 2\\epsilon\\) . The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\) , then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed. To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in 1 . Parameters criterion last_check_ratio ( float ) last_check_vr ( float ) last_check_e ( float ) pre_split_dist ( Union[List, Dict] ) update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Methods"},{"location":"api/tree/splitter/EBSTSplitter/#references","text":"Ikonomovska, E., Gama, J., & D\u017eeroski, S. (2011). Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), 128-168. \u21a9 \u21a9 \u21a9 \u21a9 Osojnik, Alja\u017e. 2017. Structured output prediction on Data Streams (Doctoral Dissertation) \u21a9","title":"References"},{"location":"api/tree/splitter/ExhaustiveSplitter/","text":"ExhaustiveSplitter \u00b6 Numeric attribute observer for classification tasks that is based on a Binary Search Tree. This algorithm 1 is also referred to as exhaustive attribute observer, since it ends up storing all the observations between split attempts 2 . This splitter cannot perform probability density estimations, so it does not work well when coupled with tree leaves using naive bayes models. Attributes \u00b6 is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees. Methods \u00b6 best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba The underlying data structure used to monitor the input does not allow probability density estimations. Hence, it always returns zero for any given input. Parameters att_val target_val ( Union[bool, str, int] ) update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float ) References \u00b6 Domingos, P. and Hulten, G., 2000, August. Mining high-speed data streams. In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 71-80). \u21a9 Pfahringer, B., Holmes, G. and Kirkby, R., 2008, May. Handling numeric attributes in hoeffding trees. In Pacific-Asia Conference on Knowledge Discovery and Data Mining (pp. 296-307). Springer, Berlin, Heidelberg. \u21a9","title":"ExhaustiveSplitter"},{"location":"api/tree/splitter/ExhaustiveSplitter/#exhaustivesplitter","text":"Numeric attribute observer for classification tasks that is based on a Binary Search Tree. This algorithm 1 is also referred to as exhaustive attribute observer, since it ends up storing all the observations between split attempts 2 . This splitter cannot perform probability density estimations, so it does not work well when coupled with tree leaves using naive bayes models.","title":"ExhaustiveSplitter"},{"location":"api/tree/splitter/ExhaustiveSplitter/#attributes","text":"is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees.","title":"Attributes"},{"location":"api/tree/splitter/ExhaustiveSplitter/#methods","text":"best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba The underlying data structure used to monitor the input does not allow probability density estimations. Hence, it always returns zero for any given input. Parameters att_val target_val ( Union[bool, str, int] ) update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Methods"},{"location":"api/tree/splitter/ExhaustiveSplitter/#references","text":"Domingos, P. and Hulten, G., 2000, August. Mining high-speed data streams. In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 71-80). \u21a9 Pfahringer, B., Holmes, G. and Kirkby, R., 2008, May. Handling numeric attributes in hoeffding trees. In Pacific-Asia Conference on Knowledge Discovery and Data Mining (pp. 296-307). Springer, Berlin, Heidelberg. \u21a9","title":"References"},{"location":"api/tree/splitter/GaussianSplitter/","text":"GaussianSplitter \u00b6 Numeric attribute observer for classification tasks that is based on Gaussian estimators. The distribution of each class is approximated using a Gaussian distribution. Hence, the probability density function can be easily calculated. Parameters \u00b6 n_splits ( int ) \u2013 defaults to 10 The number of partitions to consider when querying for split candidates. Attributes \u00b6 is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees. Methods \u00b6 best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"GaussianSplitter"},{"location":"api/tree/splitter/GaussianSplitter/#gaussiansplitter","text":"Numeric attribute observer for classification tasks that is based on Gaussian estimators. The distribution of each class is approximated using a Gaussian distribution. Hence, the probability density function can be easily calculated.","title":"GaussianSplitter"},{"location":"api/tree/splitter/GaussianSplitter/#parameters","text":"n_splits ( int ) \u2013 defaults to 10 The number of partitions to consider when querying for split candidates.","title":"Parameters"},{"location":"api/tree/splitter/GaussianSplitter/#attributes","text":"is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees.","title":"Attributes"},{"location":"api/tree/splitter/GaussianSplitter/#methods","text":"best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Methods"},{"location":"api/tree/splitter/HistogramSplitter/","text":"HistogramSplitter \u00b6 Numeric attribute observer for classification tasks that discretizes features using histograms. Parameters \u00b6 n_bins ( int ) \u2013 defaults to 256 The maximum number of bins in the histogram. n_splits ( int ) \u2013 defaults to 32 The number of split points to evaluate when querying for the best split candidate. Attributes \u00b6 is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees. Methods \u00b6 best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"HistogramSplitter"},{"location":"api/tree/splitter/HistogramSplitter/#histogramsplitter","text":"Numeric attribute observer for classification tasks that discretizes features using histograms.","title":"HistogramSplitter"},{"location":"api/tree/splitter/HistogramSplitter/#parameters","text":"n_bins ( int ) \u2013 defaults to 256 The maximum number of bins in the histogram. n_splits ( int ) \u2013 defaults to 32 The number of split points to evaluate when querying for the best split candidate.","title":"Parameters"},{"location":"api/tree/splitter/HistogramSplitter/#attributes","text":"is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees.","title":"Attributes"},{"location":"api/tree/splitter/HistogramSplitter/#methods","text":"best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Methods"},{"location":"api/tree/splitter/QOSplitter/","text":"QOSplitter \u00b6 Quantization observer (QO). This splitter utilizes a hash-based quantization algorithm to keep track of the target statistics and evaluate split candidates. QO, relies on the radius parameter to define discretization intervals for each incoming feature. Split candidates are defined as the midpoints between two consecutive hash slots. Both binary splits and multi-way splits can be created by this attribute observer. This class implements the algorithm described in 1 . The smaller the quantization radius, the more hash slots will be created to accommodate the discretized data. Hence, both the running time and memory consumption increase, but the resulting splits ought to be closer to the ones obtained by a batch exhaustive approach. On the other hand, if the radius is too large, fewer slots will be created, less memory and running time will be required, but at the cost of coarse split suggestions. QO assumes that all features have the same range. It is always advised to scale the features to apply this splitter. That can be done using the preprocessing module. A good \"rule of thumb\" is to scale data using preprocessing.StandardScaler and define the radius as a proportion of the features' standard deviation. For instance, the default radius value would correspond to one quarter of the normalized features' standard deviation (since the scaled data has zero mean and unit variance). If the features come from normal distributions, by following the empirical rule, roughly 32 hash slots will be created. Parameters \u00b6 radius ( float ) \u2013 defaults to 0.25 The quantization radius. QO discretizes the incoming feature in intervals of equal length that are defined by this parameter. allow_multiway_splits \u2013 defaults to False Whether or not allow that multiway splits are evaluated. Numeric multi-way splits use the same quantization strategy of QO to create multiple tree branches. The same quantization radius is used, and each stored slot represents the split enabling statistics of one branch. Attributes \u00b6 is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees. Methods \u00b6 best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) \u2013 defaults to True Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float ) References \u00b6 Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters. \u21a9","title":"QOSplitter"},{"location":"api/tree/splitter/QOSplitter/#qosplitter","text":"Quantization observer (QO). This splitter utilizes a hash-based quantization algorithm to keep track of the target statistics and evaluate split candidates. QO, relies on the radius parameter to define discretization intervals for each incoming feature. Split candidates are defined as the midpoints between two consecutive hash slots. Both binary splits and multi-way splits can be created by this attribute observer. This class implements the algorithm described in 1 . The smaller the quantization radius, the more hash slots will be created to accommodate the discretized data. Hence, both the running time and memory consumption increase, but the resulting splits ought to be closer to the ones obtained by a batch exhaustive approach. On the other hand, if the radius is too large, fewer slots will be created, less memory and running time will be required, but at the cost of coarse split suggestions. QO assumes that all features have the same range. It is always advised to scale the features to apply this splitter. That can be done using the preprocessing module. A good \"rule of thumb\" is to scale data using preprocessing.StandardScaler and define the radius as a proportion of the features' standard deviation. For instance, the default radius value would correspond to one quarter of the normalized features' standard deviation (since the scaled data has zero mean and unit variance). If the features come from normal distributions, by following the empirical rule, roughly 32 hash slots will be created.","title":"QOSplitter"},{"location":"api/tree/splitter/QOSplitter/#parameters","text":"radius ( float ) \u2013 defaults to 0.25 The quantization radius. QO discretizes the incoming feature in intervals of equal length that are defined by this parameter. allow_multiway_splits \u2013 defaults to False Whether or not allow that multiway splits are evaluated. Numeric multi-way splits use the same quantization strategy of QO to create multiple tree branches. The same quantization radius is used, and each stored slot represents the split enabling statistics of one branch.","title":"Parameters"},{"location":"api/tree/splitter/QOSplitter/#attributes","text":"is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees.","title":"Attributes"},{"location":"api/tree/splitter/QOSplitter/#methods","text":"best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) \u2013 defaults to True Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Methods"},{"location":"api/tree/splitter/QOSplitter/#references","text":"Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters. \u21a9","title":"References"},{"location":"api/tree/splitter/Quantizer/","text":"Quantizer \u00b6 Base class for the feature quantizers used in Stochastic Gradient Trees 1 . Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. update References \u00b6 Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9","title":"Quantizer"},{"location":"api/tree/splitter/Quantizer/#quantizer","text":"Base class for the feature quantizers used in Stochastic Gradient Trees 1 .","title":"Quantizer"},{"location":"api/tree/splitter/Quantizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. update","title":"Methods"},{"location":"api/tree/splitter/Quantizer/#references","text":"Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9","title":"References"},{"location":"api/tree/splitter/Splitter/","text":"Splitter \u00b6 Base class for the tree splitters. Each Attribute Observer (AO) or Splitter monitors one input feature and finds the best split point for this attribute. AOs can also perform other tasks related to the monitored feature, such as estimating its probability density function (classification case). This class should not be instantiated, as none of its methods are implemented. Attributes \u00b6 is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees. Methods \u00b6 best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Splitter"},{"location":"api/tree/splitter/Splitter/#splitter","text":"Base class for the tree splitters. Each Attribute Observer (AO) or Splitter monitors one input feature and finds the best split point for this attribute. AOs can also perform other tasks related to the monitored feature, such as estimating its probability density function (classification case). This class should not be instantiated, as none of its methods are implemented.","title":"Splitter"},{"location":"api/tree/splitter/Splitter/#attributes","text":"is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees.","title":"Attributes"},{"location":"api/tree/splitter/Splitter/#methods","text":"best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Get the probability for an attribute value given a class. Parameters att_val target_val ( Union[bool, str, int] ) Returns float : Probability for an attribute value given a class. update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Methods"},{"location":"api/tree/splitter/StaticQuantizer/","text":"StaticQuantizer \u00b6 Quantization strategy originally used in Stochastic Gradient Trees (SGT) 1 . Firstly, a buffer of size warm_start is stored. The data stored in the buffer is then used to quantize the input feature into n_bins intervals. These intervals will be replicated to every new quantizer. Feature values lying outside of the limits defined by the initial buffer will be mapped to the head or tail of the list of intervals. Parameters \u00b6 n_bins ( int ) \u2013 defaults to 64 The number of bins (intervals) to divide the input feature. warm_start ( int ) \u2013 defaults to 100 The number of observations used to initialize the quantization intervals. buckets ( List ) \u2013 defaults to None This parameter is only used internally by the quantizer, so it must not be set. Once the intervals are defined, new instances of this quantizer will receive the quantization information via this parameter. Methods \u00b6 clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. update References \u00b6 Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9","title":"StaticQuantizer"},{"location":"api/tree/splitter/StaticQuantizer/#staticquantizer","text":"Quantization strategy originally used in Stochastic Gradient Trees (SGT) 1 . Firstly, a buffer of size warm_start is stored. The data stored in the buffer is then used to quantize the input feature into n_bins intervals. These intervals will be replicated to every new quantizer. Feature values lying outside of the limits defined by the initial buffer will be mapped to the head or tail of the list of intervals.","title":"StaticQuantizer"},{"location":"api/tree/splitter/StaticQuantizer/#parameters","text":"n_bins ( int ) \u2013 defaults to 64 The number of bins (intervals) to divide the input feature. warm_start ( int ) \u2013 defaults to 100 The number of observations used to initialize the quantization intervals. buckets ( List ) \u2013 defaults to None This parameter is only used internally by the quantizer, so it must not be set. Once the intervals are defined, new instances of this quantizer will receive the quantization information via this parameter.","title":"Parameters"},{"location":"api/tree/splitter/StaticQuantizer/#methods","text":"clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. update","title":"Methods"},{"location":"api/tree/splitter/StaticQuantizer/#references","text":"Gouk, H., Pfahringer, B., & Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109). \u21a9","title":"References"},{"location":"api/tree/splitter/TEBSTSplitter/","text":"TEBSTSplitter \u00b6 Truncated E-BST. Variation of E-BST that rounds the incoming feature values before passing them to the binary search tree (BST). By doing so, the attribute observer might reduce its processing time and memory usage since small variations in the input values will end up being mapped to the same BST node. Parameters \u00b6 digits ( int ) \u2013 defaults to 3 The number of decimal places used to round the input feature values. Attributes \u00b6 is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees. Methods \u00b6 best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) \u2013 defaults to True Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Not implemented in regression splitters. Parameters att_val target_val ( Union[bool, str, int] ) remove_bad_splits Remove bad splits. Based on FIMT-DD's [^1] procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed). Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound ( \\(\\epsilon\\) ) are used to decide upon creating a split. A split occurs when \\(r < 1 - \\epsilon\\) . A split candidate, with merit \\(m_i\\) , is considered badr if \\(m_i / m_1 < r - 2\\epsilon\\) . The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\) , then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed. To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in [^1]. Parameters criterion last_check_ratio ( float ) last_check_vr ( float ) last_check_e ( float ) pre_split_dist ( Union[List, Dict] ) update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"TEBSTSplitter"},{"location":"api/tree/splitter/TEBSTSplitter/#tebstsplitter","text":"Truncated E-BST. Variation of E-BST that rounds the incoming feature values before passing them to the binary search tree (BST). By doing so, the attribute observer might reduce its processing time and memory usage since small variations in the input values will end up being mapped to the same BST node.","title":"TEBSTSplitter"},{"location":"api/tree/splitter/TEBSTSplitter/#parameters","text":"digits ( int ) \u2013 defaults to 3 The number of decimal places used to round the input feature values.","title":"Parameters"},{"location":"api/tree/splitter/TEBSTSplitter/#attributes","text":"is_numeric Determine whether or not the splitter works with numerical features. is_target_class Check on which kind of learning task the splitter is designed to work. If True , the splitter works with classification trees, otherwise it is designed for regression trees.","title":"Attributes"},{"location":"api/tree/splitter/TEBSTSplitter/#methods","text":"best_evaluated_split_suggestion Get the best split suggestion given a criterion and the target's statistics. Parameters criterion ( river.tree.split_criterion.base.SplitCriterion ) pre_split_dist ( Union[List, Dict] ) att_idx ( Hashable ) binary_only ( bool ) \u2013 defaults to True Returns BranchFactory : Suggestion of the best attribute split. clone Return a fresh estimator with the same parameters. The clone has the same parameters but has not been updated with any data. This works by looking at the parameters from the class signature. Each parameter is either - recursively cloned if it's a River classes. - deep-copied via copy.deepcopy if not. If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters. cond_proba Not implemented in regression splitters. Parameters att_val target_val ( Union[bool, str, int] ) remove_bad_splits Remove bad splits. Based on FIMT-DD's [^1] procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed). Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound ( \\(\\epsilon\\) ) are used to decide upon creating a split. A split occurs when \\(r < 1 - \\epsilon\\) . A split candidate, with merit \\(m_i\\) , is considered badr if \\(m_i / m_1 < r - 2\\epsilon\\) . The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\) , then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed. To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in [^1]. Parameters criterion last_check_ratio ( float ) last_check_vr ( float ) last_check_e ( float ) pre_split_dist ( Union[List, Dict] ) update Update statistics of this observer given an attribute value, its target value and the weight of the instance observed. Parameters att_val target_val ( Union[bool, str, int, numbers.Number] ) sample_weight ( float )","title":"Methods"},{"location":"api/utils/SortedWindow/","text":"SortedWindow \u00b6 Sorted running window data structure. Parameters \u00b6 size ( int ) Size of the window to compute the rolling quantile. Attributes \u00b6 size Examples \u00b6 >>> from river import utils >>> window = utils . SortedWindow ( size = 3 ) >>> for i in reversed ( range ( 9 )): ... print ( window . append ( i )) [ 8 ] [ 7 , 8 ] [ 6 , 7 , 8 ] [ 5 , 6 , 7 ] [ 4 , 5 , 6 ] [ 3 , 4 , 5 ] [ 2 , 3 , 4 ] [ 1 , 2 , 3 ] [ 0 , 1 , 2 ] Methods \u00b6 append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort References \u00b6 Left sorted inserts in Python \u21a9","title":"SortedWindow"},{"location":"api/utils/SortedWindow/#sortedwindow","text":"Sorted running window data structure.","title":"SortedWindow"},{"location":"api/utils/SortedWindow/#parameters","text":"size ( int ) Size of the window to compute the rolling quantile.","title":"Parameters"},{"location":"api/utils/SortedWindow/#attributes","text":"size","title":"Attributes"},{"location":"api/utils/SortedWindow/#examples","text":">>> from river import utils >>> window = utils . SortedWindow ( size = 3 ) >>> for i in reversed ( range ( 9 )): ... print ( window . append ( i )) [ 8 ] [ 7 , 8 ] [ 6 , 7 , 8 ] [ 5 , 6 , 7 ] [ 4 , 5 , 6 ] [ 3 , 4 , 5 ] [ 2 , 3 , 4 ] [ 1 , 2 , 3 ] [ 0 , 1 , 2 ]","title":"Examples"},{"location":"api/utils/SortedWindow/#methods","text":"append S.append(value) -- append value to the end of the sequence Parameters x clear S.clear() -> None -- remove all items from S copy count S.count(value) -> integer -- return number of occurrences of value Parameters item extend S.extend(iterable) -- extend sequence by appending elements from the iterable Parameters other index S.index(value, [start, [stop]]) -> integer -- return first index of value. Raises ValueError if the value is not present. Supporting start and stop arguments is optional, but recommended. Parameters item args insert S.insert(index, value) -- insert value before index Parameters i item pop S.pop([index]) -> item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range. Parameters i \u2013 defaults to -1 remove S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present. Parameters item reverse S.reverse() -- reverse IN PLACE sort","title":"Methods"},{"location":"api/utils/SortedWindow/#references","text":"Left sorted inserts in Python \u21a9","title":"References"},{"location":"api/utils/VectorDict/","text":"VectorDict \u00b6 Methods \u00b6 abs clear get Parameters key args kwargs items keys max maximum Parameters other min minimum Parameters other pop Parameters args kwargs popitem setdefault Parameters key args kwargs to_dict to_numpy Parameters fields update Parameters args kwargs values with_mask Parameters mask copy","title":"VectorDict"},{"location":"api/utils/VectorDict/#vectordict","text":"","title":"VectorDict"},{"location":"api/utils/VectorDict/#methods","text":"abs clear get Parameters key args kwargs items keys max maximum Parameters other min minimum Parameters other pop Parameters args kwargs popitem setdefault Parameters key args kwargs to_dict to_numpy Parameters fields update Parameters args kwargs values with_mask Parameters mask copy","title":"Methods"},{"location":"api/utils/dict2numpy/","text":"dict2numpy \u00b6 Convert a dictionary containing data to a numpy array. There is not restriction to the type of keys in data , but values must be strictly numeric. To make sure random permutations of the features do not impact on the learning algorithms, keys are first converted to strings and then sorted prior to the conversion. Parameters \u00b6 data A dictionary whose keys represent input attributes and the values represent their observed contents. Examples \u00b6 >>> from river.utils import dict2numpy >>> dict2numpy ({ 'a' : 1 , 'b' : 2 , 3 : 3 }) array ([ 3 , 1 , 2 ])","title":"dict2numpy"},{"location":"api/utils/dict2numpy/#dict2numpy","text":"Convert a dictionary containing data to a numpy array. There is not restriction to the type of keys in data , but values must be strictly numeric. To make sure random permutations of the features do not impact on the learning algorithms, keys are first converted to strings and then sorted prior to the conversion.","title":"dict2numpy"},{"location":"api/utils/dict2numpy/#parameters","text":"data A dictionary whose keys represent input attributes and the values represent their observed contents.","title":"Parameters"},{"location":"api/utils/dict2numpy/#examples","text":">>> from river.utils import dict2numpy >>> dict2numpy ({ 'a' : 1 , 'b' : 2 , 3 : 3 }) array ([ 3 , 1 , 2 ])","title":"Examples"},{"location":"api/utils/expand-param-grid/","text":"expand_param_grid \u00b6 Expands a grid of parameters. This method can be used to generate a list of model parametrizations from a dictionary where each parameter is associated with a list of possible parameters. In other words, it expands a grid of parameters. Typically, this method can be used to create copies of a given model with different parameter choices. The models can then be used as part of a model selection process, such as a selection.SuccessiveHalvingClassifier or a selection.EWARegressor . The syntax for the parameter grid is quite flexible. It allows nesting parameters and can therefore be used to generate parameters for a pipeline. Parameters \u00b6 model ( base.Estimator ) grid ( dict ) The grid of parameters to expand. The provided dictionary can be nested. The only requirement is that the values at the leaves need to be lists. Examples \u00b6 As an initial example, we can expand a grid of parameters for a single model. >>> from river import linear_model >>> from river import optim >>> from river import utils >>> model = linear_model . LinearRegression () >>> grid = { 'optimizer' : [ optim . SGD ( .1 ), optim . SGD ( .01 ), optim . SGD ( .001 )]} >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 3 >>> models [ 0 ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.1 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) You can expand parameters for multiple choices like so: >>> grid = { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 , .001 ]}), ... ( optim . Adam , { 'lr' : [ .1 , .01 , .01 ]}) ... ] ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 6 You may specify a grid of parameters for a pipeline via nesting: >>> from river import feature_extraction >>> model = ( ... feature_extraction . BagOfWords () | ... linear_model . LinearRegression () ... ) >>> grid = { ... 'BagOfWords' : { ... 'strip_accents' : [ False , True ] ... }, ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 ]}), ... ( optim . Adam , { 'lr' : [ .1 , .01 ]}) ... ] ... } ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 8","title":"expand_param_grid"},{"location":"api/utils/expand-param-grid/#expand_param_grid","text":"Expands a grid of parameters. This method can be used to generate a list of model parametrizations from a dictionary where each parameter is associated with a list of possible parameters. In other words, it expands a grid of parameters. Typically, this method can be used to create copies of a given model with different parameter choices. The models can then be used as part of a model selection process, such as a selection.SuccessiveHalvingClassifier or a selection.EWARegressor . The syntax for the parameter grid is quite flexible. It allows nesting parameters and can therefore be used to generate parameters for a pipeline.","title":"expand_param_grid"},{"location":"api/utils/expand-param-grid/#parameters","text":"model ( base.Estimator ) grid ( dict ) The grid of parameters to expand. The provided dictionary can be nested. The only requirement is that the values at the leaves need to be lists.","title":"Parameters"},{"location":"api/utils/expand-param-grid/#examples","text":"As an initial example, we can expand a grid of parameters for a single model. >>> from river import linear_model >>> from river import optim >>> from river import utils >>> model = linear_model . LinearRegression () >>> grid = { 'optimizer' : [ optim . SGD ( .1 ), optim . SGD ( .01 ), optim . SGD ( .001 )]} >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 3 >>> models [ 0 ] LinearRegression ( optimizer = SGD ( lr = Constant ( learning_rate = 0.1 ) ) loss = Squared () l2 = 0. l1 = 0. intercept_init = 0. intercept_lr = Constant ( learning_rate = 0.01 ) clip_gradient = 1e+12 initializer = Zeros () ) You can expand parameters for multiple choices like so: >>> grid = { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 , .001 ]}), ... ( optim . Adam , { 'lr' : [ .1 , .01 , .01 ]}) ... ] ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 6 You may specify a grid of parameters for a pipeline via nesting: >>> from river import feature_extraction >>> model = ( ... feature_extraction . BagOfWords () | ... linear_model . LinearRegression () ... ) >>> grid = { ... 'BagOfWords' : { ... 'strip_accents' : [ False , True ] ... }, ... 'LinearRegression' : { ... 'optimizer' : [ ... ( optim . SGD , { 'lr' : [ .1 , .01 ]}), ... ( optim . Adam , { 'lr' : [ .1 , .01 ]}) ... ] ... } ... } >>> models = utils . expand_param_grid ( model , grid ) >>> len ( models ) 8","title":"Examples"},{"location":"api/utils/log-method-calls/","text":"log_method_calls \u00b6 A context manager to log method calls. All method calls will be logged by default. This behavior can be overriden by passing filtering functions. Parameters \u00b6 class_condition ( Callable[[Any], bool] ) \u2013 defaults to None A function which determines if a class should be logged or not. method_condition ( Callable[[Any], bool] ) \u2013 defaults to None A function which determines if a method should be logged or not. Examples \u00b6 >>> import io >>> import logging >>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import preprocessing >>> from river import utils >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees ( seed = 42 ) ... ) >>> class_condition = lambda x : x . __class__ . __name__ in ( 'MinMaxScaler' , 'HalfSpaceTrees' ) >>> logger = logging . getLogger () >>> logger . setLevel ( logging . DEBUG ) >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ): ... for x , y in datasets . CreditCard () . take ( 1 ): ... score = model . score_one ( x ) ... model = model . learn_one ( x ) >>> print ( logs . getvalue ()) MinMaxScaler . learn_one MinMaxScaler . transform_one HalfSpaceTrees . score_one MinMaxScaler . transform_one HalfSpaceTrees . learn_one >>> logs . close ()","title":"log_method_calls"},{"location":"api/utils/log-method-calls/#log_method_calls","text":"A context manager to log method calls. All method calls will be logged by default. This behavior can be overriden by passing filtering functions.","title":"log_method_calls"},{"location":"api/utils/log-method-calls/#parameters","text":"class_condition ( Callable[[Any], bool] ) \u2013 defaults to None A function which determines if a class should be logged or not. method_condition ( Callable[[Any], bool] ) \u2013 defaults to None A function which determines if a method should be logged or not.","title":"Parameters"},{"location":"api/utils/log-method-calls/#examples","text":">>> import io >>> import logging >>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import preprocessing >>> from river import utils >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees ( seed = 42 ) ... ) >>> class_condition = lambda x : x . __class__ . __name__ in ( 'MinMaxScaler' , 'HalfSpaceTrees' ) >>> logger = logging . getLogger () >>> logger . setLevel ( logging . DEBUG ) >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ): ... for x , y in datasets . CreditCard () . take ( 1 ): ... score = model . score_one ( x ) ... model = model . learn_one ( x ) >>> print ( logs . getvalue ()) MinMaxScaler . learn_one MinMaxScaler . transform_one HalfSpaceTrees . score_one MinMaxScaler . transform_one HalfSpaceTrees . learn_one >>> logs . close ()","title":"Examples"},{"location":"api/utils/numpy2dict/","text":"numpy2dict \u00b6 Convert a numpy array to a dictionary. Parameters \u00b6 data ( numpy.ndarray ) An one-dimensional numpy.array. Examples \u00b6 >>> import numpy as np >>> from river.utils import numpy2dict >>> numpy2dict ( np . array ([ 1.0 , 2.0 , 3.0 ])) { 0 : 1.0 , 1 : 2.0 , 2 : 3.0 }","title":"numpy2dict"},{"location":"api/utils/numpy2dict/#numpy2dict","text":"Convert a numpy array to a dictionary.","title":"numpy2dict"},{"location":"api/utils/numpy2dict/#parameters","text":"data ( numpy.ndarray ) An one-dimensional numpy.array.","title":"Parameters"},{"location":"api/utils/numpy2dict/#examples","text":">>> import numpy as np >>> from river.utils import numpy2dict >>> numpy2dict ( np . array ([ 1.0 , 2.0 , 3.0 ])) { 0 : 1.0 , 1 : 2.0 , 2 : 3.0 }","title":"Examples"},{"location":"api/utils/pure-inference-mode/","text":"pure_inference_mode \u00b6 A context manager for making inferences with no side-effects. Calling predict_one with a pipeline will update the unsupervised steps of the pipeline. This is the expected behavior for online machine learning. However, in some cases you might just want to produce predictions without necessarily updating anything. This context manager allows you to override that behavior and make it so that unsupervised estimators are not updated when predict_one is called. Examples \u00b6 Let's first see what methods are called if we just call predict_one . >>> import io >>> import logging >>> from river import compose >>> from river import datasets >>> from river import linear_model >>> from river import preprocessing >>> from river import utils >>> model = compose . Pipeline ( ... preprocessing . StandardScaler (), ... linear_model . LinearRegression () ... ) >>> class_condition = lambda x : x . __class__ . __name__ in ( 'StandardScaler' , 'LinearRegression' ) >>> logger = logging . getLogger () >>> logger . setLevel ( logging . DEBUG ) >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ): ... for x , y in datasets . TrumpApproval () . take ( 1 ): ... _ = model . predict_one ( x ) >>> print ( logs . getvalue ()) StandardScaler . learn_one StandardScaler . transform_one LinearRegression . predict_one Now let's use the context manager and see what methods get called. >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ), utils . pure_inference_mode (): ... for x , y in datasets . TrumpApproval () . take ( 1 ): ... _ = model . predict_one ( x ) >>> print ( logs . getvalue ()) StandardScaler . transform_one LinearRegression . predict_one We can see that the scaler did not get updated before transforming the data.","title":"pure_inference_mode"},{"location":"api/utils/pure-inference-mode/#pure_inference_mode","text":"A context manager for making inferences with no side-effects. Calling predict_one with a pipeline will update the unsupervised steps of the pipeline. This is the expected behavior for online machine learning. However, in some cases you might just want to produce predictions without necessarily updating anything. This context manager allows you to override that behavior and make it so that unsupervised estimators are not updated when predict_one is called.","title":"pure_inference_mode"},{"location":"api/utils/pure-inference-mode/#examples","text":"Let's first see what methods are called if we just call predict_one . >>> import io >>> import logging >>> from river import compose >>> from river import datasets >>> from river import linear_model >>> from river import preprocessing >>> from river import utils >>> model = compose . Pipeline ( ... preprocessing . StandardScaler (), ... linear_model . LinearRegression () ... ) >>> class_condition = lambda x : x . __class__ . __name__ in ( 'StandardScaler' , 'LinearRegression' ) >>> logger = logging . getLogger () >>> logger . setLevel ( logging . DEBUG ) >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ): ... for x , y in datasets . TrumpApproval () . take ( 1 ): ... _ = model . predict_one ( x ) >>> print ( logs . getvalue ()) StandardScaler . learn_one StandardScaler . transform_one LinearRegression . predict_one Now let's use the context manager and see what methods get called. >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ), utils . pure_inference_mode (): ... for x , y in datasets . TrumpApproval () . take ( 1 ): ... _ = model . predict_one ( x ) >>> print ( logs . getvalue ()) StandardScaler . transform_one LinearRegression . predict_one We can see that the scaler did not get updated before transforming the data.","title":"Examples"},{"location":"api/utils/warm-up-mode/","text":"warm_up_mode \u00b6 A context manager for training pipelines during a warm-up phase. You don't have to worry about anything when you call predict_one and learn_one with a pipeline during in a training loop. The methods at each step of the pipeline will be called in the correct order. However, during a warm-up phase, you might just be calling learn_one because you don't need the out-of-sample predictions. In this case the unsupervised estimators in the pipeline won't be updated, because they are usually updated when predict_one is called. This context manager allows you to override that behavior and make it so that unsupervised estimators are updated when learn_one is called. Examples \u00b6 Let's first see what methods are called if we just call learn_one . >>> import io >>> import logging >>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import preprocessing >>> from river import utils >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees () ... ) >>> class_condition = lambda x : x . __class__ . __name__ in ( 'MinMaxScaler' , 'HalfSpaceTrees' ) >>> logger = logging . getLogger () >>> logger . setLevel ( logging . DEBUG ) >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ): ... for x , y in datasets . CreditCard () . take ( 1 ): ... model = model . learn_one ( x ) >>> print ( logs . getvalue ()) MinMaxScaler . transform_one HalfSpaceTrees . learn_one Now let's use the context manager and see what methods get called. >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ), utils . warm_up_mode (): ... for x , y in datasets . CreditCard () . take ( 1 ): ... model = model . learn_one ( x ) >>> print ( logs . getvalue ()) MinMaxScaler . learn_one MinMaxScaler . transform_one HalfSpaceTrees . learn_one We can see that the scaler got updated before transforming the data.","title":"warm_up_mode"},{"location":"api/utils/warm-up-mode/#warm_up_mode","text":"A context manager for training pipelines during a warm-up phase. You don't have to worry about anything when you call predict_one and learn_one with a pipeline during in a training loop. The methods at each step of the pipeline will be called in the correct order. However, during a warm-up phase, you might just be calling learn_one because you don't need the out-of-sample predictions. In this case the unsupervised estimators in the pipeline won't be updated, because they are usually updated when predict_one is called. This context manager allows you to override that behavior and make it so that unsupervised estimators are updated when learn_one is called.","title":"warm_up_mode"},{"location":"api/utils/warm-up-mode/#examples","text":"Let's first see what methods are called if we just call learn_one . >>> import io >>> import logging >>> from river import anomaly >>> from river import compose >>> from river import datasets >>> from river import preprocessing >>> from river import utils >>> model = compose . Pipeline ( ... preprocessing . MinMaxScaler (), ... anomaly . HalfSpaceTrees () ... ) >>> class_condition = lambda x : x . __class__ . __name__ in ( 'MinMaxScaler' , 'HalfSpaceTrees' ) >>> logger = logging . getLogger () >>> logger . setLevel ( logging . DEBUG ) >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ): ... for x , y in datasets . CreditCard () . take ( 1 ): ... model = model . learn_one ( x ) >>> print ( logs . getvalue ()) MinMaxScaler . transform_one HalfSpaceTrees . learn_one Now let's use the context manager and see what methods get called. >>> logs = io . StringIO () >>> sh = logging . StreamHandler ( logs ) >>> sh . setLevel ( logging . DEBUG ) >>> logger . addHandler ( sh ) >>> with utils . log_method_calls ( class_condition ), utils . warm_up_mode (): ... for x , y in datasets . CreditCard () . take ( 1 ): ... model = model . learn_one ( x ) >>> print ( logs . getvalue ()) MinMaxScaler . learn_one MinMaxScaler . transform_one HalfSpaceTrees . learn_one We can see that the scaler got updated before transforming the data.","title":"Examples"},{"location":"api/utils/math/argmax/","text":"argmax \u00b6 Argmax function. Parameters \u00b6 lst ( list )","title":"argmax"},{"location":"api/utils/math/argmax/#argmax","text":"Argmax function.","title":"argmax"},{"location":"api/utils/math/argmax/#parameters","text":"lst ( list )","title":"Parameters"},{"location":"api/utils/math/chain-dot/","text":"chain_dot \u00b6 Returns the dot product of multiple vectors represented as dicts. Parameters \u00b6 xs Examples \u00b6 >>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 , 'x2' : 1 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> z = { 'x1' : 2 , 'x2' : 1 / 3 } >>> utils . math . chain_dot ( x , y , z ) 85.0","title":"chain_dot"},{"location":"api/utils/math/chain-dot/#chain_dot","text":"Returns the dot product of multiple vectors represented as dicts.","title":"chain_dot"},{"location":"api/utils/math/chain-dot/#parameters","text":"xs","title":"Parameters"},{"location":"api/utils/math/chain-dot/#examples","text":">>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 , 'x2' : 1 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> z = { 'x1' : 2 , 'x2' : 1 / 3 } >>> utils . math . chain_dot ( x , y , z ) 85.0","title":"Examples"},{"location":"api/utils/math/clamp/","text":"clamp \u00b6 Clamp a number. This is a synonym of clipping. Parameters \u00b6 x ( float ) minimum \u2013 defaults to 0.0 maximum \u2013 defaults to 1.0","title":"clamp"},{"location":"api/utils/math/clamp/#clamp","text":"Clamp a number. This is a synonym of clipping.","title":"clamp"},{"location":"api/utils/math/clamp/#parameters","text":"x ( float ) minimum \u2013 defaults to 0.0 maximum \u2013 defaults to 1.0","title":"Parameters"},{"location":"api/utils/math/dot/","text":"dot \u00b6 Returns the dot product of two vectors represented as dicts. Parameters \u00b6 x ( dict ) y ( dict ) Examples \u00b6 >>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> utils . math . dot ( x , y ) 42","title":"dot"},{"location":"api/utils/math/dot/#dot","text":"Returns the dot product of two vectors represented as dicts.","title":"dot"},{"location":"api/utils/math/dot/#parameters","text":"x ( dict ) y ( dict )","title":"Parameters"},{"location":"api/utils/math/dot/#examples","text":">>> from river import utils >>> x = { 'x0' : 1 , 'x1' : 2 } >>> y = { 'x1' : 21 , 'x2' : 3 } >>> utils . math . dot ( x , y ) 42","title":"Examples"},{"location":"api/utils/math/dotvecmat/","text":"dotvecmat \u00b6 Vector times matrix from left side, i.e. transpose(x)A. Parameters \u00b6 x A Examples \u00b6 >>> from river import utils >>> x = { 0 : 4 , 1 : 5 } >>> A = { ... ( 0 , 0 ): 0 , ( 0 , 1 ): 1 , ... ( 1 , 0 ): 2 , ( 1 , 1 ): 3 ... } >>> C = dotvecmat ( x , A ) >>> print ( C ) { 0 : 10.0 , 1 : 19.0 }","title":"dotvecmat"},{"location":"api/utils/math/dotvecmat/#dotvecmat","text":"Vector times matrix from left side, i.e. transpose(x)A.","title":"dotvecmat"},{"location":"api/utils/math/dotvecmat/#parameters","text":"x A","title":"Parameters"},{"location":"api/utils/math/dotvecmat/#examples","text":">>> from river import utils >>> x = { 0 : 4 , 1 : 5 } >>> A = { ... ( 0 , 0 ): 0 , ( 0 , 1 ): 1 , ... ( 1 , 0 ): 2 , ( 1 , 1 ): 3 ... } >>> C = dotvecmat ( x , A ) >>> print ( C ) { 0 : 10.0 , 1 : 19.0 }","title":"Examples"},{"location":"api/utils/math/matmul2d/","text":"matmul2d \u00b6 Multiplication for 2D matrices. Parameters \u00b6 A B Examples \u00b6 >>> import pprint >>> from river import utils >>> A = { ... ( 0 , 0 ): 2 , ( 0 , 1 ): 0 , ( 0 , 2 ): 4 , ... ( 1 , 0 ): 5 , ( 1 , 1 ): 6 , ( 1 , 2 ): 0 ... } >>> B = { ... ( 0 , 0 ): 1 , ( 0 , 1 ): 1 , ( 0 , 2 ): 0 , ( 0 , 3 ): 0 , ... ( 1 , 0 ): 2 , ( 1 , 1 ): 0 , ( 1 , 2 ): 1 , ( 1 , 3 ): 3 , ... ( 2 , 0 ): 4 , ( 2 , 1 ): 0 , ( 2 , 2 ): 0 , ( 2 , 3 ): 0 ... } >>> C = matmul2d ( A , B ) >>> pprint . pprint ( C ) {( 0 , 0 ): 18.0 , ( 0 , 1 ): 2.0 , ( 0 , 2 ): 0.0 , ( 0 , 3 ): 0.0 , ( 1 , 0 ): 17.0 , ( 1 , 1 ): 5.0 , ( 1 , 2 ): 6.0 , ( 1 , 3 ): 18.0 }","title":"matmul2d"},{"location":"api/utils/math/matmul2d/#matmul2d","text":"Multiplication for 2D matrices.","title":"matmul2d"},{"location":"api/utils/math/matmul2d/#parameters","text":"A B","title":"Parameters"},{"location":"api/utils/math/matmul2d/#examples","text":">>> import pprint >>> from river import utils >>> A = { ... ( 0 , 0 ): 2 , ( 0 , 1 ): 0 , ( 0 , 2 ): 4 , ... ( 1 , 0 ): 5 , ( 1 , 1 ): 6 , ( 1 , 2 ): 0 ... } >>> B = { ... ( 0 , 0 ): 1 , ( 0 , 1 ): 1 , ( 0 , 2 ): 0 , ( 0 , 3 ): 0 , ... ( 1 , 0 ): 2 , ( 1 , 1 ): 0 , ( 1 , 2 ): 1 , ( 1 , 3 ): 3 , ... ( 2 , 0 ): 4 , ( 2 , 1 ): 0 , ( 2 , 2 ): 0 , ( 2 , 3 ): 0 ... } >>> C = matmul2d ( A , B ) >>> pprint . pprint ( C ) {( 0 , 0 ): 18.0 , ( 0 , 1 ): 2.0 , ( 0 , 2 ): 0.0 , ( 0 , 3 ): 0.0 , ( 1 , 0 ): 17.0 , ( 1 , 1 ): 5.0 , ( 1 , 2 ): 6.0 , ( 1 , 3 ): 18.0 }","title":"Examples"},{"location":"api/utils/math/minkowski-distance/","text":"minkowski_distance \u00b6 Minkowski distance. Parameters \u00b6 a ( dict ) b ( dict ) p ( int ) Parameter for the Minkowski distance. When p=1 , this is equivalent to using the Manhattan distance. When p=2 , this is equivalent to using the Euclidean distance.","title":"minkowski_distance"},{"location":"api/utils/math/minkowski-distance/#minkowski_distance","text":"Minkowski distance.","title":"minkowski_distance"},{"location":"api/utils/math/minkowski-distance/#parameters","text":"a ( dict ) b ( dict ) p ( int ) Parameter for the Minkowski distance. When p=1 , this is equivalent to using the Manhattan distance. When p=2 , this is equivalent to using the Euclidean distance.","title":"Parameters"},{"location":"api/utils/math/norm/","text":"norm \u00b6 Compute the norm of a dictionaries values. Parameters \u00b6 x ( dict ) order \u2013 defaults to None","title":"norm"},{"location":"api/utils/math/norm/#norm","text":"Compute the norm of a dictionaries values.","title":"norm"},{"location":"api/utils/math/norm/#parameters","text":"x ( dict ) order \u2013 defaults to None","title":"Parameters"},{"location":"api/utils/math/outer/","text":"outer \u00b6 Outer-product between two vectors. Parameters \u00b6 u ( dict ) v ( dict ) Examples \u00b6 >>> import pprint >>> from river import utils >>> u = dict ( enumerate (( 1 , 2 , 3 ))) >>> v = dict ( enumerate (( 2 , 4 , 8 ))) >>> uTv = utils . math . outer ( u , v ) >>> pprint . pprint ( uTv ) {( 0 , 0 ): 2 , ( 0 , 1 ): 4 , ( 0 , 2 ): 8 , ( 1 , 0 ): 4 , ( 1 , 1 ): 8 , ( 1 , 2 ): 16 , ( 2 , 0 ): 6 , ( 2 , 1 ): 12 , ( 2 , 2 ): 24 }","title":"outer"},{"location":"api/utils/math/outer/#outer","text":"Outer-product between two vectors.","title":"outer"},{"location":"api/utils/math/outer/#parameters","text":"u ( dict ) v ( dict )","title":"Parameters"},{"location":"api/utils/math/outer/#examples","text":">>> import pprint >>> from river import utils >>> u = dict ( enumerate (( 1 , 2 , 3 ))) >>> v = dict ( enumerate (( 2 , 4 , 8 ))) >>> uTv = utils . math . outer ( u , v ) >>> pprint . pprint ( uTv ) {( 0 , 0 ): 2 , ( 0 , 1 ): 4 , ( 0 , 2 ): 8 , ( 1 , 0 ): 4 , ( 1 , 1 ): 8 , ( 1 , 2 ): 16 , ( 2 , 0 ): 6 , ( 2 , 1 ): 12 , ( 2 , 2 ): 24 }","title":"Examples"},{"location":"api/utils/math/prod/","text":"prod \u00b6 Product function. Parameters \u00b6 iterable","title":"prod"},{"location":"api/utils/math/prod/#prod","text":"Product function.","title":"prod"},{"location":"api/utils/math/prod/#parameters","text":"iterable","title":"Parameters"},{"location":"api/utils/math/sherman-morrison/","text":"sherman_morrison \u00b6 Sherman\u2013Morrison formula. This modifies A_inv inplace. Parameters \u00b6 A_inv ( dict ) u ( dict ) v ( dict ) Examples \u00b6 >>> import pprint >>> from river import utils >>> A_inv = { ... ( 0 , 0 ): 0.2 , ... ( 1 , 1 ): 1 , ... ( 2 , 2 ): 1 ... } >>> u = { 0 : 1 , 1 : 2 , 2 : 3 } >>> v = { 0 : 4 } >>> inv = sherman_morrison ( A_inv , u , v ) >>> pprint . pprint ( inv ) {( 0 , 0 ): 0.111111 , ( 1 , 0 ): - 0.888888 , ( 1 , 1 ): 1 , ( 2 , 0 ): - 1.333333 , ( 2 , 2 ): 1 } References \u00b6 Wikipedia article on the Sherman-Morrison formula s \u21a9","title":"sherman_morrison"},{"location":"api/utils/math/sherman-morrison/#sherman_morrison","text":"Sherman\u2013Morrison formula. This modifies A_inv inplace.","title":"sherman_morrison"},{"location":"api/utils/math/sherman-morrison/#parameters","text":"A_inv ( dict ) u ( dict ) v ( dict )","title":"Parameters"},{"location":"api/utils/math/sherman-morrison/#examples","text":">>> import pprint >>> from river import utils >>> A_inv = { ... ( 0 , 0 ): 0.2 , ... ( 1 , 1 ): 1 , ... ( 2 , 2 ): 1 ... } >>> u = { 0 : 1 , 1 : 2 , 2 : 3 } >>> v = { 0 : 4 } >>> inv = sherman_morrison ( A_inv , u , v ) >>> pprint . pprint ( inv ) {( 0 , 0 ): 0.111111 , ( 1 , 0 ): - 0.888888 , ( 1 , 1 ): 1 , ( 2 , 0 ): - 1.333333 , ( 2 , 2 ): 1 }","title":"Examples"},{"location":"api/utils/math/sherman-morrison/#references","text":"Wikipedia article on the Sherman-Morrison formula s \u21a9","title":"References"},{"location":"api/utils/math/sigmoid/","text":"sigmoid \u00b6 Sigmoid function. Parameters \u00b6 x ( float )","title":"sigmoid"},{"location":"api/utils/math/sigmoid/#sigmoid","text":"Sigmoid function.","title":"sigmoid"},{"location":"api/utils/math/sigmoid/#parameters","text":"x ( float )","title":"Parameters"},{"location":"api/utils/math/sign/","text":"sign \u00b6 Sign function. Parameters \u00b6 x ( float )","title":"sign"},{"location":"api/utils/math/sign/#sign","text":"Sign function.","title":"sign"},{"location":"api/utils/math/sign/#parameters","text":"x ( float )","title":"Parameters"},{"location":"api/utils/math/softmax/","text":"softmax \u00b6 Normalizes a dictionary of predicted probabilities, in-place. Parameters \u00b6 y_pred ( dict )","title":"softmax"},{"location":"api/utils/math/softmax/#softmax","text":"Normalizes a dictionary of predicted probabilities, in-place.","title":"softmax"},{"location":"api/utils/math/softmax/#parameters","text":"y_pred ( dict )","title":"Parameters"},{"location":"api/utils/pretty/humanize-bytes/","text":"humanize_bytes \u00b6 Returns a human-friendly byte size. Parameters \u00b6 n_bytes ( int )","title":"humanize_bytes"},{"location":"api/utils/pretty/humanize-bytes/#humanize_bytes","text":"Returns a human-friendly byte size.","title":"humanize_bytes"},{"location":"api/utils/pretty/humanize-bytes/#parameters","text":"n_bytes ( int )","title":"Parameters"},{"location":"api/utils/pretty/print-table/","text":"print_table \u00b6 Pretty-prints a table. Parameters \u00b6 headers ( List[str] ) The column names. columns ( List[List[str]] ) The column values. order ( List[int] ) \u2013 defaults to None Order in which to print the column the values. Defaults to the order in which the values are given.","title":"print_table"},{"location":"api/utils/pretty/print-table/#print_table","text":"Pretty-prints a table.","title":"print_table"},{"location":"api/utils/pretty/print-table/#parameters","text":"headers ( List[str] ) The column names. columns ( List[List[str]] ) The column values. order ( List[int] ) \u2013 defaults to None Order in which to print the column the values. Defaults to the order in which the values are given.","title":"Parameters"},{"location":"api/utils/random/poisson/","text":"poisson \u00b6 Sample a random value from a Poisson distribution. Parameters \u00b6 rate ( float ) rng \u2013 defaults to <module 'random' from '/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/random.py'> References \u00b6 [^1] Wikipedia article","title":"poisson"},{"location":"api/utils/random/poisson/#poisson","text":"Sample a random value from a Poisson distribution.","title":"poisson"},{"location":"api/utils/random/poisson/#parameters","text":"rate ( float ) rng \u2013 defaults to <module 'random' from '/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/random.py'>","title":"Parameters"},{"location":"api/utils/random/poisson/#references","text":"[^1] Wikipedia article","title":"References"},{"location":"examples/batch-to-online/","text":"From batch to online/stream \u00b6 A quick overview of batch learning \u00b6 If you've already delved into machine learning, then you shouldn't have any difficulty in getting to use incremental learning. If you are somewhat new to machine learning, then do not worry! The point of this notebook in particular is to introduce simple notions. We'll also start to show how river fits in and explain how to use it. The whole point of machine learning is to learn from data . In supervised learning you want to learn how to predict a target \\(y\\) given a set of features \\(X\\) . Meanwhile in an unsupervised learning there is no target, and the goal is rather to identify patterns and trends in the features \\(X\\) . At this point most people tend to imagine \\(X\\) as a somewhat big table where each row is an observation and each column is a feature, and they would be quite right. Learning from tabular data is part of what's called batch learning , which basically that all of the data is available to our learning algorithm at once. Multiple libraries have been created to handle the batch learning regime, with one of the most prominent being Python's scikit-learn . As a simple example of batch learning let's say we want to learn to predict if a women has breast cancer or not. We'll use the breast cancer dataset available with scikit-learn . We'll learn to map a set of features to a binary decision using a logistic regression . Like many other models based on numerical weights, logistic regression is sensitive to the scale of the features. Rescaling the data so that each feature has mean 0 and variance 1 is generally considered good practice. We can apply the rescaling and fit the logistic regression sequentially in an elegant manner using a Pipeline . To measure the performance of the model we'll evaluate the average ROC AUC score using a 5 fold cross-validation . from sklearn import datasets from sklearn import linear_model from sklearn import metrics from sklearn import model_selection from sklearn import pipeline from sklearn import preprocessing # Load the data dataset = datasets . load_breast_cancer () X , y = dataset . data , dataset . target # Define the steps of the model model = pipeline . Pipeline ([ ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LogisticRegression ( solver = 'lbfgs' )) ]) # Define a determistic cross-validation procedure cv = model_selection . KFold ( n_splits = 5 , shuffle = True , random_state = 42 ) # Compute the MSE values scorer = metrics . make_scorer ( metrics . roc_auc_score ) scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.975 (\u00b1 0.011) This might be a lot to take in if you're not accustomed to scikit-learn, but it probably isn't if you are. Batch learning basically boils down to: Loading (and preprocessing) the data Fitting a model to the data Computing the performance of the model on unseen data This is pretty standard and is maybe how most people imagine a machine learning pipeline. However, this way of proceeding has certain downsides. First of all your laptop would crash if the load_boston function returned a dataset who's size exceeds your available amount of RAM. Sometimes you can use some tricks to get around this. For example by optimizing the data types and by using sparse representations when applicable you can potentially save precious gigabytes of RAM. However, like many tricks this only goes so far. If your dataset weighs hundreds of gigabytes then you won't go far without some special hardware. One solution is to do out-of-core learning; that is, algorithms that can learn by being presented the data in chunks or mini-batches. If you want to go down this road then take a look at Dask and Spark's MLlib . Another issue with the batch learning regime is that it can't elegantly learn from new data. Indeed if new data is made available, then the model has to learn from scratch with a new dataset composed of the old data and the new data. This is particularly annoying in a real situation where you might have new incoming data every week, day, hour, minute, or even setting. For example if you're building a recommendation engine for an e-commerce app, then you're probably training your model from 0 every week or so. As your app grows in popularity, so does the dataset you're training on. This will lead to longer and longer training times and might require a hardware upgrade. A final downside that isn't very easy to grasp concerns the manner in which features are extracted. Every time you want to train your model you first have to extract features. The trick is that some features might not be accessible at the particular point in time you are at. For example maybe that some attributes in your data warehouse get overwritten with time. In other words maybe that all the features pertaining to a particular observations are not available, whereas they were a week ago. This happens more often than not in real scenarios, and apart if you have a sophisticated data engineering pipeline then you will encounter these issues at some point. A hands-on introduction to incremental learning \u00b6 Incremental learning is also often called online learning or stream learning , but if you google online learning a lot of the results will point to educational websites. Hence, the terms \"incremental learning\" and \"stream learning\" (from which river derives it's name) are prefered. The point of incremental learning is to fit a model to a stream of data. In other words, the data isn't available in it's entirety, but rather the observations are provided one by one. As an example let's stream through the dataset used previously. for xi , yi in zip ( X , y ): # This is where the model learns pass In this case we're iterating over a dataset that is already in memory, but we could just as well stream from a CSV file, a Kafka stream, an SQL query, etc. If we look at xi we can notice that it is a numpy.ndarray . xi array([7.760e+00, 2.454e+01, 4.792e+01, 1.810e+02, 5.263e-02, 4.362e-02, 0.000e+00, 0.000e+00, 1.587e-01, 5.884e-02, 3.857e-01, 1.428e+00, 2.548e+00, 1.915e+01, 7.189e-03, 4.660e-03, 0.000e+00, 0.000e+00, 2.676e-02, 2.783e-03, 9.456e+00, 3.037e+01, 5.916e+01, 2.686e+02, 8.996e-02, 6.444e-02, 0.000e+00, 0.000e+00, 2.871e-01, 7.039e-02]) river by design works with dict s. We believe that dict s are more enjoyable to program with than numpy.ndarray s, at least for when single observations are concerned. dict 's bring the added benefit that each feature can be accessed by name rather than by position. for xi , yi in zip ( X , y ): xi = dict ( zip ( dataset . feature_names , xi )) pass xi {'mean radius': 7.76, 'mean texture': 24.54, 'mean perimeter': 47.92, 'mean area': 181.0, 'mean smoothness': 0.05263, 'mean compactness': 0.04362, 'mean concavity': 0.0, 'mean concave points': 0.0, 'mean symmetry': 0.1587, 'mean fractal dimension': 0.05884, 'radius error': 0.3857, 'texture error': 1.428, 'perimeter error': 2.548, 'area error': 19.15, 'smoothness error': 0.007189, 'compactness error': 0.00466, 'concavity error': 0.0, 'concave points error': 0.0, 'symmetry error': 0.02676, 'fractal dimension error': 0.002783, 'worst radius': 9.456, 'worst texture': 30.37, 'worst perimeter': 59.16, 'worst area': 268.6, 'worst smoothness': 0.08996, 'worst compactness': 0.06444, 'worst concavity': 0.0, 'worst concave points': 0.0, 'worst symmetry': 0.2871, 'worst fractal dimension': 0.07039} Conveniently, river 's stream module has an iter_sklearn_dataset method that we can use instead. from river import stream for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): pass The simple fact that we are getting the data as a stream means that we can't do a lot of things the same way as in a batch setting. For example let's say we want to scale the data so that it has mean 0 and variance 1, as we did earlier. To do so we simply have to subtract the mean of each feature to each value and then divide the result by the standard deviation of the feature. The problem is that we can't possible known the values of the mean and the standard deviation before actually going through all the data! One way to proceed would be to do a first pass over the data to compute the necessary values and then scale the values during a second pass. The problem is that this defeats our purpose, which is to learn by only looking at the data once. Although this might seem rather restrictive, it reaps sizable benefits down the road. The way we do feature scaling in river involves computing running statistics (also know as moving statistics ). The idea is that we use a data structure that estimates the mean and updates itself when it is provided with a value. The same goes for the variance (and thus the standard deviation). For example, if we denote \\(\\mu_t\\) the mean and \\(n_t\\) the count at any moment \\(t\\) , then updating the mean can be done as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\end{cases} \\] Likewise, the running variance can be computed as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\\\ s_{t+1} = s_t + (x - \\mu_t) \\times (x - \\mu_{t+1}) \\\\ \\sigma_{t+1} = \\frac{s_{t+1}}{n_{t+1}} \\end{cases} \\] where \\(s_t\\) is a running sum of squares and \\(\\sigma_t\\) is the running variance at time \\(t\\) . This might seem a tad more involved than the batch algorithms you learn in school, but it is rather elegant. Implementing this in Python is not too difficult. For example let's compute the running mean and variance of the 'mean area' variable. n , mean , sum_of_squares , variance = 0 , 0 , 0 , 0 for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): n += 1 old_mean = mean mean += ( xi [ 'mean area' ] - mean ) / n sum_of_squares += ( xi [ 'mean area' ] - old_mean ) * ( xi [ 'mean area' ] - mean ) variance = sum_of_squares / n print ( f 'Running mean: { mean : .3f } ' ) print ( f 'Running variance: { variance : .3f } ' ) Running mean: 654.889 Running variance: 123625.903 Let's compare this with numpy . But remember, numpy requires access to \"all\" the data. import numpy as np i = list ( dataset . feature_names ) . index ( 'mean area' ) print ( f 'True mean: { np . mean ( X [:, i ]) : .3f } ' ) print ( f 'True variance: { np . var ( X [:, i ]) : .3f } ' ) True mean: 654.889 True variance: 123625.903 The results seem to be exactly the same! The twist is that the running statistics won't be very accurate for the first few observations. In general though this doesn't matter too much. Some would even go as far as to say that this descrepancy is beneficial and acts as some sort of regularization... Now the idea is that we can compute the running statistics of each feature and scale them as they come along. The way to do this with river is to use the StandardScaler class from the preprocessing module, as so: from river import preprocessing scaler = preprocessing . StandardScaler () for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): scaler = scaler . learn_one ( xi ) Now that we are scaling the data, we can start doing some actual machine learning. We're going to implement an online linear regression task. Because all the data isn't available at once, we are obliged to do what is called stochastic gradient descent , which is a popular research topic and has a lot of variants. SGD is commonly used to train neural networks. The idea is that at each step we compute the loss between the target prediction and the truth. We then calculate the gradient, which is simply a set of derivatives with respect to each weight from the linear regression. Once we have obtained the gradient, we can update the weights by moving them in the opposite direction of the gradient. The amount by which the weights are moved typically depends on a learning rate , which is typically set by the user. Different optimizers have different ways of managing the weight update, and some handle the learning rate implicitly. Online linear regression can be done in river with the LinearRegression class from the linear_model module. We'll be using plain and simple SGD using the SGD optimizer from the optim module. During training we'll measure the squared error between the truth and the predictions. from river import linear_model from river import optim scaler = preprocessing . StandardScaler () optimizer = optim . SGD ( lr = 0.01 ) log_reg = linear_model . LogisticRegression ( optimizer ) y_true = [] y_pred = [] for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer (), shuffle = True , seed = 42 ): # Scale the features xi_scaled = scaler . learn_one ( xi ) . transform_one ( xi ) # Test the current model on the new \"unobserved\" sample yi_pred = log_reg . predict_proba_one ( xi_scaled ) # Train the model with the new sample log_reg . learn_one ( xi_scaled , yi ) # Store the truth and the prediction y_true . append ( yi ) y_pred . append ( yi_pred [ True ]) print ( f 'ROC AUC: { metrics . roc_auc_score ( y_true , y_pred ) : .3f } ' ) ROC AUC: 0.990 The ROC AUC is significantly better than the one obtained from the cross-validation of scikit-learn's logisitic regression. However to make things really comparable it would be nice to compare with the same cross-validation procedure. river has a compat module that contains utilities for making river compatible with other Python libraries. Because we're doing regression we'll be using the SKLRegressorWrapper . We'll also be using Pipeline to encapsulate the logic of the StandardScaler and the LogisticRegression in one single object. from river import compat from river import compose # We define a Pipeline, exactly like we did earlier for sklearn model = compose . Pipeline ( ( 'scale' , preprocessing . StandardScaler ()), ( 'log_reg' , linear_model . LogisticRegression ()) ) # We make the Pipeline compatible with sklearn model = compat . convert_river_to_sklearn ( model ) # We compute the CV scores using the same CV scheme and the same scoring scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.964 (\u00b1 0.016) This time the ROC AUC score is lower, which is what we would expect. Indeed online learning isn't as accurate as batch learning. However it all depends in what you're interested in. If you're only interested in predicting the next observation then the online learning regime would be better. That's why it's a bit hard to compare both approaches: they're both suited to different scenarios. Going further \u00b6 Here a few resources if you want to do some reading: Online learning -- Wikipedia What is online machine learning? -- Max Pagels Introduction to Online Learning -- USC course Online Methods in Machine Learning -- MIT course Online Learning: A Comprehensive Survey Streaming 101: The world beyond batch Machine learning for data streams Data Stream Mining: A Practical Approach","title":"From batch to online/stream"},{"location":"examples/batch-to-online/#from-batch-to-onlinestream","text":"","title":"From batch to online/stream"},{"location":"examples/batch-to-online/#a-quick-overview-of-batch-learning","text":"If you've already delved into machine learning, then you shouldn't have any difficulty in getting to use incremental learning. If you are somewhat new to machine learning, then do not worry! The point of this notebook in particular is to introduce simple notions. We'll also start to show how river fits in and explain how to use it. The whole point of machine learning is to learn from data . In supervised learning you want to learn how to predict a target \\(y\\) given a set of features \\(X\\) . Meanwhile in an unsupervised learning there is no target, and the goal is rather to identify patterns and trends in the features \\(X\\) . At this point most people tend to imagine \\(X\\) as a somewhat big table where each row is an observation and each column is a feature, and they would be quite right. Learning from tabular data is part of what's called batch learning , which basically that all of the data is available to our learning algorithm at once. Multiple libraries have been created to handle the batch learning regime, with one of the most prominent being Python's scikit-learn . As a simple example of batch learning let's say we want to learn to predict if a women has breast cancer or not. We'll use the breast cancer dataset available with scikit-learn . We'll learn to map a set of features to a binary decision using a logistic regression . Like many other models based on numerical weights, logistic regression is sensitive to the scale of the features. Rescaling the data so that each feature has mean 0 and variance 1 is generally considered good practice. We can apply the rescaling and fit the logistic regression sequentially in an elegant manner using a Pipeline . To measure the performance of the model we'll evaluate the average ROC AUC score using a 5 fold cross-validation . from sklearn import datasets from sklearn import linear_model from sklearn import metrics from sklearn import model_selection from sklearn import pipeline from sklearn import preprocessing # Load the data dataset = datasets . load_breast_cancer () X , y = dataset . data , dataset . target # Define the steps of the model model = pipeline . Pipeline ([ ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LogisticRegression ( solver = 'lbfgs' )) ]) # Define a determistic cross-validation procedure cv = model_selection . KFold ( n_splits = 5 , shuffle = True , random_state = 42 ) # Compute the MSE values scorer = metrics . make_scorer ( metrics . roc_auc_score ) scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.975 (\u00b1 0.011) This might be a lot to take in if you're not accustomed to scikit-learn, but it probably isn't if you are. Batch learning basically boils down to: Loading (and preprocessing) the data Fitting a model to the data Computing the performance of the model on unseen data This is pretty standard and is maybe how most people imagine a machine learning pipeline. However, this way of proceeding has certain downsides. First of all your laptop would crash if the load_boston function returned a dataset who's size exceeds your available amount of RAM. Sometimes you can use some tricks to get around this. For example by optimizing the data types and by using sparse representations when applicable you can potentially save precious gigabytes of RAM. However, like many tricks this only goes so far. If your dataset weighs hundreds of gigabytes then you won't go far without some special hardware. One solution is to do out-of-core learning; that is, algorithms that can learn by being presented the data in chunks or mini-batches. If you want to go down this road then take a look at Dask and Spark's MLlib . Another issue with the batch learning regime is that it can't elegantly learn from new data. Indeed if new data is made available, then the model has to learn from scratch with a new dataset composed of the old data and the new data. This is particularly annoying in a real situation where you might have new incoming data every week, day, hour, minute, or even setting. For example if you're building a recommendation engine for an e-commerce app, then you're probably training your model from 0 every week or so. As your app grows in popularity, so does the dataset you're training on. This will lead to longer and longer training times and might require a hardware upgrade. A final downside that isn't very easy to grasp concerns the manner in which features are extracted. Every time you want to train your model you first have to extract features. The trick is that some features might not be accessible at the particular point in time you are at. For example maybe that some attributes in your data warehouse get overwritten with time. In other words maybe that all the features pertaining to a particular observations are not available, whereas they were a week ago. This happens more often than not in real scenarios, and apart if you have a sophisticated data engineering pipeline then you will encounter these issues at some point.","title":"A quick overview of batch learning"},{"location":"examples/batch-to-online/#a-hands-on-introduction-to-incremental-learning","text":"Incremental learning is also often called online learning or stream learning , but if you google online learning a lot of the results will point to educational websites. Hence, the terms \"incremental learning\" and \"stream learning\" (from which river derives it's name) are prefered. The point of incremental learning is to fit a model to a stream of data. In other words, the data isn't available in it's entirety, but rather the observations are provided one by one. As an example let's stream through the dataset used previously. for xi , yi in zip ( X , y ): # This is where the model learns pass In this case we're iterating over a dataset that is already in memory, but we could just as well stream from a CSV file, a Kafka stream, an SQL query, etc. If we look at xi we can notice that it is a numpy.ndarray . xi array([7.760e+00, 2.454e+01, 4.792e+01, 1.810e+02, 5.263e-02, 4.362e-02, 0.000e+00, 0.000e+00, 1.587e-01, 5.884e-02, 3.857e-01, 1.428e+00, 2.548e+00, 1.915e+01, 7.189e-03, 4.660e-03, 0.000e+00, 0.000e+00, 2.676e-02, 2.783e-03, 9.456e+00, 3.037e+01, 5.916e+01, 2.686e+02, 8.996e-02, 6.444e-02, 0.000e+00, 0.000e+00, 2.871e-01, 7.039e-02]) river by design works with dict s. We believe that dict s are more enjoyable to program with than numpy.ndarray s, at least for when single observations are concerned. dict 's bring the added benefit that each feature can be accessed by name rather than by position. for xi , yi in zip ( X , y ): xi = dict ( zip ( dataset . feature_names , xi )) pass xi {'mean radius': 7.76, 'mean texture': 24.54, 'mean perimeter': 47.92, 'mean area': 181.0, 'mean smoothness': 0.05263, 'mean compactness': 0.04362, 'mean concavity': 0.0, 'mean concave points': 0.0, 'mean symmetry': 0.1587, 'mean fractal dimension': 0.05884, 'radius error': 0.3857, 'texture error': 1.428, 'perimeter error': 2.548, 'area error': 19.15, 'smoothness error': 0.007189, 'compactness error': 0.00466, 'concavity error': 0.0, 'concave points error': 0.0, 'symmetry error': 0.02676, 'fractal dimension error': 0.002783, 'worst radius': 9.456, 'worst texture': 30.37, 'worst perimeter': 59.16, 'worst area': 268.6, 'worst smoothness': 0.08996, 'worst compactness': 0.06444, 'worst concavity': 0.0, 'worst concave points': 0.0, 'worst symmetry': 0.2871, 'worst fractal dimension': 0.07039} Conveniently, river 's stream module has an iter_sklearn_dataset method that we can use instead. from river import stream for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): pass The simple fact that we are getting the data as a stream means that we can't do a lot of things the same way as in a batch setting. For example let's say we want to scale the data so that it has mean 0 and variance 1, as we did earlier. To do so we simply have to subtract the mean of each feature to each value and then divide the result by the standard deviation of the feature. The problem is that we can't possible known the values of the mean and the standard deviation before actually going through all the data! One way to proceed would be to do a first pass over the data to compute the necessary values and then scale the values during a second pass. The problem is that this defeats our purpose, which is to learn by only looking at the data once. Although this might seem rather restrictive, it reaps sizable benefits down the road. The way we do feature scaling in river involves computing running statistics (also know as moving statistics ). The idea is that we use a data structure that estimates the mean and updates itself when it is provided with a value. The same goes for the variance (and thus the standard deviation). For example, if we denote \\(\\mu_t\\) the mean and \\(n_t\\) the count at any moment \\(t\\) , then updating the mean can be done as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\end{cases} \\] Likewise, the running variance can be computed as so: \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\\\ s_{t+1} = s_t + (x - \\mu_t) \\times (x - \\mu_{t+1}) \\\\ \\sigma_{t+1} = \\frac{s_{t+1}}{n_{t+1}} \\end{cases} \\] where \\(s_t\\) is a running sum of squares and \\(\\sigma_t\\) is the running variance at time \\(t\\) . This might seem a tad more involved than the batch algorithms you learn in school, but it is rather elegant. Implementing this in Python is not too difficult. For example let's compute the running mean and variance of the 'mean area' variable. n , mean , sum_of_squares , variance = 0 , 0 , 0 , 0 for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): n += 1 old_mean = mean mean += ( xi [ 'mean area' ] - mean ) / n sum_of_squares += ( xi [ 'mean area' ] - old_mean ) * ( xi [ 'mean area' ] - mean ) variance = sum_of_squares / n print ( f 'Running mean: { mean : .3f } ' ) print ( f 'Running variance: { variance : .3f } ' ) Running mean: 654.889 Running variance: 123625.903 Let's compare this with numpy . But remember, numpy requires access to \"all\" the data. import numpy as np i = list ( dataset . feature_names ) . index ( 'mean area' ) print ( f 'True mean: { np . mean ( X [:, i ]) : .3f } ' ) print ( f 'True variance: { np . var ( X [:, i ]) : .3f } ' ) True mean: 654.889 True variance: 123625.903 The results seem to be exactly the same! The twist is that the running statistics won't be very accurate for the first few observations. In general though this doesn't matter too much. Some would even go as far as to say that this descrepancy is beneficial and acts as some sort of regularization... Now the idea is that we can compute the running statistics of each feature and scale them as they come along. The way to do this with river is to use the StandardScaler class from the preprocessing module, as so: from river import preprocessing scaler = preprocessing . StandardScaler () for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer ()): scaler = scaler . learn_one ( xi ) Now that we are scaling the data, we can start doing some actual machine learning. We're going to implement an online linear regression task. Because all the data isn't available at once, we are obliged to do what is called stochastic gradient descent , which is a popular research topic and has a lot of variants. SGD is commonly used to train neural networks. The idea is that at each step we compute the loss between the target prediction and the truth. We then calculate the gradient, which is simply a set of derivatives with respect to each weight from the linear regression. Once we have obtained the gradient, we can update the weights by moving them in the opposite direction of the gradient. The amount by which the weights are moved typically depends on a learning rate , which is typically set by the user. Different optimizers have different ways of managing the weight update, and some handle the learning rate implicitly. Online linear regression can be done in river with the LinearRegression class from the linear_model module. We'll be using plain and simple SGD using the SGD optimizer from the optim module. During training we'll measure the squared error between the truth and the predictions. from river import linear_model from river import optim scaler = preprocessing . StandardScaler () optimizer = optim . SGD ( lr = 0.01 ) log_reg = linear_model . LogisticRegression ( optimizer ) y_true = [] y_pred = [] for xi , yi in stream . iter_sklearn_dataset ( datasets . load_breast_cancer (), shuffle = True , seed = 42 ): # Scale the features xi_scaled = scaler . learn_one ( xi ) . transform_one ( xi ) # Test the current model on the new \"unobserved\" sample yi_pred = log_reg . predict_proba_one ( xi_scaled ) # Train the model with the new sample log_reg . learn_one ( xi_scaled , yi ) # Store the truth and the prediction y_true . append ( yi ) y_pred . append ( yi_pred [ True ]) print ( f 'ROC AUC: { metrics . roc_auc_score ( y_true , y_pred ) : .3f } ' ) ROC AUC: 0.990 The ROC AUC is significantly better than the one obtained from the cross-validation of scikit-learn's logisitic regression. However to make things really comparable it would be nice to compare with the same cross-validation procedure. river has a compat module that contains utilities for making river compatible with other Python libraries. Because we're doing regression we'll be using the SKLRegressorWrapper . We'll also be using Pipeline to encapsulate the logic of the StandardScaler and the LogisticRegression in one single object. from river import compat from river import compose # We define a Pipeline, exactly like we did earlier for sklearn model = compose . Pipeline ( ( 'scale' , preprocessing . StandardScaler ()), ( 'log_reg' , linear_model . LogisticRegression ()) ) # We make the Pipeline compatible with sklearn model = compat . convert_river_to_sklearn ( model ) # We compute the CV scores using the same CV scheme and the same scoring scores = model_selection . cross_val_score ( model , X , y , scoring = scorer , cv = cv ) # Display the average score and it's standard deviation print ( f 'ROC AUC: { scores . mean () : .3f } (\u00b1 { scores . std () : .3f } )' ) ROC AUC: 0.964 (\u00b1 0.016) This time the ROC AUC score is lower, which is what we would expect. Indeed online learning isn't as accurate as batch learning. However it all depends in what you're interested in. If you're only interested in predicting the next observation then the online learning regime would be better. That's why it's a bit hard to compare both approaches: they're both suited to different scenarios.","title":"A hands-on introduction to incremental learning"},{"location":"examples/batch-to-online/#going-further","text":"Here a few resources if you want to do some reading: Online learning -- Wikipedia What is online machine learning? -- Max Pagels Introduction to Online Learning -- USC course Online Methods in Machine Learning -- MIT course Online Learning: A Comprehensive Survey Streaming 101: The world beyond batch Machine learning for data streams Data Stream Mining: A Practical Approach","title":"Going further"},{"location":"examples/bike-sharing-forecasting/","text":"Bike-sharing forecasting \u00b6 % load_ext autoreload % autoreload 2 In this tutorial we're going to forecast the number of bikes in 5 bike stations from the city of Toulouse. We'll do so by building a simple model step by step. The dataset contains 182,470 observations. Let's first take a peak at the data. from pprint import pprint from river import datasets dataset = datasets . Bikes () for x , y in dataset : pprint ( x ) print ( f 'Number of available bikes: { y } ' ) break {'clouds': 75, 'description': 'light rain', 'humidity': 81, 'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'pressure': 1017.0, 'station': 'metro-canal-du-midi', 'temperature': 6.54, 'wind': 9.3} Number of available bikes: 1 Let's start by using a simple linear regression on the numeric features. We can select the numeric features and discard the rest of the features using a Select . Linear regression is very likely to go haywire if we don't scale the data, so we'll use a StandardScaler to do just that. We'll evaluate the model by measuring the mean absolute error. Finally we'll print the score every 20,000 observations. from river import compose from river import linear_model from river import metrics from river import evaluate from river import preprocessing from river import optim model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( dataset , model , metric , print_every = 20_000 ) [20,000] MAE: 4.912727 [40,000] MAE: 5.333554 [60,000] MAE: 5.330948 [80,000] MAE: 5.392313 [100,000] MAE: 5.423059 [120,000] MAE: 5.541223 [140,000] MAE: 5.613023 [160,000] MAE: 5.622428 [180,000] MAE: 5.567824 MAE: 5.563893 The model doesn't seem to be doing that well, but then again we didn't provide a lot of features. Generally, a good idea for this kind of problem is to look at an average of the previous values. For example, for each station we can look at the average number of bikes per hour. To do so we first have to extract the hour from the moment field. We can then use a TargetAgg to aggregate the values of the target. from river import feature_extraction from river import stats def get_hour ( x ): x [ 'hour' ] = x [ 'moment' ] . hour return x model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( dataset , model , metric , print_every = 20_000 ) [20,000] MAE: 3.721246 [40,000] MAE: 3.829972 [60,000] MAE: 3.845068 [80,000] MAE: 3.910259 [100,000] MAE: 3.888652 [120,000] MAE: 3.923727 [140,000] MAE: 3.980953 [160,000] MAE: 3.950034 [180,000] MAE: 3.934545 MAE: 3.933498 By adding a single feature, we've managed to significantly reduce the mean absolute error. At this point you might think that the model is getting slightly complex, and is difficult to understand and test. Pipelines have the advantage of being terse, but they aren't always to debug. Thankfully river has some ways to relieve the pain. The first thing we can do it to visualize the pipeline, to get an idea of how the data flows through it. model ['clouds', 'humidity', 'pressure', 'temperature', 'wind'] {'keys': {'wind', 'humidity', 'temperature', 'clouds', 'pressure'}} get_hour def get_hour(x): x['hour'] = x['moment'].hour return x y_mean_by_station_and_hour {'_feature_name': 'y_mean_by_station_and_hour', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7fd9871cb4c0>, Mean: 0.), {('metro-canal-du-midi', 0): Mean: 7.93981, ('metro-canal-du-midi', 1): Mean: 8.179704, ('metro-canal-du-midi', 2): Mean: 8.35824, ('metro-canal-du-midi', 3): Mean: 8.656051, ('metro-canal-du-midi', 4): Mean: 8.868445, ('metro-canal-du-midi', 5): Mean: 8.99656, ('metro-canal-du-midi', 6): Mean: 9.09966, ('metro-canal-du-midi', 7): Mean: 8.852642, ('metro-canal-du-midi', 8): Mean: 12.66712, ('metro-canal-du-midi', 9): Mean: 13.412186, ('metro-canal-du-midi', 10): Mean: 12.486815, ('metro-canal-du-midi', 11): Mean: 11.675479, ('metro-canal-du-midi', 12): Mean: 10.197409, ('metro-canal-du-midi', 13): Mean: 10.650855, ('metro-canal-du-midi', 14): Mean: 11.109123, ('metro-canal-du-midi', 15): Mean: 11.068934, ('metro-canal-du-midi', 16): Mean: 11.274958, ('metro-canal-du-midi', 17): Mean: 8.459136, ('metro-canal-du-midi', 18): Mean: 7.587469, ('metro-canal-du-midi', 19): Mean: 7.734677, ('metro-canal-du-midi', 20): Mean: 7.582465, ('metro-canal-du-midi', 21): Mean: 7.190665, ('metro-canal-du-midi', 22): Mean: 7.486895, ('metro-canal-du-midi', 23): Mean: 7.840791, ('place-des-carmes', 0): Mean: 4.720696, ('place-des-carmes', 1): Mean: 3.390295, ('place-des-carmes', 2): Mean: 2.232181, ('place-des-carmes', 3): Mean: 1.371981, ('place-des-carmes', 4): Mean: 1.051665, ('place-des-carmes', 5): Mean: 0.984993, ('place-des-carmes', 6): Mean: 2.039947, ('place-des-carmes', 7): Mean: 3.850369, ('place-des-carmes', 8): Mean: 3.792624, ('place-des-carmes', 9): Mean: 5.957182, ('place-des-carmes', 10): Mean: 8.575303, ('place-des-carmes', 11): Mean: 9.321546, ('place-des-carmes', 12): Mean: 10.511931, ('place-des-carmes', 13): Mean: 11.392745, ('place-des-carmes', 14): Mean: 10.735003, ('place-des-carmes', 15): Mean: 10.198787, ('place-des-carmes', 16): Mean: 9.941479, ('place-des-carmes', 17): Mean: 9.125579, ('place-des-carmes', 18): Mean: 7.660775, ('place-des-carmes', 19): Mean: 6.847649, ('place-des-carmes', 20): Mean: 9.626876, ('place-des-carmes', 21): Mean: 11.602929, ('place-des-carmes', 22): Mean: 10.405537, ('place-des-carmes', 23): Mean: 7.700904, ('place-esquirol', 0): Mean: 7.415789, ('place-esquirol', 1): Mean: 5.244396, ('place-esquirol', 2): Mean: 2.858635, ('place-esquirol', 3): Mean: 1.155929, ('place-esquirol', 4): Mean: 0.73306, ('place-esquirol', 5): Mean: 0.668546, ('place-esquirol', 6): Mean: 1.21265, ('place-esquirol', 7): Mean: 3.107535, ('place-esquirol', 8): Mean: 8.518696, ('place-esquirol', 9): Mean: 15.470588, ('place-esquirol', 10): Mean: 19.465005, ('place-esquirol', 11): Mean: 22.976512, ('place-esquirol', 12): Mean: 25.324159, ('place-esquirol', 13): Mean: 25.428847, ('place-esquirol', 14): Mean: 24.57762, ('place-esquirol', 15): Mean: 24.416851, ('place-esquirol', 16): Mean: 23.555125, ('place-esquirol', 17): Mean: 22.062564, ('place-esquirol', 18): Mean: 18.10623, ('place-esquirol', 19): Mean: 11.916638, ('place-esquirol', 20): Mean: 13.346362, ('place-esquirol', 21): Mean: 16.743318, ('place-esquirol', 22): Mean: 15.562088, ('place-esquirol', 23): Mean: 10.911134, ('place-jeanne-darc', 0): Mean: 6.541667, ('place-jeanne-darc', 1): Mean: 5.99892, ('place-jeanne-darc', 2): Mean: 5.598169, ('place-jeanne-darc', 3): Mean: 5.180556, ('place-jeanne-darc', 4): Mean: 4.779626, ('place-jeanne-darc', 5): Mean: 4.67063, ('place-jeanne-darc', 6): Mean: 4.611995, ('place-jeanne-darc', 7): Mean: 4.960718, ('place-jeanne-darc', 8): Mean: 5.552273, ('place-jeanne-darc', 9): Mean: 6.249573, ('place-jeanne-darc', 10): Mean: 5.735553, ('place-jeanne-darc', 11): Mean: 5.616142, ('place-jeanne-darc', 12): Mean: 5.787478, ('place-jeanne-darc', 13): Mean: 5.817699, ('place-jeanne-darc', 14): Mean: 5.657546, ('place-jeanne-darc', 15): Mean: 6.224604, ('place-jeanne-darc', 16): Mean: 5.796141, ('place-jeanne-darc', 17): Mean: 5.743089, ('place-jeanne-darc', 18): Mean: 5.674784, ('place-jeanne-darc', 19): Mean: 5.833068, ('place-jeanne-darc', 20): Mean: 6.015755, ('place-jeanne-darc', 21): Mean: 6.242541, ('place-jeanne-darc', 22): Mean: 6.141509, ('place-jeanne-darc', 23): Mean: 6.493028, ('pomme', 0): Mean: 3.301532, ('pomme', 1): Mean: 2.312914, ('pomme', 2): Mean: 2.144453, ('pomme', 3): Mean: 1.563622, ('pomme', 4): Mean: 0.947328, ('pomme', 5): Mean: 0.924175, ('pomme', 6): Mean: 1.287805, ('pomme', 7): Mean: 1.299456, ('pomme', 8): Mean: 2.94988, ('pomme', 9): Mean: 7.89396, ('pomme', 10): Mean: 11.791436, ('pomme', 11): Mean: 12.976854, ('pomme', 12): Mean: 13.962654, ('pomme', 13): Mean: 11.692257, ('pomme', 14): Mean: 11.180851, ('pomme', 15): Mean: 11.939586, ('pomme', 16): Mean: 12.267051, ('pomme', 17): Mean: 12.132993, ('pomme', 18): Mean: 11.399108, ('pomme', 19): Mean: 6.37021, ('pomme', 20): Mean: 5.279234, ('pomme', 21): Mean: 6.254257, ('pomme', 22): Mean: 6.568678, ('pomme', 23): Mean: 5.235756}), 'by': ['station', 'hour'], 'how': Mean: 0., 'on': 'y'} StandardScaler {'counts': Counter({'y_mean_by_station_and_hour': 182470, 'wind': 182470, 'humidity': 182470, 'temperature': 182470, 'clouds': 182470, 'pressure': 182470}), 'means': defaultdict(<class 'float'>, {'clouds': 30.315131254453505, 'humidity': 62.24244533347998, 'pressure': 1017.0563060996391, 'temperature': 20.50980692716619, 'wind': 3.4184331122924543, 'y_mean_by_station_and_hour': 9.468200635816528}), 'vars': defaultdict(<class 'float'>, {'clouds': 1389.0025610928221, 'humidity': 349.59967918503554, 'pressure': 33.298307526514115, 'temperature': 34.70701720774977, 'wind': 4.473627075744674, 'y_mean_by_station_and_hour': 33.720872727055365}), 'with_std': True} LinearRegression {'_weights': {'y_mean_by_station_and_hour': 3.8719218238428725, 'wind': -0.2612193604527138, 'humidity': 3.8817929874945234, 'temperature': -2.795077764828726, 'clouds': -0.6106470619450345, 'pressure': 2.148194846809032}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 6.096564954881431, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.001}), 'n_iterations': 182470})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } We can also use the debug_one method to see what happens to one particular instance. Let's train the model on the first 10,000 observations and then call debug_one on the next one. To do this, we will turn the Bike object into a Python generator with iter() function. The Pythonic way to read the first 10,000 elements of a generator is to use itertools.islice . import itertools model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () for x , y in itertools . islice ( dataset , 10000 ): y_pred = model . predict_one ( x ) model . learn_one ( x , y ) x , y = next ( iter ( dataset )) print ( model . debug_one ( x )) 0. Input -------- clouds: 75 (int) description: light rain (str) humidity: 81 (int) moment: 2016-04-01 00:00:07 (datetime) pressure: 1,017.00000 (float) station: metro-canal-du-midi (str) temperature: 6.54000 (float) wind: 9.30000 (float) 1. Transformer union -------------------- 1.0 Select ---------- clouds: 75 (int) humidity: 81 (int) pressure: 1,017.00000 (float) temperature: 6.54000 (float) wind: 9.30000 (float) 1.1 get_hour | y_mean_by_station_and_hour ----------------------------------------- y_mean_by_station_and_hour: 4.43243 (float) clouds: 75 (int) humidity: 81 (int) pressure: 1,017.00000 (float) temperature: 6.54000 (float) wind: 9.30000 (float) y_mean_by_station_and_hour: 4.43243 (float) 2. StandardScaler ----------------- clouds: 0.47566 (float) humidity: 0.42247 (float) pressure: 1.05314 (float) temperature: -1.22098 (float) wind: 2.21104 (float) y_mean_by_station_and_hour: -0.59098 (float) 3. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 6.58252 6.58252 pressure 1.05314 3.78529 3.98646 humidity 0.42247 1.44921 0.61225 y_mean_by_station_and_hour -0.59098 0.54167 -0.32011 clouds 0.47566 -1.92255 -0.91448 wind 2.21104 -0.77720 -1.71843 temperature -1.22098 2.47030 -3.01619 Prediction: 5.21201 The debug_one method shows what happens to an input set of features, step by step. And now comes the catch. Up until now we've been using the progressive_val_score method from the evaluate module. What this does it that it sequentially predicts the output of an observation and updates the model immediately afterwards. This way of proceeding is often used for evaluating online learning models. But in some cases it is the wrong approach. When evaluating a machine learning model, the goal is to simulate production conditions in order to get a trust-worthy assessment of the performance of the model. In our case, we typically want to forecast the number of bikes available in a station, say, 30 minutes ahead. Then, once the 30 minutes have passed, the true number of available bikes will be available and we will be able to update the model using the features available 30 minutes ago. What we really want is to evaluate the model by forecasting 30 minutes ahead and only updating the model once the true values are available. This can be done using the moment and delay parameters in the progressive_val_score method. The idea is that each observation in the stream of the data is shown twice to the model: once for making a prediction, and once for updating the model when the true value is revealed. The moment parameter determines which variable should be used as a timestamp, while the delay parameter controls the duration to wait before revealing the true values to the model. import datetime as dt evaluate . progressive_val_score ( dataset = dataset , model = model . clone (), metric = metrics . MAE (), moment = 'moment' , delay = dt . timedelta ( minutes = 30 ), print_every = 20_000 ) [20,000] MAE: 4.378419 [40,000] MAE: 4.328999 [60,000] MAE: 4.277895 [80,000] MAE: 4.287503 [100,000] MAE: 4.236114 [120,000] MAE: 4.238951 [140,000] MAE: 4.278382 [160,000] MAE: 4.24341 [180,000] MAE: 4.230743 MAE: 4.231731 The performance is a bit worse, which is to be expected. Indeed, the task is more difficult: the model is only shown the ground truth 30 minutes after making a prediction. The takeaway of this notebook is that the progressive_val_score method can be used to simulate a production scenario, and is thus extremely valuable.","title":"Bike-sharing forecasting"},{"location":"examples/bike-sharing-forecasting/#bike-sharing-forecasting","text":"% load_ext autoreload % autoreload 2 In this tutorial we're going to forecast the number of bikes in 5 bike stations from the city of Toulouse. We'll do so by building a simple model step by step. The dataset contains 182,470 observations. Let's first take a peak at the data. from pprint import pprint from river import datasets dataset = datasets . Bikes () for x , y in dataset : pprint ( x ) print ( f 'Number of available bikes: { y } ' ) break {'clouds': 75, 'description': 'light rain', 'humidity': 81, 'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'pressure': 1017.0, 'station': 'metro-canal-du-midi', 'temperature': 6.54, 'wind': 9.3} Number of available bikes: 1 Let's start by using a simple linear regression on the numeric features. We can select the numeric features and discard the rest of the features using a Select . Linear regression is very likely to go haywire if we don't scale the data, so we'll use a StandardScaler to do just that. We'll evaluate the model by measuring the mean absolute error. Finally we'll print the score every 20,000 observations. from river import compose from river import linear_model from river import metrics from river import evaluate from river import preprocessing from river import optim model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( dataset , model , metric , print_every = 20_000 ) [20,000] MAE: 4.912727 [40,000] MAE: 5.333554 [60,000] MAE: 5.330948 [80,000] MAE: 5.392313 [100,000] MAE: 5.423059 [120,000] MAE: 5.541223 [140,000] MAE: 5.613023 [160,000] MAE: 5.622428 [180,000] MAE: 5.567824 MAE: 5.563893 The model doesn't seem to be doing that well, but then again we didn't provide a lot of features. Generally, a good idea for this kind of problem is to look at an average of the previous values. For example, for each station we can look at the average number of bikes per hour. To do so we first have to extract the hour from the moment field. We can then use a TargetAgg to aggregate the values of the target. from river import feature_extraction from river import stats def get_hour ( x ): x [ 'hour' ] = x [ 'moment' ] . hour return x model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression ( optimizer = optim . SGD ( 0.001 )) metric = metrics . MAE () evaluate . progressive_val_score ( dataset , model , metric , print_every = 20_000 ) [20,000] MAE: 3.721246 [40,000] MAE: 3.829972 [60,000] MAE: 3.845068 [80,000] MAE: 3.910259 [100,000] MAE: 3.888652 [120,000] MAE: 3.923727 [140,000] MAE: 3.980953 [160,000] MAE: 3.950034 [180,000] MAE: 3.934545 MAE: 3.933498 By adding a single feature, we've managed to significantly reduce the mean absolute error. At this point you might think that the model is getting slightly complex, and is difficult to understand and test. Pipelines have the advantage of being terse, but they aren't always to debug. Thankfully river has some ways to relieve the pain. The first thing we can do it to visualize the pipeline, to get an idea of how the data flows through it. model ['clouds', 'humidity', 'pressure', 'temperature', 'wind'] {'keys': {'wind', 'humidity', 'temperature', 'clouds', 'pressure'}} get_hour def get_hour(x): x['hour'] = x['moment'].hour return x y_mean_by_station_and_hour {'_feature_name': 'y_mean_by_station_and_hour', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7fd9871cb4c0>, Mean: 0.), {('metro-canal-du-midi', 0): Mean: 7.93981, ('metro-canal-du-midi', 1): Mean: 8.179704, ('metro-canal-du-midi', 2): Mean: 8.35824, ('metro-canal-du-midi', 3): Mean: 8.656051, ('metro-canal-du-midi', 4): Mean: 8.868445, ('metro-canal-du-midi', 5): Mean: 8.99656, ('metro-canal-du-midi', 6): Mean: 9.09966, ('metro-canal-du-midi', 7): Mean: 8.852642, ('metro-canal-du-midi', 8): Mean: 12.66712, ('metro-canal-du-midi', 9): Mean: 13.412186, ('metro-canal-du-midi', 10): Mean: 12.486815, ('metro-canal-du-midi', 11): Mean: 11.675479, ('metro-canal-du-midi', 12): Mean: 10.197409, ('metro-canal-du-midi', 13): Mean: 10.650855, ('metro-canal-du-midi', 14): Mean: 11.109123, ('metro-canal-du-midi', 15): Mean: 11.068934, ('metro-canal-du-midi', 16): Mean: 11.274958, ('metro-canal-du-midi', 17): Mean: 8.459136, ('metro-canal-du-midi', 18): Mean: 7.587469, ('metro-canal-du-midi', 19): Mean: 7.734677, ('metro-canal-du-midi', 20): Mean: 7.582465, ('metro-canal-du-midi', 21): Mean: 7.190665, ('metro-canal-du-midi', 22): Mean: 7.486895, ('metro-canal-du-midi', 23): Mean: 7.840791, ('place-des-carmes', 0): Mean: 4.720696, ('place-des-carmes', 1): Mean: 3.390295, ('place-des-carmes', 2): Mean: 2.232181, ('place-des-carmes', 3): Mean: 1.371981, ('place-des-carmes', 4): Mean: 1.051665, ('place-des-carmes', 5): Mean: 0.984993, ('place-des-carmes', 6): Mean: 2.039947, ('place-des-carmes', 7): Mean: 3.850369, ('place-des-carmes', 8): Mean: 3.792624, ('place-des-carmes', 9): Mean: 5.957182, ('place-des-carmes', 10): Mean: 8.575303, ('place-des-carmes', 11): Mean: 9.321546, ('place-des-carmes', 12): Mean: 10.511931, ('place-des-carmes', 13): Mean: 11.392745, ('place-des-carmes', 14): Mean: 10.735003, ('place-des-carmes', 15): Mean: 10.198787, ('place-des-carmes', 16): Mean: 9.941479, ('place-des-carmes', 17): Mean: 9.125579, ('place-des-carmes', 18): Mean: 7.660775, ('place-des-carmes', 19): Mean: 6.847649, ('place-des-carmes', 20): Mean: 9.626876, ('place-des-carmes', 21): Mean: 11.602929, ('place-des-carmes', 22): Mean: 10.405537, ('place-des-carmes', 23): Mean: 7.700904, ('place-esquirol', 0): Mean: 7.415789, ('place-esquirol', 1): Mean: 5.244396, ('place-esquirol', 2): Mean: 2.858635, ('place-esquirol', 3): Mean: 1.155929, ('place-esquirol', 4): Mean: 0.73306, ('place-esquirol', 5): Mean: 0.668546, ('place-esquirol', 6): Mean: 1.21265, ('place-esquirol', 7): Mean: 3.107535, ('place-esquirol', 8): Mean: 8.518696, ('place-esquirol', 9): Mean: 15.470588, ('place-esquirol', 10): Mean: 19.465005, ('place-esquirol', 11): Mean: 22.976512, ('place-esquirol', 12): Mean: 25.324159, ('place-esquirol', 13): Mean: 25.428847, ('place-esquirol', 14): Mean: 24.57762, ('place-esquirol', 15): Mean: 24.416851, ('place-esquirol', 16): Mean: 23.555125, ('place-esquirol', 17): Mean: 22.062564, ('place-esquirol', 18): Mean: 18.10623, ('place-esquirol', 19): Mean: 11.916638, ('place-esquirol', 20): Mean: 13.346362, ('place-esquirol', 21): Mean: 16.743318, ('place-esquirol', 22): Mean: 15.562088, ('place-esquirol', 23): Mean: 10.911134, ('place-jeanne-darc', 0): Mean: 6.541667, ('place-jeanne-darc', 1): Mean: 5.99892, ('place-jeanne-darc', 2): Mean: 5.598169, ('place-jeanne-darc', 3): Mean: 5.180556, ('place-jeanne-darc', 4): Mean: 4.779626, ('place-jeanne-darc', 5): Mean: 4.67063, ('place-jeanne-darc', 6): Mean: 4.611995, ('place-jeanne-darc', 7): Mean: 4.960718, ('place-jeanne-darc', 8): Mean: 5.552273, ('place-jeanne-darc', 9): Mean: 6.249573, ('place-jeanne-darc', 10): Mean: 5.735553, ('place-jeanne-darc', 11): Mean: 5.616142, ('place-jeanne-darc', 12): Mean: 5.787478, ('place-jeanne-darc', 13): Mean: 5.817699, ('place-jeanne-darc', 14): Mean: 5.657546, ('place-jeanne-darc', 15): Mean: 6.224604, ('place-jeanne-darc', 16): Mean: 5.796141, ('place-jeanne-darc', 17): Mean: 5.743089, ('place-jeanne-darc', 18): Mean: 5.674784, ('place-jeanne-darc', 19): Mean: 5.833068, ('place-jeanne-darc', 20): Mean: 6.015755, ('place-jeanne-darc', 21): Mean: 6.242541, ('place-jeanne-darc', 22): Mean: 6.141509, ('place-jeanne-darc', 23): Mean: 6.493028, ('pomme', 0): Mean: 3.301532, ('pomme', 1): Mean: 2.312914, ('pomme', 2): Mean: 2.144453, ('pomme', 3): Mean: 1.563622, ('pomme', 4): Mean: 0.947328, ('pomme', 5): Mean: 0.924175, ('pomme', 6): Mean: 1.287805, ('pomme', 7): Mean: 1.299456, ('pomme', 8): Mean: 2.94988, ('pomme', 9): Mean: 7.89396, ('pomme', 10): Mean: 11.791436, ('pomme', 11): Mean: 12.976854, ('pomme', 12): Mean: 13.962654, ('pomme', 13): Mean: 11.692257, ('pomme', 14): Mean: 11.180851, ('pomme', 15): Mean: 11.939586, ('pomme', 16): Mean: 12.267051, ('pomme', 17): Mean: 12.132993, ('pomme', 18): Mean: 11.399108, ('pomme', 19): Mean: 6.37021, ('pomme', 20): Mean: 5.279234, ('pomme', 21): Mean: 6.254257, ('pomme', 22): Mean: 6.568678, ('pomme', 23): Mean: 5.235756}), 'by': ['station', 'hour'], 'how': Mean: 0., 'on': 'y'} StandardScaler {'counts': Counter({'y_mean_by_station_and_hour': 182470, 'wind': 182470, 'humidity': 182470, 'temperature': 182470, 'clouds': 182470, 'pressure': 182470}), 'means': defaultdict(<class 'float'>, {'clouds': 30.315131254453505, 'humidity': 62.24244533347998, 'pressure': 1017.0563060996391, 'temperature': 20.50980692716619, 'wind': 3.4184331122924543, 'y_mean_by_station_and_hour': 9.468200635816528}), 'vars': defaultdict(<class 'float'>, {'clouds': 1389.0025610928221, 'humidity': 349.59967918503554, 'pressure': 33.298307526514115, 'temperature': 34.70701720774977, 'wind': 4.473627075744674, 'y_mean_by_station_and_hour': 33.720872727055365}), 'with_std': True} LinearRegression {'_weights': {'y_mean_by_station_and_hour': 3.8719218238428725, 'wind': -0.2612193604527138, 'humidity': 3.8817929874945234, 'temperature': -2.795077764828726, 'clouds': -0.6106470619450345, 'pressure': 2.148194846809032}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 6.096564954881431, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.001}), 'n_iterations': 182470})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } We can also use the debug_one method to see what happens to one particular instance. Let's train the model on the first 10,000 observations and then call debug_one on the next one. To do this, we will turn the Bike object into a Python generator with iter() function. The Pythonic way to read the first 10,000 elements of a generator is to use itertools.islice . import itertools model = compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) model += ( get_hour | feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () for x , y in itertools . islice ( dataset , 10000 ): y_pred = model . predict_one ( x ) model . learn_one ( x , y ) x , y = next ( iter ( dataset )) print ( model . debug_one ( x )) 0. Input -------- clouds: 75 (int) description: light rain (str) humidity: 81 (int) moment: 2016-04-01 00:00:07 (datetime) pressure: 1,017.00000 (float) station: metro-canal-du-midi (str) temperature: 6.54000 (float) wind: 9.30000 (float) 1. Transformer union -------------------- 1.0 Select ---------- clouds: 75 (int) humidity: 81 (int) pressure: 1,017.00000 (float) temperature: 6.54000 (float) wind: 9.30000 (float) 1.1 get_hour | y_mean_by_station_and_hour ----------------------------------------- y_mean_by_station_and_hour: 4.43243 (float) clouds: 75 (int) humidity: 81 (int) pressure: 1,017.00000 (float) temperature: 6.54000 (float) wind: 9.30000 (float) y_mean_by_station_and_hour: 4.43243 (float) 2. StandardScaler ----------------- clouds: 0.47566 (float) humidity: 0.42247 (float) pressure: 1.05314 (float) temperature: -1.22098 (float) wind: 2.21104 (float) y_mean_by_station_and_hour: -0.59098 (float) 3. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 6.58252 6.58252 pressure 1.05314 3.78529 3.98646 humidity 0.42247 1.44921 0.61225 y_mean_by_station_and_hour -0.59098 0.54167 -0.32011 clouds 0.47566 -1.92255 -0.91448 wind 2.21104 -0.77720 -1.71843 temperature -1.22098 2.47030 -3.01619 Prediction: 5.21201 The debug_one method shows what happens to an input set of features, step by step. And now comes the catch. Up until now we've been using the progressive_val_score method from the evaluate module. What this does it that it sequentially predicts the output of an observation and updates the model immediately afterwards. This way of proceeding is often used for evaluating online learning models. But in some cases it is the wrong approach. When evaluating a machine learning model, the goal is to simulate production conditions in order to get a trust-worthy assessment of the performance of the model. In our case, we typically want to forecast the number of bikes available in a station, say, 30 minutes ahead. Then, once the 30 minutes have passed, the true number of available bikes will be available and we will be able to update the model using the features available 30 minutes ago. What we really want is to evaluate the model by forecasting 30 minutes ahead and only updating the model once the true values are available. This can be done using the moment and delay parameters in the progressive_val_score method. The idea is that each observation in the stream of the data is shown twice to the model: once for making a prediction, and once for updating the model when the true value is revealed. The moment parameter determines which variable should be used as a timestamp, while the delay parameter controls the duration to wait before revealing the true values to the model. import datetime as dt evaluate . progressive_val_score ( dataset = dataset , model = model . clone (), metric = metrics . MAE (), moment = 'moment' , delay = dt . timedelta ( minutes = 30 ), print_every = 20_000 ) [20,000] MAE: 4.378419 [40,000] MAE: 4.328999 [60,000] MAE: 4.277895 [80,000] MAE: 4.287503 [100,000] MAE: 4.236114 [120,000] MAE: 4.238951 [140,000] MAE: 4.278382 [160,000] MAE: 4.24341 [180,000] MAE: 4.230743 MAE: 4.231731 The performance is a bit worse, which is to be expected. Indeed, the task is more difficult: the model is only shown the ground truth 30 minutes after making a prediction. The takeaway of this notebook is that the progressive_val_score method can be used to simulate a production scenario, and is thus extremely valuable.","title":"Bike-sharing forecasting"},{"location":"examples/building-a-simple-nowcasting-model/","text":"Building a simple nowcasting model \u00b6 % matplotlib inline Nowcasting is a special case of forecasting. It simply consists in predicting the next value in a time series. We'll be using the international airline passenger data available from here . This particular dataset is included with river in the datasets module. from river import datasets for x , y in datasets . AirlinePassengers (): print ( x , y ) break {'month': datetime.datetime(1949, 1, 1, 0, 0)} 112 The data is as simple as can be: it consists of a sequence of months and values representing the total number of international airline passengers per month. Our goal is going to be to predict the number of passengers for the next month at each step. Notice that because the dataset is small -- which is usually the case for time series -- we could just fit a model from scratch each month. However for the sake of example we're going to train a single model online. Although the overall performance might be potentially weaker, training a time series model online has the benefit of being scalable if, say, you have have thousands of time series to manage . We'll start with a very simple model where the only feature will be the ordinal date of each month. This should be able to capture some of the underlying trend. from river import compose from river import linear_model from river import preprocessing def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) We'll write down a function to evaluate the model. This will go through each observation in the dataset and update the model as it goes on. The prior predictions will be stored along with the true values and will be plotted together. from river import metrics import matplotlib.pyplot as plt def evaluate_model ( model ): metric = metrics . Rolling ( metrics . MAE (), 12 ) dates = [] y_trues = [] y_preds = [] for x , y in datasets . AirlinePassengers (): # Obtain the prior prediction and update the model in one go y_pred = model . predict_one ( x ) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_pred ) # Store the true value and the prediction dates . append ( x [ 'month' ]) y_trues . append ( y ) y_preds . append ( y_pred ) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Ground truth' ) ax . plot ( dates , y_preds , lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . legend () ax . set_title ( metric ) Let's evaluate our first model. evaluate_model ( model ) /Users/max.halford/anaconda3/lib/python3.9/site-packages/IPython/core/pylabtools.py:151: UserWarning: Glyph 9 ( ) missing from current font. fig.canvas.print_figure(bytes_io, **kw) The model has captured a trend but not the right one. Indeed it thinks the trend is linear whereas we can visually see that the growth of the data increases with time. In other words the second derivative of the series is positive. This is a well know problem in time series forecasting and there are thus many ways to handle it; for example by using a Box-Cox transform . However we are going to do something a bit different, and instead linearly detrend the series using a TargetStandardScaler . from river import stats model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )), ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) Now let's try and capture the monthly trend by one-hot encoding the month name. import calendar def get_month ( x ): return { calendar . month_name [ month ]: month == x [ 'month' ] . month for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )) ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) This seems pretty decent. We can take a look at the weights of the linear regression to get an idea of the importance of each feature. model . regressor [ 'lin_reg' ] . weights {'January': -0.13808091575141299, 'February': -0.18716063793638954, 'March': -0.026469206216021102, 'April': -0.03500685108350436, 'May': -0.013638742192777328, 'June': 0.16194267303548826, 'July': 0.31995865445067634, 'August': 0.2810396556938982, 'September': 0.03834350518076595, 'October': -0.11655850082390988, 'November': -0.2663497734491209, 'December': -0.15396048501165746, 'ordinal_date': 1.0234863735122575} As could be expected the months of July and August have the highest weights because these are the months where people typically go on holiday abroad. The month of December has a low weight because this is a month of festivities in most of the Western world where people usually stay at home. Our model seems to understand which months are important, but it fails to see that the importance of each month grows multiplicatively as the years go on. In other words our model is too shy. We can fix this by increasing the learning rate of the LinearRegression 's optimizer. from river import optim model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) This is starting to look good! Naturally in production we would tune the learning rate, ideally in real-time. Before finishing, we're going to introduce a cool feature extraction trick based on radial basis function kernels . The one-hot encoding we did on the month is a good idea but if you think about it is a bit rigid. Indeed the value of each feature is going to be 0 or 1, depending on the month of each observation. We're basically saying that the month of September is as distant to the month of August as it is to the month of March. Of course this isn't true, and it would be nice if our features would reflect this. To do so we can simply calculate the distance between the month of each observation and all the months in the calendar. Instead of simply computing the distance linearly, we're going to use a so-called Gaussian radial basic function kernel . This is a bit of a mouthful but for us it boils down to a simple formula, which is: \\[d(i, j) = exp(-\\frac{(i - j)^2}{2\\sigma^2})\\] Intuitively this computes a similarity between two months -- denoted by \\(i\\) and \\(j\\) -- which decreases the further apart they are from each other. The \\(sigma\\) parameter can be seen as a hyperparameter than can be tuned -- in the following snippet we'll simply ignore it. The thing to take away is that this results in smoother predictions than when using a one-hot encoding scheme, which is often a desirable property. You can also see trick in action in this nice presentation . import math def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month_distances' , compose . FuncTransformer ( get_month_distances )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) We've managed to get a good looking prediction curve with a reasonably simple model. What's more our model has the advantage of being interpretable and easy to debug. There surely are more rocks to squeeze (e.g. tune the hyperparameters, use an ensemble model, etc.) but we'll leave that as an exercice to the reader. As a finishing touch we'll rewrite our pipeline using the | operator, which is called a \"pipe\". extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) ) model = extract_features | scale | learn model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model )","title":"Building a simple nowcasting model"},{"location":"examples/building-a-simple-nowcasting-model/#building-a-simple-nowcasting-model","text":"% matplotlib inline Nowcasting is a special case of forecasting. It simply consists in predicting the next value in a time series. We'll be using the international airline passenger data available from here . This particular dataset is included with river in the datasets module. from river import datasets for x , y in datasets . AirlinePassengers (): print ( x , y ) break {'month': datetime.datetime(1949, 1, 1, 0, 0)} 112 The data is as simple as can be: it consists of a sequence of months and values representing the total number of international airline passengers per month. Our goal is going to be to predict the number of passengers for the next month at each step. Notice that because the dataset is small -- which is usually the case for time series -- we could just fit a model from scratch each month. However for the sake of example we're going to train a single model online. Although the overall performance might be potentially weaker, training a time series model online has the benefit of being scalable if, say, you have have thousands of time series to manage . We'll start with a very simple model where the only feature will be the ordinal date of each month. This should be able to capture some of the underlying trend. from river import compose from river import linear_model from river import preprocessing def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) We'll write down a function to evaluate the model. This will go through each observation in the dataset and update the model as it goes on. The prior predictions will be stored along with the true values and will be plotted together. from river import metrics import matplotlib.pyplot as plt def evaluate_model ( model ): metric = metrics . Rolling ( metrics . MAE (), 12 ) dates = [] y_trues = [] y_preds = [] for x , y in datasets . AirlinePassengers (): # Obtain the prior prediction and update the model in one go y_pred = model . predict_one ( x ) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_pred ) # Store the true value and the prediction dates . append ( x [ 'month' ]) y_trues . append ( y ) y_preds . append ( y_pred ) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Ground truth' ) ax . plot ( dates , y_preds , lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . legend () ax . set_title ( metric ) Let's evaluate our first model. evaluate_model ( model ) /Users/max.halford/anaconda3/lib/python3.9/site-packages/IPython/core/pylabtools.py:151: UserWarning: Glyph 9 ( ) missing from current font. fig.canvas.print_figure(bytes_io, **kw) The model has captured a trend but not the right one. Indeed it thinks the trend is linear whereas we can visually see that the growth of the data increases with time. In other words the second derivative of the series is positive. This is a well know problem in time series forecasting and there are thus many ways to handle it; for example by using a Box-Cox transform . However we are going to do something a bit different, and instead linearly detrend the series using a TargetStandardScaler . from river import stats model = compose . Pipeline ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )), ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) Now let's try and capture the monthly trend by one-hot encoding the month name. import calendar def get_month ( x ): return { calendar . month_name [ month ]: month == x [ 'month' ] . month for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 )) ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) This seems pretty decent. We can take a look at the weights of the linear regression to get an idea of the importance of each feature. model . regressor [ 'lin_reg' ] . weights {'January': -0.13808091575141299, 'February': -0.18716063793638954, 'March': -0.026469206216021102, 'April': -0.03500685108350436, 'May': -0.013638742192777328, 'June': 0.16194267303548826, 'July': 0.31995865445067634, 'August': 0.2810396556938982, 'September': 0.03834350518076595, 'October': -0.11655850082390988, 'November': -0.2663497734491209, 'December': -0.15396048501165746, 'ordinal_date': 1.0234863735122575} As could be expected the months of July and August have the highest weights because these are the months where people typically go on holiday abroad. The month of December has a low weight because this is a month of festivities in most of the Western world where people usually stay at home. Our model seems to understand which months are important, but it fails to see that the importance of each month grows multiplicatively as the years go on. In other words our model is too shy. We can fix this by increasing the learning rate of the LinearRegression 's optimizer. from river import optim model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month' , compose . FuncTransformer ( get_month )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) This is starting to look good! Naturally in production we would tune the learning rate, ideally in real-time. Before finishing, we're going to introduce a cool feature extraction trick based on radial basis function kernels . The one-hot encoding we did on the month is a good idea but if you think about it is a bit rigid. Indeed the value of each feature is going to be 0 or 1, depending on the month of each observation. We're basically saying that the month of September is as distant to the month of August as it is to the month of March. Of course this isn't true, and it would be nice if our features would reflect this. To do so we can simply calculate the distance between the month of each observation and all the months in the calendar. Instead of simply computing the distance linearly, we're going to use a so-called Gaussian radial basic function kernel . This is a bit of a mouthful but for us it boils down to a simple formula, which is: \\[d(i, j) = exp(-\\frac{(i - j)^2}{2\\sigma^2})\\] Intuitively this computes a similarity between two months -- denoted by \\(i\\) and \\(j\\) -- which decreases the further apart they are from each other. The \\(sigma\\) parameter can be seen as a hyperparameter than can be tuned -- in the following snippet we'll simply ignore it. The thing to take away is that this results in smoother predictions than when using a one-hot encoding scheme, which is often a desirable property. You can also see trick in action in this nice presentation . import math def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'ordinal_date' , compose . FuncTransformer ( get_ordinal_date )), ( 'month_distances' , compose . FuncTransformer ( get_month_distances )), )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) )) ) model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model ) We've managed to get a good looking prediction curve with a reasonably simple model. What's more our model has the advantage of being interpretable and easy to debug. There surely are more rocks to squeeze (e.g. tune the hyperparameters, use an ensemble model, etc.) but we'll leave that as an exercice to the reader. As a finishing touch we'll rewrite our pipeline using the | operator, which is called a \"pipe\". extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ) ) model = extract_features | scale | learn model = preprocessing . TargetStandardScaler ( regressor = model ) evaluate_model ( model )","title":"Building a simple nowcasting model"},{"location":"examples/concept-drift-detection/","text":"Concept Drift \u00b6 In the context of data streams, it is assumed that data can change over time. The change in the relationship between the data (features) and the target to learn is known as Concept Drift . As examples we can mention, the electricity demand across the year, the stock market, and the likelihood of a new movie to be successful. Let's consider the movie example: Two movies can have similar features such as popular actors/directors, storyline, production budget, marketing campaigns, etc. yet it is not certain that both will be similarly successful. What the target audience considers worth watching (and their money) is constantly changing and production companies must adapt accordingly to avoid \"box office flops\". Impact of drift on learning \u00b6 Concept drift can have a significant impact on predictive performance if not handled properly. Most batch learning models will fail in the presence of concept drift as they are essentially trained on different data. On the other hand, stream learning methods continuously update themselves and adapt to new concepts. Furthermore, drift-aware methods use change detection methods (a.k.a. drift detectors) to trigger mitigation mechanisms if a change in performance is detected. Detecting concept drift \u00b6 Multiple drift detection methods have been proposed. The goal of a drift detector is to signal an alarm in the presence of drift. A good drift detector maximizes the number of true positives while keeping the number of false positives to a minimum. It must also be resource-wise efficient to work in the context of infinite data streams. For this example, we will generate a synthetic data stream by concatenating 3 distributions of 1000 samples each: \\(dist_a\\) : \\(\\mu=0.8\\) , \\(\\sigma=0.05\\) \\(dist_b\\) : \\(\\mu=0.4\\) , \\(\\sigma=0.02\\) \\(dist_c\\) : \\(\\mu=0.6\\) , \\(\\sigma=0.1\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib import gridspec # Generate data for 3 distributions random_state = np . random . RandomState ( seed = 42 ) dist_a = random_state . normal ( 0.8 , 0.05 , 1000 ) dist_b = random_state . normal ( 0.4 , 0.02 , 1000 ) dist_c = random_state . normal ( 0.6 , 0.1 , 1000 ) # Concatenate data to simulate a data stream with 2 drifts stream = np . concatenate (( dist_a , dist_b , dist_c )) # Auxiliary function to plot the data def plot_data ( dist_a , dist_b , dist_c , drifts = None ): fig = plt . figure ( figsize = ( 7 , 3 ), tight_layout = True ) gs = gridspec . GridSpec ( 1 , 2 , width_ratios = [ 3 , 1 ]) ax1 , ax2 = plt . subplot ( gs [ 0 ]), plt . subplot ( gs [ 1 ]) ax1 . grid () ax1 . plot ( stream , label = 'Stream' ) ax2 . grid ( axis = 'y' ) ax2 . hist ( dist_a , label = r '$dist_a$' ) ax2 . hist ( dist_b , label = r '$dist_b$' ) ax2 . hist ( dist_c , label = r '$dist_c$' ) if drifts is not None : for drift_detected in drifts : ax1 . axvline ( drift_detected , color = 'red' ) plt . show () plot_data ( dist_a , dist_b , dist_c ) Drift detection test \u00b6 We will use the ADaptive WINdowing ( ADWIN ) drift detection method. Remember that the goal is to indicate that drift has occurred after samples 1000 and 2000 in the synthetic data stream. from river import drift drift_detector = drift . ADWIN () drifts = [] for i , val in enumerate ( stream ): drift_detector . update ( val ) # Data is processed one sample at a time if drift_detector . change_detected : # The drift detector indicates after each sample if there is a drift in the data print ( f 'Change detected at index { i } ' ) drifts . append ( i ) drift_detector . reset () # As a best practice, we reset the detector plot_data ( dist_a , dist_b , dist_c , drifts ) Change detected at index 1055 Change detected at index 2079 We see that ADWIN successfully indicates the presence of drift (red vertical lines) close to the begining of a new data distribution. We conclude this example with some remarks regarding concept drift detectors and their usage: In practice, drift detectors provide stream learning methods with robustness against concept drift. Drift detectors monitor the model usually through a performance metric. Drift detectors work on univariate data. This is why they are used to monitor a model's performance and not the data itself. Remember that concept drift is defined as a change in the relationship between data and the target to learn (in supervised learning). Drift detectors define their expectations regarding input data. It is important to know these expectations to feed a given drift detector with the correct data.","title":"Concept Drift"},{"location":"examples/concept-drift-detection/#concept-drift","text":"In the context of data streams, it is assumed that data can change over time. The change in the relationship between the data (features) and the target to learn is known as Concept Drift . As examples we can mention, the electricity demand across the year, the stock market, and the likelihood of a new movie to be successful. Let's consider the movie example: Two movies can have similar features such as popular actors/directors, storyline, production budget, marketing campaigns, etc. yet it is not certain that both will be similarly successful. What the target audience considers worth watching (and their money) is constantly changing and production companies must adapt accordingly to avoid \"box office flops\".","title":"Concept Drift"},{"location":"examples/concept-drift-detection/#impact-of-drift-on-learning","text":"Concept drift can have a significant impact on predictive performance if not handled properly. Most batch learning models will fail in the presence of concept drift as they are essentially trained on different data. On the other hand, stream learning methods continuously update themselves and adapt to new concepts. Furthermore, drift-aware methods use change detection methods (a.k.a. drift detectors) to trigger mitigation mechanisms if a change in performance is detected.","title":"Impact of drift on learning"},{"location":"examples/concept-drift-detection/#detecting-concept-drift","text":"Multiple drift detection methods have been proposed. The goal of a drift detector is to signal an alarm in the presence of drift. A good drift detector maximizes the number of true positives while keeping the number of false positives to a minimum. It must also be resource-wise efficient to work in the context of infinite data streams. For this example, we will generate a synthetic data stream by concatenating 3 distributions of 1000 samples each: \\(dist_a\\) : \\(\\mu=0.8\\) , \\(\\sigma=0.05\\) \\(dist_b\\) : \\(\\mu=0.4\\) , \\(\\sigma=0.02\\) \\(dist_c\\) : \\(\\mu=0.6\\) , \\(\\sigma=0.1\\) . import numpy as np import matplotlib.pyplot as plt from matplotlib import gridspec # Generate data for 3 distributions random_state = np . random . RandomState ( seed = 42 ) dist_a = random_state . normal ( 0.8 , 0.05 , 1000 ) dist_b = random_state . normal ( 0.4 , 0.02 , 1000 ) dist_c = random_state . normal ( 0.6 , 0.1 , 1000 ) # Concatenate data to simulate a data stream with 2 drifts stream = np . concatenate (( dist_a , dist_b , dist_c )) # Auxiliary function to plot the data def plot_data ( dist_a , dist_b , dist_c , drifts = None ): fig = plt . figure ( figsize = ( 7 , 3 ), tight_layout = True ) gs = gridspec . GridSpec ( 1 , 2 , width_ratios = [ 3 , 1 ]) ax1 , ax2 = plt . subplot ( gs [ 0 ]), plt . subplot ( gs [ 1 ]) ax1 . grid () ax1 . plot ( stream , label = 'Stream' ) ax2 . grid ( axis = 'y' ) ax2 . hist ( dist_a , label = r '$dist_a$' ) ax2 . hist ( dist_b , label = r '$dist_b$' ) ax2 . hist ( dist_c , label = r '$dist_c$' ) if drifts is not None : for drift_detected in drifts : ax1 . axvline ( drift_detected , color = 'red' ) plt . show () plot_data ( dist_a , dist_b , dist_c )","title":"Detecting concept drift"},{"location":"examples/concept-drift-detection/#drift-detection-test","text":"We will use the ADaptive WINdowing ( ADWIN ) drift detection method. Remember that the goal is to indicate that drift has occurred after samples 1000 and 2000 in the synthetic data stream. from river import drift drift_detector = drift . ADWIN () drifts = [] for i , val in enumerate ( stream ): drift_detector . update ( val ) # Data is processed one sample at a time if drift_detector . change_detected : # The drift detector indicates after each sample if there is a drift in the data print ( f 'Change detected at index { i } ' ) drifts . append ( i ) drift_detector . reset () # As a best practice, we reset the detector plot_data ( dist_a , dist_b , dist_c , drifts ) Change detected at index 1055 Change detected at index 2079 We see that ADWIN successfully indicates the presence of drift (red vertical lines) close to the begining of a new data distribution. We conclude this example with some remarks regarding concept drift detectors and their usage: In practice, drift detectors provide stream learning methods with robustness against concept drift. Drift detectors monitor the model usually through a performance metric. Drift detectors work on univariate data. This is why they are used to monitor a model's performance and not the data itself. Remember that concept drift is defined as a change in the relationship between data and the target to learn (in supervised learning). Drift detectors define their expectations regarding input data. It is important to know these expectations to feed a given drift detector with the correct data.","title":"Drift detection test"},{"location":"examples/content-personalization/","text":"Content personalization \u00b6 Without context \u00b6 This example takes inspiration from Vowpal Wabbit's excellent tutorial . Content personalization is about taking into account user preferences. It's a special case of recommender systems. Ideally, side-information should be taken into account in addition to the user. But we'll start with something simpler. We'll assume that each user has stable preferences that are independent of the context. We capture this by implementing a \"reward\" function. users = [ 'Tom' , 'Anna' ] items = { 'politics' , 'sports' , 'music' , 'food' , 'finance' , 'health' , 'camping' } def get_reward ( user , item ) -> bool : if user == 'Tom' : return item in { 'music' , 'politics' } if user == 'Anna' : return item in { 'politics' , 'sports' } Measuring the performance of a recommendation is not straightforward, mostly because of the interactive aspect of recommender systems. In a real situation, recommendations are presented to a user, and the user gives feedback indicating whether they like what they have been recommended or not. This feedback loop can't be captured entirely by a historical dataset. Some kind of simulator is required to generate recommendations and capture feedback. We already have a reward function. Now let's implement a simulation function. import random import matplotlib.pyplot as plt def plot_ctr ( ctr ): plt . plot ( range ( 1 , len ( ctr ) + 1 ), ctr ) plt . xlabel ( 'n_iterations' , fontsize = 14 ) plt . ylabel ( 'CTR' , fontsize = 14 ) plt . ylim ([ 0 , 1 ]) plt . title ( f 'final CTR: { ctr [ - 1 ] : .2% } ' , fontsize = 14 ) plt . grid () def simulate ( n , reward_func , model , seed ): rng = random . Random ( seed ) n_clicks = 0 ctr = [] # click-through rate along time for i in range ( n ): # Pick a user at random user = rng . choice ( users ) # Make a single recommendation item = model . rank ( user , items = items )[ 0 ] # Measure the reward clicked = reward_func ( user , item ) n_clicks += clicked ctr . append ( n_clicks / ( i + 1 )) # Update the model model . learn_one ( user , item , clicked ) plot_ctr ( ctr ) This simulation function does quite a few things. It can be seen as a simple reinforcement learning simulation. It samples a user, and then ask the model to provide a single recommendation. The user then gives as to whether they liked the recommendation or not. Crucially, the user doesn't tell us what item they would have liked. We could model this as a multi-class classification problem if that were the case. The strategy parameter determines the mechanism used to generate the recommendations. The 'best' strategy means that the items are each scored by the model, and are then ranked from the most preferred to the least preferred. Here the most preferred item is the one which gets recommended. But you could imagine all sorts of alternative ways to proceed. We can first evaluate a recommended which acts completely at random. It assigns a random preference to each item, regardless of the user. from river import reco model = reco . RandomNormal ( seed = 10 ) simulate ( 5_000 , get_reward , model , seed = 42 ) We can see that the click-through rate (CTR) oscillates around 28.74%. In fact, this model is expected to be correct 100 * (2 / 7)% = 28.57% of the time. Indeed, each user likes two items, and there are seven items in total. Let's now use the Baseline recommended. This one models each preference as the following sum: \\[preference = \\bar{y} + b_{u} + b_{i}\\] where \\(\\bar{y}\\) is the average CTR overall \\(b_{u}\\) is the average CTR per user minus \\(\\bar{y}\\) -- it's therefore called a bias \\(b_{i}\\) is the average CTR per item minus \\(\\bar{y}\\) This model is considered to be a baseline because it doesn't actually learn what items are preferred by each user. Instead it models each user and item separately. We shouldn't expect it to be a strong model. It should however do better than the random model used above. model = reco . Baseline ( seed = 10 ) simulate ( 5_000 , get_reward , model , seed = 42 ) This baseline model seems perfect, which is surprising. The reason why it works so well is because both users have in common that they both like politics. The model therefore learns that the 'politics' is a good item to recommend. model . i_biases defaultdict(Zeros (), {'music': -0.013333333333333336, 'camping': -0.01, 'food': -0.0078000000000000005, 'health': -0.0063106666666666675, 'finance': -0.0052320723809523816, 'politics': 0.014896375560251602, 'sports': 0.0}) The model is not as performant if we use a reward function where both users have different preferences. simulate ( 5_000 , reward_func = lambda user , item : ( item in { 'music' , 'politics' } if user == \"Tom\" else item in { 'food' , 'sports' } ), model = model , seed = 42 ) A good recommender model should at the very least understand what kind of items each user prefers. One of the simplest and yet performant way to do this is Simon Funk's SGD method he developped for the Netflix challenge and wrote about here . It models each user and each item as latent vectors. The dot product of these two vectors is the expected preference of the user for the item. model = reco . FunkMF ( seed = 10 ) simulate ( 5_000 , get_reward , model , seed = 42 ) We can see that this model learns what items each user enjoys very well. Of course, there are some caveats. In our simulation, we ask the model to recommend the item most likely to be preferred for each user. Indeed, we rank all the items and pick the item at the top of the list. We do this many times for only two users. This is of course not realistic. Users will get fed up with recommendations if they're always shown the same item. It's important to include diversity into recommendations, and to let the model explore other options instead of always focusing on the item with the highest score. This is where evaluating recommender systems gets tricky: the reward function itself is difficult to model. We will keep ignoring these caveats in this notebook. Instead we will focus on a different concern: making recommendations when context is involved. With context \u00b6 We'll add some context by making it so that user preferences change depending on the time the day. Very simply, preferences might change from morning to afternoon. This is captured by the following reward function. times_of_day = [ 'morning' , 'afternoon' ] def get_reward ( user , item , context ): if user == 'Tom' : if context [ 'time_of_day' ] == 'morning' : return item == 'politics' if context [ 'time_of_day' ] == 'afternoon' : return item == 'music' if user == 'Anna' : if context [ 'time_of_day' ] == 'morning' : return item == 'sports' if context [ 'time_of_day' ] == 'afternoon' : return item == 'politics' We have to update our simulation function to generate a random context at each step. We also want our model to use it for recommending items as well as learning. def simulate ( n , reward_func , model , seed ): rng = random . Random ( seed ) n_clicks = 0 ctr = [] for i in range ( n ): user = rng . choice ( users ) # New: pass a context context = { 'time_of_day' : rng . choice ( times_of_day )} item = model . rank ( user , items , context )[ 0 ] clicked = reward_func ( user , item , context ) n_clicks += clicked ctr . append ( n_clicks / ( i + 1 )) # New: pass a context model . learn_one ( user , item , clicked , context ) plot_ctr ( ctr ) Not all models are capable of taking into account context. For instance, the FunkMF model only models users and items. It completely ignores the context, even when we provide one. All recommender models inherit from the base Recommender class. They also have a property which indicates whether or not they are able to handle context: model = reco . FunkMF ( seed = 10 ) model . is_contextual False Let's see well it performs. simulate ( 5_000 , get_reward , model , seed = 42 ) The performance has roughly been divided by half. This is most likely because there are now two times of day, and if the model has learnt preferences for one time of the day, then it's expected to be wrong half of the time. Before delving into recsys models that can handle context, a simple hack is to notice that we can append the time of day to the user. This effectively results in new users which our model can distinguish between. We could apply this trick during the simulation, but we can also override the behavior of the learn_one and rank methods of our model. class FunkMFWithHack ( reco . FunkMF ): def learn_one ( self , user , item , reward , context ): user = f \" { user } @ { context [ 'time_of_day' ] } \" return super () . learn_one ( user , item , reward , context ) def rank ( self , user , items , context ): user = f \" { user } @ { context [ 'time_of_day' ] } \" return super () . rank ( user , items , context ) model = FunkMFWithHack ( seed = 29 ) simulate ( 5_000 , get_reward , model , seed = 42 ) We can verify that the model has learnt the correct preferences by looking at the expected preference for each (user, item) pair. import pandas as pd ( pd . DataFrame ( { 'user' : user , 'item' : item , 'preference' : model . predict_one ( user , item ) } for user in model . u_latents for item in model . i_latents ) . pivot ( 'user' , 'item' ) . style . highlight_max ( color = 'lightgreen' , axis = 'columns' ) ) #T_36cea_row0_col5, #T_36cea_row1_col6, #T_36cea_row2_col4, #T_36cea_row3_col5 { background-color: lightgreen; } preference item camping finance food health music politics sports user Anna@afternoon 0.044712 -0.063282 -0.060270 -0.041465 -0.059729 1.000000 0.062710 Anna@morning 0.101267 0.076300 -0.117756 -0.135705 0.260879 0.063001 1.000000 Tom@afternoon 0.116019 0.136308 0.088899 -0.182063 1.000000 -0.228918 0.268113 Tom@morning 0.042014 -0.070943 -0.072108 -0.036848 -0.213144 1.000000 -0.006144","title":"Content personalization"},{"location":"examples/content-personalization/#content-personalization","text":"","title":"Content personalization"},{"location":"examples/content-personalization/#without-context","text":"This example takes inspiration from Vowpal Wabbit's excellent tutorial . Content personalization is about taking into account user preferences. It's a special case of recommender systems. Ideally, side-information should be taken into account in addition to the user. But we'll start with something simpler. We'll assume that each user has stable preferences that are independent of the context. We capture this by implementing a \"reward\" function. users = [ 'Tom' , 'Anna' ] items = { 'politics' , 'sports' , 'music' , 'food' , 'finance' , 'health' , 'camping' } def get_reward ( user , item ) -> bool : if user == 'Tom' : return item in { 'music' , 'politics' } if user == 'Anna' : return item in { 'politics' , 'sports' } Measuring the performance of a recommendation is not straightforward, mostly because of the interactive aspect of recommender systems. In a real situation, recommendations are presented to a user, and the user gives feedback indicating whether they like what they have been recommended or not. This feedback loop can't be captured entirely by a historical dataset. Some kind of simulator is required to generate recommendations and capture feedback. We already have a reward function. Now let's implement a simulation function. import random import matplotlib.pyplot as plt def plot_ctr ( ctr ): plt . plot ( range ( 1 , len ( ctr ) + 1 ), ctr ) plt . xlabel ( 'n_iterations' , fontsize = 14 ) plt . ylabel ( 'CTR' , fontsize = 14 ) plt . ylim ([ 0 , 1 ]) plt . title ( f 'final CTR: { ctr [ - 1 ] : .2% } ' , fontsize = 14 ) plt . grid () def simulate ( n , reward_func , model , seed ): rng = random . Random ( seed ) n_clicks = 0 ctr = [] # click-through rate along time for i in range ( n ): # Pick a user at random user = rng . choice ( users ) # Make a single recommendation item = model . rank ( user , items = items )[ 0 ] # Measure the reward clicked = reward_func ( user , item ) n_clicks += clicked ctr . append ( n_clicks / ( i + 1 )) # Update the model model . learn_one ( user , item , clicked ) plot_ctr ( ctr ) This simulation function does quite a few things. It can be seen as a simple reinforcement learning simulation. It samples a user, and then ask the model to provide a single recommendation. The user then gives as to whether they liked the recommendation or not. Crucially, the user doesn't tell us what item they would have liked. We could model this as a multi-class classification problem if that were the case. The strategy parameter determines the mechanism used to generate the recommendations. The 'best' strategy means that the items are each scored by the model, and are then ranked from the most preferred to the least preferred. Here the most preferred item is the one which gets recommended. But you could imagine all sorts of alternative ways to proceed. We can first evaluate a recommended which acts completely at random. It assigns a random preference to each item, regardless of the user. from river import reco model = reco . RandomNormal ( seed = 10 ) simulate ( 5_000 , get_reward , model , seed = 42 ) We can see that the click-through rate (CTR) oscillates around 28.74%. In fact, this model is expected to be correct 100 * (2 / 7)% = 28.57% of the time. Indeed, each user likes two items, and there are seven items in total. Let's now use the Baseline recommended. This one models each preference as the following sum: \\[preference = \\bar{y} + b_{u} + b_{i}\\] where \\(\\bar{y}\\) is the average CTR overall \\(b_{u}\\) is the average CTR per user minus \\(\\bar{y}\\) -- it's therefore called a bias \\(b_{i}\\) is the average CTR per item minus \\(\\bar{y}\\) This model is considered to be a baseline because it doesn't actually learn what items are preferred by each user. Instead it models each user and item separately. We shouldn't expect it to be a strong model. It should however do better than the random model used above. model = reco . Baseline ( seed = 10 ) simulate ( 5_000 , get_reward , model , seed = 42 ) This baseline model seems perfect, which is surprising. The reason why it works so well is because both users have in common that they both like politics. The model therefore learns that the 'politics' is a good item to recommend. model . i_biases defaultdict(Zeros (), {'music': -0.013333333333333336, 'camping': -0.01, 'food': -0.0078000000000000005, 'health': -0.0063106666666666675, 'finance': -0.0052320723809523816, 'politics': 0.014896375560251602, 'sports': 0.0}) The model is not as performant if we use a reward function where both users have different preferences. simulate ( 5_000 , reward_func = lambda user , item : ( item in { 'music' , 'politics' } if user == \"Tom\" else item in { 'food' , 'sports' } ), model = model , seed = 42 ) A good recommender model should at the very least understand what kind of items each user prefers. One of the simplest and yet performant way to do this is Simon Funk's SGD method he developped for the Netflix challenge and wrote about here . It models each user and each item as latent vectors. The dot product of these two vectors is the expected preference of the user for the item. model = reco . FunkMF ( seed = 10 ) simulate ( 5_000 , get_reward , model , seed = 42 ) We can see that this model learns what items each user enjoys very well. Of course, there are some caveats. In our simulation, we ask the model to recommend the item most likely to be preferred for each user. Indeed, we rank all the items and pick the item at the top of the list. We do this many times for only two users. This is of course not realistic. Users will get fed up with recommendations if they're always shown the same item. It's important to include diversity into recommendations, and to let the model explore other options instead of always focusing on the item with the highest score. This is where evaluating recommender systems gets tricky: the reward function itself is difficult to model. We will keep ignoring these caveats in this notebook. Instead we will focus on a different concern: making recommendations when context is involved.","title":"Without context"},{"location":"examples/content-personalization/#with-context","text":"We'll add some context by making it so that user preferences change depending on the time the day. Very simply, preferences might change from morning to afternoon. This is captured by the following reward function. times_of_day = [ 'morning' , 'afternoon' ] def get_reward ( user , item , context ): if user == 'Tom' : if context [ 'time_of_day' ] == 'morning' : return item == 'politics' if context [ 'time_of_day' ] == 'afternoon' : return item == 'music' if user == 'Anna' : if context [ 'time_of_day' ] == 'morning' : return item == 'sports' if context [ 'time_of_day' ] == 'afternoon' : return item == 'politics' We have to update our simulation function to generate a random context at each step. We also want our model to use it for recommending items as well as learning. def simulate ( n , reward_func , model , seed ): rng = random . Random ( seed ) n_clicks = 0 ctr = [] for i in range ( n ): user = rng . choice ( users ) # New: pass a context context = { 'time_of_day' : rng . choice ( times_of_day )} item = model . rank ( user , items , context )[ 0 ] clicked = reward_func ( user , item , context ) n_clicks += clicked ctr . append ( n_clicks / ( i + 1 )) # New: pass a context model . learn_one ( user , item , clicked , context ) plot_ctr ( ctr ) Not all models are capable of taking into account context. For instance, the FunkMF model only models users and items. It completely ignores the context, even when we provide one. All recommender models inherit from the base Recommender class. They also have a property which indicates whether or not they are able to handle context: model = reco . FunkMF ( seed = 10 ) model . is_contextual False Let's see well it performs. simulate ( 5_000 , get_reward , model , seed = 42 ) The performance has roughly been divided by half. This is most likely because there are now two times of day, and if the model has learnt preferences for one time of the day, then it's expected to be wrong half of the time. Before delving into recsys models that can handle context, a simple hack is to notice that we can append the time of day to the user. This effectively results in new users which our model can distinguish between. We could apply this trick during the simulation, but we can also override the behavior of the learn_one and rank methods of our model. class FunkMFWithHack ( reco . FunkMF ): def learn_one ( self , user , item , reward , context ): user = f \" { user } @ { context [ 'time_of_day' ] } \" return super () . learn_one ( user , item , reward , context ) def rank ( self , user , items , context ): user = f \" { user } @ { context [ 'time_of_day' ] } \" return super () . rank ( user , items , context ) model = FunkMFWithHack ( seed = 29 ) simulate ( 5_000 , get_reward , model , seed = 42 ) We can verify that the model has learnt the correct preferences by looking at the expected preference for each (user, item) pair. import pandas as pd ( pd . DataFrame ( { 'user' : user , 'item' : item , 'preference' : model . predict_one ( user , item ) } for user in model . u_latents for item in model . i_latents ) . pivot ( 'user' , 'item' ) . style . highlight_max ( color = 'lightgreen' , axis = 'columns' ) ) #T_36cea_row0_col5, #T_36cea_row1_col6, #T_36cea_row2_col4, #T_36cea_row3_col5 { background-color: lightgreen; } preference item camping finance food health music politics sports user Anna@afternoon 0.044712 -0.063282 -0.060270 -0.041465 -0.059729 1.000000 0.062710 Anna@morning 0.101267 0.076300 -0.117756 -0.135705 0.260879 0.063001 1.000000 Tom@afternoon 0.116019 0.136308 0.088899 -0.182063 1.000000 -0.228918 0.268113 Tom@morning 0.042014 -0.070943 -0.072108 -0.036848 -0.213144 1.000000 -0.006144","title":"With context"},{"location":"examples/debugging-a-pipeline/","text":"Debugging a pipeline \u00b6 river encourages users to make use of pipelines. The biggest pain point of pipelines is that it can be hard to understand what's happening to the data, especially when the pipeline is complex. Fortunately the Pipeline class has a debug_one method that can help out. Let's look at a fairly complex pipeline for predicting the number of bikes in 5 bike stations from the city of Toulouse. It doesn't matter if you understand the pipeline or not; the point of this notebook is to learn how to introspect a pipeline. import datetime as dt from river import compose from river import datasets from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats from river import stream X_y = datasets . Bikes () X_y = stream . simulate_qa ( X_y , moment = 'moment' , delay = dt . timedelta ( minutes = 30 )) def add_time_features ( x ): return { ** x , 'hour' : x [ 'moment' ] . hour , 'day' : x [ 'moment' ] . weekday () } model = add_time_features model |= ( compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) + feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () metric = metrics . MAE () questions = {} for i , x , y in X_y : # Question is_question = y is None if is_question : y_pred = model . predict_one ( x ) questions [ i ] = y_pred # Answer else : metric . update ( y , questions [ i ]) model = model . learn_one ( x , y ) if i >= 30000 and i % 30000 == 0 : print ( i , metric ) 30000 MAE: 2.220942 60000 MAE: 2.270271 90000 MAE: 2.301302 120000 MAE: 2.275876 150000 MAE: 2.275224 180000 MAE: 2.289347 Let's start by looking at the pipeline. You can click each cell to display the current state for each step of the pipeline. model add_time_features def add_time_features(x): return { **x, 'hour': x['moment'].hour, 'day': x['moment'].weekday() } ['clouds', 'humidity', 'pressure', 'temperature', 'wind'] {'keys': {'temperature', 'wind', 'humidity', 'pressure', 'clouds'}} y_mean_by_station_and_hour {'_feature_name': 'y_mean_by_station_and_hour', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f8f928024c0>, Mean: 0.), {('metro-canal-du-midi', 0): Mean: 7.93981, ('metro-canal-du-midi', 1): Mean: 8.179704, ('metro-canal-du-midi', 2): Mean: 8.35824, ('metro-canal-du-midi', 3): Mean: 8.656051, ('metro-canal-du-midi', 4): Mean: 8.868445, ('metro-canal-du-midi', 5): Mean: 8.99656, ('metro-canal-du-midi', 6): Mean: 9.09966, ('metro-canal-du-midi', 7): Mean: 8.852642, ('metro-canal-du-midi', 8): Mean: 12.66712, ('metro-canal-du-midi', 9): Mean: 13.412186, ('metro-canal-du-midi', 10): Mean: 12.486815, ('metro-canal-du-midi', 11): Mean: 11.675479, ('metro-canal-du-midi', 12): Mean: 10.197409, ('metro-canal-du-midi', 13): Mean: 10.650855, ('metro-canal-du-midi', 14): Mean: 11.109123, ('metro-canal-du-midi', 15): Mean: 11.068934, ('metro-canal-du-midi', 16): Mean: 11.274958, ('metro-canal-du-midi', 17): Mean: 8.459136, ('metro-canal-du-midi', 18): Mean: 7.587469, ('metro-canal-du-midi', 19): Mean: 7.734677, ('metro-canal-du-midi', 20): Mean: 7.582465, ('metro-canal-du-midi', 21): Mean: 7.190665, ('metro-canal-du-midi', 22): Mean: 7.486895, ('metro-canal-du-midi', 23): Mean: 7.840791, ('place-des-carmes', 0): Mean: 4.720696, ('place-des-carmes', 1): Mean: 3.390295, ('place-des-carmes', 2): Mean: 2.232181, ('place-des-carmes', 3): Mean: 1.371981, ('place-des-carmes', 4): Mean: 1.051665, ('place-des-carmes', 5): Mean: 0.984993, ('place-des-carmes', 6): Mean: 2.039947, ('place-des-carmes', 7): Mean: 3.850369, ('place-des-carmes', 8): Mean: 3.792624, ('place-des-carmes', 9): Mean: 5.957182, ('place-des-carmes', 10): Mean: 8.575303, ('place-des-carmes', 11): Mean: 9.321546, ('place-des-carmes', 12): Mean: 10.511931, ('place-des-carmes', 13): Mean: 11.392745, ('place-des-carmes', 14): Mean: 10.735003, ('place-des-carmes', 15): Mean: 10.198787, ('place-des-carmes', 16): Mean: 9.941479, ('place-des-carmes', 17): Mean: 9.125579, ('place-des-carmes', 18): Mean: 7.660775, ('place-des-carmes', 19): Mean: 6.847649, ('place-des-carmes', 20): Mean: 9.626876, ('place-des-carmes', 21): Mean: 11.602929, ('place-des-carmes', 22): Mean: 10.405537, ('place-des-carmes', 23): Mean: 7.700904, ('place-esquirol', 0): Mean: 7.415789, ('place-esquirol', 1): Mean: 5.244396, ('place-esquirol', 2): Mean: 2.858635, ('place-esquirol', 3): Mean: 1.155929, ('place-esquirol', 4): Mean: 0.73306, ('place-esquirol', 5): Mean: 0.668546, ('place-esquirol', 6): Mean: 1.21265, ('place-esquirol', 7): Mean: 3.107535, ('place-esquirol', 8): Mean: 8.518696, ('place-esquirol', 9): Mean: 15.470588, ('place-esquirol', 10): Mean: 19.465005, ('place-esquirol', 11): Mean: 22.976512, ('place-esquirol', 12): Mean: 25.324159, ('place-esquirol', 13): Mean: 25.428847, ('place-esquirol', 14): Mean: 24.57762, ('place-esquirol', 15): Mean: 24.416851, ('place-esquirol', 16): Mean: 23.555125, ('place-esquirol', 17): Mean: 22.062564, ('place-esquirol', 18): Mean: 18.10623, ('place-esquirol', 19): Mean: 11.916638, ('place-esquirol', 20): Mean: 13.346362, ('place-esquirol', 21): Mean: 16.743318, ('place-esquirol', 22): Mean: 15.562088, ('place-esquirol', 23): Mean: 10.911134, ('place-jeanne-darc', 0): Mean: 6.541667, ('place-jeanne-darc', 1): Mean: 5.99892, ('place-jeanne-darc', 2): Mean: 5.598169, ('place-jeanne-darc', 3): Mean: 5.180556, ('place-jeanne-darc', 4): Mean: 4.779626, ('place-jeanne-darc', 5): Mean: 4.67063, ('place-jeanne-darc', 6): Mean: 4.611995, ('place-jeanne-darc', 7): Mean: 4.960718, ('place-jeanne-darc', 8): Mean: 5.552273, ('place-jeanne-darc', 9): Mean: 6.249573, ('place-jeanne-darc', 10): Mean: 5.735553, ('place-jeanne-darc', 11): Mean: 5.616142, ('place-jeanne-darc', 12): Mean: 5.787478, ('place-jeanne-darc', 13): Mean: 5.817699, ('place-jeanne-darc', 14): Mean: 5.657546, ('place-jeanne-darc', 15): Mean: 6.224604, ('place-jeanne-darc', 16): Mean: 5.796141, ('place-jeanne-darc', 17): Mean: 5.743089, ('place-jeanne-darc', 18): Mean: 5.674784, ('place-jeanne-darc', 19): Mean: 5.833068, ('place-jeanne-darc', 20): Mean: 6.015755, ('place-jeanne-darc', 21): Mean: 6.242541, ('place-jeanne-darc', 22): Mean: 6.141509, ('place-jeanne-darc', 23): Mean: 6.493028, ('pomme', 0): Mean: 3.301532, ('pomme', 1): Mean: 2.312914, ('pomme', 2): Mean: 2.144453, ('pomme', 3): Mean: 1.563622, ('pomme', 4): Mean: 0.947328, ('pomme', 5): Mean: 0.924175, ('pomme', 6): Mean: 1.287805, ('pomme', 7): Mean: 1.299456, ('pomme', 8): Mean: 2.94988, ('pomme', 9): Mean: 7.89396, ('pomme', 10): Mean: 11.791436, ('pomme', 11): Mean: 12.976854, ('pomme', 12): Mean: 13.962654, ('pomme', 13): Mean: 11.692257, ('pomme', 14): Mean: 11.180851, ('pomme', 15): Mean: 11.939586, ('pomme', 16): Mean: 12.267051, ('pomme', 17): Mean: 12.132993, ('pomme', 18): Mean: 11.399108, ('pomme', 19): Mean: 6.37021, ('pomme', 20): Mean: 5.279234, ('pomme', 21): Mean: 6.254257, ('pomme', 22): Mean: 6.568678, ('pomme', 23): Mean: 5.235756}), 'by': ['station', 'hour'], 'how': Mean: 0., 'on': 'y'} y_ewm_0.5_by_station {'_feature_name': 'y_ewm_0.5_by_station', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f8f928024c0>, EWMean: 0.), {('metro-canal-du-midi',): EWMean: 4.690531, ('place-des-carmes',): EWMean: 3.295317, ('place-esquirol',): EWMean: 31.539759, ('place-jeanne-darc',): EWMean: 22.449934, ('pomme',): EWMean: 11.803716}), 'by': ['station'], 'how': EWMean: 0., 'on': 'y'} StandardScaler {'counts': Counter({'y_ewm_0.5_by_station': 182470, 'y_mean_by_station_and_hour': 182470, 'temperature': 182470, 'wind': 182470, 'humidity': 182470, 'pressure': 182470, 'clouds': 182470}), 'means': defaultdict(<class 'float'>, {'clouds': 30.315131254453505, 'humidity': 62.24244533347998, 'pressure': 1017.0563060996391, 'temperature': 20.50980692716619, 'wind': 3.4184331122924543, 'y_ewm_0.5_by_station': 10.08331958752748, 'y_mean_by_station_and_hour': 9.410348580619415}), 'vars': defaultdict(<class 'float'>, {'clouds': 1389.0025610928221, 'humidity': 349.59967918503554, 'pressure': 33.298307526514115, 'temperature': 34.70701720774977, 'wind': 4.473627075744674, 'y_ewm_0.5_by_station': 80.17355266024735, 'y_mean_by_station_and_hour': 33.98249801051089}), 'with_std': True} LinearRegression {'_weights': {'y_ewm_0.5_by_station': 9.264175276315452, 'y_mean_by_station_and_hour': 0.19801400070497754, 'temperature': -0.42112178062191985, 'wind': -0.04087954775179702, 'humidity': 1.0125248437612904, 'pressure': 0.18137498909137262, 'clouds': -0.3269694794458269}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 9.223158690689175, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 182470})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } As mentioned above the Pipeline class has a debug_one method. You can use this at any point you want to visualize what happen to an input x . For example, let's see what happens to the last seen x . print ( model . debug_one ( x )) 0. Input -------- clouds: 88 (int) description: overcast clouds (str) humidity: 84 (int) moment: 2016-10-05 09:57:18 (datetime) pressure: 1,017.34000 (float) station: pomme (str) temperature: 17.45000 (float) wind: 1.95000 (float) 1. add_time_features -------------------- clouds: 88 (int) day: 2 (int) description: overcast clouds (str) hour: 9 (int) humidity: 84 (int) moment: 2016-10-05 09:57:18 (datetime) pressure: 1,017.34000 (float) station: pomme (str) temperature: 17.45000 (float) wind: 1.95000 (float) 2. Transformer union -------------------- 2.0 Select ---------- clouds: 88 (int) humidity: 84 (int) pressure: 1,017.34000 (float) temperature: 17.45000 (float) wind: 1.95000 (float) 2.1 TargetAgg ------------- y_mean_by_station_and_hour: 7.89396 (float) 2.2 TargetAgg1 -------------- y_ewm_0.5_by_station: 11.80372 (float) clouds: 88 (int) humidity: 84 (int) pressure: 1,017.34000 (float) temperature: 17.45000 (float) wind: 1.95000 (float) y_ewm_0.5_by_station: 11.80372 (float) y_mean_by_station_and_hour: 7.89396 (float) 3. StandardScaler ----------------- clouds: 1.54778 (float) humidity: 1.16366 (float) pressure: 0.04916 (float) temperature: -0.51938 (float) wind: -0.69426 (float) y_ewm_0.5_by_station: 0.19214 (float) y_mean_by_station_and_hour: -0.26013 (float) 4. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 9.22316 9.22316 y_ewm_0.5_by_station 0.19214 9.26418 1.78000 humidity 1.16366 1.01252 1.17823 temperature -0.51938 -0.42112 0.21872 wind -0.69426 -0.04088 0.02838 pressure 0.04916 0.18137 0.00892 y_mean_by_station_and_hour -0.26013 0.19801 -0.05151 clouds 1.54778 -0.32697 -0.50608 Prediction: 11.87982 The pipeline does quite a few things, but using debug_one shows what happens step by step. This is really useful for checking that the pipeline is behaving as you're expecting it too. Remember that you can debug_one whenever you wish, be it before, during, or after training a model.","title":"Debugging a pipeline"},{"location":"examples/debugging-a-pipeline/#debugging-a-pipeline","text":"river encourages users to make use of pipelines. The biggest pain point of pipelines is that it can be hard to understand what's happening to the data, especially when the pipeline is complex. Fortunately the Pipeline class has a debug_one method that can help out. Let's look at a fairly complex pipeline for predicting the number of bikes in 5 bike stations from the city of Toulouse. It doesn't matter if you understand the pipeline or not; the point of this notebook is to learn how to introspect a pipeline. import datetime as dt from river import compose from river import datasets from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats from river import stream X_y = datasets . Bikes () X_y = stream . simulate_qa ( X_y , moment = 'moment' , delay = dt . timedelta ( minutes = 30 )) def add_time_features ( x ): return { ** x , 'hour' : x [ 'moment' ] . hour , 'day' : x [ 'moment' ] . weekday () } model = add_time_features model |= ( compose . Select ( 'clouds' , 'humidity' , 'pressure' , 'temperature' , 'wind' ) + feature_extraction . TargetAgg ( by = [ 'station' , 'hour' ], how = stats . Mean ()) + feature_extraction . TargetAgg ( by = 'station' , how = stats . EWMean ()) ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () metric = metrics . MAE () questions = {} for i , x , y in X_y : # Question is_question = y is None if is_question : y_pred = model . predict_one ( x ) questions [ i ] = y_pred # Answer else : metric . update ( y , questions [ i ]) model = model . learn_one ( x , y ) if i >= 30000 and i % 30000 == 0 : print ( i , metric ) 30000 MAE: 2.220942 60000 MAE: 2.270271 90000 MAE: 2.301302 120000 MAE: 2.275876 150000 MAE: 2.275224 180000 MAE: 2.289347 Let's start by looking at the pipeline. You can click each cell to display the current state for each step of the pipeline. model add_time_features def add_time_features(x): return { **x, 'hour': x['moment'].hour, 'day': x['moment'].weekday() } ['clouds', 'humidity', 'pressure', 'temperature', 'wind'] {'keys': {'temperature', 'wind', 'humidity', 'pressure', 'clouds'}} y_mean_by_station_and_hour {'_feature_name': 'y_mean_by_station_and_hour', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f8f928024c0>, Mean: 0.), {('metro-canal-du-midi', 0): Mean: 7.93981, ('metro-canal-du-midi', 1): Mean: 8.179704, ('metro-canal-du-midi', 2): Mean: 8.35824, ('metro-canal-du-midi', 3): Mean: 8.656051, ('metro-canal-du-midi', 4): Mean: 8.868445, ('metro-canal-du-midi', 5): Mean: 8.99656, ('metro-canal-du-midi', 6): Mean: 9.09966, ('metro-canal-du-midi', 7): Mean: 8.852642, ('metro-canal-du-midi', 8): Mean: 12.66712, ('metro-canal-du-midi', 9): Mean: 13.412186, ('metro-canal-du-midi', 10): Mean: 12.486815, ('metro-canal-du-midi', 11): Mean: 11.675479, ('metro-canal-du-midi', 12): Mean: 10.197409, ('metro-canal-du-midi', 13): Mean: 10.650855, ('metro-canal-du-midi', 14): Mean: 11.109123, ('metro-canal-du-midi', 15): Mean: 11.068934, ('metro-canal-du-midi', 16): Mean: 11.274958, ('metro-canal-du-midi', 17): Mean: 8.459136, ('metro-canal-du-midi', 18): Mean: 7.587469, ('metro-canal-du-midi', 19): Mean: 7.734677, ('metro-canal-du-midi', 20): Mean: 7.582465, ('metro-canal-du-midi', 21): Mean: 7.190665, ('metro-canal-du-midi', 22): Mean: 7.486895, ('metro-canal-du-midi', 23): Mean: 7.840791, ('place-des-carmes', 0): Mean: 4.720696, ('place-des-carmes', 1): Mean: 3.390295, ('place-des-carmes', 2): Mean: 2.232181, ('place-des-carmes', 3): Mean: 1.371981, ('place-des-carmes', 4): Mean: 1.051665, ('place-des-carmes', 5): Mean: 0.984993, ('place-des-carmes', 6): Mean: 2.039947, ('place-des-carmes', 7): Mean: 3.850369, ('place-des-carmes', 8): Mean: 3.792624, ('place-des-carmes', 9): Mean: 5.957182, ('place-des-carmes', 10): Mean: 8.575303, ('place-des-carmes', 11): Mean: 9.321546, ('place-des-carmes', 12): Mean: 10.511931, ('place-des-carmes', 13): Mean: 11.392745, ('place-des-carmes', 14): Mean: 10.735003, ('place-des-carmes', 15): Mean: 10.198787, ('place-des-carmes', 16): Mean: 9.941479, ('place-des-carmes', 17): Mean: 9.125579, ('place-des-carmes', 18): Mean: 7.660775, ('place-des-carmes', 19): Mean: 6.847649, ('place-des-carmes', 20): Mean: 9.626876, ('place-des-carmes', 21): Mean: 11.602929, ('place-des-carmes', 22): Mean: 10.405537, ('place-des-carmes', 23): Mean: 7.700904, ('place-esquirol', 0): Mean: 7.415789, ('place-esquirol', 1): Mean: 5.244396, ('place-esquirol', 2): Mean: 2.858635, ('place-esquirol', 3): Mean: 1.155929, ('place-esquirol', 4): Mean: 0.73306, ('place-esquirol', 5): Mean: 0.668546, ('place-esquirol', 6): Mean: 1.21265, ('place-esquirol', 7): Mean: 3.107535, ('place-esquirol', 8): Mean: 8.518696, ('place-esquirol', 9): Mean: 15.470588, ('place-esquirol', 10): Mean: 19.465005, ('place-esquirol', 11): Mean: 22.976512, ('place-esquirol', 12): Mean: 25.324159, ('place-esquirol', 13): Mean: 25.428847, ('place-esquirol', 14): Mean: 24.57762, ('place-esquirol', 15): Mean: 24.416851, ('place-esquirol', 16): Mean: 23.555125, ('place-esquirol', 17): Mean: 22.062564, ('place-esquirol', 18): Mean: 18.10623, ('place-esquirol', 19): Mean: 11.916638, ('place-esquirol', 20): Mean: 13.346362, ('place-esquirol', 21): Mean: 16.743318, ('place-esquirol', 22): Mean: 15.562088, ('place-esquirol', 23): Mean: 10.911134, ('place-jeanne-darc', 0): Mean: 6.541667, ('place-jeanne-darc', 1): Mean: 5.99892, ('place-jeanne-darc', 2): Mean: 5.598169, ('place-jeanne-darc', 3): Mean: 5.180556, ('place-jeanne-darc', 4): Mean: 4.779626, ('place-jeanne-darc', 5): Mean: 4.67063, ('place-jeanne-darc', 6): Mean: 4.611995, ('place-jeanne-darc', 7): Mean: 4.960718, ('place-jeanne-darc', 8): Mean: 5.552273, ('place-jeanne-darc', 9): Mean: 6.249573, ('place-jeanne-darc', 10): Mean: 5.735553, ('place-jeanne-darc', 11): Mean: 5.616142, ('place-jeanne-darc', 12): Mean: 5.787478, ('place-jeanne-darc', 13): Mean: 5.817699, ('place-jeanne-darc', 14): Mean: 5.657546, ('place-jeanne-darc', 15): Mean: 6.224604, ('place-jeanne-darc', 16): Mean: 5.796141, ('place-jeanne-darc', 17): Mean: 5.743089, ('place-jeanne-darc', 18): Mean: 5.674784, ('place-jeanne-darc', 19): Mean: 5.833068, ('place-jeanne-darc', 20): Mean: 6.015755, ('place-jeanne-darc', 21): Mean: 6.242541, ('place-jeanne-darc', 22): Mean: 6.141509, ('place-jeanne-darc', 23): Mean: 6.493028, ('pomme', 0): Mean: 3.301532, ('pomme', 1): Mean: 2.312914, ('pomme', 2): Mean: 2.144453, ('pomme', 3): Mean: 1.563622, ('pomme', 4): Mean: 0.947328, ('pomme', 5): Mean: 0.924175, ('pomme', 6): Mean: 1.287805, ('pomme', 7): Mean: 1.299456, ('pomme', 8): Mean: 2.94988, ('pomme', 9): Mean: 7.89396, ('pomme', 10): Mean: 11.791436, ('pomme', 11): Mean: 12.976854, ('pomme', 12): Mean: 13.962654, ('pomme', 13): Mean: 11.692257, ('pomme', 14): Mean: 11.180851, ('pomme', 15): Mean: 11.939586, ('pomme', 16): Mean: 12.267051, ('pomme', 17): Mean: 12.132993, ('pomme', 18): Mean: 11.399108, ('pomme', 19): Mean: 6.37021, ('pomme', 20): Mean: 5.279234, ('pomme', 21): Mean: 6.254257, ('pomme', 22): Mean: 6.568678, ('pomme', 23): Mean: 5.235756}), 'by': ['station', 'hour'], 'how': Mean: 0., 'on': 'y'} y_ewm_0.5_by_station {'_feature_name': 'y_ewm_0.5_by_station', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f8f928024c0>, EWMean: 0.), {('metro-canal-du-midi',): EWMean: 4.690531, ('place-des-carmes',): EWMean: 3.295317, ('place-esquirol',): EWMean: 31.539759, ('place-jeanne-darc',): EWMean: 22.449934, ('pomme',): EWMean: 11.803716}), 'by': ['station'], 'how': EWMean: 0., 'on': 'y'} StandardScaler {'counts': Counter({'y_ewm_0.5_by_station': 182470, 'y_mean_by_station_and_hour': 182470, 'temperature': 182470, 'wind': 182470, 'humidity': 182470, 'pressure': 182470, 'clouds': 182470}), 'means': defaultdict(<class 'float'>, {'clouds': 30.315131254453505, 'humidity': 62.24244533347998, 'pressure': 1017.0563060996391, 'temperature': 20.50980692716619, 'wind': 3.4184331122924543, 'y_ewm_0.5_by_station': 10.08331958752748, 'y_mean_by_station_and_hour': 9.410348580619415}), 'vars': defaultdict(<class 'float'>, {'clouds': 1389.0025610928221, 'humidity': 349.59967918503554, 'pressure': 33.298307526514115, 'temperature': 34.70701720774977, 'wind': 4.473627075744674, 'y_ewm_0.5_by_station': 80.17355266024735, 'y_mean_by_station_and_hour': 33.98249801051089}), 'with_std': True} LinearRegression {'_weights': {'y_ewm_0.5_by_station': 9.264175276315452, 'y_mean_by_station_and_hour': 0.19801400070497754, 'temperature': -0.42112178062191985, 'wind': -0.04087954775179702, 'humidity': 1.0125248437612904, 'pressure': 0.18137498909137262, 'clouds': -0.3269694794458269}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 9.223158690689175, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 182470})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } As mentioned above the Pipeline class has a debug_one method. You can use this at any point you want to visualize what happen to an input x . For example, let's see what happens to the last seen x . print ( model . debug_one ( x )) 0. Input -------- clouds: 88 (int) description: overcast clouds (str) humidity: 84 (int) moment: 2016-10-05 09:57:18 (datetime) pressure: 1,017.34000 (float) station: pomme (str) temperature: 17.45000 (float) wind: 1.95000 (float) 1. add_time_features -------------------- clouds: 88 (int) day: 2 (int) description: overcast clouds (str) hour: 9 (int) humidity: 84 (int) moment: 2016-10-05 09:57:18 (datetime) pressure: 1,017.34000 (float) station: pomme (str) temperature: 17.45000 (float) wind: 1.95000 (float) 2. Transformer union -------------------- 2.0 Select ---------- clouds: 88 (int) humidity: 84 (int) pressure: 1,017.34000 (float) temperature: 17.45000 (float) wind: 1.95000 (float) 2.1 TargetAgg ------------- y_mean_by_station_and_hour: 7.89396 (float) 2.2 TargetAgg1 -------------- y_ewm_0.5_by_station: 11.80372 (float) clouds: 88 (int) humidity: 84 (int) pressure: 1,017.34000 (float) temperature: 17.45000 (float) wind: 1.95000 (float) y_ewm_0.5_by_station: 11.80372 (float) y_mean_by_station_and_hour: 7.89396 (float) 3. StandardScaler ----------------- clouds: 1.54778 (float) humidity: 1.16366 (float) pressure: 0.04916 (float) temperature: -0.51938 (float) wind: -0.69426 (float) y_ewm_0.5_by_station: 0.19214 (float) y_mean_by_station_and_hour: -0.26013 (float) 4. LinearRegression ------------------- Name Value Weight Contribution Intercept 1.00000 9.22316 9.22316 y_ewm_0.5_by_station 0.19214 9.26418 1.78000 humidity 1.16366 1.01252 1.17823 temperature -0.51938 -0.42112 0.21872 wind -0.69426 -0.04088 0.02838 pressure 0.04916 0.18137 0.00892 y_mean_by_station_and_hour -0.26013 0.19801 -0.05151 clouds 1.54778 -0.32697 -0.50608 Prediction: 11.87982 The pipeline does quite a few things, but using debug_one shows what happens step by step. This is really useful for checking that the pipeline is behaving as you're expecting it too. Remember that you can debug_one whenever you wish, be it before, during, or after training a model.","title":"Debugging a pipeline"},{"location":"examples/imbalanced-learning/","text":"Working with imbalanced data \u00b6 In machine learning it is quite usual to have to deal with imbalanced dataset. This is particularly true in online learning for tasks such as fraud detection and spam classification. In these two cases, which are binary classification problems, there are usually many more 0s than 1s, which generally hinders the performance of the classifiers we thrown at them. As an example we'll use the credit card dataset available in river . We'll first use a collections.Counter to count the number of 0s and 1s in order to get an idea of the class balance. import collections from river import datasets X_y = datasets . CreditCard () counts = collections . Counter ( y for _ , y in X_y ) for c , count in counts . items (): print ( f ' { c } : { count } ( { count / sum ( counts . values ()) : .5% } )' ) Downloading https://maxhalford.github.io/files/datasets/creditcardfraud.zip (65.95 MB) Uncompressing into /Users/max.halford/river_data/CreditCard 0: 284315 (99.82725%) 1: 492 (0.17275%) Baseline \u00b6 The dataset is quite unbalanced. For each 1 there are about 578 0s. Let's now train a logistic regression with default parameters and see how well it does. We'll measure the ROC AUC score. from river import linear_model from river import metrics from river import evaluate from river import preprocessing X_y = datasets . CreditCard () model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression () ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 89.11% Importance weighting \u00b6 The performance is already quite acceptable, but as we will now see we can do even better. The first thing we can do is to add weight to the 1s by using the weight_pos argument of the Log loss function. from river import optim model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 91.43% Focal loss \u00b6 The deep learning for object detection community has produced a special loss function for imbalanced learning called focal loss . We are doing binary classification, so we can plug the binary version of focal loss into our logistic regression and see how well it fairs. model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . BinaryFocalLoss ( 2 , 1 )) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 91.31% Under-sampling the majority class \u00b6 Adding importance weights only works with gradient-based models (which includes neural networks). A more generic, and potentially more effective approach, is to use undersamplig and oversampling. As an example, we'll under-sample the stream so that our logistic regression encounter 20% of 1s and 80% of 0s. Under-sampling has the additional benefit of requiring less training steps, and thus reduces the total training time. from river import imblearn model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : .8 , 1 : .2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 94.75% The RandomUnderSampler class is a wrapper for classifiers. This is represented by a rectangle around the logistic regression bubble when we visualize the model. model StandardScaler {'counts': Counter({'Time': 284807, 'V1': 284807, 'V2': 284807, 'V3': 284807, 'V4': 284807, 'V5': 284807, 'V6': 284807, 'V7': 284807, 'V8': 284807, 'V9': 284807, 'V10': 284807, 'V11': 284807, 'V12': 284807, 'V13': 284807, 'V14': 284807, 'V15': 284807, 'V16': 284807, 'V17': 284807, 'V18': 284807, 'V19': 284807, 'V20': 284807, 'V21': 284807, 'V22': 284807, 'V23': 284807, 'V24': 284807, 'V25': 284807, 'V26': 284807, 'V27': 284807, 'V28': 284807, 'Amount': 284807}), 'means': defaultdict(<class 'float'>, {'Amount': 88.34961925093155, 'Time': 94813.8595750808, 'V1': 2.9277520180090704e-15, 'V10': 2.419775348112352e-15, 'V11': 2.6777824308789593e-15, 'V12': -2.2140916080800113e-15, 'V13': 8.342900777166882e-16, 'V14': 1.903846574088133e-15, 'V15': 8.581815631423259e-15, 'V16': 1.4766213137618707e-15, 'V17': -1.6801787893383664e-16, 'V18': 5.854597499006342e-16, 'V19': 1.0841438330912623e-15, 'V2': 5.886023480140661e-16, 'V20': 7.744049542249276e-16, 'V21': 2.332071227413037e-16, 'V22': 4.956273530422241e-16, 'V23': -2.4249219202998693e-16, 'V24': 4.437131669261511e-15, 'V25': -6.981503896318856e-16, 'V26': 1.6805599541646309e-15, 'V27': -3.266881107112892e-16, 'V28': -1.173670292237036e-16, 'V3': -1.2140654523102711e-15, 'V4': 3.4083746059071583e-15, 'V5': 3.0974740213536643e-15, 'V6': 1.6259034591771526e-15, 'V7': -1.293283785185756e-16, 'V8': 3.1643541546820877e-16, 'V9': -1.6996522885539796e-15}), 'vars': defaultdict(<class 'float'>, {'Amount': 62559.84938856013, 'Time': 2255116088.124347, 'V1': 3.8364757815609964, 'V10': 1.1855896488198305, 'V11': 1.041851426830977, 'V12': 0.9983999112951535, 'V13': 0.9905673151089326, 'V14': 0.9189023195064231, 'V15': 0.837800459457307, 'V16': 0.7678164267285925, 'V17': 0.721370914880897, 'V18': 0.7025368914993138, 'V19': 0.6626596101863256, 'V2': 2.726810450381156, 'V20': 0.594323307231822, 'V21': 0.5395236333332668, 'V22': 0.5266409057048476, 'V23': 0.3899492915994535, 'V24': 0.3668070828485584, 'V25': 0.27172987273928645, 'V26': 0.23254207582578096, 'V27': 0.16291861895803472, 'V28': 0.10895457872151114, 'V3': 2.2990211684909436, 'V4': 2.004676782760293, 'V5': 1.905074357779823, 'V6': 1.7749400245019011, 'V7': 1.5303951971990823, 'V8': 1.426473847533605, 'V9': 1.2069882295421888}), 'with_std': True} RandomUnderSampler {'_actual_dist': Counter({0: 284315, 1: 492}), '_pivot': 1, '_rng': <random.Random object at 0x7fb73901e810>, 'classifier': LogisticRegression ( optimizer=SGD ( lr=Constant ( learning_rate=0.01 ) ) loss=Log ( weight_pos=1. weight_neg=1. ) l2=0. intercept_init=0. intercept_lr=Constant ( learning_rate=0.01 ) clip_gradient=1e+12 initializer=Zeros () ), 'desired_dist': {0: 0.8, 1: 0.2}, 'seed': 42} LogisticRegression {'_weights': {'Time': -1.6435308107994573, 'V1': -0.0711798457459422, 'V2': 0.08689788816561662, 'V3': -0.22624828183952506, 'V4': 0.6827332420162909, 'V5': 0.18833620045466432, 'V6': -0.11695093658674378, 'V7': -0.13413474923347, 'V8': -0.2575447733912745, 'V9': -0.02888439300081377, 'V10': -0.2491688000120769, 'V11': 0.32422036210718175, 'V12': -0.6194078910255973, 'V13': -0.0302453737827456, 'V14': -0.5855987715566451, 'V15': -0.09972202536223844, 'V16': -0.2402670346526167, 'V17': -0.055365057905480845, 'V18': 0.032474863276146626, 'V19': -0.08494838975759278, 'V20': -0.12459547198256606, 'V21': 0.04276103699144131, 'V22': 0.10363988666872352, 'V23': -0.08712048453858105, 'V24': 0.043970621647021875, 'V25': -0.050376004211653315, 'V26': -0.02767069610819979, 'V27': 0.12223298288462736, 'V28': -0.019825032606385427, 'Amount': 0.027224523831184406}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': -1.0699242219644576, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Log({'weight_pos': 1.0, 'weight_neg': 1.0}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 3633})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } Over-sampling the minority class \u00b6 We can also attain the same class distribution by over-sampling the minority class. This will come at cost of having to train with more samples. model = ( preprocessing . StandardScaler () | imblearn . RandomOverSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : .8 , 1 : .2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 91.71% Sampling with a desired sample size \u00b6 The downside of both RandomUnderSampler and RandomOverSampler is that you don't have any control on the amount of data the classifier trains on. The number of samples is adjusted so that the target distribution can be attained, either by under-sampling or over-sampling. However, you can do both at the same time and choose how much data the classifier will see. To do so, we can use the RandomSampler class. In addition to the desired class distribution, we can specify how much data to train on. The samples will both be under-sampled and over-sampled in order to fit your constraints. This is powerful because it allows you to control both the class distribution and the size of the training data (and thus the training time). In the following example we'll set it so that the model will train with 1 percent of the data. model = ( preprocessing . StandardScaler () | imblearn . RandomSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : .8 , 1 : .2 }, sampling_rate = .01 , seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 94.71% Hybrid approach \u00b6 As you might have guessed by now, nothing is stopping you from mixing imbalanced learning methods together. As an example, let's combine sampling.RandomUnderSampler and the weight_pos parameter from the optim.losses.Log loss function. model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ), desired_dist = { 0 : .8 , 1 : .2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 96.52%","title":"Working with imbalanced data"},{"location":"examples/imbalanced-learning/#working-with-imbalanced-data","text":"In machine learning it is quite usual to have to deal with imbalanced dataset. This is particularly true in online learning for tasks such as fraud detection and spam classification. In these two cases, which are binary classification problems, there are usually many more 0s than 1s, which generally hinders the performance of the classifiers we thrown at them. As an example we'll use the credit card dataset available in river . We'll first use a collections.Counter to count the number of 0s and 1s in order to get an idea of the class balance. import collections from river import datasets X_y = datasets . CreditCard () counts = collections . Counter ( y for _ , y in X_y ) for c , count in counts . items (): print ( f ' { c } : { count } ( { count / sum ( counts . values ()) : .5% } )' ) Downloading https://maxhalford.github.io/files/datasets/creditcardfraud.zip (65.95 MB) Uncompressing into /Users/max.halford/river_data/CreditCard 0: 284315 (99.82725%) 1: 492 (0.17275%)","title":"Working with imbalanced data"},{"location":"examples/imbalanced-learning/#baseline","text":"The dataset is quite unbalanced. For each 1 there are about 578 0s. Let's now train a logistic regression with default parameters and see how well it does. We'll measure the ROC AUC score. from river import linear_model from river import metrics from river import evaluate from river import preprocessing X_y = datasets . CreditCard () model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression () ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 89.11%","title":"Baseline"},{"location":"examples/imbalanced-learning/#importance-weighting","text":"The performance is already quite acceptable, but as we will now see we can do even better. The first thing we can do is to add weight to the 1s by using the weight_pos argument of the Log loss function. from river import optim model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 91.43%","title":"Importance weighting"},{"location":"examples/imbalanced-learning/#focal-loss","text":"The deep learning for object detection community has produced a special loss function for imbalanced learning called focal loss . We are doing binary classification, so we can plug the binary version of focal loss into our logistic regression and see how well it fairs. model = ( preprocessing . StandardScaler () | linear_model . LogisticRegression ( loss = optim . losses . BinaryFocalLoss ( 2 , 1 )) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 91.31%","title":"Focal loss"},{"location":"examples/imbalanced-learning/#under-sampling-the-majority-class","text":"Adding importance weights only works with gradient-based models (which includes neural networks). A more generic, and potentially more effective approach, is to use undersamplig and oversampling. As an example, we'll under-sample the stream so that our logistic regression encounter 20% of 1s and 80% of 0s. Under-sampling has the additional benefit of requiring less training steps, and thus reduces the total training time. from river import imblearn model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : .8 , 1 : .2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 94.75% The RandomUnderSampler class is a wrapper for classifiers. This is represented by a rectangle around the logistic regression bubble when we visualize the model. model StandardScaler {'counts': Counter({'Time': 284807, 'V1': 284807, 'V2': 284807, 'V3': 284807, 'V4': 284807, 'V5': 284807, 'V6': 284807, 'V7': 284807, 'V8': 284807, 'V9': 284807, 'V10': 284807, 'V11': 284807, 'V12': 284807, 'V13': 284807, 'V14': 284807, 'V15': 284807, 'V16': 284807, 'V17': 284807, 'V18': 284807, 'V19': 284807, 'V20': 284807, 'V21': 284807, 'V22': 284807, 'V23': 284807, 'V24': 284807, 'V25': 284807, 'V26': 284807, 'V27': 284807, 'V28': 284807, 'Amount': 284807}), 'means': defaultdict(<class 'float'>, {'Amount': 88.34961925093155, 'Time': 94813.8595750808, 'V1': 2.9277520180090704e-15, 'V10': 2.419775348112352e-15, 'V11': 2.6777824308789593e-15, 'V12': -2.2140916080800113e-15, 'V13': 8.342900777166882e-16, 'V14': 1.903846574088133e-15, 'V15': 8.581815631423259e-15, 'V16': 1.4766213137618707e-15, 'V17': -1.6801787893383664e-16, 'V18': 5.854597499006342e-16, 'V19': 1.0841438330912623e-15, 'V2': 5.886023480140661e-16, 'V20': 7.744049542249276e-16, 'V21': 2.332071227413037e-16, 'V22': 4.956273530422241e-16, 'V23': -2.4249219202998693e-16, 'V24': 4.437131669261511e-15, 'V25': -6.981503896318856e-16, 'V26': 1.6805599541646309e-15, 'V27': -3.266881107112892e-16, 'V28': -1.173670292237036e-16, 'V3': -1.2140654523102711e-15, 'V4': 3.4083746059071583e-15, 'V5': 3.0974740213536643e-15, 'V6': 1.6259034591771526e-15, 'V7': -1.293283785185756e-16, 'V8': 3.1643541546820877e-16, 'V9': -1.6996522885539796e-15}), 'vars': defaultdict(<class 'float'>, {'Amount': 62559.84938856013, 'Time': 2255116088.124347, 'V1': 3.8364757815609964, 'V10': 1.1855896488198305, 'V11': 1.041851426830977, 'V12': 0.9983999112951535, 'V13': 0.9905673151089326, 'V14': 0.9189023195064231, 'V15': 0.837800459457307, 'V16': 0.7678164267285925, 'V17': 0.721370914880897, 'V18': 0.7025368914993138, 'V19': 0.6626596101863256, 'V2': 2.726810450381156, 'V20': 0.594323307231822, 'V21': 0.5395236333332668, 'V22': 0.5266409057048476, 'V23': 0.3899492915994535, 'V24': 0.3668070828485584, 'V25': 0.27172987273928645, 'V26': 0.23254207582578096, 'V27': 0.16291861895803472, 'V28': 0.10895457872151114, 'V3': 2.2990211684909436, 'V4': 2.004676782760293, 'V5': 1.905074357779823, 'V6': 1.7749400245019011, 'V7': 1.5303951971990823, 'V8': 1.426473847533605, 'V9': 1.2069882295421888}), 'with_std': True} RandomUnderSampler {'_actual_dist': Counter({0: 284315, 1: 492}), '_pivot': 1, '_rng': <random.Random object at 0x7fb73901e810>, 'classifier': LogisticRegression ( optimizer=SGD ( lr=Constant ( learning_rate=0.01 ) ) loss=Log ( weight_pos=1. weight_neg=1. ) l2=0. intercept_init=0. intercept_lr=Constant ( learning_rate=0.01 ) clip_gradient=1e+12 initializer=Zeros () ), 'desired_dist': {0: 0.8, 1: 0.2}, 'seed': 42} LogisticRegression {'_weights': {'Time': -1.6435308107994573, 'V1': -0.0711798457459422, 'V2': 0.08689788816561662, 'V3': -0.22624828183952506, 'V4': 0.6827332420162909, 'V5': 0.18833620045466432, 'V6': -0.11695093658674378, 'V7': -0.13413474923347, 'V8': -0.2575447733912745, 'V9': -0.02888439300081377, 'V10': -0.2491688000120769, 'V11': 0.32422036210718175, 'V12': -0.6194078910255973, 'V13': -0.0302453737827456, 'V14': -0.5855987715566451, 'V15': -0.09972202536223844, 'V16': -0.2402670346526167, 'V17': -0.055365057905480845, 'V18': 0.032474863276146626, 'V19': -0.08494838975759278, 'V20': -0.12459547198256606, 'V21': 0.04276103699144131, 'V22': 0.10363988666872352, 'V23': -0.08712048453858105, 'V24': 0.043970621647021875, 'V25': -0.050376004211653315, 'V26': -0.02767069610819979, 'V27': 0.12223298288462736, 'V28': -0.019825032606385427, 'Amount': 0.027224523831184406}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': -1.0699242219644576, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Log({'weight_pos': 1.0, 'weight_neg': 1.0}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 3633})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; }","title":"Under-sampling the majority class"},{"location":"examples/imbalanced-learning/#over-sampling-the-minority-class","text":"We can also attain the same class distribution by over-sampling the minority class. This will come at cost of having to train with more samples. model = ( preprocessing . StandardScaler () | imblearn . RandomOverSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : .8 , 1 : .2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 91.71%","title":"Over-sampling the minority class"},{"location":"examples/imbalanced-learning/#sampling-with-a-desired-sample-size","text":"The downside of both RandomUnderSampler and RandomOverSampler is that you don't have any control on the amount of data the classifier trains on. The number of samples is adjusted so that the target distribution can be attained, either by under-sampling or over-sampling. However, you can do both at the same time and choose how much data the classifier will see. To do so, we can use the RandomSampler class. In addition to the desired class distribution, we can specify how much data to train on. The samples will both be under-sampled and over-sampled in order to fit your constraints. This is powerful because it allows you to control both the class distribution and the size of the training data (and thus the training time). In the following example we'll set it so that the model will train with 1 percent of the data. model = ( preprocessing . StandardScaler () | imblearn . RandomSampler ( classifier = linear_model . LogisticRegression (), desired_dist = { 0 : .8 , 1 : .2 }, sampling_rate = .01 , seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 94.71%","title":"Sampling with a desired sample size"},{"location":"examples/imbalanced-learning/#hybrid-approach","text":"As you might have guessed by now, nothing is stopping you from mixing imbalanced learning methods together. As an example, let's combine sampling.RandomUnderSampler and the weight_pos parameter from the optim.losses.Log loss function. model = ( preprocessing . StandardScaler () | imblearn . RandomUnderSampler ( classifier = linear_model . LogisticRegression ( loss = optim . losses . Log ( weight_pos = 5 ) ), desired_dist = { 0 : .8 , 1 : .2 }, seed = 42 ) ) metric = metrics . ROCAUC () evaluate . progressive_val_score ( X_y , model , metric ) ROCAUC: 96.52%","title":"Hybrid approach"},{"location":"examples/quantile-regression-uncertainty/","text":"Handling uncertainty with quantile regression \u00b6 % matplotlib inline Quantile regression is useful when you're not so much interested in the accuracy of your model, but rather you want your model to be good at ranking observations correctly. The typical way to perform quantile regression is to use a special loss function, namely the quantile loss. The quantile loss takes a parameter, \\(\\alpha\\) (alpha), which indicates which quantile the model should be targeting. In the case of \\(\\alpha = 0.5\\) , then this is equivalent to asking the model to predict the median value of the target, and not the most likely value which would be the mean. A nice thing we can do with quantile regression is to produce a prediction interval for each prediction. Indeed, if we predict the lower and upper quantiles of the target then we will be able to obtain a \"trust region\" in between which the true value is likely to belong. Of course, the likeliness will depend on the chosen quantiles. For a slightly more detailed explanation see this blog post. As an example, let us take the simple nowcasting model we built in another notebook . Instead of predicting the mean value of the target distribution, we will predict the 5th, 50th, 95th quantiles. This will require training three separate models, so we will encapsulate the model building logic in a function called make_model . We also have to slightly adapt the training loop, but not by much. Finally, we will draw the prediction interval along with the predictions from for 50th quantile (i.e. the median) and the true values. import calendar import math import matplotlib.pyplot as plt from river import compose from river import datasets from river import linear_model from river import metrics from river import optim from river import preprocessing from river import stats def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } def make_model ( alpha ): extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ), loss = optim . losses . Quantile ( alpha = alpha ) ) model = extract_features | scale | learn model = preprocessing . TargetStandardScaler ( regressor = model ) return model metric = metrics . MAE () models = { 'lower' : make_model ( alpha = 0.05 ), 'center' : make_model ( alpha = 0.5 ), 'upper' : make_model ( alpha = 0.95 ) } dates = [] y_trues = [] y_preds = { 'lower' : [], 'center' : [], 'upper' : [] } for x , y in datasets . AirlinePassengers (): y_trues . append ( y ) dates . append ( x [ 'month' ]) for name , model in models . items (): y_preds [ name ] . append ( model . predict_one ( x )) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_preds [ 'center' ][ - 1 ]) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Truth' ) ax . plot ( dates , y_preds [ 'center' ], lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . fill_between ( dates , y_preds [ 'lower' ], y_preds [ 'upper' ], color = '#e74c3c' , alpha = 0.3 , label = 'Prediction interval' ) ax . legend () ax . set_title ( metric ); An important thing to note is that the prediction interval we obtained should not be confused with a confidence interval. Simply put, a prediction interval represents uncertainty for where the true value lies, whereas a confidence interval encapsulates the uncertainty on the prediction. You can find out more by reading this CrossValidated post.","title":"Handling uncertainty with quantile regression"},{"location":"examples/quantile-regression-uncertainty/#handling-uncertainty-with-quantile-regression","text":"% matplotlib inline Quantile regression is useful when you're not so much interested in the accuracy of your model, but rather you want your model to be good at ranking observations correctly. The typical way to perform quantile regression is to use a special loss function, namely the quantile loss. The quantile loss takes a parameter, \\(\\alpha\\) (alpha), which indicates which quantile the model should be targeting. In the case of \\(\\alpha = 0.5\\) , then this is equivalent to asking the model to predict the median value of the target, and not the most likely value which would be the mean. A nice thing we can do with quantile regression is to produce a prediction interval for each prediction. Indeed, if we predict the lower and upper quantiles of the target then we will be able to obtain a \"trust region\" in between which the true value is likely to belong. Of course, the likeliness will depend on the chosen quantiles. For a slightly more detailed explanation see this blog post. As an example, let us take the simple nowcasting model we built in another notebook . Instead of predicting the mean value of the target distribution, we will predict the 5th, 50th, 95th quantiles. This will require training three separate models, so we will encapsulate the model building logic in a function called make_model . We also have to slightly adapt the training loop, but not by much. Finally, we will draw the prediction interval along with the predictions from for 50th quantile (i.e. the median) and the true values. import calendar import math import matplotlib.pyplot as plt from river import compose from river import datasets from river import linear_model from river import metrics from river import optim from river import preprocessing from river import stats def get_ordinal_date ( x ): return { 'ordinal_date' : x [ 'month' ] . toordinal ()} def get_month_distances ( x ): return { calendar . month_name [ month ]: math . exp ( - ( x [ 'month' ] . month - month ) ** 2 ) for month in range ( 1 , 13 ) } def make_model ( alpha ): extract_features = compose . TransformerUnion ( get_ordinal_date , get_month_distances ) scale = preprocessing . StandardScaler () learn = linear_model . LinearRegression ( intercept_lr = 0 , optimizer = optim . SGD ( 0.03 ), loss = optim . losses . Quantile ( alpha = alpha ) ) model = extract_features | scale | learn model = preprocessing . TargetStandardScaler ( regressor = model ) return model metric = metrics . MAE () models = { 'lower' : make_model ( alpha = 0.05 ), 'center' : make_model ( alpha = 0.5 ), 'upper' : make_model ( alpha = 0.95 ) } dates = [] y_trues = [] y_preds = { 'lower' : [], 'center' : [], 'upper' : [] } for x , y in datasets . AirlinePassengers (): y_trues . append ( y ) dates . append ( x [ 'month' ]) for name , model in models . items (): y_preds [ name ] . append ( model . predict_one ( x )) model . learn_one ( x , y ) # Update the error metric metric . update ( y , y_preds [ 'center' ][ - 1 ]) # Plot the results fig , ax = plt . subplots ( figsize = ( 10 , 6 )) ax . grid ( alpha = 0.75 ) ax . plot ( dates , y_trues , lw = 3 , color = '#2ecc71' , alpha = 0.8 , label = 'Truth' ) ax . plot ( dates , y_preds [ 'center' ], lw = 3 , color = '#e74c3c' , alpha = 0.8 , label = 'Prediction' ) ax . fill_between ( dates , y_preds [ 'lower' ], y_preds [ 'upper' ], color = '#e74c3c' , alpha = 0.3 , label = 'Prediction interval' ) ax . legend () ax . set_title ( metric ); An important thing to note is that the prediction interval we obtained should not be confused with a confidence interval. Simply put, a prediction interval represents uncertainty for where the true value lies, whereas a confidence interval encapsulates the uncertainty on the prediction. You can find out more by reading this CrossValidated post.","title":"Handling uncertainty with quantile regression"},{"location":"examples/the-art-of-using-pipelines/","text":"The art of using pipelines \u00b6 Pipelines are a natural way to think about a machine learning system. Indeed with some practice a data scientist can visualise data \"flowing\" through a series of steps. The input is typically some raw data which has to be processed in some manner. The goal is to represent the data in such a way that is can be ingested by a machine learning algorithm. Along the way some steps will extract features, while others will normalize the data and remove undesirable elements. Pipelines are simple, and yet they are a powerful way of designing sophisticated machine learning systems. Both scikit-learn and pandas make it possible to use pipelines. However it's quite rare to see pipelines being used in practice (at least on Kaggle). Sometimes you get to see people using scikit-learn's pipeline module, however the pipe method from pandas is sadly underappreciated. A big reason why pipelines are not given much love is that it's easier to think of batch learning in terms of a script or a notebook. Indeed many people doing data science seem to prefer a procedural style to a declarative style. Moreover in practice pipelines can be a bit rigid if one wishes to do non-orthodox operations. Although pipelines may be a bit of an odd fit for batch learning, they make complete sense when they are used for online learning. Indeed the UNIX philosophy has advocated the use of pipelines for data processing for many decades. If you can visualise data as a stream of observations then using pipelines should make a lot of sense to you. We'll attempt to convince you by writing a machine learning algorithm in a procedural way and then converting it to a declarative pipeline in small steps. Hopefully by the end you'll be convinced, or not! In this notebook we'll manipulate data from the Kaggle Recruit Restaurants Visitor Forecasting competition . The data is directly available through river 's datasets module. from pprint import pprint from river import datasets for x , y in datasets . Restaurants (): pprint ( x ) pprint ( y ) break Downloading https://maxhalford.github.io/files/datasets/kaggle_recruit_restaurants.zip (4.28 MB) Uncompressing into /Users/max.halford/river_data/Restaurants {'area_name': 'T\u014dky\u014d-to Nerima-ku Toyotamakita', 'date': datetime.datetime(2016, 1, 1, 0, 0), 'genre_name': 'Izakaya', 'is_holiday': True, 'latitude': 35.7356234, 'longitude': 139.6516577, 'store_id': 'air_04341b588bde96cd'} 10 We'll start by building and running a model using a procedural coding style. The performance of the model doesn't matter, we're simply interested in the design of the model. from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats means = ( feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) scaler = preprocessing . StandardScaler () lin_reg = linear_model . LinearRegression () metric = metrics . MAE () for x , y in datasets . Restaurants (): # Derive date features x [ 'weekday' ] = x [ 'date' ] . weekday () x [ 'is_weekend' ] = x [ 'date' ] . weekday () in ( 5 , 6 ) # Process the rolling means of the target for mean in means : x = { ** x , ** mean . transform_one ( x )} mean . learn_one ( x , y ) # Remove the key/value pairs that aren't features for key in [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ]: x . pop ( key ) # Rescale the data x = scaler . learn_one ( x ) . transform_one ( x ) # Fit the linear regression y_pred = lin_reg . predict_one ( x ) lin_reg . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.465114 We're not using many features. We can print the last x to get an idea of the features (don't forget they've been scaled!) pprint ( x ) {'is_holiday': -0.23103573677646685, 'is_weekend': 1.6249280076334165, 'weekday': 1.0292832579142892, 'y_rollingmean_14_by_store_id': -1.4125913815779154, 'y_rollingmean_21_by_store_id': -1.3980979075298519, 'y_rollingmean_7_by_store_id': -1.3502314499809096} The above chunk of code is quite explicit but it's a bit verbose. The whole point of libraries such as river is to make life easier for users. Moreover there's too much space for users to mess up the order in which things are done, which increases the chance of there being target leakage. We'll now rewrite our model in a declarative fashion using a pipeline \u00e0 la sklearn . from river import compose def get_date_features ( x ): weekday = x [ 'date' ] . weekday () return { 'weekday' : weekday , 'is_weekend' : weekday in ( 5 , 6 )} model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) metric = metrics . MAE () for x , y in datasets . Restaurants (): # Make a prediction without using the target y_pred = model . predict_one ( x ) # Update the model using the target model . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.38533 We use a Pipeline to arrange each step in a sequential order. A TransformerUnion is used to merge multiple feature extractors into a single transformer. The for loop is now much shorter and is thus easier to grok: we get the out-of-fold prediction, we fit the model, and finally we update the metric. This way of evaluating a model is typical of online learning, and so we put it wrapped it inside a function called progressive_val_score part of the evaluate module. We can use it to replace the for loop. from river import evaluate model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) evaluate . progressive_val_score ( dataset = datasets . Restaurants (), model = model , metric = metrics . MAE ()) MAE: 8.38533 Notice that you couldn't have used the progressive_val_score method if you wrote the model in a procedural manner. Our code is getting shorter, but it's still a bit difficult on the eyes. Indeed there is a lot of boilerplate code associated with pipelines that can get tedious to write. However river has some special tricks up it's sleeve to save you from a lot of pain. The first trick is that the name of each step in the pipeline can be omitted. If no name is given for a step then river automatically infers one. model = compose . Pipeline ( compose . TransformerUnion ( compose . FuncTransformer ( get_date_features ), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Under the hood a Pipeline inherits from collections.OrderedDict . Indeed this makes sense because if you think about it a Pipeline is simply a sequence of steps where each step has a name. The reason we mention this is because it means you can manipulate a Pipeline the same way you would manipulate an ordinary dict . For instance we can print the name of each step by using the keys method. for name in model . steps : print ( name ) TransformerUnion Discard StandardScaler LinearRegression The first step is a FeatureUnion and it's string representation contains the string representation of each of it's elements. Not having to write names saves up some time and space and is certainly less tedious. The next trick is that we can use mathematical operators to compose our pipeline. For example we can use the + operator to merge Transformer s into a TransformerUnion . model = compose . Pipeline ( compose . FuncTransformer ( get_date_features ) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Likewhise we can use the | operator to assemble steps into a Pipeline . model = ( compose . FuncTransformer ( get_date_features ) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) to_discard = [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ] model = model | compose . Discard ( * to_discard ) | preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Hopefully you'll agree that this is a powerful way to express machine learning pipelines. For some people this should be quite remeniscent of the UNIX pipe operator. One final trick we want to mention is that functions are automatically wrapped with a FuncTransformer , which can be quite handy. model = get_date_features for n in [ 7 , 14 , 21 ]: model += feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( n )) model |= compose . Discard ( * to_discard ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Naturally some may prefer the procedural style we first used because they find it easier to work with. It all depends on your style and you should use what you feel comfortable with. However we encourage you to use operators because we believe that this will increase the readability of your code, which is very important. To each their own! Before finishing we can take an interactive look at our pipeline. model get_date_features def get_date_features(x): weekday = x['date'].weekday() return {'weekday': weekday, 'is_weekend': weekday in (5, 6)} y_rollingmean_7_by_store_id {'_feature_name': 'y_rollingmean_7_by_store_id', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f830e2024c0>, RollingMean: 0.), {('air_00a91d42b08b08d9',): RollingMean: 31.571429, ('air_0164b9927d20bcc3',): RollingMean: 6.428571, ('air_0241aa3964b7f861',): RollingMean: 11.428571, ('air_0328696196e46f18',): RollingMean: 10., ('air_034a3d5b40d5b1b1',): RollingMean: 28.428571, ('air_036d4f1ee7285390',): RollingMean: 27.142857, ('air_0382c794b73b51ad',): RollingMean: 29.142857, ('air_03963426c9312048',): RollingMean: 45.714286, ('air_04341b588bde96cd',): RollingMean: 32.857143, ('air_049f6d5b402a31b2',): RollingMean: 16.571429, ('air_04cae7c1bc9b2a0b',): RollingMean: 18.571429, ('air_0585011fa179bcce',): RollingMean: 5.571429, ('air_05c325d315cc17f5',): RollingMean: 29.714286, ('air_0647f17b4dc041c8',): RollingMean: 29.714286, ('air_064e203265ee5753',): RollingMean: 19.142857, ('air_066f0221b8a4d533',): RollingMean: 11.428571, ('air_06f95ac5c33aca10',): RollingMean: 27.142857, ('air_0728814bd98f7367',): RollingMean: 8.285714, ('air_0768ab3910f7967f',): RollingMean: 32.571429, ('air_07b314d83059c4d2',): RollingMean: 41.285714, ('air_07bb665f9cdfbdfb',): RollingMean: 24.142857, ('air_082908692355165e',): RollingMean: 48., ('air_083ddc520ea47e1e',): RollingMean: 14.857143, ('air_0845d8395f30c6bb',): RollingMean: 25.285714, ('air_084d98859256acf0',): RollingMean: 12.714286, ('air_0867f7bebad6a649',): RollingMean: 19.142857, ('air_08ba8cd01b3ba010',): RollingMean: 10., ('air_08cb3c4ee6cd6a22',): RollingMean: 10.857143, ('air_08ef81d5b7a0d13f',): RollingMean: 12.857143, ('air_08f994758a1e76d4',): RollingMean: 29.285714, ('air_09040f6df960ddb8',): RollingMean: 17.571429, ('air_0919d54f0c9a24b8',): RollingMean: 37., ('air_09661c0f3259cc04',): RollingMean: 26.428571, ('air_09a845d5b5944b01',): RollingMean: 7.571429, ('air_09fd1f5c58583141',): RollingMean: 8.571429, ('air_0a74a5408a0b8642',): RollingMean: 28.857143, ('air_0b184ec04c741a6a',): RollingMean: 11.857143, ('air_0b1e72d2d4422b20',): RollingMean: 20.857143, ('air_0b9038300f8b2b50',): RollingMean: 13.428571, ('air_0e1eae99b8723bc1',): RollingMean: 12.571429, ('air_0e7c11b9abc50163',): RollingMean: 37., ('air_0ead98dd07e7a82a',): RollingMean: 10.571429, ('air_0f0cdeee6c9bf3d7',): RollingMean: 25.571429, ('air_0f2f96335f274801',): RollingMean: 11.428571, ('air_0f60e1576a7d397d',): RollingMean: 4.857143, ('air_1033310359ceeac1',): RollingMean: 20.857143, ('air_10393f12e9069760',): RollingMean: 13.285714, ('air_105a7954e32dba9b',): RollingMean: 50.714286, ('air_10713fbf3071c361',): RollingMean: 12.857143, ('air_10bbe8acd943d8f6',): RollingMean: 28., ('air_12c4fb7a423df20d',): RollingMean: 21.142857, ('air_138ee734ac79ff90',): RollingMean: 6.285714, ('air_138ff410757b845f',): RollingMean: 49.714286, ('air_1408dd53f31a8a65',): RollingMean: 24.285714, ('air_142e78ba7001da9c',): RollingMean: 14.142857, ('air_1509881b22965b34',): RollingMean: 17., ('air_152c1f08d7d20e07',): RollingMean: 12., ('air_15ae33469e9ea2dd',): RollingMean: 8.285714, ('air_15e6e15c7ea2c162',): RollingMean: 19.571429, ('air_16179d43b6ee5fd8',): RollingMean: 8.428571, ('air_1653a6c513865af3',): RollingMean: 35., ('air_168441ada3e878e1',): RollingMean: 54.571429, ('air_16c4cfddeb2cf69b',): RollingMean: 9.428571, ('air_16cf0a73233896de',): RollingMean: 13., ('air_1707a3f18bb0da07',): RollingMean: 23.142857, ('air_17a6ab40f97fd4d8',): RollingMean: 6.571429, ('air_17bed6dbf7c8b0fc',): RollingMean: 20.428571, ('air_1979eaff8189d086',): RollingMean: 9.857143, ('air_1ab60ce33bfed8a8',): RollingMean: 10.142857, ('air_1ae94f514a0bce13',): RollingMean: 6.571429, ('air_1ba4e87ef7422183',): RollingMean: 35.571429, ('air_1c0b150f9e696a5f',): RollingMean: 100.714286, ('air_1c95a84924d72500',): RollingMean: 9.285714, ('air_1d1e8860ae04f8e9',): RollingMean: 15.142857, ('air_1d25ca6c76df48b4',): RollingMean: 42.857143, ('air_1d3f797dd1f7cf1c',): RollingMean: 39., ('air_1dd8f6f47480d1a2',): RollingMean: 39.142857, ('air_1dea9815ccd36620',): RollingMean: 10.285714, ('air_1e23210b584540e7',): RollingMean: 3.857143, ('air_1e665503b8474c55',): RollingMean: 6.142857, ('air_1eeff462acb24fb7',): RollingMean: 19.571429, ('air_1f1390a8be2272b3',): RollingMean: 19., ('air_1f34e9beded2231a',): RollingMean: 9., ('air_1f7f8fa557bc0d55',): RollingMean: 3.714286, ('air_2009041dbf9264de',): RollingMean: 52.285714, ('air_20619d21192aa571',): RollingMean: 13.285714, ('air_20add8092c9bb51d',): RollingMean: 33.571429, ('air_2195cd5025a98033',): RollingMean: 34.142857, ('air_21f5052d5330528d',): RollingMean: 31.857143, ('air_220cba70c890b119',): RollingMean: 8.714286, ('air_22682e965418936f',): RollingMean: 10.142857, ('air_228f10bec0bda9c8',): RollingMean: 17.142857, ('air_229d7e508d9f1b5e',): RollingMean: 11.428571, ('air_232dcee6f7c51d37',): RollingMean: 6.857143, ('air_234d3dbf7f3d5a50',): RollingMean: 6.428571, ('air_23e1b11aee2a1407',): RollingMean: 46.857143, ('air_23ee674e91469086',): RollingMean: 21.142857, ('air_24b9b2a020826ede',): RollingMean: 32.714286, ('air_24e8414b9b07decb',): RollingMean: 5.857143, ('air_2545dd3a00f265e2',): RollingMean: 56., ('air_256be208a979e023',): RollingMean: 8., ('air_2570ccb93badde68',): RollingMean: 37.428571, ('air_258ad2619d7bff9a',): RollingMean: 38.428571, ('air_258dc112912fc458',): RollingMean: 67.571429, ('air_25c583983246b7b0',): RollingMean: 29.857143, ('air_25d8e5cc57dd87d9',): RollingMean: 26.285714, ('air_25e9888d30b386df',): RollingMean: 5.142857, ('air_2634e41551e9807d',): RollingMean: 18.428571, ('air_26c5bbeb7bb82bf1',): RollingMean: 27.142857, ('air_26f10355d9b4d82a',): RollingMean: 33.285714, ('air_2703dcb33192b181',): RollingMean: 54.142857, ('air_275732a5db46f4d3',): RollingMean: 18.714286, ('air_27e991812b0d9c92',): RollingMean: 42., ('air_28064154614b2e6c',): RollingMean: 22.857143, ('air_287d2de7d3c93406',): RollingMean: 11.857143, ('air_28a9fa1ec0839375',): RollingMean: 34.142857, ('air_28dbe91c4c9656be',): RollingMean: 33.571429, ('air_290e7a57b390f78e',): RollingMean: 14.285714, ('air_298513175efdf261',): RollingMean: 24.857143, ('air_2a184c1745274b2b',): RollingMean: 3.428571, ('air_2a24aec099333f39',): RollingMean: 8.857143, ('air_2a3743e37aab04b4',): RollingMean: 17.428571, ('air_2a485b92210c98b5',): RollingMean: 22.857143, ('air_2a7f14da7fe0f699',): RollingMean: 25., ('air_2aab19554f91ff82',): RollingMean: 43.571429, ('air_2ac361b97630e2df',): RollingMean: 13.285714, ('air_2b8b29ddfd35018e',): RollingMean: 8.714286, ('air_2b9bc9f5f5168ea1',): RollingMean: 21., ('air_2bffb19a24d11729',): RollingMean: 11., ('air_2c505f9ad67d4635',): RollingMean: 16.571429, ('air_2c6c79d597e48096',): RollingMean: 14.714286, ('air_2c6fef1ce0e13a5a',): RollingMean: 28.714286, ('air_2c989829acbd1c6b',): RollingMean: 28.142857, ('air_2cee51fa6fdf6c0d',): RollingMean: 17.142857, ('air_2d3afcb91762fe01',): RollingMean: 51., ('air_2d78d9a1f4dd02ca',): RollingMean: 11.714286, ('air_2e7cb1f1a2a9cd6a',): RollingMean: 31.428571, ('air_2f8ced25216df926',): RollingMean: 12.714286, ('air_2fc149abe33adcb4',): RollingMean: 38.285714, ('air_2fc478dc9f0a6b31',): RollingMean: 12.857143, ('air_2fed81034f8834e5',): RollingMean: 23.857143, ('air_303bac187b53083a',): RollingMean: 9.571429, ('air_310e467e6e625004',): RollingMean: 16.714286, ('air_3155ee23d92202da',): RollingMean: 14.428571, ('air_31c753b48a657b6c',): RollingMean: 21.285714, ('air_32460819c7600037',): RollingMean: 46.857143, ('air_324f7c39a8410e7c',): RollingMean: 12.428571, ('air_326ca454ef3558bc',): RollingMean: 23.714286, ('air_32b02ba5dc2027f4',): RollingMean: 29., ('air_32c61b620a766138',): RollingMean: 28., ('air_32f5d7cd696e3c4a',): RollingMean: 20.714286, ('air_33b01025210d6007',): RollingMean: 12., ('air_3440e0ea1b70a99b',): RollingMean: 30., ('air_346ade7d29230634',): RollingMean: 7., ('air_347be2c4feeb408b',): RollingMean: 22.571429, ('air_349278fa964bb12f',): RollingMean: 19.714286, ('air_3525f11ef0bf0c35',): RollingMean: 44.714286, ('air_35512c42db0868da',): RollingMean: 5.142857, ('air_3561fd1c0bce6a95',): RollingMean: 11.714286, ('air_35c4732dcbfe31be',): RollingMean: 8.714286, ('air_36429b5ca4407b3e',): RollingMean: 20., ('air_36bcf77d3382d36e',): RollingMean: 31.285714, ('air_37189c92b6c761ec',): RollingMean: 20.285714, ('air_375a5241615b5e22',): RollingMean: 7.142857, ('air_382f5ace4e2247b8',): RollingMean: 8.857143, ('air_383f5b2f8d345a49',): RollingMean: 12.714286, ('air_38746ffe9aa20c7e',): RollingMean: 4.571429, ('air_396166d47733d5c9',): RollingMean: 31., ('air_396942e6423a2145',): RollingMean: 24.428571, ('air_397d3f32a7196aa2',): RollingMean: 33.142857, ('air_3980af67be35afdb',): RollingMean: 20., ('air_3982a2c4ea2ed431',): RollingMean: 33.428571, ('air_399904bdb7685ca0',): RollingMean: 29., ('air_39dccf7df20b1c6a',): RollingMean: 26.142857, ('air_3a8a3f8fb5cd7f88',): RollingMean: 22.428571, ('air_3aa839e8e0cb6c87',): RollingMean: 29.857143, ('air_3ac24136722e2291',): RollingMean: 15.142857, ('air_3b20733899b5287f',): RollingMean: 41.857143, ('air_3b6438b125086430',): RollingMean: 13.857143, ('air_3bb99a1fe0583897',): RollingMean: 39.428571, ('air_3bd49f98ab7f36ab',): RollingMean: 15.857143, ('air_3c05c8f26c611eb9',): RollingMean: 22.571429, ('air_3c938075889fc059',): RollingMean: 27.285714, ('air_3cad29d1a23209d2',): RollingMean: 9.142857, ('air_3caef3f76b8f26c5',): RollingMean: 25.428571, ('air_3d3a2b509180e798',): RollingMean: 17., ('air_3e6cea17a9d2c0f1',): RollingMean: 18.714286, ('air_3e93f3c81008696d',): RollingMean: 39.714286, ('air_3f91d592acd6cc0b',): RollingMean: 21.714286, ('air_401b39f97e56b939',): RollingMean: 11.285714, ('air_4043b7ccfbffa732',): RollingMean: 47.857143, ('air_4092cfbd95a3ac1b',): RollingMean: 27.714286, ('air_40953e2d8b4f2857',): RollingMean: 17.428571, ('air_40f6193ea3ed1b91',): RollingMean: 17.857143, ('air_414ff459ed18fa48',): RollingMean: 14.285714, ('air_41bbf6e1d9814c4b',): RollingMean: 7.714286, ('air_421670f21da5ba31',): RollingMean: 18.428571, ('air_4254c3fc3ad078bd',): RollingMean: 12.285714, ('air_42c9aa6d617c5057',): RollingMean: 47., ('air_42d41eb58cad170e',): RollingMean: 33.571429, ('air_43b65e4b05bff2d3',): RollingMean: 19.571429, ('air_43d577e0c9460e64',): RollingMean: 32., ('air_4433ab8e9999915f',): RollingMean: 21.142857, ('air_4481a87c1d7c9896',): RollingMean: 24.142857, ('air_452100f5305dde64',): RollingMean: 7.714286, ('air_45326ebb8dc72cfb',): RollingMean: 22.428571, ('air_4570f52104fe0982',): RollingMean: 8.571429, ('air_4579cb0669fd411b',): RollingMean: 19., ('air_457efe8c3a30ea17',): RollingMean: 6.857143, ('air_464a62de0d57be1e',): RollingMean: 26.428571, ('air_465bddfed3353b23',): RollingMean: 30.285714, ('air_47070be6093f123e',): RollingMean: 44.285714, ('air_472b19e3b5bffa41',): RollingMean: 14., ('air_473cf23b9e7c0a37',): RollingMean: 10.142857, ('air_473f98b212d37b4a',): RollingMean: 27.714286, ('air_47beaffd3806c979',): RollingMean: 18.571429, ('air_483eba479dc9910d',): RollingMean: 19.285714, ('air_48e9fc98b62495a7',): RollingMean: 23.142857, ('air_48f4da6223571da4',): RollingMean: 21.428571, ('air_48ffd31594bc3263',): RollingMean: 4., ('air_49211568cab5fdee',): RollingMean: 25.285714, ('air_4974785f48853db9',): RollingMean: 7.285714, ('air_4b251b9f8373f1ae',): RollingMean: 25.857143, ('air_4b380b4db9d37883',): RollingMean: 25.285714, ('air_4b55d8aea1d2b395',): RollingMean: 36.142857, ('air_4b9085d0d46a6211',): RollingMean: 21.285714, ('air_4beac252540f865e',): RollingMean: 47.571429, ('air_4c2ed28f3f19ca52',): RollingMean: 14.571429, ('air_4c665a2bfff0da3b',): RollingMean: 8.857143, ('air_4c727b55acdee495',): RollingMean: 14.285714, ('air_4cab15ad29c0ffbc',): RollingMean: 19.142857, ('air_4cab91146e3d1897',): RollingMean: 16., ('air_4cca5666eaf5c709',): RollingMean: 37.571429, ('air_4ce7b17062a1bf73',): RollingMean: 6., ('air_4d21676ed11f0bac',): RollingMean: 30.714286, ('air_4d71826793c09b22',): RollingMean: 20.857143, ('air_4d90a22572fa1ec9',): RollingMean: 25.285714, ('air_4de6d887a7b1c1fc',): RollingMean: 16.142857, ('air_4dea8d17f6f59c56',): RollingMean: 27.857143, ('air_4e1c38f68f435596',): RollingMean: 33.285714, ('air_4f762e840b3996e1',): RollingMean: 10., ('air_4feeb8600f131e43',): RollingMean: 55.714286, ('air_500641aca4cf673c',): RollingMean: 18., ('air_506fe758114df773',): RollingMean: 32.571429, ('air_51281cd059d7b89b',): RollingMean: 16.571429, ('air_51319e7acf0438cf',): RollingMean: 13.857143, ('air_52a08ef3efdb4bb0',): RollingMean: 35.428571, ('air_52e2a1fd42bc917a',): RollingMean: 11.142857, ('air_536043fcf1a4f8a4',): RollingMean: 29.571429, ('air_539d693f7317c62d',): RollingMean: 18.571429, ('air_546b353cbea4a45b',): RollingMean: 14.285714, ('air_5485912b44f976de',): RollingMean: 8., ('air_54d6c25d33f5260e',): RollingMean: 45., ('air_54ed43163b7596c4',): RollingMean: 14., ('air_55390f784018349a',): RollingMean: 48.142857, ('air_55c3627912b9c849',): RollingMean: 8.714286, ('air_55e11c33d4758131',): RollingMean: 22.571429, ('air_56cd12f31a0afc04',): RollingMean: 29.571429, ('air_56cebcbd6906e04c',): RollingMean: 24.285714, ('air_56ea46c14b2dd967',): RollingMean: 45.142857, ('air_57013002b912772b',): RollingMean: 6.285714, ('air_573ecdf81b157d22',): RollingMean: 25.857143, ('air_57c9eea1a2b66e65',): RollingMean: 14.285714, ('air_57ed725a1930a5b9',): RollingMean: 14., ('air_5878b6f2a9da12c1',): RollingMean: 14., ('air_59cc9b2b209c6331',): RollingMean: 9.285714, ('air_5a9a6cbeeb434c08',): RollingMean: 23.714286, ('air_5acc13d655a6e8b2',): RollingMean: 23.714286, ('air_5afb1cca48ceaa19',): RollingMean: 51.571429, ('air_5b6d18c470bbfaf9',): RollingMean: 39.285714, ('air_5b704df317ed1962',): RollingMean: 2.142857, ('air_5bd22f9cc1426a90',): RollingMean: 37.285714, ('air_5c65468938c07fa5',): RollingMean: 11.428571, ('air_5c7489c9ec755e2d',): RollingMean: 39.714286, ('air_5c817ef28f236bdf',): RollingMean: 45.428571, ('air_5cb030b9f0b91537',): RollingMean: 11.142857, ('air_5cfc537125d97f16',): RollingMean: 8.428571, ('air_5d7c744c3a2ef624',): RollingMean: 32.428571, ('air_5d945ade487cdf4d',): RollingMean: 17., ('air_5dea8a7a5bf5eb71',): RollingMean: 32.285714, ('air_5e339a1f364cdb00',): RollingMean: 13.571429, ('air_5e34c6fe6fabd10e',): RollingMean: 18.285714, ('air_5e70fe82f9e4fab6',): RollingMean: 17.857143, ('air_5e939e005bd34633',): RollingMean: 1.857143, ('air_5ed3198e4a5eed0f',): RollingMean: 34.571429, ('air_5f3a3ef4cba110a4',): RollingMean: 34.571429, ('air_5f6fa1b897fe80d5',): RollingMean: 26., ('air_5fbda8e9302f7c13',): RollingMean: 26.714286, ('air_602ca92c0db34f8f',): RollingMean: 16.857143, ('air_609050e4e4f79ae1',): RollingMean: 10.571429, ('air_60a7057184ec7ec7',): RollingMean: 30.428571, ('air_60aa54ecbc602348',): RollingMean: 5.714286, ('air_6108821ffafa9b72',): RollingMean: 26., ('air_614e2f7e76dff854',): RollingMean: 11.571429, ('air_61668cc2b0778898',): RollingMean: 9.285714, ('air_61b8d37c33617f21',): RollingMean: 28.857143, ('air_61de73b097513f58',): RollingMean: 8.714286, ('air_622375b4815cf5cb',): RollingMean: 44.857143, ('air_627cabe2fe53f33f',): RollingMean: 14.571429, ('air_629d9935273c82ae',): RollingMean: 27.142857, ('air_629edf21ea38ac2d',): RollingMean: 39.142857, ('air_632ba66e1f75aa28',): RollingMean: 20.142857, ('air_638c35eb25e53eea',): RollingMean: 23.571429, ('air_63a750d8b4b6a976',): RollingMean: 30.142857, ('air_63a88d81295195ed',): RollingMean: 29.571429, ('air_63b13c56b7201bd9',): RollingMean: 26.285714, ('air_63e28ee0b0c955a7',): RollingMean: 25.857143, ('air_640cf4835f0d9ba3',): RollingMean: 30., ('air_6411203a47b5ec77',): RollingMean: 10., ('air_645cb18b33f938cf',): RollingMean: 13.571429, ('air_646b93e336f0dded',): RollingMean: 8.142857, ('air_64a5d5c1381837af',): RollingMean: 38.428571, ('air_64d4491ad8cdb1c6',): RollingMean: 14.714286, ('air_650f9b9de0c5542c',): RollingMean: 23.857143, ('air_657a0748462f85de',): RollingMean: 8.285714, ('air_65e294f1ae6df9c3',): RollingMean: 18.857143, ('air_6607fe3671242ce3',): RollingMean: 44.142857, ('air_670a0c1c4108bcea',): RollingMean: 27.857143, ('air_671b4bea84dafb67',): RollingMean: 26., ('air_673acd9fa5e0dd78',): RollingMean: 7.142857, ('air_67483104fa38ef6c',): RollingMean: 30.428571, ('air_675aa35cba456fd1',): RollingMean: 43.285714, ('air_67f87c159d9e2ee2',): RollingMean: 39.857143, ('air_68147db09287bf74',): RollingMean: 21.285714, ('air_681b0c56328dd2af',): RollingMean: 35.428571, ('air_681f96e6a6595f82',): RollingMean: 35.857143, ('air_68301bcb11e2f389',): RollingMean: 27.142857, ('air_683371d9baabf410',): RollingMean: 31.714286, ('air_6836438b543ba698',): RollingMean: 11.571429, ('air_6873982b9e19c7ad',): RollingMean: 6.285714, ('air_68c1de82037d87e6',): RollingMean: 25., ('air_68cc910e7b307b09',): RollingMean: 9.428571, ('air_68d075113f368946',): RollingMean: 23.857143, ('air_6902e4ec305b3d08',): RollingMean: 38.428571, ('air_694571ea13fb9e0e',): RollingMean: 29.285714, ('air_6a15e4eae523189d',): RollingMean: 17.857143, ('air_6b15edd1b4fbb96a',): RollingMean: 31., ('air_6b2268863b14a2af',): RollingMean: 20.285714, ('air_6b65745d432fd77f',): RollingMean: 23.428571, ('air_6b7678aae65d2d59',): RollingMean: 9., ('air_6b942d5ebbc759c2',): RollingMean: 12.857143, ('air_6b9fa44a9cf504a1',): RollingMean: 4.857143, ('air_6c1128955c58b690',): RollingMean: 14.285714, ('air_6c91a28278a16f64',): RollingMean: 9.142857, ('air_6c952e3c6e590945',): RollingMean: 15.571429, ('air_6ca1d941c8199a67',): RollingMean: 28.571429, ('air_6cbe54f0aa30b615',): RollingMean: 13.714286, ('air_6ced51c24fb54262',): RollingMean: 9.142857, ('air_6d64dba2edd4fc0c',): RollingMean: 5.142857, ('air_6d65542aa43b598b',): RollingMean: 30., ('air_6d65dd11d96e00fb',): RollingMean: 5.285714, ('air_6e06824d0934dd81',): RollingMean: 23.285714, ('air_6e3fd96320d24324',): RollingMean: 7.857143, ('air_6e64fb5821402cd2',): RollingMean: 8.142857, ('air_6ff5fca957798daa',): RollingMean: 7.285714, ('air_707d4b6328f2c2df',): RollingMean: 28.857143, ('air_709262d948dd0b6e',): RollingMean: 14.714286, ('air_70e9e8cd55879414',): RollingMean: 10.857143, ('air_70f834596eb99fee',): RollingMean: 21., ('air_710d6537cb7623df',): RollingMean: 31.714286, ('air_712dd258f7f91b4b',): RollingMean: 20.571429, ('air_71903025d39a4571',): RollingMean: 15.142857, ('air_722297e7f26db91d',): RollingMean: 12.285714, ('air_728ff578acc6ac6e',): RollingMean: 11.857143, ('air_72f5146cf0c49beb',): RollingMean: 13., ('air_735bcbe1763d6e98',): RollingMean: 10.285714, ('air_73f316e6a18d8aa9',): RollingMean: 23.714286, ('air_7420042ff75f9aca',): RollingMean: 33.285714, ('air_746211c0b532e8aa',): RollingMean: 64.142857, ('air_747f375eb3900e1e',): RollingMean: 4.428571, ('air_74cf22153214064c',): RollingMean: 13.714286, ('air_7514d90009613cd6',): RollingMean: 75.714286, ('air_754ae581ad80cc9f',): RollingMean: 10.857143, ('air_75864c80d2fb334a',): RollingMean: 11.571429, ('air_75bd5d1b6dc6670d',): RollingMean: 11.857143, ('air_764f71040a413d4d',): RollingMean: 54.428571, ('air_77488fa378cf98c3',): RollingMean: 6.857143, ('air_77dfc83450cbc89c',): RollingMean: 42.714286, ('air_7831b00996701c0f',): RollingMean: 23.428571, ('air_789103bf53b8096b',): RollingMean: 54., ('air_789466e488705c93',): RollingMean: 22.714286, ('air_78df4dc6a7e83e41',): RollingMean: 16.857143, ('air_79afb3f52b4d062c',): RollingMean: 9., ('air_79f528087f49df06',): RollingMean: 31., ('air_7a81bd7fadcbf3d8',): RollingMean: 4., ('air_7a946aada80376a4',): RollingMean: 16.142857, ('air_7bacc4d36fb094c9',): RollingMean: 6.571429, ('air_7bc6ca04d7b0f3b8',): RollingMean: 8.428571, ('air_7bda6048a4a78837',): RollingMean: 24.857143, ('air_7c7774c66fb237f7',): RollingMean: 7.571429, ('air_7cc17a324ae5c7dc',): RollingMean: 14.714286, ('air_7cf5a02c0e01b647',): RollingMean: 33.857143, ('air_7d65049f9d275c0d',): RollingMean: 11.571429, ('air_7dacea2f22afccfb',): RollingMean: 38.142857, ('air_7db266904cb0d72a',): RollingMean: 13.571429, ('air_7e12c5d27f44a8de',): RollingMean: 25.571429, ('air_7ef9a5ea5c8fe39f',): RollingMean: 10.857143, ('air_7f3dc18494bce98b',): RollingMean: 15.428571, ('air_7f9e15afafcf4c75',): RollingMean: 41.857143, ('air_7fbf7649eb13ad9b',): RollingMean: 19.571429, ('air_800c02226e2e0288',): RollingMean: 15.285714, ('air_8093d0b565e9dbdf',): RollingMean: 39.142857, ('air_8110d68cc869b85e',): RollingMean: 51.857143, ('air_81546875de9c8e78',): RollingMean: 5., ('air_81a12d67c22e012f',): RollingMean: 19.714286, ('air_81bd68142db76f58',): RollingMean: 17.714286, ('air_81c2600146d07d16',): RollingMean: 6.142857, ('air_81c5dff692063446',): RollingMean: 14.857143, ('air_820d1919cbecaa0a',): RollingMean: 32.714286, ('air_82a6ae14151953ba',): RollingMean: 41.714286, ('air_831658500aa7c846',): RollingMean: 31.571429, ('air_832f9dbe9ee4ebd3',): RollingMean: 12.428571, ('air_83db5aff8f50478e',): RollingMean: 6., ('air_84060403939d8216',): RollingMean: 15.571429, ('air_848616680ef061bd',): RollingMean: 29.571429, ('air_84f6876ff7e83ae7',): RollingMean: 18.428571, ('air_8523d6a70de49e6c',): RollingMean: 31.571429, ('air_859feab8e3c9f98d',): RollingMean: 25.285714, ('air_85bd13a49370c392',): RollingMean: 12.571429, ('air_86cfbf2624576fad',): RollingMean: 7.571429, ('air_86f7b2109e4abd65',): RollingMean: 47.571429, ('air_87059630ab6fe47f',): RollingMean: 4.285714, ('air_87078cf7903a648c',): RollingMean: 6.285714, ('air_87467487d21891dd',): RollingMean: 10.142857, ('air_8764b3473ddcceaf',): RollingMean: 4.857143, ('air_876d7a23c47811cb',): RollingMean: 16.571429, ('air_877f79706adbfb06',): RollingMean: 10.285714, ('air_87ca98aa7664de94',): RollingMean: 13.714286, ('air_87f9e1024b951f01',): RollingMean: 12.142857, ('air_883ca28ef0ed3d55',): RollingMean: 13.857143, ('air_88c8e34baa79217b',): RollingMean: 35.571429, ('air_88ca84051ba95339',): RollingMean: 16.428571, ('air_88f31db64991768a',): RollingMean: 8.428571, ('air_890d7e28e8eaaa11',): RollingMean: 9.714286, ('air_89e7328af22efe74',): RollingMean: 41., ('air_8a1d21fad48374e8',): RollingMean: 13.857143, ('air_8a59bb0c497b771e',): RollingMean: 23.857143, ('air_8a906e5801eac81c',): RollingMean: 21.857143, ('air_8b4a46dc521bfcfe',): RollingMean: 31.714286, ('air_8c119d1f16049f20',): RollingMean: 29.857143, ('air_8c3175aa5e4fc569',): RollingMean: 131.714286, ('air_8cc350fd70ee0757',): RollingMean: 37.285714, ('air_8ce035ee1d8a56a6',): RollingMean: 19.571429, ('air_8d50c64692322dff',): RollingMean: 12.571429, ('air_8d61f49aa0373492',): RollingMean: 49.714286, ('air_8e429650fcf7a0ae',): RollingMean: 19.428571, ('air_8e4360a64dbd4c50',): RollingMean: 20., ('air_8e492076a1179383',): RollingMean: 43.571429, ('air_8e8f42f047537154',): RollingMean: 28.285714, ('air_8ec47c0f1e2c879e',): RollingMean: 32., ('air_8f13ef0f5e8c64dd',): RollingMean: 5., ('air_8f273fb9ad2fed6f',): RollingMean: 12.857143, ('air_8f3b563416efc6ad',): RollingMean: 15., ('air_900d755ebd2f7bbd',): RollingMean: 97.285714, ('air_901925b628677c2e',): RollingMean: 8.571429, ('air_90213bcae4afa274',): RollingMean: 29.571429, ('air_90bd5de52c166767',): RollingMean: 21.714286, ('air_90ed0a2f24755533',): RollingMean: 50., ('air_90f0efbb702d77b7',): RollingMean: 30.857143, ('air_9105a29b0eb250d2',): RollingMean: 16.857143, ('air_91236b89d29567af',): RollingMean: 27.428571, ('air_9152d9926e5c4a3a',): RollingMean: 31.142857, ('air_915558a55c2bc56c',): RollingMean: 17.142857, ('air_91beafbba9382b0a',): RollingMean: 36.428571, ('air_91d72e16c4bcba55',): RollingMean: 15.714286, ('air_9241121af22ff1d6',): RollingMean: 27.285714, ('air_929d8513e3cdb423',): RollingMean: 8.285714, ('air_931a8a4321b6e7d1',): RollingMean: 4., ('air_9352c401d5adb01b',): RollingMean: 25.571429, ('air_9387ff95e886ebc7',): RollingMean: 11.857143, ('air_938ef91ecdde6878',): RollingMean: 27., ('air_939964477035ef0b',): RollingMean: 16.857143, ('air_93b9bb641f8fc982',): RollingMean: 24.857143, ('air_93dd7070c9bf5453',): RollingMean: 29.142857, ('air_93ebe490d4abb8e9',): RollingMean: 21.285714, ('air_9438d67241c81314',): RollingMean: 31.714286, ('air_947eb2cae4f3e8f2',): RollingMean: 36.714286, ('air_9483d65e9cc9a6b7',): RollingMean: 15.428571, ('air_950381108f839348',): RollingMean: 32.142857, ('air_95d28905941fd4cb',): RollingMean: 36.428571, ('air_95e917913cd988f3',): RollingMean: 25.714286, ('air_96005f79124e12bf',): RollingMean: 42.714286, ('air_965b2e0cf4119003',): RollingMean: 40., ('air_96743eee94114261',): RollingMean: 15.571429, ('air_96773a6236d279b1',): RollingMean: 25.428571, ('air_968d72c12eed09f0',): RollingMean: 17.285714, ('air_96929a799b12a43e',): RollingMean: 27.428571, ('air_96ec3cfe78cb0652',): RollingMean: 21.285714, ('air_97159fc4e90053fe',): RollingMean: 24.142857, ('air_97958e7fce98b6a3',): RollingMean: 17.857143, ('air_97b2a9f975fc702c',): RollingMean: 40.428571, ('air_97cf68dc1a9beac0',): RollingMean: 14.571429, ('air_97e0f2feec4d577a',): RollingMean: 18.714286, ('air_9828505fefc77d75',): RollingMean: 12.714286, ('air_98b54e32ccddd896',): RollingMean: 17.428571, ('air_990a642a3deb2903',): RollingMean: 33.428571, ('air_99157b6163835eec',): RollingMean: 34.428571, ('air_99a5183695b849f9',): RollingMean: 25.857143, ('air_99b01136f451fc0e',): RollingMean: 43.857143, ('air_99c3eae84130c1cb',): RollingMean: 41.857143, ('air_9a30407764f4ff84',): RollingMean: 20., ('air_9a6f6e7f623003d2',): RollingMean: 2.857143, ('air_9aa32b3db0fab3a5',): RollingMean: 15.857143, ('air_9aa92007e3628dbc',): RollingMean: 36.571429, ('air_9ae7081cb77dc51e',): RollingMean: 32.857143, ('air_9b13c7feb0a0c431',): RollingMean: 12.714286, ('air_9b6af3db40da4ae2',): RollingMean: 29., ('air_9bbc673495e23532',): RollingMean: 4.571429, ('air_9bf0ccac497c4af3',): RollingMean: 47.285714, ('air_9bf595ef095572fb',): RollingMean: 28.142857, ('air_9c6787aa03a45586',): RollingMean: 86., ('air_9ca2767761efff4d',): RollingMean: 9.142857, ('air_9cd5e310f488bced',): RollingMean: 11.571429, ('air_9cf2f1ba86229773',): RollingMean: 34.285714, ('air_9d3482b4680aee88',): RollingMean: 9.571429, ('air_9d452a881f7f2bb7',): RollingMean: 9.285714, ('air_9d474ec2448c700d',): RollingMean: 11.857143, ('air_9d5a980b211e1795',): RollingMean: 11.285714, ('air_9d93d95720f2e831',): RollingMean: 8.857143, ('air_9dc9483f717d73ee',): RollingMean: 4.714286, ('air_9dd7d38b0f1760c4',): RollingMean: 3., ('air_9e920b758503ef54',): RollingMean: 7.285714, ('air_9efaa7ded03c5a71',): RollingMean: 13.857143, ('air_9f277fb7a2c1d842',): RollingMean: 9.857143, ('air_9fc607777ad76b26',): RollingMean: 16.285714, ('air_a083834e7ffe187e',): RollingMean: 20.857143, ('air_a11473cc1eb9a27f',): RollingMean: 31.714286, ('air_a17f0778617c76e2',): RollingMean: 30.285714, ('air_a1fe8c588c8d2f30',): RollingMean: 17.285714, ('air_a218912784bf767d',): RollingMean: 13., ('air_a21ffca0bea1661a',): RollingMean: 1.142857, ('air_a239a44805932bab',): RollingMean: 35.142857, ('air_a24bf50c3e90d583',): RollingMean: 18.285714, ('air_a2567267116a3b75',): RollingMean: 16.285714, ('air_a257c9749d8d0ff6',): RollingMean: 18.142857, ('air_a271c9ba19e81d17',): RollingMean: 29.142857, ('air_a2b29aa7feb4e36f',): RollingMean: 21.571429, ('air_a304330715435390',): RollingMean: 8.142857, ('air_a33461f4392ec62c',): RollingMean: 30.142857, ('air_a373500730e2a9e0',): RollingMean: 10.142857, ('air_a38f25e3399d1b25',): RollingMean: 41.142857, ('air_a41b032371a63427',): RollingMean: 9.428571, ('air_a49f1cf0634f13e5',): RollingMean: 16.857143, ('air_a510dcfe979f09eb',): RollingMean: 12.714286, ('air_a546cbf478a8b6e4',): RollingMean: 28.714286, ('air_a55d17bd3f3033cb',): RollingMean: 12.142857, ('air_a563896da3777078',): RollingMean: 23.142857, ('air_a678e5b144ca24ce',): RollingMean: 18.571429, ('air_a7404a854919e990',): RollingMean: 8.571429, ('air_a8533b7a992bb0ca',): RollingMean: 19.285714, ('air_a85f0c0c889f6b7e',): RollingMean: 50.571429, ('air_a85f8c0bfd61889f',): RollingMean: 17.142857, ('air_a88ac559064dec08',): RollingMean: 28., ('air_a9133955abccf071',): RollingMean: 27., ('air_a9178f19da58fe99',): RollingMean: 7.714286, ('air_a9a380530c1e121f',): RollingMean: 45.285714, ('air_aa0049fe3cc6f4d6',): RollingMean: 11.142857, ('air_ab3ae0e410b20069',): RollingMean: 16.714286, ('air_ab9746a0f83084b7',): RollingMean: 1.142857, ('air_abcdc8115988a010',): RollingMean: 9.857143, ('air_abf06fcca748dca5',): RollingMean: 9., ('air_ac7a7427c9ae12a5',): RollingMean: 63.857143, ('air_ad13e71e21235131',): RollingMean: 10.285714, ('air_ad60f6b76c9df7ed',): RollingMean: 30.571429, ('air_ad7777590c884721',): RollingMean: 9.428571, ('air_add9a575623726c8',): RollingMean: 47.571429, ('air_ade6e836ffd1da64',): RollingMean: 11.571429, ('air_aed3a8b49abe4a48',): RollingMean: 5., ('air_af03c277a167b2bd',): RollingMean: 36.285714, ('air_af24e3e817dea1e5',): RollingMean: 15.285714, ('air_af63df35857b16e6',): RollingMean: 25.714286, ('air_b0a6a4c5e95c74cf',): RollingMean: 19.571429, ('air_b162fb07fbbdea33',): RollingMean: 15.285714, ('air_b192fb5310436005',): RollingMean: 8., ('air_b1a72bf1ebf4b8ef',): RollingMean: 46.285714, ('air_b1bb1fae86617d7a',): RollingMean: 36.428571, ('air_b1d822f75c9fc615',): RollingMean: 10.714286, ('air_b2395df0e874078d',): RollingMean: 6.571429, ('air_b23d0f519291247d',): RollingMean: 34., ('air_b259b4e4a51a690d',): RollingMean: 18.142857, ('air_b28bed4b2e7167b7',): RollingMean: 19.142857, ('air_b2a639cc7e02edf1',): RollingMean: 20.142857, ('air_b2d8bc9c88b85f96',): RollingMean: 8.142857, ('air_b2d97bd2337c5ba7',): RollingMean: 36.142857, ('air_b2dcec37b83e2494',): RollingMean: 7.857143, ('air_b30fffd7ab1e75a5',): RollingMean: 9.428571, ('air_b3180b74332ba886',): RollingMean: 14.285714, ('air_b3a824511477a4ed',): RollingMean: 6.285714, ('air_b439391e72899756',): RollingMean: 20.142857, ('air_b45b8e456f53942a',): RollingMean: 9.285714, ('air_b4f32bcc399da2b9',): RollingMean: 20.428571, ('air_b5598d12d1b84890',): RollingMean: 5.428571, ('air_b5bdd318005d9aa4',): RollingMean: 39.428571, ('air_b60cc7d6aee68194',): RollingMean: 13.285714, ('air_b711b43ae472cb6b',): RollingMean: 22.571429, ('air_b7fa3d2fca744dd2',): RollingMean: 41.428571, ('air_b80fed1a07c817d2',): RollingMean: 4.142857, ('air_b88192b35ac03c24',): RollingMean: 21., ('air_b8925441167c3152',): RollingMean: 1.714286, ('air_b8a5ee69e5fdcc5b',): RollingMean: 31.571429, ('air_b8d9e1624baaadc2',): RollingMean: 6.857143, ('air_b9e27558fb8bd5c4',): RollingMean: 13.714286, ('air_ba495cccc8f0f237',): RollingMean: 18.714286, ('air_ba937bf13d40fb24',): RollingMean: 15.714286, ('air_bac5f4441db21db9',): RollingMean: 45.857143, ('air_baf28ac9f13a307d',): RollingMean: 14.571429, ('air_bb09595bab7d5cfb',): RollingMean: 33.857143, ('air_bb26d6d079594414',): RollingMean: 11.428571, ('air_bb4ff06cd661ee9b',): RollingMean: 33.285714, ('air_bbe1c1a47e09f161',): RollingMean: 1.428571, ('air_bc991c51d6613745',): RollingMean: 19.714286, ('air_bc9a129e11a2efe0',): RollingMean: 30.857143, ('air_bcce1ea4350b7b72',): RollingMean: 26., ('air_bd74a9222edfdfe1',): RollingMean: 13.428571, ('air_bdd32aa407c16335',): RollingMean: 16.714286, ('air_bebd55ed63ab2422',): RollingMean: 10.857143, ('air_bed603c423b7d9d4',): RollingMean: 5.857143, ('air_bedd35489e666605',): RollingMean: 35.857143, ('air_bf13014b6e3e60ca',): RollingMean: 31.857143, ('air_bf21b8350771879b',): RollingMean: 22.142857, ('air_bf617aa68d5f1cfa',): RollingMean: 7.571429, ('air_bf7591560077332d',): RollingMean: 9.142857, ('air_bfafaed35e213fd7',): RollingMean: 14.714286, ('air_bfda7731a6c6fc61',): RollingMean: 20.285714, ('air_c027e2b560442808',): RollingMean: 17.285714, ('air_c0385db498b391e5',): RollingMean: 34.285714, ('air_c1d5d165c055b866',): RollingMean: 30.142857, ('air_c1ff20617c54fee7',): RollingMean: 8.142857, ('air_c225148c0fcc5c72',): RollingMean: 39.428571, ('air_c2626f5f86d57342',): RollingMean: 16.142857, ('air_c26f027b5bc1f081',): RollingMean: 5.857143, ('air_c28983412a7eefcf',): RollingMean: 40.571429, ('air_c2c8435bdb3516d4',): RollingMean: 35., ('air_c31472d14e29cee8',): RollingMean: 16.714286, ('air_c3585b0fba3998d0',): RollingMean: 9.285714, ('air_c3bc011cca3bec65',): RollingMean: 4.285714, ('air_c3dcaf3aeb18e20e',): RollingMean: 15.714286, ('air_c47aa7493b15f297',): RollingMean: 23., ('air_c4fa5c562d5409ca',): RollingMean: 15.857143, ('air_c52c63c781fe48f6',): RollingMean: 29.428571, ('air_c5459218282bedd5',): RollingMean: 21.714286, ('air_c66dbd2c37832d00',): RollingMean: 16.714286, ('air_c6a164dd4060e960',): RollingMean: 15.857143, ('air_c6aa2efba0ffc8eb',): RollingMean: 26.428571, ('air_c6ffd6a93e6b68d6',): RollingMean: 15.714286, ('air_c73d319ffabf287a',): RollingMean: 18.428571, ('air_c759b6abeb552160',): RollingMean: 7.142857, ('air_c77ee2b7d36da265',): RollingMean: 42., ('air_c7d30ab0e07f31d5',): RollingMean: 20.285714, ('air_c7f78b4f3cba33ff',): RollingMean: 25.142857, ('air_c8265ecc116f2284',): RollingMean: 9.142857, ('air_c88467d88b2c8ecd',): RollingMean: 19.428571, ('air_c8a657c8c5c93d69',): RollingMean: 9.142857, ('air_c8c0ef02ed72053f',): RollingMean: 27.428571, ('air_c8fe396d6c46275d',): RollingMean: 18., ('air_c92745dfdd2ec68a',): RollingMean: 21.857143, ('air_c9ed65554b6edffb',): RollingMean: 12.714286, ('air_c9f6de13be8b8f25',): RollingMean: 3.571429, ('air_ca1315af9e073bd1',): RollingMean: 43.714286, ('air_ca6ae8d49a2f1eaf',): RollingMean: 24.142857, ('air_ca957d3a1529fbd3',): RollingMean: 31.285714, ('air_cadf9cfb510a1d78',): RollingMean: 29.714286, ('air_caf996ac27206301',): RollingMean: 4.714286, ('air_cb083b4789a8d3a2',): RollingMean: 18.714286, ('air_cb25551c4cd8d9f3',): RollingMean: 5.714286, ('air_cb7467aed805e7fe',): RollingMean: 40.428571, ('air_cb935ff8610ba3d3',): RollingMean: 4.142857, ('air_cbe139af83feb388',): RollingMean: 10.428571, ('air_cbe867adcf44e14f',): RollingMean: 15.714286, ('air_cc1a0e985ce63711',): RollingMean: 27.285714, ('air_cc35590cd1da8554',): RollingMean: 24.571429, ('air_ccd19a5bc5573ae5',): RollingMean: 34.857143, ('air_cd4b301d5d3918d8',): RollingMean: 5.857143, ('air_cd5f54969be9ed08',): RollingMean: 6.285714, ('air_ced6297e5bdf5130',): RollingMean: 23.428571, ('air_cf2229e64408d9fe',): RollingMean: 20.428571, ('air_cf22e368c1a71d53',): RollingMean: 34.857143, ('air_cf5ab75a0afb8af9',): RollingMean: 48., ('air_cfcc94797d2b5d3d',): RollingMean: 18.285714, ('air_cfdeb326418194ff',): RollingMean: 17.285714, ('air_d00161e19f08290b',): RollingMean: 28.714286, ('air_d00a15343325e5f7',): RollingMean: 21.142857, ('air_d07e57b21109304a',): RollingMean: 11.428571, ('air_d0a1e69685259c92',): RollingMean: 32., ('air_d0a7bd3339c3d12a',): RollingMean: 46.714286, ('air_d0e8a085d8dc83aa',): RollingMean: 6.571429, ('air_d138b593ebda55cc',): RollingMean: 6., ('air_d1418d6fd6d634f2',): RollingMean: 17.714286, ('air_d186b2cb0b9ce022',): RollingMean: 14.428571, ('air_d1f20424f76cc78e',): RollingMean: 19.857143, ('air_d34c0861a2be94cb',): RollingMean: 41.285714, ('air_d3e7b5952cd09ccb',): RollingMean: 17.857143, ('air_d44d210d2994f01b',): RollingMean: 7., ('air_d473620754bf9fc2',): RollingMean: 11., ('air_d477b6339b8ce69f',): RollingMean: 11., ('air_d4981cdde163b172',): RollingMean: 27.142857, ('air_d4b5a4b04c5f2d04',): RollingMean: 15.142857, ('air_d4d218b451f82c3d',): RollingMean: 9.428571, ('air_d500b48a8735fbd3',): RollingMean: 20.142857, ('air_d54d6fcb116fbed3',): RollingMean: 4.714286, ('air_d5e0a20370c325c7',): RollingMean: 33.285714, ('air_d63cfa6d6ab78446',): RollingMean: 20.857143, ('air_d69b08a175bc0387',): RollingMean: 13.571429, ('air_d6b3e67261f07646',): RollingMean: 11.714286, ('air_d8abb9e490abf94f',): RollingMean: 12.714286, ('air_d97dabf7aae60da5',): RollingMean: 34.714286, ('air_d98380a4aeb0290b',): RollingMean: 44.285714, ('air_daa7947e1c47f5ed',): RollingMean: 31.142857, ('air_dabfbd0ec951925a',): RollingMean: 8.142857, ('air_dad0b6a36138f309',): RollingMean: 5.142857, ('air_db1233ad855b34d5',): RollingMean: 25.857143, ('air_db4b38ebe7a7ceff',): RollingMean: 19.714286, ('air_db80363d35f10926',): RollingMean: 36.142857, ('air_dbf64f1ce38c7442',): RollingMean: 14., ('air_dc0e080ba0a5e5af',): RollingMean: 9.428571, ('air_dc71c6cc06cd1aa2',): RollingMean: 6.857143, ('air_de692863bb2dd758',): RollingMean: 22., ('air_de803f7e324936b8',): RollingMean: 24.571429, ('air_de88770300008624',): RollingMean: 21.857143, ('air_dea0655f96947922',): RollingMean: 37., ('air_df507aec929ce5f6',): RollingMean: 24.857143, ('air_df554c4527a1cfe6',): RollingMean: 57.285714, ('air_df5cf5cd03eb68d0',): RollingMean: 7.285714, ('air_df843e6b22e8d540',): RollingMean: 12.285714, ('air_df9355c47c5df9d3',): RollingMean: 32.428571, ('air_dfad598ff642dab7',): RollingMean: 28.285714, ('air_dfe068a1bf85f395',): RollingMean: 41.142857, ('air_e00fe7853c0100d6',): RollingMean: 18.142857, ('air_e0118664da63a2d0',): RollingMean: 15.428571, ('air_e01d99390355408d',): RollingMean: 10.571429, ('air_e053c561f32acc28',): RollingMean: 16.428571, ('air_e08b9cf82057a170',): RollingMean: 34., ('air_e0aee25b56a069f2',): RollingMean: 14.857143, ('air_e0e69668214ff972',): RollingMean: 11.142857, ('air_e0f241bd406810c0',): RollingMean: 34.714286, ('air_e1b76fcb5208fb6b',): RollingMean: 18.714286, ('air_e2208a79e2678432',): RollingMean: 47.428571, ('air_e270aff84ac7e4c8',): RollingMean: 22.714286, ('air_e3020992d5fe5dfd',): RollingMean: 14.285714, ('air_e34c631c766f2766',): RollingMean: 24.857143, ('air_e42bdc3377d1eee7',): RollingMean: 23.428571, ('air_e483f5b3c4f310e0',): RollingMean: 6., ('air_e524c6a9e06cc3a1',): RollingMean: 9., ('air_e55abd740f93ecc4',): RollingMean: 45.285714, ('air_e57dd6884595f60d',): RollingMean: 37.714286, ('air_e58f669b6f1a08ce',): RollingMean: 12.142857, ('air_e5cf003abcc5febb',): RollingMean: 18.285714, ('air_e64de0a6bf0739af',): RollingMean: 38.285714, ('air_e657ca554b0c008c',): RollingMean: 28.285714, ('air_e700e390226d9985',): RollingMean: 18.714286, ('air_e76a668009c5dabc',): RollingMean: 9.285714, ('air_e7d2ac6d53d1b744',): RollingMean: 11.714286, ('air_e7fbee4e3cfe65c5',): RollingMean: 39., ('air_e88bbe2ede3467aa',): RollingMean: 21.285714, ('air_e89735e80d614a7e',): RollingMean: 31.428571, ('air_e8ed9335d0c38333',): RollingMean: 30.142857, ('air_e9ebf7fc520ac76a',): RollingMean: 29.142857, ('air_ea6d0c3acf00b22a',): RollingMean: 25.571429, ('air_ea7c16131980c837',): RollingMean: 7., ('air_eb120e6d384a17a8',): RollingMean: 48.428571, ('air_eb20a89bba7dd3d0',): RollingMean: 3.142857, ('air_eb2d2653586315dd',): RollingMean: 35.285714, ('air_eb5788dba285e725',): RollingMean: 31.142857, ('air_ebd31e812960f517',): RollingMean: 30.571429, ('air_ebe02c3090271fa9',): RollingMean: 11.285714, ('air_ec0fad2def4dcff0',): RollingMean: 16., ('air_eca4a5a191e8d993',): RollingMean: 32.571429, ('air_eca5e0064dc9314a',): RollingMean: 33.714286, ('air_ecab54b57a71b10d',): RollingMean: 13., ('air_eceb97ad6a7d4c07',): RollingMean: 30.714286, ('air_ecf7f141339f1d57',): RollingMean: 20.142857, ('air_eda179770dfa9f91',): RollingMean: 10.428571, ('air_edd5e3d696a5811b',): RollingMean: 38.142857, ('air_ee3a01f0c71a769f',): RollingMean: 28.142857, ('air_ee3ba9af184c6c82',): RollingMean: 21.285714, ('air_eec5e572b9eb9c23',): RollingMean: 15.571429, ('air_eeeadee005c006a2',): RollingMean: 13.714286, ('air_ef47430bcd6f6a89',): RollingMean: 13.857143, ('air_ef789667e2e6fe96',): RollingMean: 36.428571, ('air_ef920fa6f4b085f6',): RollingMean: 32.142857, ('air_efc80d3f96b3aff7',): RollingMean: 8.428571, ('air_efd70b04de878f25',): RollingMean: 30., ('air_efef1e3daecce07e',): RollingMean: 43.428571, ('air_f068442ebb6c246c',): RollingMean: 11.571429, ('air_f0c7272956e62f12',): RollingMean: 5.428571, ('air_f0fb0975bdc2cdf9',): RollingMean: 10.142857, ('air_f1094dbf2aef85d9',): RollingMean: 7.142857, ('air_f180301886c21375',): RollingMean: 18.142857, ('air_f183a514cb8ff4fa',): RollingMean: 38., ('air_f1f9027d4fa8f653',): RollingMean: 22., ('air_f267dd70a6a6b5d3',): RollingMean: 31.857143, ('air_f26f36ec4dc5adb0',): RollingMean: 39.857143, ('air_f2985de32bb792e0',): RollingMean: 24.714286, ('air_f2c5a1f24279c531',): RollingMean: 18.571429, ('air_f3602e4fa2f12993',): RollingMean: 11., ('air_f3f9824b7d70c3cf',): RollingMean: 15.714286, ('air_f4936b91c9addbf0',): RollingMean: 16.142857, ('air_f593fa60ac3541e2',): RollingMean: 8., ('air_f690c42545146e0a',): RollingMean: 11.714286, ('air_f6b2489ccf873c3b',): RollingMean: 16.285714, ('air_f6bfd27e2e174d16',): RollingMean: 14.142857, ('air_f6cdaf7b7fdc6d78',): RollingMean: 12.285714, ('air_f8233ad00755c35c',): RollingMean: 28.714286, ('air_f85e21e543cf44f2',): RollingMean: 5.714286, ('air_f88898cd09f40496',): RollingMean: 7.714286, ('air_f911308e19d64236',): RollingMean: 47., ('air_f9168b23fdfc1e52',): RollingMean: 14.142857, ('air_f927b2da69a82341',): RollingMean: 9.428571, ('air_f957c6d6467d4d90',): RollingMean: 9.285714, ('air_f96765e800907c77',): RollingMean: 38.428571, ('air_fa12b40b02fecfd8',): RollingMean: 14.571429, ('air_fa4ffc9057812fa2',): RollingMean: 6., ('air_fab092c35776a9b1',): RollingMean: 10.571429, ('air_fb44f566d4f64a4e',): RollingMean: 14.857143, ('air_fbadf737162a5ce3',): RollingMean: 15., ('air_fc477473134e9ae5',): RollingMean: 15.714286, ('air_fcd4492c83f1c6b9',): RollingMean: 24.142857, ('air_fcfbdcf7b1f82c6e',): RollingMean: 39.857143, ('air_fd154088b1de6fa7',): RollingMean: 4.428571, ('air_fd6aac1043520e83',): RollingMean: 39.428571, ('air_fdc02ec4a3d21ea4',): RollingMean: 8.142857, ('air_fdcfef8bd859f650',): RollingMean: 3.714286, ('air_fe22ef5a9cbef123',): RollingMean: 24.428571, ('air_fe58c074ec1445ea',): RollingMean: 35., ('air_fea5dc9594450608',): RollingMean: 17.428571, ('air_fee8dcf4d619598e',): RollingMean: 29.571429, ('air_fef9ccb3ba0da2f7',): RollingMean: 8.714286, ('air_ffcc2d5087e1b476',): RollingMean: 24.714286, ('air_fff68b929994bfbd',): RollingMean: 4.142857}), 'by': ['store_id'], 'how': RollingMean: 0., 'on': 'y'} y_rollingmean_14_by_store_id {'_feature_name': 'y_rollingmean_14_by_store_id', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f830e2024c0>, RollingMean: 0.), {('air_00a91d42b08b08d9',): RollingMean: 28.428571, ('air_0164b9927d20bcc3',): RollingMean: 6.571429, ('air_0241aa3964b7f861',): RollingMean: 9.928571, ('air_0328696196e46f18',): RollingMean: 8.142857, ('air_034a3d5b40d5b1b1',): RollingMean: 24.285714, ('air_036d4f1ee7285390',): RollingMean: 22.714286, ('air_0382c794b73b51ad',): RollingMean: 26.571429, ('air_03963426c9312048',): RollingMean: 47.142857, ('air_04341b588bde96cd',): RollingMean: 32.5, ('air_049f6d5b402a31b2',): RollingMean: 13.571429, ('air_04cae7c1bc9b2a0b',): RollingMean: 20., ('air_0585011fa179bcce',): RollingMean: 4.785714, ('air_05c325d315cc17f5',): RollingMean: 28.142857, ('air_0647f17b4dc041c8',): RollingMean: 30.928571, ('air_064e203265ee5753',): RollingMean: 18.714286, ('air_066f0221b8a4d533',): RollingMean: 11.142857, ('air_06f95ac5c33aca10',): RollingMean: 29.714286, ('air_0728814bd98f7367',): RollingMean: 7.785714, ('air_0768ab3910f7967f',): RollingMean: 28.214286, ('air_07b314d83059c4d2',): RollingMean: 38.571429, ('air_07bb665f9cdfbdfb',): RollingMean: 25.785714, ('air_082908692355165e',): RollingMean: 46.071429, ('air_083ddc520ea47e1e',): RollingMean: 12.642857, ('air_0845d8395f30c6bb',): RollingMean: 22.714286, ('air_084d98859256acf0',): RollingMean: 16.142857, ('air_0867f7bebad6a649',): RollingMean: 21., ('air_08ba8cd01b3ba010',): RollingMean: 10.285714, ('air_08cb3c4ee6cd6a22',): RollingMean: 12.642857, ('air_08ef81d5b7a0d13f',): RollingMean: 14.5, ('air_08f994758a1e76d4',): RollingMean: 28., ('air_09040f6df960ddb8',): RollingMean: 15.571429, ('air_0919d54f0c9a24b8',): RollingMean: 35.857143, ('air_09661c0f3259cc04',): RollingMean: 28.857143, ('air_09a845d5b5944b01',): RollingMean: 6.928571, ('air_09fd1f5c58583141',): RollingMean: 8.642857, ('air_0a74a5408a0b8642',): RollingMean: 28.428571, ('air_0b184ec04c741a6a',): RollingMean: 12.857143, ('air_0b1e72d2d4422b20',): RollingMean: 20.928571, ('air_0b9038300f8b2b50',): RollingMean: 11.428571, ('air_0e1eae99b8723bc1',): RollingMean: 10.642857, ('air_0e7c11b9abc50163',): RollingMean: 35.071429, ('air_0ead98dd07e7a82a',): RollingMean: 13.571429, ('air_0f0cdeee6c9bf3d7',): RollingMean: 22.071429, ('air_0f2f96335f274801',): RollingMean: 9.928571, ('air_0f60e1576a7d397d',): RollingMean: 6.214286, ('air_1033310359ceeac1',): RollingMean: 18.642857, ('air_10393f12e9069760',): RollingMean: 13.571429, ('air_105a7954e32dba9b',): RollingMean: 51.5, ('air_10713fbf3071c361',): RollingMean: 12.285714, ('air_10bbe8acd943d8f6',): RollingMean: 30.857143, ('air_12c4fb7a423df20d',): RollingMean: 20.071429, ('air_138ee734ac79ff90',): RollingMean: 7.214286, ('air_138ff410757b845f',): RollingMean: 54.428571, ('air_1408dd53f31a8a65',): RollingMean: 27.857143, ('air_142e78ba7001da9c',): RollingMean: 13.642857, ('air_1509881b22965b34',): RollingMean: 19., ('air_152c1f08d7d20e07',): RollingMean: 11.857143, ('air_15ae33469e9ea2dd',): RollingMean: 10.285714, ('air_15e6e15c7ea2c162',): RollingMean: 18.642857, ('air_16179d43b6ee5fd8',): RollingMean: 7.714286, ('air_1653a6c513865af3',): RollingMean: 32.5, ('air_168441ada3e878e1',): RollingMean: 45.714286, ('air_16c4cfddeb2cf69b',): RollingMean: 12.071429, ('air_16cf0a73233896de',): RollingMean: 11.428571, ('air_1707a3f18bb0da07',): RollingMean: 26.214286, ('air_17a6ab40f97fd4d8',): RollingMean: 8.285714, ('air_17bed6dbf7c8b0fc',): RollingMean: 19.785714, ('air_1979eaff8189d086',): RollingMean: 9.071429, ('air_1ab60ce33bfed8a8',): RollingMean: 9.642857, ('air_1ae94f514a0bce13',): RollingMean: 7., ('air_1ba4e87ef7422183',): RollingMean: 38.714286, ('air_1c0b150f9e696a5f',): RollingMean: 100.785714, ('air_1c95a84924d72500',): RollingMean: 8.714286, ('air_1d1e8860ae04f8e9',): RollingMean: 15.071429, ('air_1d25ca6c76df48b4',): RollingMean: 42.214286, ('air_1d3f797dd1f7cf1c',): RollingMean: 33.571429, ('air_1dd8f6f47480d1a2',): RollingMean: 37.428571, ('air_1dea9815ccd36620',): RollingMean: 10.5, ('air_1e23210b584540e7',): RollingMean: 3.857143, ('air_1e665503b8474c55',): RollingMean: 5.785714, ('air_1eeff462acb24fb7',): RollingMean: 16.428571, ('air_1f1390a8be2272b3',): RollingMean: 18.214286, ('air_1f34e9beded2231a',): RollingMean: 8.214286, ('air_1f7f8fa557bc0d55',): RollingMean: 3.928571, ('air_2009041dbf9264de',): RollingMean: 51.285714, ('air_20619d21192aa571',): RollingMean: 16.785714, ('air_20add8092c9bb51d',): RollingMean: 31.642857, ('air_2195cd5025a98033',): RollingMean: 29.428571, ('air_21f5052d5330528d',): RollingMean: 30.857143, ('air_220cba70c890b119',): RollingMean: 7.928571, ('air_22682e965418936f',): RollingMean: 10., ('air_228f10bec0bda9c8',): RollingMean: 16.785714, ('air_229d7e508d9f1b5e',): RollingMean: 9.571429, ('air_232dcee6f7c51d37',): RollingMean: 5.571429, ('air_234d3dbf7f3d5a50',): RollingMean: 7.642857, ('air_23e1b11aee2a1407',): RollingMean: 46., ('air_23ee674e91469086',): RollingMean: 20.714286, ('air_24b9b2a020826ede',): RollingMean: 31.5, ('air_24e8414b9b07decb',): RollingMean: 6.071429, ('air_2545dd3a00f265e2',): RollingMean: 46.785714, ('air_256be208a979e023',): RollingMean: 7.428571, ('air_2570ccb93badde68',): RollingMean: 39.357143, ('air_258ad2619d7bff9a',): RollingMean: 36.714286, ('air_258dc112912fc458',): RollingMean: 61.428571, ('air_25c583983246b7b0',): RollingMean: 24.428571, ('air_25d8e5cc57dd87d9',): RollingMean: 24.928571, ('air_25e9888d30b386df',): RollingMean: 4.928571, ('air_2634e41551e9807d',): RollingMean: 14.857143, ('air_26c5bbeb7bb82bf1',): RollingMean: 27.071429, ('air_26f10355d9b4d82a',): RollingMean: 33.785714, ('air_2703dcb33192b181',): RollingMean: 52.428571, ('air_275732a5db46f4d3',): RollingMean: 15.928571, ('air_27e991812b0d9c92',): RollingMean: 41.428571, ('air_28064154614b2e6c',): RollingMean: 22.857143, ('air_287d2de7d3c93406',): RollingMean: 13., ('air_28a9fa1ec0839375',): RollingMean: 29.071429, ('air_28dbe91c4c9656be',): RollingMean: 33.571429, ('air_290e7a57b390f78e',): RollingMean: 13.857143, ('air_298513175efdf261',): RollingMean: 26.428571, ('air_2a184c1745274b2b',): RollingMean: 4.214286, ('air_2a24aec099333f39',): RollingMean: 7.285714, ('air_2a3743e37aab04b4',): RollingMean: 20.071429, ('air_2a485b92210c98b5',): RollingMean: 18.142857, ('air_2a7f14da7fe0f699',): RollingMean: 27.214286, ('air_2aab19554f91ff82',): RollingMean: 49.714286, ('air_2ac361b97630e2df',): RollingMean: 12.071429, ('air_2b8b29ddfd35018e',): RollingMean: 10.928571, ('air_2b9bc9f5f5168ea1',): RollingMean: 21.428571, ('air_2bffb19a24d11729',): RollingMean: 12.428571, ('air_2c505f9ad67d4635',): RollingMean: 16.5, ('air_2c6c79d597e48096',): RollingMean: 17.928571, ('air_2c6fef1ce0e13a5a',): RollingMean: 30.785714, ('air_2c989829acbd1c6b',): RollingMean: 28.357143, ('air_2cee51fa6fdf6c0d',): RollingMean: 16.571429, ('air_2d3afcb91762fe01',): RollingMean: 45.142857, ('air_2d78d9a1f4dd02ca',): RollingMean: 11.357143, ('air_2e7cb1f1a2a9cd6a',): RollingMean: 27.571429, ('air_2f8ced25216df926',): RollingMean: 14.142857, ('air_2fc149abe33adcb4',): RollingMean: 35.214286, ('air_2fc478dc9f0a6b31',): RollingMean: 11.428571, ('air_2fed81034f8834e5',): RollingMean: 20.714286, ('air_303bac187b53083a',): RollingMean: 10.428571, ('air_310e467e6e625004',): RollingMean: 15.214286, ('air_3155ee23d92202da',): RollingMean: 16.5, ('air_31c753b48a657b6c',): RollingMean: 24.285714, ('air_32460819c7600037',): RollingMean: 51.071429, ('air_324f7c39a8410e7c',): RollingMean: 10.928571, ('air_326ca454ef3558bc',): RollingMean: 22.214286, ('air_32b02ba5dc2027f4',): RollingMean: 27.5, ('air_32c61b620a766138',): RollingMean: 26.785714, ('air_32f5d7cd696e3c4a',): RollingMean: 23.142857, ('air_33b01025210d6007',): RollingMean: 11.785714, ('air_3440e0ea1b70a99b',): RollingMean: 28., ('air_346ade7d29230634',): RollingMean: 7.857143, ('air_347be2c4feeb408b',): RollingMean: 21.071429, ('air_349278fa964bb12f',): RollingMean: 19.214286, ('air_3525f11ef0bf0c35',): RollingMean: 41.142857, ('air_35512c42db0868da',): RollingMean: 6.071429, ('air_3561fd1c0bce6a95',): RollingMean: 10.714286, ('air_35c4732dcbfe31be',): RollingMean: 6.785714, ('air_36429b5ca4407b3e',): RollingMean: 20., ('air_36bcf77d3382d36e',): RollingMean: 32.5, ('air_37189c92b6c761ec',): RollingMean: 14.857143, ('air_375a5241615b5e22',): RollingMean: 7., ('air_382f5ace4e2247b8',): RollingMean: 7.785714, ('air_383f5b2f8d345a49',): RollingMean: 12.357143, ('air_38746ffe9aa20c7e',): RollingMean: 3.785714, ('air_396166d47733d5c9',): RollingMean: 24.714286, ('air_396942e6423a2145',): RollingMean: 21.857143, ('air_397d3f32a7196aa2',): RollingMean: 35.5, ('air_3980af67be35afdb',): RollingMean: 15.785714, ('air_3982a2c4ea2ed431',): RollingMean: 30.5, ('air_399904bdb7685ca0',): RollingMean: 27.785714, ('air_39dccf7df20b1c6a',): RollingMean: 26.714286, ('air_3a8a3f8fb5cd7f88',): RollingMean: 21.214286, ('air_3aa839e8e0cb6c87',): RollingMean: 27.5, ('air_3ac24136722e2291',): RollingMean: 13.142857, ('air_3b20733899b5287f',): RollingMean: 39.857143, ('air_3b6438b125086430',): RollingMean: 13.285714, ('air_3bb99a1fe0583897',): RollingMean: 40.285714, ('air_3bd49f98ab7f36ab',): RollingMean: 13., ('air_3c05c8f26c611eb9',): RollingMean: 25.285714, ('air_3c938075889fc059',): RollingMean: 30.5, ('air_3cad29d1a23209d2',): RollingMean: 8.357143, ('air_3caef3f76b8f26c5',): RollingMean: 25.642857, ('air_3d3a2b509180e798',): RollingMean: 17.714286, ('air_3e6cea17a9d2c0f1',): RollingMean: 17.071429, ('air_3e93f3c81008696d',): RollingMean: 34.214286, ('air_3f91d592acd6cc0b',): RollingMean: 24.928571, ('air_401b39f97e56b939',): RollingMean: 11.785714, ('air_4043b7ccfbffa732',): RollingMean: 44.571429, ('air_4092cfbd95a3ac1b',): RollingMean: 23., ('air_40953e2d8b4f2857',): RollingMean: 15.428571, ('air_40f6193ea3ed1b91',): RollingMean: 16.714286, ('air_414ff459ed18fa48',): RollingMean: 16., ('air_41bbf6e1d9814c4b',): RollingMean: 8.714286, ('air_421670f21da5ba31',): RollingMean: 17.928571, ('air_4254c3fc3ad078bd',): RollingMean: 11.357143, ('air_42c9aa6d617c5057',): RollingMean: 42.714286, ('air_42d41eb58cad170e',): RollingMean: 32.285714, ('air_43b65e4b05bff2d3',): RollingMean: 20.642857, ('air_43d577e0c9460e64',): RollingMean: 35.142857, ('air_4433ab8e9999915f',): RollingMean: 21.142857, ('air_4481a87c1d7c9896',): RollingMean: 20.928571, ('air_452100f5305dde64',): RollingMean: 7.428571, ('air_45326ebb8dc72cfb',): RollingMean: 29.142857, ('air_4570f52104fe0982',): RollingMean: 7.357143, ('air_4579cb0669fd411b',): RollingMean: 18.071429, ('air_457efe8c3a30ea17',): RollingMean: 6.285714, ('air_464a62de0d57be1e',): RollingMean: 26.857143, ('air_465bddfed3353b23',): RollingMean: 27.071429, ('air_47070be6093f123e',): RollingMean: 46.285714, ('air_472b19e3b5bffa41',): RollingMean: 13.5, ('air_473cf23b9e7c0a37',): RollingMean: 9.357143, ('air_473f98b212d37b4a',): RollingMean: 27.357143, ('air_47beaffd3806c979',): RollingMean: 19.214286, ('air_483eba479dc9910d',): RollingMean: 21.642857, ('air_48e9fc98b62495a7',): RollingMean: 17.071429, ('air_48f4da6223571da4',): RollingMean: 22.571429, ('air_48ffd31594bc3263',): RollingMean: 4.928571, ('air_49211568cab5fdee',): RollingMean: 25., ('air_4974785f48853db9',): RollingMean: 6.928571, ('air_4b251b9f8373f1ae',): RollingMean: 26.928571, ('air_4b380b4db9d37883',): RollingMean: 25.571429, ('air_4b55d8aea1d2b395',): RollingMean: 34.285714, ('air_4b9085d0d46a6211',): RollingMean: 28.142857, ('air_4beac252540f865e',): RollingMean: 41.571429, ('air_4c2ed28f3f19ca52',): RollingMean: 14.642857, ('air_4c665a2bfff0da3b',): RollingMean: 8.857143, ('air_4c727b55acdee495',): RollingMean: 15.357143, ('air_4cab15ad29c0ffbc',): RollingMean: 21.214286, ('air_4cab91146e3d1897',): RollingMean: 15., ('air_4cca5666eaf5c709',): RollingMean: 34.428571, ('air_4ce7b17062a1bf73',): RollingMean: 7.857143, ('air_4d21676ed11f0bac',): RollingMean: 32.857143, ('air_4d71826793c09b22',): RollingMean: 21.642857, ('air_4d90a22572fa1ec9',): RollingMean: 25.785714, ('air_4de6d887a7b1c1fc',): RollingMean: 15.357143, ('air_4dea8d17f6f59c56',): RollingMean: 25.214286, ('air_4e1c38f68f435596',): RollingMean: 34.071429, ('air_4f762e840b3996e1',): RollingMean: 11.285714, ('air_4feeb8600f131e43',): RollingMean: 57.714286, ('air_500641aca4cf673c',): RollingMean: 15.142857, ('air_506fe758114df773',): RollingMean: 28.428571, ('air_51281cd059d7b89b',): RollingMean: 13.928571, ('air_51319e7acf0438cf',): RollingMean: 13.571429, ('air_52a08ef3efdb4bb0',): RollingMean: 47.928571, ('air_52e2a1fd42bc917a',): RollingMean: 11.642857, ('air_536043fcf1a4f8a4',): RollingMean: 30.071429, ('air_539d693f7317c62d',): RollingMean: 18., ('air_546b353cbea4a45b',): RollingMean: 17.357143, ('air_5485912b44f976de',): RollingMean: 8.428571, ('air_54d6c25d33f5260e',): RollingMean: 40.5, ('air_54ed43163b7596c4',): RollingMean: 16.5, ('air_55390f784018349a',): RollingMean: 46., ('air_55c3627912b9c849',): RollingMean: 10., ('air_55e11c33d4758131',): RollingMean: 22.071429, ('air_56cd12f31a0afc04',): RollingMean: 29.785714, ('air_56cebcbd6906e04c',): RollingMean: 17.357143, ('air_56ea46c14b2dd967',): RollingMean: 42.214286, ('air_57013002b912772b',): RollingMean: 5.571429, ('air_573ecdf81b157d22',): RollingMean: 28.285714, ('air_57c9eea1a2b66e65',): RollingMean: 14.357143, ('air_57ed725a1930a5b9',): RollingMean: 15.642857, ('air_5878b6f2a9da12c1',): RollingMean: 13.357143, ('air_59cc9b2b209c6331',): RollingMean: 9.071429, ('air_5a9a6cbeeb434c08',): RollingMean: 23.071429, ('air_5acc13d655a6e8b2',): RollingMean: 24.071429, ('air_5afb1cca48ceaa19',): RollingMean: 42.142857, ('air_5b6d18c470bbfaf9',): RollingMean: 37.285714, ('air_5b704df317ed1962',): RollingMean: 2.214286, ('air_5bd22f9cc1426a90',): RollingMean: 32.357143, ('air_5c65468938c07fa5',): RollingMean: 16.214286, ('air_5c7489c9ec755e2d',): RollingMean: 33.428571, ('air_5c817ef28f236bdf',): RollingMean: 42.428571, ('air_5cb030b9f0b91537',): RollingMean: 11.071429, ('air_5cfc537125d97f16',): RollingMean: 9.571429, ('air_5d7c744c3a2ef624',): RollingMean: 32.428571, ('air_5d945ade487cdf4d',): RollingMean: 13.5, ('air_5dea8a7a5bf5eb71',): RollingMean: 28.285714, ('air_5e339a1f364cdb00',): RollingMean: 11.285714, ('air_5e34c6fe6fabd10e',): RollingMean: 20.357143, ('air_5e70fe82f9e4fab6',): RollingMean: 15.5, ('air_5e939e005bd34633',): RollingMean: 2.571429, ('air_5ed3198e4a5eed0f',): RollingMean: 38.071429, ('air_5f3a3ef4cba110a4',): RollingMean: 32.214286, ('air_5f6fa1b897fe80d5',): RollingMean: 29.785714, ('air_5fbda8e9302f7c13',): RollingMean: 27.928571, ('air_602ca92c0db34f8f',): RollingMean: 19., ('air_609050e4e4f79ae1',): RollingMean: 11.857143, ('air_60a7057184ec7ec7',): RollingMean: 27.857143, ('air_60aa54ecbc602348',): RollingMean: 5.428571, ('air_6108821ffafa9b72',): RollingMean: 24.785714, ('air_614e2f7e76dff854',): RollingMean: 11.857143, ('air_61668cc2b0778898',): RollingMean: 8.428571, ('air_61b8d37c33617f21',): RollingMean: 27.428571, ('air_61de73b097513f58',): RollingMean: 9.714286, ('air_622375b4815cf5cb',): RollingMean: 37.5, ('air_627cabe2fe53f33f',): RollingMean: 14.5, ('air_629d9935273c82ae',): RollingMean: 23.142857, ('air_629edf21ea38ac2d',): RollingMean: 35.214286, ('air_632ba66e1f75aa28',): RollingMean: 19.142857, ('air_638c35eb25e53eea',): RollingMean: 19.5, ('air_63a750d8b4b6a976',): RollingMean: 23.428571, ('air_63a88d81295195ed',): RollingMean: 29.5, ('air_63b13c56b7201bd9',): RollingMean: 22.285714, ('air_63e28ee0b0c955a7',): RollingMean: 22., ('air_640cf4835f0d9ba3',): RollingMean: 26.714286, ('air_6411203a47b5ec77',): RollingMean: 8.928571, ('air_645cb18b33f938cf',): RollingMean: 17.071429, ('air_646b93e336f0dded',): RollingMean: 7.428571, ('air_64a5d5c1381837af',): RollingMean: 40., ('air_64d4491ad8cdb1c6',): RollingMean: 13.714286, ('air_650f9b9de0c5542c',): RollingMean: 22.428571, ('air_657a0748462f85de',): RollingMean: 8., ('air_65e294f1ae6df9c3',): RollingMean: 22.214286, ('air_6607fe3671242ce3',): RollingMean: 42.571429, ('air_670a0c1c4108bcea',): RollingMean: 25., ('air_671b4bea84dafb67',): RollingMean: 26.071429, ('air_673acd9fa5e0dd78',): RollingMean: 6.214286, ('air_67483104fa38ef6c',): RollingMean: 29.571429, ('air_675aa35cba456fd1',): RollingMean: 43.642857, ('air_67f87c159d9e2ee2',): RollingMean: 36.5, ('air_68147db09287bf74',): RollingMean: 24., ('air_681b0c56328dd2af',): RollingMean: 35., ('air_681f96e6a6595f82',): RollingMean: 37.285714, ('air_68301bcb11e2f389',): RollingMean: 26.428571, ('air_683371d9baabf410',): RollingMean: 31.071429, ('air_6836438b543ba698',): RollingMean: 12.928571, ('air_6873982b9e19c7ad',): RollingMean: 5., ('air_68c1de82037d87e6',): RollingMean: 25.785714, ('air_68cc910e7b307b09',): RollingMean: 7.928571, ('air_68d075113f368946',): RollingMean: 20.285714, ('air_6902e4ec305b3d08',): RollingMean: 36.857143, ('air_694571ea13fb9e0e',): RollingMean: 30.571429, ('air_6a15e4eae523189d',): RollingMean: 17.785714, ('air_6b15edd1b4fbb96a',): RollingMean: 31.785714, ('air_6b2268863b14a2af',): RollingMean: 18.857143, ('air_6b65745d432fd77f',): RollingMean: 23.571429, ('air_6b7678aae65d2d59',): RollingMean: 6.928571, ('air_6b942d5ebbc759c2',): RollingMean: 14.714286, ('air_6b9fa44a9cf504a1',): RollingMean: 5.785714, ('air_6c1128955c58b690',): RollingMean: 13., ('air_6c91a28278a16f64',): RollingMean: 8.642857, ('air_6c952e3c6e590945',): RollingMean: 15.642857, ('air_6ca1d941c8199a67',): RollingMean: 26.071429, ('air_6cbe54f0aa30b615',): RollingMean: 15.571429, ('air_6ced51c24fb54262',): RollingMean: 7.785714, ('air_6d64dba2edd4fc0c',): RollingMean: 9.428571, ('air_6d65542aa43b598b',): RollingMean: 27.785714, ('air_6d65dd11d96e00fb',): RollingMean: 4.428571, ('air_6e06824d0934dd81',): RollingMean: 21.928571, ('air_6e3fd96320d24324',): RollingMean: 8.285714, ('air_6e64fb5821402cd2',): RollingMean: 8.357143, ('air_6ff5fca957798daa',): RollingMean: 7.857143, ('air_707d4b6328f2c2df',): RollingMean: 28.5, ('air_709262d948dd0b6e',): RollingMean: 11.071429, ('air_70e9e8cd55879414',): RollingMean: 10.928571, ('air_70f834596eb99fee',): RollingMean: 21.428571, ('air_710d6537cb7623df',): RollingMean: 32.071429, ('air_712dd258f7f91b4b',): RollingMean: 15.714286, ('air_71903025d39a4571',): RollingMean: 14.642857, ('air_722297e7f26db91d',): RollingMean: 11.071429, ('air_728ff578acc6ac6e',): RollingMean: 10.571429, ('air_72f5146cf0c49beb',): RollingMean: 12.214286, ('air_735bcbe1763d6e98',): RollingMean: 8.642857, ('air_73f316e6a18d8aa9',): RollingMean: 22.785714, ('air_7420042ff75f9aca',): RollingMean: 35., ('air_746211c0b532e8aa',): RollingMean: 53.5, ('air_747f375eb3900e1e',): RollingMean: 5.5, ('air_74cf22153214064c',): RollingMean: 10.142857, ('air_7514d90009613cd6',): RollingMean: 66.928571, ('air_754ae581ad80cc9f',): RollingMean: 13.928571, ('air_75864c80d2fb334a',): RollingMean: 10.357143, ('air_75bd5d1b6dc6670d',): RollingMean: 14.142857, ('air_764f71040a413d4d',): RollingMean: 49.428571, ('air_77488fa378cf98c3',): RollingMean: 9., ('air_77dfc83450cbc89c',): RollingMean: 41.571429, ('air_7831b00996701c0f',): RollingMean: 23.5, ('air_789103bf53b8096b',): RollingMean: 55.928571, ('air_789466e488705c93',): RollingMean: 24.928571, ('air_78df4dc6a7e83e41',): RollingMean: 17.5, ('air_79afb3f52b4d062c',): RollingMean: 10., ('air_79f528087f49df06',): RollingMean: 34.071429, ('air_7a81bd7fadcbf3d8',): RollingMean: 5., ('air_7a946aada80376a4',): RollingMean: 16., ('air_7bacc4d36fb094c9',): RollingMean: 6.142857, ('air_7bc6ca04d7b0f3b8',): RollingMean: 12.071429, ('air_7bda6048a4a78837',): RollingMean: 23.857143, ('air_7c7774c66fb237f7',): RollingMean: 8.714286, ('air_7cc17a324ae5c7dc',): RollingMean: 14.714286, ('air_7cf5a02c0e01b647',): RollingMean: 33.214286, ('air_7d65049f9d275c0d',): RollingMean: 10.857143, ('air_7dacea2f22afccfb',): RollingMean: 32.357143, ('air_7db266904cb0d72a',): RollingMean: 13., ('air_7e12c5d27f44a8de',): RollingMean: 23.785714, ('air_7ef9a5ea5c8fe39f',): RollingMean: 11.142857, ('air_7f3dc18494bce98b',): RollingMean: 14.071429, ('air_7f9e15afafcf4c75',): RollingMean: 35.428571, ('air_7fbf7649eb13ad9b',): RollingMean: 18.714286, ('air_800c02226e2e0288',): RollingMean: 13.785714, ('air_8093d0b565e9dbdf',): RollingMean: 37., ('air_8110d68cc869b85e',): RollingMean: 45.642857, ('air_81546875de9c8e78',): RollingMean: 4.642857, ('air_81a12d67c22e012f',): RollingMean: 20.285714, ('air_81bd68142db76f58',): RollingMean: 25.357143, ('air_81c2600146d07d16',): RollingMean: 6.5, ('air_81c5dff692063446',): RollingMean: 11.285714, ('air_820d1919cbecaa0a',): RollingMean: 33.357143, ('air_82a6ae14151953ba',): RollingMean: 37.357143, ('air_831658500aa7c846',): RollingMean: 29.928571, ('air_832f9dbe9ee4ebd3',): RollingMean: 13.285714, ('air_83db5aff8f50478e',): RollingMean: 7.5, ('air_84060403939d8216',): RollingMean: 15.285714, ('air_848616680ef061bd',): RollingMean: 29.857143, ('air_84f6876ff7e83ae7',): RollingMean: 19.214286, ('air_8523d6a70de49e6c',): RollingMean: 33.785714, ('air_859feab8e3c9f98d',): RollingMean: 22.571429, ('air_85bd13a49370c392',): RollingMean: 11.928571, ('air_86cfbf2624576fad',): RollingMean: 6.857143, ('air_86f7b2109e4abd65',): RollingMean: 49.428571, ('air_87059630ab6fe47f',): RollingMean: 3.714286, ('air_87078cf7903a648c',): RollingMean: 6., ('air_87467487d21891dd',): RollingMean: 13.571429, ('air_8764b3473ddcceaf',): RollingMean: 5., ('air_876d7a23c47811cb',): RollingMean: 15.928571, ('air_877f79706adbfb06',): RollingMean: 12.142857, ('air_87ca98aa7664de94',): RollingMean: 10.714286, ('air_87f9e1024b951f01',): RollingMean: 11.285714, ('air_883ca28ef0ed3d55',): RollingMean: 14.142857, ('air_88c8e34baa79217b',): RollingMean: 30.714286, ('air_88ca84051ba95339',): RollingMean: 18.642857, ('air_88f31db64991768a',): RollingMean: 8.785714, ('air_890d7e28e8eaaa11',): RollingMean: 8.071429, ('air_89e7328af22efe74',): RollingMean: 34., ('air_8a1d21fad48374e8',): RollingMean: 11.857143, ('air_8a59bb0c497b771e',): RollingMean: 27.214286, ('air_8a906e5801eac81c',): RollingMean: 23.357143, ('air_8b4a46dc521bfcfe',): RollingMean: 29.071429, ('air_8c119d1f16049f20',): RollingMean: 25.428571, ('air_8c3175aa5e4fc569',): RollingMean: 80.071429, ('air_8cc350fd70ee0757',): RollingMean: 32., ('air_8ce035ee1d8a56a6',): RollingMean: 18.357143, ('air_8d50c64692322dff',): RollingMean: 10.785714, ('air_8d61f49aa0373492',): RollingMean: 45.642857, ('air_8e429650fcf7a0ae',): RollingMean: 19.214286, ('air_8e4360a64dbd4c50',): RollingMean: 20.357143, ('air_8e492076a1179383',): RollingMean: 43.642857, ('air_8e8f42f047537154',): RollingMean: 29.357143, ('air_8ec47c0f1e2c879e',): RollingMean: 30.714286, ('air_8f13ef0f5e8c64dd',): RollingMean: 6.285714, ('air_8f273fb9ad2fed6f',): RollingMean: 13.071429, ('air_8f3b563416efc6ad',): RollingMean: 13.642857, ('air_900d755ebd2f7bbd',): RollingMean: 92.071429, ('air_901925b628677c2e',): RollingMean: 9.142857, ('air_90213bcae4afa274',): RollingMean: 27.357143, ('air_90bd5de52c166767',): RollingMean: 22.071429, ('air_90ed0a2f24755533',): RollingMean: 41.785714, ('air_90f0efbb702d77b7',): RollingMean: 32.214286, ('air_9105a29b0eb250d2',): RollingMean: 18.285714, ('air_91236b89d29567af',): RollingMean: 23.071429, ('air_9152d9926e5c4a3a',): RollingMean: 36.142857, ('air_915558a55c2bc56c',): RollingMean: 17.785714, ('air_91beafbba9382b0a',): RollingMean: 36.5, ('air_91d72e16c4bcba55',): RollingMean: 14.785714, ('air_9241121af22ff1d6',): RollingMean: 29.928571, ('air_929d8513e3cdb423',): RollingMean: 7., ('air_931a8a4321b6e7d1',): RollingMean: 5.142857, ('air_9352c401d5adb01b',): RollingMean: 25.571429, ('air_9387ff95e886ebc7',): RollingMean: 13.214286, ('air_938ef91ecdde6878',): RollingMean: 23.214286, ('air_939964477035ef0b',): RollingMean: 17.928571, ('air_93b9bb641f8fc982',): RollingMean: 28.285714, ('air_93dd7070c9bf5453',): RollingMean: 29.428571, ('air_93ebe490d4abb8e9',): RollingMean: 17.714286, ('air_9438d67241c81314',): RollingMean: 37., ('air_947eb2cae4f3e8f2',): RollingMean: 32.071429, ('air_9483d65e9cc9a6b7',): RollingMean: 15.285714, ('air_950381108f839348',): RollingMean: 28.142857, ('air_95d28905941fd4cb',): RollingMean: 30.785714, ('air_95e917913cd988f3',): RollingMean: 23.642857, ('air_96005f79124e12bf',): RollingMean: 40.428571, ('air_965b2e0cf4119003',): RollingMean: 47.357143, ('air_96743eee94114261',): RollingMean: 13.428571, ('air_96773a6236d279b1',): RollingMean: 24.785714, ('air_968d72c12eed09f0',): RollingMean: 18., ('air_96929a799b12a43e',): RollingMean: 27.214286, ('air_96ec3cfe78cb0652',): RollingMean: 18.5, ('air_97159fc4e90053fe',): RollingMean: 24., ('air_97958e7fce98b6a3',): RollingMean: 16.928571, ('air_97b2a9f975fc702c',): RollingMean: 40.142857, ('air_97cf68dc1a9beac0',): RollingMean: 13.428571, ('air_97e0f2feec4d577a',): RollingMean: 15.071429, ('air_9828505fefc77d75',): RollingMean: 12.5, ('air_98b54e32ccddd896',): RollingMean: 18.214286, ('air_990a642a3deb2903',): RollingMean: 33.5, ('air_99157b6163835eec',): RollingMean: 33.785714, ('air_99a5183695b849f9',): RollingMean: 30.928571, ('air_99b01136f451fc0e',): RollingMean: 41.428571, ('air_99c3eae84130c1cb',): RollingMean: 39.928571, ('air_9a30407764f4ff84',): RollingMean: 17., ('air_9a6f6e7f623003d2',): RollingMean: 3.142857, ('air_9aa32b3db0fab3a5',): RollingMean: 17.142857, ('air_9aa92007e3628dbc',): RollingMean: 31.642857, ('air_9ae7081cb77dc51e',): RollingMean: 29.571429, ('air_9b13c7feb0a0c431',): RollingMean: 10.714286, ('air_9b6af3db40da4ae2',): RollingMean: 29.785714, ('air_9bbc673495e23532',): RollingMean: 5.142857, ('air_9bf0ccac497c4af3',): RollingMean: 44.571429, ('air_9bf595ef095572fb',): RollingMean: 25.642857, ('air_9c6787aa03a45586',): RollingMean: 92.142857, ('air_9ca2767761efff4d',): RollingMean: 8.357143, ('air_9cd5e310f488bced',): RollingMean: 14.642857, ('air_9cf2f1ba86229773',): RollingMean: 34., ('air_9d3482b4680aee88',): RollingMean: 9.785714, ('air_9d452a881f7f2bb7',): RollingMean: 7.857143, ('air_9d474ec2448c700d',): RollingMean: 12.857143, ('air_9d5a980b211e1795',): RollingMean: 11.571429, ('air_9d93d95720f2e831',): RollingMean: 8.285714, ('air_9dc9483f717d73ee',): RollingMean: 5.571429, ('air_9dd7d38b0f1760c4',): RollingMean: 2.5, ('air_9e920b758503ef54',): RollingMean: 5.5, ('air_9efaa7ded03c5a71',): RollingMean: 12.214286, ('air_9f277fb7a2c1d842',): RollingMean: 12.142857, ('air_9fc607777ad76b26',): RollingMean: 15.928571, ('air_a083834e7ffe187e',): RollingMean: 20.285714, ('air_a11473cc1eb9a27f',): RollingMean: 33.071429, ('air_a17f0778617c76e2',): RollingMean: 38., ('air_a1fe8c588c8d2f30',): RollingMean: 15.785714, ('air_a218912784bf767d',): RollingMean: 14.357143, ('air_a21ffca0bea1661a',): RollingMean: 1.071429, ('air_a239a44805932bab',): RollingMean: 34.428571, ('air_a24bf50c3e90d583',): RollingMean: 17.285714, ('air_a2567267116a3b75',): RollingMean: 16.642857, ('air_a257c9749d8d0ff6',): RollingMean: 18.428571, ('air_a271c9ba19e81d17',): RollingMean: 28.857143, ('air_a2b29aa7feb4e36f',): RollingMean: 16.642857, ('air_a304330715435390',): RollingMean: 7.642857, ('air_a33461f4392ec62c',): RollingMean: 28.142857, ('air_a373500730e2a9e0',): RollingMean: 11., ('air_a38f25e3399d1b25',): RollingMean: 41.857143, ('air_a41b032371a63427',): RollingMean: 11.357143, ('air_a49f1cf0634f13e5',): RollingMean: 22.214286, ('air_a510dcfe979f09eb',): RollingMean: 13.714286, ('air_a546cbf478a8b6e4',): RollingMean: 27.5, ('air_a55d17bd3f3033cb',): RollingMean: 12.285714, ('air_a563896da3777078',): RollingMean: 21.571429, ('air_a678e5b144ca24ce',): RollingMean: 16.714286, ('air_a7404a854919e990',): RollingMean: 7.357143, ('air_a8533b7a992bb0ca',): RollingMean: 18.571429, ('air_a85f0c0c889f6b7e',): RollingMean: 47.571429, ('air_a85f8c0bfd61889f',): RollingMean: 15.142857, ('air_a88ac559064dec08',): RollingMean: 32.142857, ('air_a9133955abccf071',): RollingMean: 27.785714, ('air_a9178f19da58fe99',): RollingMean: 7.428571, ('air_a9a380530c1e121f',): RollingMean: 41.285714, ('air_aa0049fe3cc6f4d6',): RollingMean: 10.142857, ('air_ab3ae0e410b20069',): RollingMean: 17.928571, ('air_ab9746a0f83084b7',): RollingMean: 6.714286, ('air_abcdc8115988a010',): RollingMean: 10.857143, ('air_abf06fcca748dca5',): RollingMean: 9.5, ('air_ac7a7427c9ae12a5',): RollingMean: 62.071429, ('air_ad13e71e21235131',): RollingMean: 16.071429, ('air_ad60f6b76c9df7ed',): RollingMean: 23.357143, ('air_ad7777590c884721',): RollingMean: 8.357143, ('air_add9a575623726c8',): RollingMean: 40.285714, ('air_ade6e836ffd1da64',): RollingMean: 10.214286, ('air_aed3a8b49abe4a48',): RollingMean: 6.214286, ('air_af03c277a167b2bd',): RollingMean: 26.642857, ('air_af24e3e817dea1e5',): RollingMean: 15.357143, ('air_af63df35857b16e6',): RollingMean: 23.857143, ('air_b0a6a4c5e95c74cf',): RollingMean: 18.642857, ('air_b162fb07fbbdea33',): RollingMean: 15.285714, ('air_b192fb5310436005',): RollingMean: 8.785714, ('air_b1a72bf1ebf4b8ef',): RollingMean: 52.285714, ('air_b1bb1fae86617d7a',): RollingMean: 34.428571, ('air_b1d822f75c9fc615',): RollingMean: 10.785714, ('air_b2395df0e874078d',): RollingMean: 7.071429, ('air_b23d0f519291247d',): RollingMean: 28.785714, ('air_b259b4e4a51a690d',): RollingMean: 22.785714, ('air_b28bed4b2e7167b7',): RollingMean: 16.928571, ('air_b2a639cc7e02edf1',): RollingMean: 20.714286, ('air_b2d8bc9c88b85f96',): RollingMean: 14.714286, ('air_b2d97bd2337c5ba7',): RollingMean: 28.785714, ('air_b2dcec37b83e2494',): RollingMean: 7.428571, ('air_b30fffd7ab1e75a5',): RollingMean: 9.214286, ('air_b3180b74332ba886',): RollingMean: 13.857143, ('air_b3a824511477a4ed',): RollingMean: 6.214286, ('air_b439391e72899756',): RollingMean: 19.928571, ('air_b45b8e456f53942a',): RollingMean: 10.857143, ('air_b4f32bcc399da2b9',): RollingMean: 29.071429, ('air_b5598d12d1b84890',): RollingMean: 5.857143, ('air_b5bdd318005d9aa4',): RollingMean: 34., ('air_b60cc7d6aee68194',): RollingMean: 11.357143, ('air_b711b43ae472cb6b',): RollingMean: 20.642857, ('air_b7fa3d2fca744dd2',): RollingMean: 40.785714, ('air_b80fed1a07c817d2',): RollingMean: 4.285714, ('air_b88192b35ac03c24',): RollingMean: 17.5, ('air_b8925441167c3152',): RollingMean: 2.071429, ('air_b8a5ee69e5fdcc5b',): RollingMean: 34.142857, ('air_b8d9e1624baaadc2',): RollingMean: 6.214286, ('air_b9e27558fb8bd5c4',): RollingMean: 12.071429, ('air_ba495cccc8f0f237',): RollingMean: 17.357143, ('air_ba937bf13d40fb24',): RollingMean: 15.285714, ('air_bac5f4441db21db9',): RollingMean: 41.785714, ('air_baf28ac9f13a307d',): RollingMean: 13.571429, ('air_bb09595bab7d5cfb',): RollingMean: 29.5, ('air_bb26d6d079594414',): RollingMean: 13.285714, ('air_bb4ff06cd661ee9b',): RollingMean: 34.428571, ('air_bbe1c1a47e09f161',): RollingMean: 1.642857, ('air_bc991c51d6613745',): RollingMean: 18.571429, ('air_bc9a129e11a2efe0',): RollingMean: 30.785714, ('air_bcce1ea4350b7b72',): RollingMean: 20.857143, ('air_bd74a9222edfdfe1',): RollingMean: 14.285714, ('air_bdd32aa407c16335',): RollingMean: 13.785714, ('air_bebd55ed63ab2422',): RollingMean: 8.785714, ('air_bed603c423b7d9d4',): RollingMean: 6.142857, ('air_bedd35489e666605',): RollingMean: 38.642857, ('air_bf13014b6e3e60ca',): RollingMean: 27., ('air_bf21b8350771879b',): RollingMean: 23.857143, ('air_bf617aa68d5f1cfa',): RollingMean: 6.857143, ('air_bf7591560077332d',): RollingMean: 8.357143, ('air_bfafaed35e213fd7',): RollingMean: 12.857143, ('air_bfda7731a6c6fc61',): RollingMean: 19.071429, ('air_c027e2b560442808',): RollingMean: 15.857143, ('air_c0385db498b391e5',): RollingMean: 33.5, ('air_c1d5d165c055b866',): RollingMean: 30.071429, ('air_c1ff20617c54fee7',): RollingMean: 7.785714, ('air_c225148c0fcc5c72',): RollingMean: 34.857143, ('air_c2626f5f86d57342',): RollingMean: 15.928571, ('air_c26f027b5bc1f081',): RollingMean: 5.071429, ('air_c28983412a7eefcf',): RollingMean: 35.285714, ('air_c2c8435bdb3516d4',): RollingMean: 31.214286, ('air_c31472d14e29cee8',): RollingMean: 14.857143, ('air_c3585b0fba3998d0',): RollingMean: 9.357143, ('air_c3bc011cca3bec65',): RollingMean: 5.642857, ('air_c3dcaf3aeb18e20e',): RollingMean: 17.428571, ('air_c47aa7493b15f297',): RollingMean: 21.142857, ('air_c4fa5c562d5409ca',): RollingMean: 13.785714, ('air_c52c63c781fe48f6',): RollingMean: 27.714286, ('air_c5459218282bedd5',): RollingMean: 22.571429, ('air_c66dbd2c37832d00',): RollingMean: 16.714286, ('air_c6a164dd4060e960',): RollingMean: 12.428571, ('air_c6aa2efba0ffc8eb',): RollingMean: 28.857143, ('air_c6ffd6a93e6b68d6',): RollingMean: 17.357143, ('air_c73d319ffabf287a',): RollingMean: 15.285714, ('air_c759b6abeb552160',): RollingMean: 5.071429, ('air_c77ee2b7d36da265',): RollingMean: 42.071429, ('air_c7d30ab0e07f31d5',): RollingMean: 17.142857, ('air_c7f78b4f3cba33ff',): RollingMean: 22.785714, ('air_c8265ecc116f2284',): RollingMean: 9.142857, ('air_c88467d88b2c8ecd',): RollingMean: 18.428571, ('air_c8a657c8c5c93d69',): RollingMean: 7.928571, ('air_c8c0ef02ed72053f',): RollingMean: 26.5, ('air_c8fe396d6c46275d',): RollingMean: 14.357143, ('air_c92745dfdd2ec68a',): RollingMean: 18.428571, ('air_c9ed65554b6edffb',): RollingMean: 12.928571, ('air_c9f6de13be8b8f25',): RollingMean: 4.357143, ('air_ca1315af9e073bd1',): RollingMean: 45.285714, ('air_ca6ae8d49a2f1eaf',): RollingMean: 20.928571, ('air_ca957d3a1529fbd3',): RollingMean: 33.714286, ('air_cadf9cfb510a1d78',): RollingMean: 31.071429, ('air_caf996ac27206301',): RollingMean: 5.642857, ('air_cb083b4789a8d3a2',): RollingMean: 17.214286, ('air_cb25551c4cd8d9f3',): RollingMean: 9., ('air_cb7467aed805e7fe',): RollingMean: 36.571429, ('air_cb935ff8610ba3d3',): RollingMean: 4.857143, ('air_cbe139af83feb388',): RollingMean: 9.928571, ('air_cbe867adcf44e14f',): RollingMean: 15.5, ('air_cc1a0e985ce63711',): RollingMean: 27.785714, ('air_cc35590cd1da8554',): RollingMean: 20.857143, ('air_ccd19a5bc5573ae5',): RollingMean: 37.714286, ('air_cd4b301d5d3918d8',): RollingMean: 6.928571, ('air_cd5f54969be9ed08',): RollingMean: 7.214286, ('air_ced6297e5bdf5130',): RollingMean: 24.428571, ('air_cf2229e64408d9fe',): RollingMean: 17.857143, ('air_cf22e368c1a71d53',): RollingMean: 37.285714, ('air_cf5ab75a0afb8af9',): RollingMean: 45.214286, ('air_cfcc94797d2b5d3d',): RollingMean: 17.285714, ('air_cfdeb326418194ff',): RollingMean: 15.142857, ('air_d00161e19f08290b',): RollingMean: 26., ('air_d00a15343325e5f7',): RollingMean: 18.714286, ('air_d07e57b21109304a',): RollingMean: 10.142857, ('air_d0a1e69685259c92',): RollingMean: 29.285714, ('air_d0a7bd3339c3d12a',): RollingMean: 39.785714, ('air_d0e8a085d8dc83aa',): RollingMean: 7.571429, ('air_d138b593ebda55cc',): RollingMean: 5.714286, ('air_d1418d6fd6d634f2',): RollingMean: 16.285714, ('air_d186b2cb0b9ce022',): RollingMean: 13.357143, ('air_d1f20424f76cc78e',): RollingMean: 20.928571, ('air_d34c0861a2be94cb',): RollingMean: 42.571429, ('air_d3e7b5952cd09ccb',): RollingMean: 18.642857, ('air_d44d210d2994f01b',): RollingMean: 6.071429, ('air_d473620754bf9fc2',): RollingMean: 12.571429, ('air_d477b6339b8ce69f',): RollingMean: 8.857143, ('air_d4981cdde163b172',): RollingMean: 23.428571, ('air_d4b5a4b04c5f2d04',): RollingMean: 12.642857, ('air_d4d218b451f82c3d',): RollingMean: 9.785714, ('air_d500b48a8735fbd3',): RollingMean: 18.071429, ('air_d54d6fcb116fbed3',): RollingMean: 4.214286, ('air_d5e0a20370c325c7',): RollingMean: 29.857143, ('air_d63cfa6d6ab78446',): RollingMean: 18.428571, ('air_d69b08a175bc0387',): RollingMean: 10.857143, ('air_d6b3e67261f07646',): RollingMean: 13.714286, ('air_d8abb9e490abf94f',): RollingMean: 12., ('air_d97dabf7aae60da5',): RollingMean: 33.285714, ('air_d98380a4aeb0290b',): RollingMean: 43.357143, ('air_daa7947e1c47f5ed',): RollingMean: 34.357143, ('air_dabfbd0ec951925a',): RollingMean: 7.642857, ('air_dad0b6a36138f309',): RollingMean: 5.5, ('air_db1233ad855b34d5',): RollingMean: 24.142857, ('air_db4b38ebe7a7ceff',): RollingMean: 24.5, ('air_db80363d35f10926',): RollingMean: 28.785714, ('air_dbf64f1ce38c7442',): RollingMean: 14.928571, ('air_dc0e080ba0a5e5af',): RollingMean: 8.928571, ('air_dc71c6cc06cd1aa2',): RollingMean: 6.285714, ('air_de692863bb2dd758',): RollingMean: 20.857143, ('air_de803f7e324936b8',): RollingMean: 24.285714, ('air_de88770300008624',): RollingMean: 20., ('air_dea0655f96947922',): RollingMean: 38.571429, ('air_df507aec929ce5f6',): RollingMean: 19.071429, ('air_df554c4527a1cfe6',): RollingMean: 53.5, ('air_df5cf5cd03eb68d0',): RollingMean: 7.857143, ('air_df843e6b22e8d540',): RollingMean: 10.285714, ('air_df9355c47c5df9d3',): RollingMean: 30.285714, ('air_dfad598ff642dab7',): RollingMean: 26.071429, ('air_dfe068a1bf85f395',): RollingMean: 36.428571, ('air_e00fe7853c0100d6',): RollingMean: 20.214286, ('air_e0118664da63a2d0',): RollingMean: 16.714286, ('air_e01d99390355408d',): RollingMean: 11.571429, ('air_e053c561f32acc28',): RollingMean: 17.928571, ('air_e08b9cf82057a170',): RollingMean: 34.5, ('air_e0aee25b56a069f2',): RollingMean: 14.214286, ('air_e0e69668214ff972',): RollingMean: 9.785714, ('air_e0f241bd406810c0',): RollingMean: 33.142857, ('air_e1b76fcb5208fb6b',): RollingMean: 14.571429, ('air_e2208a79e2678432',): RollingMean: 45.142857, ('air_e270aff84ac7e4c8',): RollingMean: 25.928571, ('air_e3020992d5fe5dfd',): RollingMean: 13.5, ('air_e34c631c766f2766',): RollingMean: 24.642857, ('air_e42bdc3377d1eee7',): RollingMean: 20.785714, ('air_e483f5b3c4f310e0',): RollingMean: 5.285714, ('air_e524c6a9e06cc3a1',): RollingMean: 8.785714, ('air_e55abd740f93ecc4',): RollingMean: 46., ('air_e57dd6884595f60d',): RollingMean: 39.428571, ('air_e58f669b6f1a08ce',): RollingMean: 11.142857, ('air_e5cf003abcc5febb',): RollingMean: 12.571429, ('air_e64de0a6bf0739af',): RollingMean: 43.214286, ('air_e657ca554b0c008c',): RollingMean: 25., ('air_e700e390226d9985',): RollingMean: 15.928571, ('air_e76a668009c5dabc',): RollingMean: 7.785714, ('air_e7d2ac6d53d1b744',): RollingMean: 9.357143, ('air_e7fbee4e3cfe65c5',): RollingMean: 36., ('air_e88bbe2ede3467aa',): RollingMean: 22.857143, ('air_e89735e80d614a7e',): RollingMean: 33.785714, ('air_e8ed9335d0c38333',): RollingMean: 24.857143, ('air_e9ebf7fc520ac76a',): RollingMean: 28.428571, ('air_ea6d0c3acf00b22a',): RollingMean: 22.285714, ('air_ea7c16131980c837',): RollingMean: 7.071429, ('air_eb120e6d384a17a8',): RollingMean: 42.785714, ('air_eb20a89bba7dd3d0',): RollingMean: 3., ('air_eb2d2653586315dd',): RollingMean: 31.428571, ('air_eb5788dba285e725',): RollingMean: 27.071429, ('air_ebd31e812960f517',): RollingMean: 26.857143, ('air_ebe02c3090271fa9',): RollingMean: 11.142857, ('air_ec0fad2def4dcff0',): RollingMean: 15.142857, ('air_eca4a5a191e8d993',): RollingMean: 28.357143, ('air_eca5e0064dc9314a',): RollingMean: 34.571429, ('air_ecab54b57a71b10d',): RollingMean: 13.071429, ('air_eceb97ad6a7d4c07',): RollingMean: 27.857143, ('air_ecf7f141339f1d57',): RollingMean: 19.857143, ('air_eda179770dfa9f91',): RollingMean: 10.642857, ('air_edd5e3d696a5811b',): RollingMean: 39.357143, ('air_ee3a01f0c71a769f',): RollingMean: 25.285714, ('air_ee3ba9af184c6c82',): RollingMean: 18.642857, ('air_eec5e572b9eb9c23',): RollingMean: 11.142857, ('air_eeeadee005c006a2',): RollingMean: 12.142857, ('air_ef47430bcd6f6a89',): RollingMean: 14.857143, ('air_ef789667e2e6fe96',): RollingMean: 36.357143, ('air_ef920fa6f4b085f6',): RollingMean: 33.928571, ('air_efc80d3f96b3aff7',): RollingMean: 9.428571, ('air_efd70b04de878f25',): RollingMean: 31., ('air_efef1e3daecce07e',): RollingMean: 40.428571, ('air_f068442ebb6c246c',): RollingMean: 10.071429, ('air_f0c7272956e62f12',): RollingMean: 4.285714, ('air_f0fb0975bdc2cdf9',): RollingMean: 10.285714, ('air_f1094dbf2aef85d9',): RollingMean: 6.714286, ('air_f180301886c21375',): RollingMean: 14.428571, ('air_f183a514cb8ff4fa',): RollingMean: 42.071429, ('air_f1f9027d4fa8f653',): RollingMean: 26.5, ('air_f267dd70a6a6b5d3',): RollingMean: 44.5, ('air_f26f36ec4dc5adb0',): RollingMean: 38.785714, ('air_f2985de32bb792e0',): RollingMean: 26.285714, ('air_f2c5a1f24279c531',): RollingMean: 14.357143, ('air_f3602e4fa2f12993',): RollingMean: 11.571429, ('air_f3f9824b7d70c3cf',): RollingMean: 16.642857, ('air_f4936b91c9addbf0',): RollingMean: 16., ('air_f593fa60ac3541e2',): RollingMean: 13.642857, ('air_f690c42545146e0a',): RollingMean: 12.928571, ('air_f6b2489ccf873c3b',): RollingMean: 15.928571, ('air_f6bfd27e2e174d16',): RollingMean: 12.928571, ('air_f6cdaf7b7fdc6d78',): RollingMean: 10., ('air_f8233ad00755c35c',): RollingMean: 29.571429, ('air_f85e21e543cf44f2',): RollingMean: 4.785714, ('air_f88898cd09f40496',): RollingMean: 8.857143, ('air_f911308e19d64236',): RollingMean: 40.571429, ('air_f9168b23fdfc1e52',): RollingMean: 19.5, ('air_f927b2da69a82341',): RollingMean: 8.357143, ('air_f957c6d6467d4d90',): RollingMean: 10.642857, ('air_f96765e800907c77',): RollingMean: 43.857143, ('air_fa12b40b02fecfd8',): RollingMean: 15., ('air_fa4ffc9057812fa2',): RollingMean: 5.142857, ('air_fab092c35776a9b1',): RollingMean: 10.714286, ('air_fb44f566d4f64a4e',): RollingMean: 15.857143, ('air_fbadf737162a5ce3',): RollingMean: 14.571429, ('air_fc477473134e9ae5',): RollingMean: 16.857143, ('air_fcd4492c83f1c6b9',): RollingMean: 22.357143, ('air_fcfbdcf7b1f82c6e',): RollingMean: 35.642857, ('air_fd154088b1de6fa7',): RollingMean: 6.428571, ('air_fd6aac1043520e83',): RollingMean: 36.071429, ('air_fdc02ec4a3d21ea4',): RollingMean: 8.071429, ('air_fdcfef8bd859f650',): RollingMean: 3.642857, ('air_fe22ef5a9cbef123',): RollingMean: 21.714286, ('air_fe58c074ec1445ea',): RollingMean: 32.785714, ('air_fea5dc9594450608',): RollingMean: 15.571429, ('air_fee8dcf4d619598e',): RollingMean: 26.785714, ('air_fef9ccb3ba0da2f7',): RollingMean: 9.714286, ('air_ffcc2d5087e1b476',): RollingMean: 20., ('air_fff68b929994bfbd',): RollingMean: 4.285714}), 'by': ['store_id'], 'how': RollingMean: 0., 'on': 'y'} y_rollingmean_21_by_store_id {'_feature_name': 'y_rollingmean_21_by_store_id', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f830e2024c0>, RollingMean: 0.), {('air_00a91d42b08b08d9',): RollingMean: 29.190476, ('air_0164b9927d20bcc3',): RollingMean: 8.380952, ('air_0241aa3964b7f861',): RollingMean: 8.904762, ('air_0328696196e46f18',): RollingMean: 8.904762, ('air_034a3d5b40d5b1b1',): RollingMean: 22.52381, ('air_036d4f1ee7285390',): RollingMean: 21.238095, ('air_0382c794b73b51ad',): RollingMean: 27.380952, ('air_03963426c9312048',): RollingMean: 40.428571, ('air_04341b588bde96cd',): RollingMean: 35.333333, ('air_049f6d5b402a31b2',): RollingMean: 12.47619, ('air_04cae7c1bc9b2a0b',): RollingMean: 19.238095, ('air_0585011fa179bcce',): RollingMean: 5.333333, ('air_05c325d315cc17f5',): RollingMean: 27., ('air_0647f17b4dc041c8',): RollingMean: 30.52381, ('air_064e203265ee5753',): RollingMean: 19.47619, ('air_066f0221b8a4d533',): RollingMean: 12.428571, ('air_06f95ac5c33aca10',): RollingMean: 30.047619, ('air_0728814bd98f7367',): RollingMean: 8.095238, ('air_0768ab3910f7967f',): RollingMean: 24.952381, ('air_07b314d83059c4d2',): RollingMean: 36.380952, ('air_07bb665f9cdfbdfb',): RollingMean: 26.333333, ('air_082908692355165e',): RollingMean: 49.52381, ('air_083ddc520ea47e1e',): RollingMean: 13.238095, ('air_0845d8395f30c6bb',): RollingMean: 21.714286, ('air_084d98859256acf0',): RollingMean: 15.761905, ('air_0867f7bebad6a649',): RollingMean: 22.380952, ('air_08ba8cd01b3ba010',): RollingMean: 10.666667, ('air_08cb3c4ee6cd6a22',): RollingMean: 12.666667, ('air_08ef81d5b7a0d13f',): RollingMean: 13.952381, ('air_08f994758a1e76d4',): RollingMean: 27.714286, ('air_09040f6df960ddb8',): RollingMean: 16., ('air_0919d54f0c9a24b8',): RollingMean: 31.714286, ('air_09661c0f3259cc04',): RollingMean: 28.47619, ('air_09a845d5b5944b01',): RollingMean: 6.380952, ('air_09fd1f5c58583141',): RollingMean: 8.333333, ('air_0a74a5408a0b8642',): RollingMean: 28.095238, ('air_0b184ec04c741a6a',): RollingMean: 11.190476, ('air_0b1e72d2d4422b20',): RollingMean: 22.333333, ('air_0b9038300f8b2b50',): RollingMean: 12.380952, ('air_0e1eae99b8723bc1',): RollingMean: 11.952381, ('air_0e7c11b9abc50163',): RollingMean: 36.904762, ('air_0ead98dd07e7a82a',): RollingMean: 13.857143, ('air_0f0cdeee6c9bf3d7',): RollingMean: 25.238095, ('air_0f2f96335f274801',): RollingMean: 10., ('air_0f60e1576a7d397d',): RollingMean: 6.619048, ('air_1033310359ceeac1',): RollingMean: 18.809524, ('air_10393f12e9069760',): RollingMean: 15.714286, ('air_105a7954e32dba9b',): RollingMean: 50.857143, ('air_10713fbf3071c361',): RollingMean: 12.047619, ('air_10bbe8acd943d8f6',): RollingMean: 26.809524, ('air_12c4fb7a423df20d',): RollingMean: 20.857143, ('air_138ee734ac79ff90',): RollingMean: 8.714286, ('air_138ff410757b845f',): RollingMean: 54.285714, ('air_1408dd53f31a8a65',): RollingMean: 25.190476, ('air_142e78ba7001da9c',): RollingMean: 13.619048, ('air_1509881b22965b34',): RollingMean: 16.666667, ('air_152c1f08d7d20e07',): RollingMean: 13.238095, ('air_15ae33469e9ea2dd',): RollingMean: 11.428571, ('air_15e6e15c7ea2c162',): RollingMean: 18.952381, ('air_16179d43b6ee5fd8',): RollingMean: 8.285714, ('air_1653a6c513865af3',): RollingMean: 32.52381, ('air_168441ada3e878e1',): RollingMean: 41.47619, ('air_16c4cfddeb2cf69b',): RollingMean: 11.52381, ('air_16cf0a73233896de',): RollingMean: 10.52381, ('air_1707a3f18bb0da07',): RollingMean: 27.285714, ('air_17a6ab40f97fd4d8',): RollingMean: 6.904762, ('air_17bed6dbf7c8b0fc',): RollingMean: 19.095238, ('air_1979eaff8189d086',): RollingMean: 9.666667, ('air_1ab60ce33bfed8a8',): RollingMean: 9.714286, ('air_1ae94f514a0bce13',): RollingMean: 6.904762, ('air_1ba4e87ef7422183',): RollingMean: 37.619048, ('air_1c0b150f9e696a5f',): RollingMean: 107.238095, ('air_1c95a84924d72500',): RollingMean: 9.619048, ('air_1d1e8860ae04f8e9',): RollingMean: 12.904762, ('air_1d25ca6c76df48b4',): RollingMean: 39.666667, ('air_1d3f797dd1f7cf1c',): RollingMean: 33.428571, ('air_1dd8f6f47480d1a2',): RollingMean: 37.857143, ('air_1dea9815ccd36620',): RollingMean: 10.428571, ('air_1e23210b584540e7',): RollingMean: 4.047619, ('air_1e665503b8474c55',): RollingMean: 5.571429, ('air_1eeff462acb24fb7',): RollingMean: 16.333333, ('air_1f1390a8be2272b3',): RollingMean: 18.095238, ('air_1f34e9beded2231a',): RollingMean: 8.095238, ('air_1f7f8fa557bc0d55',): RollingMean: 3.619048, ('air_2009041dbf9264de',): RollingMean: 50.047619, ('air_20619d21192aa571',): RollingMean: 17.571429, ('air_20add8092c9bb51d',): RollingMean: 30.428571, ('air_2195cd5025a98033',): RollingMean: 28.809524, ('air_21f5052d5330528d',): RollingMean: 32.809524, ('air_220cba70c890b119',): RollingMean: 9.142857, ('air_22682e965418936f',): RollingMean: 8.857143, ('air_228f10bec0bda9c8',): RollingMean: 17.333333, ('air_229d7e508d9f1b5e',): RollingMean: 10.809524, ('air_232dcee6f7c51d37',): RollingMean: 5.571429, ('air_234d3dbf7f3d5a50',): RollingMean: 7.571429, ('air_23e1b11aee2a1407',): RollingMean: 45.571429, ('air_23ee674e91469086',): RollingMean: 21.714286, ('air_24b9b2a020826ede',): RollingMean: 31.666667, ('air_24e8414b9b07decb',): RollingMean: 5.952381, ('air_2545dd3a00f265e2',): RollingMean: 48.761905, ('air_256be208a979e023',): RollingMean: 6.47619, ('air_2570ccb93badde68',): RollingMean: 38.333333, ('air_258ad2619d7bff9a',): RollingMean: 30.666667, ('air_258dc112912fc458',): RollingMean: 61.571429, ('air_25c583983246b7b0',): RollingMean: 20.047619, ('air_25d8e5cc57dd87d9',): RollingMean: 26.190476, ('air_25e9888d30b386df',): RollingMean: 4.285714, ('air_2634e41551e9807d',): RollingMean: 13., ('air_26c5bbeb7bb82bf1',): RollingMean: 28.952381, ('air_26f10355d9b4d82a',): RollingMean: 32.52381, ('air_2703dcb33192b181',): RollingMean: 49.428571, ('air_275732a5db46f4d3',): RollingMean: 14.952381, ('air_27e991812b0d9c92',): RollingMean: 44.238095, ('air_28064154614b2e6c',): RollingMean: 21.714286, ('air_287d2de7d3c93406',): RollingMean: 13.047619, ('air_28a9fa1ec0839375',): RollingMean: 29.571429, ('air_28dbe91c4c9656be',): RollingMean: 34.619048, ('air_290e7a57b390f78e',): RollingMean: 13.714286, ('air_298513175efdf261',): RollingMean: 27.285714, ('air_2a184c1745274b2b',): RollingMean: 3.952381, ('air_2a24aec099333f39',): RollingMean: 6.666667, ('air_2a3743e37aab04b4',): RollingMean: 18.428571, ('air_2a485b92210c98b5',): RollingMean: 21.571429, ('air_2a7f14da7fe0f699',): RollingMean: 28.047619, ('air_2aab19554f91ff82',): RollingMean: 51.285714, ('air_2ac361b97630e2df',): RollingMean: 12., ('air_2b8b29ddfd35018e',): RollingMean: 11.095238, ('air_2b9bc9f5f5168ea1',): RollingMean: 20.190476, ('air_2bffb19a24d11729',): RollingMean: 11.142857, ('air_2c505f9ad67d4635',): RollingMean: 15.428571, ('air_2c6c79d597e48096',): RollingMean: 16.380952, ('air_2c6fef1ce0e13a5a',): RollingMean: 31.190476, ('air_2c989829acbd1c6b',): RollingMean: 29.333333, ('air_2cee51fa6fdf6c0d',): RollingMean: 16.619048, ('air_2d3afcb91762fe01',): RollingMean: 44.857143, ('air_2d78d9a1f4dd02ca',): RollingMean: 11.333333, ('air_2e7cb1f1a2a9cd6a',): RollingMean: 27.666667, ('air_2f8ced25216df926',): RollingMean: 13.714286, ('air_2fc149abe33adcb4',): RollingMean: 34.857143, ('air_2fc478dc9f0a6b31',): RollingMean: 11.714286, ('air_2fed81034f8834e5',): RollingMean: 20.47619, ('air_303bac187b53083a',): RollingMean: 10.047619, ('air_310e467e6e625004',): RollingMean: 15.47619, ('air_3155ee23d92202da',): RollingMean: 16.380952, ('air_31c753b48a657b6c',): RollingMean: 24.904762, ('air_32460819c7600037',): RollingMean: 50.761905, ('air_324f7c39a8410e7c',): RollingMean: 11.809524, ('air_326ca454ef3558bc',): RollingMean: 23.714286, ('air_32b02ba5dc2027f4',): RollingMean: 29.285714, ('air_32c61b620a766138',): RollingMean: 27.380952, ('air_32f5d7cd696e3c4a',): RollingMean: 22.190476, ('air_33b01025210d6007',): RollingMean: 10.285714, ('air_3440e0ea1b70a99b',): RollingMean: 27.904762, ('air_346ade7d29230634',): RollingMean: 7.761905, ('air_347be2c4feeb408b',): RollingMean: 22.047619, ('air_349278fa964bb12f',): RollingMean: 18.666667, ('air_3525f11ef0bf0c35',): RollingMean: 39.761905, ('air_35512c42db0868da',): RollingMean: 6.238095, ('air_3561fd1c0bce6a95',): RollingMean: 12.142857, ('air_35c4732dcbfe31be',): RollingMean: 6.571429, ('air_36429b5ca4407b3e',): RollingMean: 18.904762, ('air_36bcf77d3382d36e',): RollingMean: 32.285714, ('air_37189c92b6c761ec',): RollingMean: 19.47619, ('air_375a5241615b5e22',): RollingMean: 7.428571, ('air_382f5ace4e2247b8',): RollingMean: 8.761905, ('air_383f5b2f8d345a49',): RollingMean: 14.238095, ('air_38746ffe9aa20c7e',): RollingMean: 4., ('air_396166d47733d5c9',): RollingMean: 24.952381, ('air_396942e6423a2145',): RollingMean: 19.333333, ('air_397d3f32a7196aa2',): RollingMean: 31.190476, ('air_3980af67be35afdb',): RollingMean: 17.380952, ('air_3982a2c4ea2ed431',): RollingMean: 31.714286, ('air_399904bdb7685ca0',): RollingMean: 26., ('air_39dccf7df20b1c6a',): RollingMean: 24.809524, ('air_3a8a3f8fb5cd7f88',): RollingMean: 21.285714, ('air_3aa839e8e0cb6c87',): RollingMean: 27.380952, ('air_3ac24136722e2291',): RollingMean: 14., ('air_3b20733899b5287f',): RollingMean: 39.904762, ('air_3b6438b125086430',): RollingMean: 13.380952, ('air_3bb99a1fe0583897',): RollingMean: 37.904762, ('air_3bd49f98ab7f36ab',): RollingMean: 11.809524, ('air_3c05c8f26c611eb9',): RollingMean: 23.380952, ('air_3c938075889fc059',): RollingMean: 28.428571, ('air_3cad29d1a23209d2',): RollingMean: 9.142857, ('air_3caef3f76b8f26c5',): RollingMean: 25.761905, ('air_3d3a2b509180e798',): RollingMean: 17.142857, ('air_3e6cea17a9d2c0f1',): RollingMean: 17.714286, ('air_3e93f3c81008696d',): RollingMean: 34.47619, ('air_3f91d592acd6cc0b',): RollingMean: 24.666667, ('air_401b39f97e56b939',): RollingMean: 12.095238, ('air_4043b7ccfbffa732',): RollingMean: 43.428571, ('air_4092cfbd95a3ac1b',): RollingMean: 26.761905, ('air_40953e2d8b4f2857',): RollingMean: 17.47619, ('air_40f6193ea3ed1b91',): RollingMean: 15.190476, ('air_414ff459ed18fa48',): RollingMean: 16.333333, ('air_41bbf6e1d9814c4b',): RollingMean: 7.714286, ('air_421670f21da5ba31',): RollingMean: 17.52381, ('air_4254c3fc3ad078bd',): RollingMean: 10.904762, ('air_42c9aa6d617c5057',): RollingMean: 43.142857, ('air_42d41eb58cad170e',): RollingMean: 27.571429, ('air_43b65e4b05bff2d3',): RollingMean: 21.952381, ('air_43d577e0c9460e64',): RollingMean: 38.571429, ('air_4433ab8e9999915f',): RollingMean: 19.619048, ('air_4481a87c1d7c9896',): RollingMean: 22.095238, ('air_452100f5305dde64',): RollingMean: 7.571429, ('air_45326ebb8dc72cfb',): RollingMean: 30.714286, ('air_4570f52104fe0982',): RollingMean: 7.285714, ('air_4579cb0669fd411b',): RollingMean: 16.380952, ('air_457efe8c3a30ea17',): RollingMean: 7.142857, ('air_464a62de0d57be1e',): RollingMean: 25.619048, ('air_465bddfed3353b23',): RollingMean: 25.952381, ('air_47070be6093f123e',): RollingMean: 48.52381, ('air_472b19e3b5bffa41',): RollingMean: 14.47619, ('air_473cf23b9e7c0a37',): RollingMean: 8.571429, ('air_473f98b212d37b4a',): RollingMean: 27.142857, ('air_47beaffd3806c979',): RollingMean: 20.47619, ('air_483eba479dc9910d',): RollingMean: 26.095238, ('air_48e9fc98b62495a7',): RollingMean: 18.380952, ('air_48f4da6223571da4',): RollingMean: 22.190476, ('air_48ffd31594bc3263',): RollingMean: 4.857143, ('air_49211568cab5fdee',): RollingMean: 23.380952, ('air_4974785f48853db9',): RollingMean: 6.428571, ('air_4b251b9f8373f1ae',): RollingMean: 27.714286, ('air_4b380b4db9d37883',): RollingMean: 25.571429, ('air_4b55d8aea1d2b395',): RollingMean: 36.904762, ('air_4b9085d0d46a6211',): RollingMean: 29.428571, ('air_4beac252540f865e',): RollingMean: 39.714286, ('air_4c2ed28f3f19ca52',): RollingMean: 13.857143, ('air_4c665a2bfff0da3b',): RollingMean: 8.666667, ('air_4c727b55acdee495',): RollingMean: 14.809524, ('air_4cab15ad29c0ffbc',): RollingMean: 20.047619, ('air_4cab91146e3d1897',): RollingMean: 14.47619, ('air_4cca5666eaf5c709',): RollingMean: 29.714286, ('air_4ce7b17062a1bf73',): RollingMean: 9.047619, ('air_4d21676ed11f0bac',): RollingMean: 30., ('air_4d71826793c09b22',): RollingMean: 21.333333, ('air_4d90a22572fa1ec9',): RollingMean: 26.238095, ('air_4de6d887a7b1c1fc',): RollingMean: 15.52381, ('air_4dea8d17f6f59c56',): RollingMean: 23.285714, ('air_4e1c38f68f435596',): RollingMean: 35.952381, ('air_4f762e840b3996e1',): RollingMean: 11.380952, ('air_4feeb8600f131e43',): RollingMean: 57.428571, ('air_500641aca4cf673c',): RollingMean: 15.666667, ('air_506fe758114df773',): RollingMean: 27.619048, ('air_51281cd059d7b89b',): RollingMean: 12.285714, ('air_51319e7acf0438cf',): RollingMean: 12.952381, ('air_52a08ef3efdb4bb0',): RollingMean: 44.904762, ('air_52e2a1fd42bc917a',): RollingMean: 10.761905, ('air_536043fcf1a4f8a4',): RollingMean: 28.238095, ('air_539d693f7317c62d',): RollingMean: 17.285714, ('air_546b353cbea4a45b',): RollingMean: 16.52381, ('air_5485912b44f976de',): RollingMean: 8.809524, ('air_54d6c25d33f5260e',): RollingMean: 38.47619, ('air_54ed43163b7596c4',): RollingMean: 17.047619, ('air_55390f784018349a',): RollingMean: 47.285714, ('air_55c3627912b9c849',): RollingMean: 9.952381, ('air_55e11c33d4758131',): RollingMean: 22.571429, ('air_56cd12f31a0afc04',): RollingMean: 30.619048, ('air_56cebcbd6906e04c',): RollingMean: 17.857143, ('air_56ea46c14b2dd967',): RollingMean: 39.047619, ('air_57013002b912772b',): RollingMean: 4.52381, ('air_573ecdf81b157d22',): RollingMean: 28.380952, ('air_57c9eea1a2b66e65',): RollingMean: 13.904762, ('air_57ed725a1930a5b9',): RollingMean: 17., ('air_5878b6f2a9da12c1',): RollingMean: 11.809524, ('air_59cc9b2b209c6331',): RollingMean: 10.809524, ('air_5a9a6cbeeb434c08',): RollingMean: 25.142857, ('air_5acc13d655a6e8b2',): RollingMean: 25.238095, ('air_5afb1cca48ceaa19',): RollingMean: 41.333333, ('air_5b6d18c470bbfaf9',): RollingMean: 34.142857, ('air_5b704df317ed1962',): RollingMean: 2.095238, ('air_5bd22f9cc1426a90',): RollingMean: 29.095238, ('air_5c65468938c07fa5',): RollingMean: 14., ('air_5c7489c9ec755e2d',): RollingMean: 40.380952, ('air_5c817ef28f236bdf',): RollingMean: 43.238095, ('air_5cb030b9f0b91537',): RollingMean: 10.238095, ('air_5cfc537125d97f16',): RollingMean: 9.952381, ('air_5d7c744c3a2ef624',): RollingMean: 30.47619, ('air_5d945ade487cdf4d',): RollingMean: 12.714286, ('air_5dea8a7a5bf5eb71',): RollingMean: 31.047619, ('air_5e339a1f364cdb00',): RollingMean: 10.428571, ('air_5e34c6fe6fabd10e',): RollingMean: 18.809524, ('air_5e70fe82f9e4fab6',): RollingMean: 15.857143, ('air_5e939e005bd34633',): RollingMean: 3.190476, ('air_5ed3198e4a5eed0f',): RollingMean: 39.190476, ('air_5f3a3ef4cba110a4',): RollingMean: 31.47619, ('air_5f6fa1b897fe80d5',): RollingMean: 28.809524, ('air_5fbda8e9302f7c13',): RollingMean: 26.47619, ('air_602ca92c0db34f8f',): RollingMean: 21.142857, ('air_609050e4e4f79ae1',): RollingMean: 11.714286, ('air_60a7057184ec7ec7',): RollingMean: 27.761905, ('air_60aa54ecbc602348',): RollingMean: 5.095238, ('air_6108821ffafa9b72',): RollingMean: 25.809524, ('air_614e2f7e76dff854',): RollingMean: 11.285714, ('air_61668cc2b0778898',): RollingMean: 10., ('air_61b8d37c33617f21',): RollingMean: 27.52381, ('air_61de73b097513f58',): RollingMean: 10.714286, ('air_622375b4815cf5cb',): RollingMean: 35.142857, ('air_627cabe2fe53f33f',): RollingMean: 14.904762, ('air_629d9935273c82ae',): RollingMean: 21.428571, ('air_629edf21ea38ac2d',): RollingMean: 37.571429, ('air_632ba66e1f75aa28',): RollingMean: 17.857143, ('air_638c35eb25e53eea',): RollingMean: 20.619048, ('air_63a750d8b4b6a976',): RollingMean: 24.047619, ('air_63a88d81295195ed',): RollingMean: 29.809524, ('air_63b13c56b7201bd9',): RollingMean: 20., ('air_63e28ee0b0c955a7',): RollingMean: 23.571429, ('air_640cf4835f0d9ba3',): RollingMean: 24.47619, ('air_6411203a47b5ec77',): RollingMean: 10.095238, ('air_645cb18b33f938cf',): RollingMean: 16.047619, ('air_646b93e336f0dded',): RollingMean: 6.619048, ('air_64a5d5c1381837af',): RollingMean: 40.571429, ('air_64d4491ad8cdb1c6',): RollingMean: 14.047619, ('air_650f9b9de0c5542c',): RollingMean: 24., ('air_657a0748462f85de',): RollingMean: 7.952381, ('air_65e294f1ae6df9c3',): RollingMean: 23., ('air_6607fe3671242ce3',): RollingMean: 40.190476, ('air_670a0c1c4108bcea',): RollingMean: 25.285714, ('air_671b4bea84dafb67',): RollingMean: 27., ('air_673acd9fa5e0dd78',): RollingMean: 5.857143, ('air_67483104fa38ef6c',): RollingMean: 30.904762, ('air_675aa35cba456fd1',): RollingMean: 46.666667, ('air_67f87c159d9e2ee2',): RollingMean: 39.47619, ('air_68147db09287bf74',): RollingMean: 23.190476, ('air_681b0c56328dd2af',): RollingMean: 33.285714, ('air_681f96e6a6595f82',): RollingMean: 41.952381, ('air_68301bcb11e2f389',): RollingMean: 24., ('air_683371d9baabf410',): RollingMean: 32., ('air_6836438b543ba698',): RollingMean: 13.285714, ('air_6873982b9e19c7ad',): RollingMean: 5.190476, ('air_68c1de82037d87e6',): RollingMean: 23.761905, ('air_68cc910e7b307b09',): RollingMean: 7.428571, ('air_68d075113f368946',): RollingMean: 20.142857, ('air_6902e4ec305b3d08',): RollingMean: 38.761905, ('air_694571ea13fb9e0e',): RollingMean: 30.904762, ('air_6a15e4eae523189d',): RollingMean: 19.285714, ('air_6b15edd1b4fbb96a',): RollingMean: 30.238095, ('air_6b2268863b14a2af',): RollingMean: 18.238095, ('air_6b65745d432fd77f',): RollingMean: 23.571429, ('air_6b7678aae65d2d59',): RollingMean: 6.904762, ('air_6b942d5ebbc759c2',): RollingMean: 13.571429, ('air_6b9fa44a9cf504a1',): RollingMean: 6.142857, ('air_6c1128955c58b690',): RollingMean: 14.095238, ('air_6c91a28278a16f64',): RollingMean: 10.380952, ('air_6c952e3c6e590945',): RollingMean: 15.285714, ('air_6ca1d941c8199a67',): RollingMean: 26.619048, ('air_6cbe54f0aa30b615',): RollingMean: 17., ('air_6ced51c24fb54262',): RollingMean: 8.380952, ('air_6d64dba2edd4fc0c',): RollingMean: 9.857143, ('air_6d65542aa43b598b',): RollingMean: 28.095238, ('air_6d65dd11d96e00fb',): RollingMean: 5.285714, ('air_6e06824d0934dd81',): RollingMean: 21.285714, ('air_6e3fd96320d24324',): RollingMean: 9.190476, ('air_6e64fb5821402cd2',): RollingMean: 8.619048, ('air_6ff5fca957798daa',): RollingMean: 7.190476, ('air_707d4b6328f2c2df',): RollingMean: 29.571429, ('air_709262d948dd0b6e',): RollingMean: 11., ('air_70e9e8cd55879414',): RollingMean: 10.857143, ('air_70f834596eb99fee',): RollingMean: 21.333333, ('air_710d6537cb7623df',): RollingMean: 29.904762, ('air_712dd258f7f91b4b',): RollingMean: 15.142857, ('air_71903025d39a4571',): RollingMean: 14.809524, ('air_722297e7f26db91d',): RollingMean: 11.904762, ('air_728ff578acc6ac6e',): RollingMean: 9.809524, ('air_72f5146cf0c49beb',): RollingMean: 13.238095, ('air_735bcbe1763d6e98',): RollingMean: 8.047619, ('air_73f316e6a18d8aa9',): RollingMean: 23.238095, ('air_7420042ff75f9aca',): RollingMean: 35., ('air_746211c0b532e8aa',): RollingMean: 49.190476, ('air_747f375eb3900e1e',): RollingMean: 5.047619, ('air_74cf22153214064c',): RollingMean: 11.095238, ('air_7514d90009613cd6',): RollingMean: 56.857143, ('air_754ae581ad80cc9f',): RollingMean: 14.380952, ('air_75864c80d2fb334a',): RollingMean: 10.714286, ('air_75bd5d1b6dc6670d',): RollingMean: 12.952381, ('air_764f71040a413d4d',): RollingMean: 51.142857, ('air_77488fa378cf98c3',): RollingMean: 8.904762, ('air_77dfc83450cbc89c',): RollingMean: 43.857143, ('air_7831b00996701c0f',): RollingMean: 25.952381, ('air_789103bf53b8096b',): RollingMean: 58.52381, ('air_789466e488705c93',): RollingMean: 25.285714, ('air_78df4dc6a7e83e41',): RollingMean: 19.238095, ('air_79afb3f52b4d062c',): RollingMean: 9., ('air_79f528087f49df06',): RollingMean: 32.047619, ('air_7a81bd7fadcbf3d8',): RollingMean: 6.190476, ('air_7a946aada80376a4',): RollingMean: 13.952381, ('air_7bacc4d36fb094c9',): RollingMean: 6.285714, ('air_7bc6ca04d7b0f3b8',): RollingMean: 15.52381, ('air_7bda6048a4a78837',): RollingMean: 24.714286, ('air_7c7774c66fb237f7',): RollingMean: 8.714286, ('air_7cc17a324ae5c7dc',): RollingMean: 15.095238, ('air_7cf5a02c0e01b647',): RollingMean: 31.238095, ('air_7d65049f9d275c0d',): RollingMean: 9.380952, ('air_7dacea2f22afccfb',): RollingMean: 29.285714, ('air_7db266904cb0d72a',): RollingMean: 14.047619, ('air_7e12c5d27f44a8de',): RollingMean: 24.714286, ('air_7ef9a5ea5c8fe39f',): RollingMean: 10.666667, ('air_7f3dc18494bce98b',): RollingMean: 13.761905, ('air_7f9e15afafcf4c75',): RollingMean: 35.190476, ('air_7fbf7649eb13ad9b',): RollingMean: 19.333333, ('air_800c02226e2e0288',): RollingMean: 14.952381, ('air_8093d0b565e9dbdf',): RollingMean: 34.809524, ('air_8110d68cc869b85e',): RollingMean: 45.904762, ('air_81546875de9c8e78',): RollingMean: 5.428571, ('air_81a12d67c22e012f',): RollingMean: 19.285714, ('air_81bd68142db76f58',): RollingMean: 28.047619, ('air_81c2600146d07d16',): RollingMean: 8.714286, ('air_81c5dff692063446',): RollingMean: 9.380952, ('air_820d1919cbecaa0a',): RollingMean: 33.619048, ('air_82a6ae14151953ba',): RollingMean: 36.47619, ('air_831658500aa7c846',): RollingMean: 30.428571, ('air_832f9dbe9ee4ebd3',): RollingMean: 13.809524, ('air_83db5aff8f50478e',): RollingMean: 8.190476, ('air_84060403939d8216',): RollingMean: 14.809524, ('air_848616680ef061bd',): RollingMean: 32.238095, ('air_84f6876ff7e83ae7',): RollingMean: 19.380952, ('air_8523d6a70de49e6c',): RollingMean: 31.380952, ('air_859feab8e3c9f98d',): RollingMean: 22.238095, ('air_85bd13a49370c392',): RollingMean: 11.47619, ('air_86cfbf2624576fad',): RollingMean: 7.047619, ('air_86f7b2109e4abd65',): RollingMean: 53.333333, ('air_87059630ab6fe47f',): RollingMean: 4.380952, ('air_87078cf7903a648c',): RollingMean: 6.142857, ('air_87467487d21891dd',): RollingMean: 15.761905, ('air_8764b3473ddcceaf',): RollingMean: 4.333333, ('air_876d7a23c47811cb',): RollingMean: 16.142857, ('air_877f79706adbfb06',): RollingMean: 11.952381, ('air_87ca98aa7664de94',): RollingMean: 13.47619, ('air_87f9e1024b951f01',): RollingMean: 12.380952, ('air_883ca28ef0ed3d55',): RollingMean: 13.619048, ('air_88c8e34baa79217b',): RollingMean: 28.571429, ('air_88ca84051ba95339',): RollingMean: 18.238095, ('air_88f31db64991768a',): RollingMean: 9.47619, ('air_890d7e28e8eaaa11',): RollingMean: 7.333333, ('air_89e7328af22efe74',): RollingMean: 40.857143, ('air_8a1d21fad48374e8',): RollingMean: 12.380952, ('air_8a59bb0c497b771e',): RollingMean: 27.809524, ('air_8a906e5801eac81c',): RollingMean: 25.095238, ('air_8b4a46dc521bfcfe',): RollingMean: 25.714286, ('air_8c119d1f16049f20',): RollingMean: 24.095238, ('air_8c3175aa5e4fc569',): RollingMean: 60.619048, ('air_8cc350fd70ee0757',): RollingMean: 31.571429, ('air_8ce035ee1d8a56a6',): RollingMean: 19., ('air_8d50c64692322dff',): RollingMean: 10.238095, ('air_8d61f49aa0373492',): RollingMean: 45.571429, ('air_8e429650fcf7a0ae',): RollingMean: 20.047619, ('air_8e4360a64dbd4c50',): RollingMean: 20.333333, ('air_8e492076a1179383',): RollingMean: 59.285714, ('air_8e8f42f047537154',): RollingMean: 29.095238, ('air_8ec47c0f1e2c879e',): RollingMean: 30.619048, ('air_8f13ef0f5e8c64dd',): RollingMean: 6.952381, ('air_8f273fb9ad2fed6f',): RollingMean: 15.571429, ('air_8f3b563416efc6ad',): RollingMean: 12.904762, ('air_900d755ebd2f7bbd',): RollingMean: 82.2, ('air_901925b628677c2e',): RollingMean: 9.333333, ('air_90213bcae4afa274',): RollingMean: 26.761905, ('air_90bd5de52c166767',): RollingMean: 23.142857, ('air_90ed0a2f24755533',): RollingMean: 38.952381, ('air_90f0efbb702d77b7',): RollingMean: 30.047619, ('air_9105a29b0eb250d2',): RollingMean: 18.190476, ('air_91236b89d29567af',): RollingMean: 20.571429, ('air_9152d9926e5c4a3a',): RollingMean: 37.47619, ('air_915558a55c2bc56c',): RollingMean: 18.190476, ('air_91beafbba9382b0a',): RollingMean: 34.904762, ('air_91d72e16c4bcba55',): RollingMean: 15.809524, ('air_9241121af22ff1d6',): RollingMean: 31.619048, ('air_929d8513e3cdb423',): RollingMean: 7.619048, ('air_931a8a4321b6e7d1',): RollingMean: 5.714286, ('air_9352c401d5adb01b',): RollingMean: 27.904762, ('air_9387ff95e886ebc7',): RollingMean: 18.380952, ('air_938ef91ecdde6878',): RollingMean: 22.047619, ('air_939964477035ef0b',): RollingMean: 19.571429, ('air_93b9bb641f8fc982',): RollingMean: 27.047619, ('air_93dd7070c9bf5453',): RollingMean: 34.095238, ('air_93ebe490d4abb8e9',): RollingMean: 16.47619, ('air_9438d67241c81314',): RollingMean: 35.666667, ('air_947eb2cae4f3e8f2',): RollingMean: 34., ('air_9483d65e9cc9a6b7',): RollingMean: 14.47619, ('air_950381108f839348',): RollingMean: 30.095238, ('air_95d28905941fd4cb',): RollingMean: 29.47619, ('air_95e917913cd988f3',): RollingMean: 24.428571, ('air_96005f79124e12bf',): RollingMean: 41.619048, ('air_965b2e0cf4119003',): RollingMean: 53.904762, ('air_96743eee94114261',): RollingMean: 13.904762, ('air_96773a6236d279b1',): RollingMean: 25.714286, ('air_968d72c12eed09f0',): RollingMean: 19.285714, ('air_96929a799b12a43e',): RollingMean: 27.761905, ('air_96ec3cfe78cb0652',): RollingMean: 18.047619, ('air_97159fc4e90053fe',): RollingMean: 23.714286, ('air_97958e7fce98b6a3',): RollingMean: 19.095238, ('air_97b2a9f975fc702c',): RollingMean: 34.285714, ('air_97cf68dc1a9beac0',): RollingMean: 12.428571, ('air_97e0f2feec4d577a',): RollingMean: 16.142857, ('air_9828505fefc77d75',): RollingMean: 14.857143, ('air_98b54e32ccddd896',): RollingMean: 17.952381, ('air_990a642a3deb2903',): RollingMean: 34.428571, ('air_99157b6163835eec',): RollingMean: 36.285714, ('air_99a5183695b849f9',): RollingMean: 35.52381, ('air_99b01136f451fc0e',): RollingMean: 40.761905, ('air_99c3eae84130c1cb',): RollingMean: 41.095238, ('air_9a30407764f4ff84',): RollingMean: 17.428571, ('air_9a6f6e7f623003d2',): RollingMean: 3.190476, ('air_9aa32b3db0fab3a5',): RollingMean: 16.095238, ('air_9aa92007e3628dbc',): RollingMean: 31.333333, ('air_9ae7081cb77dc51e',): RollingMean: 28.714286, ('air_9b13c7feb0a0c431',): RollingMean: 10.52381, ('air_9b6af3db40da4ae2',): RollingMean: 28., ('air_9bbc673495e23532',): RollingMean: 4.571429, ('air_9bf0ccac497c4af3',): RollingMean: 43.142857, ('air_9bf595ef095572fb',): RollingMean: 25.571429, ('air_9c6787aa03a45586',): RollingMean: 97.809524, ('air_9ca2767761efff4d',): RollingMean: 10.190476, ('air_9cd5e310f488bced',): RollingMean: 13.666667, ('air_9cf2f1ba86229773',): RollingMean: 32.142857, ('air_9d3482b4680aee88',): RollingMean: 10.190476, ('air_9d452a881f7f2bb7',): RollingMean: 9.142857, ('air_9d474ec2448c700d',): RollingMean: 12.380952, ('air_9d5a980b211e1795',): RollingMean: 11.285714, ('air_9d93d95720f2e831',): RollingMean: 7.52381, ('air_9dc9483f717d73ee',): RollingMean: 5.47619, ('air_9dd7d38b0f1760c4',): RollingMean: 2.428571, ('air_9e920b758503ef54',): RollingMean: 5.571429, ('air_9efaa7ded03c5a71',): RollingMean: 10.238095, ('air_9f277fb7a2c1d842',): RollingMean: 11.571429, ('air_9fc607777ad76b26',): RollingMean: 16.761905, ('air_a083834e7ffe187e',): RollingMean: 19.904762, ('air_a11473cc1eb9a27f',): RollingMean: 35.714286, ('air_a17f0778617c76e2',): RollingMean: 37.571429, ('air_a1fe8c588c8d2f30',): RollingMean: 15., ('air_a218912784bf767d',): RollingMean: 14.809524, ('air_a21ffca0bea1661a',): RollingMean: 1.095238, ('air_a239a44805932bab',): RollingMean: 33.047619, ('air_a24bf50c3e90d583',): RollingMean: 20.142857, ('air_a2567267116a3b75',): RollingMean: 16.142857, ('air_a257c9749d8d0ff6',): RollingMean: 19., ('air_a271c9ba19e81d17',): RollingMean: 27.52381, ('air_a2b29aa7feb4e36f',): RollingMean: 16.761905, ('air_a304330715435390',): RollingMean: 7.714286, ('air_a33461f4392ec62c',): RollingMean: 28.857143, ('air_a373500730e2a9e0',): RollingMean: 10.47619, ('air_a38f25e3399d1b25',): RollingMean: 43.571429, ('air_a41b032371a63427',): RollingMean: 11.571429, ('air_a49f1cf0634f13e5',): RollingMean: 24.238095, ('air_a510dcfe979f09eb',): RollingMean: 14.571429, ('air_a546cbf478a8b6e4',): RollingMean: 28.095238, ('air_a55d17bd3f3033cb',): RollingMean: 12.952381, ('air_a563896da3777078',): RollingMean: 21.714286, ('air_a678e5b144ca24ce',): RollingMean: 15.52381, ('air_a7404a854919e990',): RollingMean: 8., ('air_a8533b7a992bb0ca',): RollingMean: 17.619048, ('air_a85f0c0c889f6b7e',): RollingMean: 42.761905, ('air_a85f8c0bfd61889f',): RollingMean: 12.952381, ('air_a88ac559064dec08',): RollingMean: 33.809524, ('air_a9133955abccf071',): RollingMean: 27.952381, ('air_a9178f19da58fe99',): RollingMean: 6.857143, ('air_a9a380530c1e121f',): RollingMean: 40.52381, ('air_aa0049fe3cc6f4d6',): RollingMean: 9.380952, ('air_ab3ae0e410b20069',): RollingMean: 16.52381, ('air_ab9746a0f83084b7',): RollingMean: 8.857143, ('air_abcdc8115988a010',): RollingMean: 11.809524, ('air_abf06fcca748dca5',): RollingMean: 8.428571, ('air_ac7a7427c9ae12a5',): RollingMean: 59.095238, ('air_ad13e71e21235131',): RollingMean: 19.666667, ('air_ad60f6b76c9df7ed',): RollingMean: 22.809524, ('air_ad7777590c884721',): RollingMean: 8.142857, ('air_add9a575623726c8',): RollingMean: 41.714286, ('air_ade6e836ffd1da64',): RollingMean: 8.857143, ('air_aed3a8b49abe4a48',): RollingMean: 5.857143, ('air_af03c277a167b2bd',): RollingMean: 25.904762, ('air_af24e3e817dea1e5',): RollingMean: 15.095238, ('air_af63df35857b16e6',): RollingMean: 23.142857, ('air_b0a6a4c5e95c74cf',): RollingMean: 17.190476, ('air_b162fb07fbbdea33',): RollingMean: 14.809524, ('air_b192fb5310436005',): RollingMean: 7.666667, ('air_b1a72bf1ebf4b8ef',): RollingMean: 65.095238, ('air_b1bb1fae86617d7a',): RollingMean: 35.333333, ('air_b1d822f75c9fc615',): RollingMean: 10.142857, ('air_b2395df0e874078d',): RollingMean: 6.47619, ('air_b23d0f519291247d',): RollingMean: 26.428571, ('air_b259b4e4a51a690d',): RollingMean: 21.047619, ('air_b28bed4b2e7167b7',): RollingMean: 16., ('air_b2a639cc7e02edf1',): RollingMean: 19.47619, ('air_b2d8bc9c88b85f96',): RollingMean: 16.666667, ('air_b2d97bd2337c5ba7',): RollingMean: 31.952381, ('air_b2dcec37b83e2494',): RollingMean: 7.904762, ('air_b30fffd7ab1e75a5',): RollingMean: 10.047619, ('air_b3180b74332ba886',): RollingMean: 11.52381, ('air_b3a824511477a4ed',): RollingMean: 6.380952, ('air_b439391e72899756',): RollingMean: 19.190476, ('air_b45b8e456f53942a',): RollingMean: 11., ('air_b4f32bcc399da2b9',): RollingMean: 29.190476, ('air_b5598d12d1b84890',): RollingMean: 5.380952, ('air_b5bdd318005d9aa4',): RollingMean: 36.809524, ('air_b60cc7d6aee68194',): RollingMean: 11.52381, ('air_b711b43ae472cb6b',): RollingMean: 19.809524, ('air_b7fa3d2fca744dd2',): RollingMean: 41.333333, ('air_b80fed1a07c817d2',): RollingMean: 4.666667, ('air_b88192b35ac03c24',): RollingMean: 15.666667, ('air_b8925441167c3152',): RollingMean: 2.047619, ('air_b8a5ee69e5fdcc5b',): RollingMean: 38., ('air_b8d9e1624baaadc2',): RollingMean: 5.952381, ('air_b9e27558fb8bd5c4',): RollingMean: 12.47619, ('air_ba495cccc8f0f237',): RollingMean: 15.904762, ('air_ba937bf13d40fb24',): RollingMean: 17.285714, ('air_bac5f4441db21db9',): RollingMean: 40.761905, ('air_baf28ac9f13a307d',): RollingMean: 15.619048, ('air_bb09595bab7d5cfb',): RollingMean: 27.809524, ('air_bb26d6d079594414',): RollingMean: 11.571429, ('air_bb4ff06cd661ee9b',): RollingMean: 34.428571, ('air_bbe1c1a47e09f161',): RollingMean: 1.52381, ('air_bc991c51d6613745',): RollingMean: 20.095238, ('air_bc9a129e11a2efe0',): RollingMean: 31.666667, ('air_bcce1ea4350b7b72',): RollingMean: 18.52381, ('air_bd74a9222edfdfe1',): RollingMean: 12.904762, ('air_bdd32aa407c16335',): RollingMean: 16.428571, ('air_bebd55ed63ab2422',): RollingMean: 8.571429, ('air_bed603c423b7d9d4',): RollingMean: 5.428571, ('air_bedd35489e666605',): RollingMean: 39.714286, ('air_bf13014b6e3e60ca',): RollingMean: 32.952381, ('air_bf21b8350771879b',): RollingMean: 26.809524, ('air_bf617aa68d5f1cfa',): RollingMean: 6.809524, ('air_bf7591560077332d',): RollingMean: 8.904762, ('air_bfafaed35e213fd7',): RollingMean: 11.952381, ('air_bfda7731a6c6fc61',): RollingMean: 19.428571, ('air_c027e2b560442808',): RollingMean: 15., ('air_c0385db498b391e5',): RollingMean: 31.904762, ('air_c1d5d165c055b866',): RollingMean: 30., ('air_c1ff20617c54fee7',): RollingMean: 7.809524, ('air_c225148c0fcc5c72',): RollingMean: 36.52381, ('air_c2626f5f86d57342',): RollingMean: 16.904762, ('air_c26f027b5bc1f081',): RollingMean: 5.142857, ('air_c28983412a7eefcf',): RollingMean: 38.809524, ('air_c2c8435bdb3516d4',): RollingMean: 30.619048, ('air_c31472d14e29cee8',): RollingMean: 13.142857, ('air_c3585b0fba3998d0',): RollingMean: 8.904762, ('air_c3bc011cca3bec65',): RollingMean: 7.666667, ('air_c3dcaf3aeb18e20e',): RollingMean: 17., ('air_c47aa7493b15f297',): RollingMean: 20.571429, ('air_c4fa5c562d5409ca',): RollingMean: 13.52381, ('air_c52c63c781fe48f6',): RollingMean: 27.761905, ('air_c5459218282bedd5',): RollingMean: 23.809524, ('air_c66dbd2c37832d00',): RollingMean: 17.285714, ('air_c6a164dd4060e960',): RollingMean: 12.952381, ('air_c6aa2efba0ffc8eb',): RollingMean: 29.571429, ('air_c6ffd6a93e6b68d6',): RollingMean: 15.571429, ('air_c73d319ffabf287a',): RollingMean: 16.095238, ('air_c759b6abeb552160',): RollingMean: 9.095238, ('air_c77ee2b7d36da265',): RollingMean: 42.095238, ('air_c7d30ab0e07f31d5',): RollingMean: 16.095238, ('air_c7f78b4f3cba33ff',): RollingMean: 23.952381, ('air_c8265ecc116f2284',): RollingMean: 8.428571, ('air_c88467d88b2c8ecd',): RollingMean: 19.952381, ('air_c8a657c8c5c93d69',): RollingMean: 7.142857, ('air_c8c0ef02ed72053f',): RollingMean: 27.190476, ('air_c8fe396d6c46275d',): RollingMean: 16.142857, ('air_c92745dfdd2ec68a',): RollingMean: 18.52381, ('air_c9ed65554b6edffb',): RollingMean: 11.809524, ('air_c9f6de13be8b8f25',): RollingMean: 3.809524, ('air_ca1315af9e073bd1',): RollingMean: 42.380952, ('air_ca6ae8d49a2f1eaf',): RollingMean: 21.380952, ('air_ca957d3a1529fbd3',): RollingMean: 33.619048, ('air_cadf9cfb510a1d78',): RollingMean: 32.666667, ('air_caf996ac27206301',): RollingMean: 4.52381, ('air_cb083b4789a8d3a2',): RollingMean: 17.52381, ('air_cb25551c4cd8d9f3',): RollingMean: 9.428571, ('air_cb7467aed805e7fe',): RollingMean: 36.095238, ('air_cb935ff8610ba3d3',): RollingMean: 5.952381, ('air_cbe139af83feb388',): RollingMean: 10.428571, ('air_cbe867adcf44e14f',): RollingMean: 15.380952, ('air_cc1a0e985ce63711',): RollingMean: 30., ('air_cc35590cd1da8554',): RollingMean: 18.190476, ('air_ccd19a5bc5573ae5',): RollingMean: 35.904762, ('air_cd4b301d5d3918d8',): RollingMean: 6.47619, ('air_cd5f54969be9ed08',): RollingMean: 7.142857, ('air_ced6297e5bdf5130',): RollingMean: 25.809524, ('air_cf2229e64408d9fe',): RollingMean: 16.571429, ('air_cf22e368c1a71d53',): RollingMean: 36.428571, ('air_cf5ab75a0afb8af9',): RollingMean: 45.190476, ('air_cfcc94797d2b5d3d',): RollingMean: 17.333333, ('air_cfdeb326418194ff',): RollingMean: 14.761905, ('air_d00161e19f08290b',): RollingMean: 26.666667, ('air_d00a15343325e5f7',): RollingMean: 17.571429, ('air_d07e57b21109304a',): RollingMean: 11.142857, ('air_d0a1e69685259c92',): RollingMean: 33.190476, ('air_d0a7bd3339c3d12a',): RollingMean: 36.714286, ('air_d0e8a085d8dc83aa',): RollingMean: 7.952381, ('air_d138b593ebda55cc',): RollingMean: 5.380952, ('air_d1418d6fd6d634f2',): RollingMean: 15.714286, ('air_d186b2cb0b9ce022',): RollingMean: 13.380952, ('air_d1f20424f76cc78e',): RollingMean: 19.333333, ('air_d34c0861a2be94cb',): RollingMean: 43.142857, ('air_d3e7b5952cd09ccb',): RollingMean: 19.714286, ('air_d44d210d2994f01b',): RollingMean: 5.714286, ('air_d473620754bf9fc2',): RollingMean: 12.904762, ('air_d477b6339b8ce69f',): RollingMean: 8.047619, ('air_d4981cdde163b172',): RollingMean: 24.714286, ('air_d4b5a4b04c5f2d04',): RollingMean: 12.619048, ('air_d4d218b451f82c3d',): RollingMean: 9.904762, ('air_d500b48a8735fbd3',): RollingMean: 17.47619, ('air_d54d6fcb116fbed3',): RollingMean: 4.428571, ('air_d5e0a20370c325c7',): RollingMean: 29.190476, ('air_d63cfa6d6ab78446',): RollingMean: 18.238095, ('air_d69b08a175bc0387',): RollingMean: 10.809524, ('air_d6b3e67261f07646',): RollingMean: 14.666667, ('air_d8abb9e490abf94f',): RollingMean: 12.380952, ('air_d97dabf7aae60da5',): RollingMean: 33.190476, ('air_d98380a4aeb0290b',): RollingMean: 42.761905, ('air_daa7947e1c47f5ed',): RollingMean: 34., ('air_dabfbd0ec951925a',): RollingMean: 7.142857, ('air_dad0b6a36138f309',): RollingMean: 5.571429, ('air_db1233ad855b34d5',): RollingMean: 25.52381, ('air_db4b38ebe7a7ceff',): RollingMean: 23.714286, ('air_db80363d35f10926',): RollingMean: 28.714286, ('air_dbf64f1ce38c7442',): RollingMean: 15.47619, ('air_dc0e080ba0a5e5af',): RollingMean: 9.047619, ('air_dc71c6cc06cd1aa2',): RollingMean: 6.190476, ('air_de692863bb2dd758',): RollingMean: 21.238095, ('air_de803f7e324936b8',): RollingMean: 25.619048, ('air_de88770300008624',): RollingMean: 17.428571, ('air_dea0655f96947922',): RollingMean: 35.809524, ('air_df507aec929ce5f6',): RollingMean: 23.285714, ('air_df554c4527a1cfe6',): RollingMean: 52.952381, ('air_df5cf5cd03eb68d0',): RollingMean: 7.380952, ('air_df843e6b22e8d540',): RollingMean: 11.952381, ('air_df9355c47c5df9d3',): RollingMean: 27.52381, ('air_dfad598ff642dab7',): RollingMean: 25.952381, ('air_dfe068a1bf85f395',): RollingMean: 37.857143, ('air_e00fe7853c0100d6',): RollingMean: 20.904762, ('air_e0118664da63a2d0',): RollingMean: 16.333333, ('air_e01d99390355408d',): RollingMean: 11.333333, ('air_e053c561f32acc28',): RollingMean: 19.666667, ('air_e08b9cf82057a170',): RollingMean: 33.333333, ('air_e0aee25b56a069f2',): RollingMean: 14.428571, ('air_e0e69668214ff972',): RollingMean: 9.904762, ('air_e0f241bd406810c0',): RollingMean: 32.285714, ('air_e1b76fcb5208fb6b',): RollingMean: 13.52381, ('air_e2208a79e2678432',): RollingMean: 47.714286, ('air_e270aff84ac7e4c8',): RollingMean: 24.571429, ('air_e3020992d5fe5dfd',): RollingMean: 12.190476, ('air_e34c631c766f2766',): RollingMean: 24.47619, ('air_e42bdc3377d1eee7',): RollingMean: 21.190476, ('air_e483f5b3c4f310e0',): RollingMean: 5.380952, ('air_e524c6a9e06cc3a1',): RollingMean: 8.238095, ('air_e55abd740f93ecc4',): RollingMean: 45.666667, ('air_e57dd6884595f60d',): RollingMean: 38.571429, ('air_e58f669b6f1a08ce',): RollingMean: 10.761905, ('air_e5cf003abcc5febb',): RollingMean: 11.428571, ('air_e64de0a6bf0739af',): RollingMean: 45.809524, ('air_e657ca554b0c008c',): RollingMean: 22.571429, ('air_e700e390226d9985',): RollingMean: 16.619048, ('air_e76a668009c5dabc',): RollingMean: 7.952381, ('air_e7d2ac6d53d1b744',): RollingMean: 9.952381, ('air_e7fbee4e3cfe65c5',): RollingMean: 33.095238, ('air_e88bbe2ede3467aa',): RollingMean: 24.380952, ('air_e89735e80d614a7e',): RollingMean: 32.428571, ('air_e8ed9335d0c38333',): RollingMean: 26.52381, ('air_e9ebf7fc520ac76a',): RollingMean: 28.904762, ('air_ea6d0c3acf00b22a',): RollingMean: 21.714286, ('air_ea7c16131980c837',): RollingMean: 7.190476, ('air_eb120e6d384a17a8',): RollingMean: 42.809524, ('air_eb20a89bba7dd3d0',): RollingMean: 2.952381, ('air_eb2d2653586315dd',): RollingMean: 32.380952, ('air_eb5788dba285e725',): RollingMean: 23.52381, ('air_ebd31e812960f517',): RollingMean: 26.47619, ('air_ebe02c3090271fa9',): RollingMean: 11.333333, ('air_ec0fad2def4dcff0',): RollingMean: 15.904762, ('air_eca4a5a191e8d993',): RollingMean: 25.714286, ('air_eca5e0064dc9314a',): RollingMean: 34.571429, ('air_ecab54b57a71b10d',): RollingMean: 13.285714, ('air_eceb97ad6a7d4c07',): RollingMean: 26.571429, ('air_ecf7f141339f1d57',): RollingMean: 18.428571, ('air_eda179770dfa9f91',): RollingMean: 9.428571, ('air_edd5e3d696a5811b',): RollingMean: 42.761905, ('air_ee3a01f0c71a769f',): RollingMean: 26.761905, ('air_ee3ba9af184c6c82',): RollingMean: 16.904762, ('air_eec5e572b9eb9c23',): RollingMean: 14.52381, ('air_eeeadee005c006a2',): RollingMean: 11.952381, ('air_ef47430bcd6f6a89',): RollingMean: 13.809524, ('air_ef789667e2e6fe96',): RollingMean: 33.190476, ('air_ef920fa6f4b085f6',): RollingMean: 37.857143, ('air_efc80d3f96b3aff7',): RollingMean: 9.190476, ('air_efd70b04de878f25',): RollingMean: 31.428571, ('air_efef1e3daecce07e',): RollingMean: 40.666667, ('air_f068442ebb6c246c',): RollingMean: 11.47619, ('air_f0c7272956e62f12',): RollingMean: 3.714286, ('air_f0fb0975bdc2cdf9',): RollingMean: 11.285714, ('air_f1094dbf2aef85d9',): RollingMean: 6.142857, ('air_f180301886c21375',): RollingMean: 14.142857, ('air_f183a514cb8ff4fa',): RollingMean: 43.238095, ('air_f1f9027d4fa8f653',): RollingMean: 28.714286, ('air_f267dd70a6a6b5d3',): RollingMean: 57.714286, ('air_f26f36ec4dc5adb0',): RollingMean: 38.809524, ('air_f2985de32bb792e0',): RollingMean: 31.47619, ('air_f2c5a1f24279c531',): RollingMean: 15.428571, ('air_f3602e4fa2f12993',): RollingMean: 12.52381, ('air_f3f9824b7d70c3cf',): RollingMean: 15.809524, ('air_f4936b91c9addbf0',): RollingMean: 15.666667, ('air_f593fa60ac3541e2',): RollingMean: 12.285714, ('air_f690c42545146e0a',): RollingMean: 12.142857, ('air_f6b2489ccf873c3b',): RollingMean: 15.857143, ('air_f6bfd27e2e174d16',): RollingMean: 12.714286, ('air_f6cdaf7b7fdc6d78',): RollingMean: 8.714286, ('air_f8233ad00755c35c',): RollingMean: 30.333333, ('air_f85e21e543cf44f2',): RollingMean: 5.666667, ('air_f88898cd09f40496',): RollingMean: 7.952381, ('air_f911308e19d64236',): RollingMean: 43.666667, ('air_f9168b23fdfc1e52',): RollingMean: 17.47619, ('air_f927b2da69a82341',): RollingMean: 10.47619, ('air_f957c6d6467d4d90',): RollingMean: 10.47619, ('air_f96765e800907c77',): RollingMean: 45.190476, ('air_fa12b40b02fecfd8',): RollingMean: 15.52381, ('air_fa4ffc9057812fa2',): RollingMean: 4.904762, ('air_fab092c35776a9b1',): RollingMean: 10.809524, ('air_fb44f566d4f64a4e',): RollingMean: 15.809524, ('air_fbadf737162a5ce3',): RollingMean: 15.047619, ('air_fc477473134e9ae5',): RollingMean: 13.333333, ('air_fcd4492c83f1c6b9',): RollingMean: 21.714286, ('air_fcfbdcf7b1f82c6e',): RollingMean: 37.47619, ('air_fd154088b1de6fa7',): RollingMean: 6.52381, ('air_fd6aac1043520e83',): RollingMean: 33.380952, ('air_fdc02ec4a3d21ea4',): RollingMean: 7.619048, ('air_fdcfef8bd859f650',): RollingMean: 3.52381, ('air_fe22ef5a9cbef123',): RollingMean: 23.142857, ('air_fe58c074ec1445ea',): RollingMean: 31.285714, ('air_fea5dc9594450608',): RollingMean: 15.428571, ('air_fee8dcf4d619598e',): RollingMean: 26.190476, ('air_fef9ccb3ba0da2f7',): RollingMean: 8.857143, ('air_ffcc2d5087e1b476',): RollingMean: 19.952381, ('air_fff68b929994bfbd',): RollingMean: 4.428571}), 'by': ['store_id'], 'how': RollingMean: 0., 'on': 'y'} ~['area_name', 'date', 'genre_name', 'latitude', 'longitude', 'store_id'] {'keys': {'area_name', 'date', 'genre_name', 'latitude', 'longitude', 'store_id'}} StandardScaler {'counts': Counter({'y_rollingmean_21_by_store_id': 252108, 'y_rollingmean_14_by_store_id': 252108, 'y_rollingmean_7_by_store_id': 252108, 'weekday': 252108, 'is_weekend': 252108}), 'means': defaultdict(<class 'float'>, {'is_weekend': 0.27469576530693085, 'weekday': 3.0196780744759444, 'y_rollingmean_14_by_store_id': 20.897453818387582, 'y_rollingmean_21_by_store_id': 20.901790561001423, 'y_rollingmean_7_by_store_id': 20.895968753375726}), 'vars': defaultdict(<class 'float'>, {'is_weekend': 0.1992380018293697, 'weekday': 3.7017047339732057, 'y_rollingmean_14_by_store_id': 139.4838567930601, 'y_rollingmean_21_by_store_id': 135.6375578980582, 'y_rollingmean_7_by_store_id': 148.74195644058028}), 'with_std': True} LinearRegression {'_weights': {'y_rollingmean_21_by_store_id': 8.267976730511927, 'y_rollingmean_14_by_store_id': 3.68602087744672, 'y_rollingmean_7_by_store_id': -0.7363408297986024, 'weekday': 6.318523886308725, 'is_weekend': -2.378332613642489}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 19.93106280511352, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 252108})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; }","title":"The art of using pipelines"},{"location":"examples/the-art-of-using-pipelines/#the-art-of-using-pipelines","text":"Pipelines are a natural way to think about a machine learning system. Indeed with some practice a data scientist can visualise data \"flowing\" through a series of steps. The input is typically some raw data which has to be processed in some manner. The goal is to represent the data in such a way that is can be ingested by a machine learning algorithm. Along the way some steps will extract features, while others will normalize the data and remove undesirable elements. Pipelines are simple, and yet they are a powerful way of designing sophisticated machine learning systems. Both scikit-learn and pandas make it possible to use pipelines. However it's quite rare to see pipelines being used in practice (at least on Kaggle). Sometimes you get to see people using scikit-learn's pipeline module, however the pipe method from pandas is sadly underappreciated. A big reason why pipelines are not given much love is that it's easier to think of batch learning in terms of a script or a notebook. Indeed many people doing data science seem to prefer a procedural style to a declarative style. Moreover in practice pipelines can be a bit rigid if one wishes to do non-orthodox operations. Although pipelines may be a bit of an odd fit for batch learning, they make complete sense when they are used for online learning. Indeed the UNIX philosophy has advocated the use of pipelines for data processing for many decades. If you can visualise data as a stream of observations then using pipelines should make a lot of sense to you. We'll attempt to convince you by writing a machine learning algorithm in a procedural way and then converting it to a declarative pipeline in small steps. Hopefully by the end you'll be convinced, or not! In this notebook we'll manipulate data from the Kaggle Recruit Restaurants Visitor Forecasting competition . The data is directly available through river 's datasets module. from pprint import pprint from river import datasets for x , y in datasets . Restaurants (): pprint ( x ) pprint ( y ) break Downloading https://maxhalford.github.io/files/datasets/kaggle_recruit_restaurants.zip (4.28 MB) Uncompressing into /Users/max.halford/river_data/Restaurants {'area_name': 'T\u014dky\u014d-to Nerima-ku Toyotamakita', 'date': datetime.datetime(2016, 1, 1, 0, 0), 'genre_name': 'Izakaya', 'is_holiday': True, 'latitude': 35.7356234, 'longitude': 139.6516577, 'store_id': 'air_04341b588bde96cd'} 10 We'll start by building and running a model using a procedural coding style. The performance of the model doesn't matter, we're simply interested in the design of the model. from river import feature_extraction from river import linear_model from river import metrics from river import preprocessing from river import stats means = ( feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) scaler = preprocessing . StandardScaler () lin_reg = linear_model . LinearRegression () metric = metrics . MAE () for x , y in datasets . Restaurants (): # Derive date features x [ 'weekday' ] = x [ 'date' ] . weekday () x [ 'is_weekend' ] = x [ 'date' ] . weekday () in ( 5 , 6 ) # Process the rolling means of the target for mean in means : x = { ** x , ** mean . transform_one ( x )} mean . learn_one ( x , y ) # Remove the key/value pairs that aren't features for key in [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ]: x . pop ( key ) # Rescale the data x = scaler . learn_one ( x ) . transform_one ( x ) # Fit the linear regression y_pred = lin_reg . predict_one ( x ) lin_reg . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.465114 We're not using many features. We can print the last x to get an idea of the features (don't forget they've been scaled!) pprint ( x ) {'is_holiday': -0.23103573677646685, 'is_weekend': 1.6249280076334165, 'weekday': 1.0292832579142892, 'y_rollingmean_14_by_store_id': -1.4125913815779154, 'y_rollingmean_21_by_store_id': -1.3980979075298519, 'y_rollingmean_7_by_store_id': -1.3502314499809096} The above chunk of code is quite explicit but it's a bit verbose. The whole point of libraries such as river is to make life easier for users. Moreover there's too much space for users to mess up the order in which things are done, which increases the chance of there being target leakage. We'll now rewrite our model in a declarative fashion using a pipeline \u00e0 la sklearn . from river import compose def get_date_features ( x ): weekday = x [ 'date' ] . weekday () return { 'weekday' : weekday , 'is_weekend' : weekday in ( 5 , 6 )} model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) metric = metrics . MAE () for x , y in datasets . Restaurants (): # Make a prediction without using the target y_pred = model . predict_one ( x ) # Update the model using the target model . learn_one ( x , y ) # Update the metric using the out-of-fold prediction metric . update ( y , y_pred ) print ( metric ) MAE: 8.38533 We use a Pipeline to arrange each step in a sequential order. A TransformerUnion is used to merge multiple feature extractors into a single transformer. The for loop is now much shorter and is thus easier to grok: we get the out-of-fold prediction, we fit the model, and finally we update the metric. This way of evaluating a model is typical of online learning, and so we put it wrapped it inside a function called progressive_val_score part of the evaluate module. We can use it to replace the for loop. from river import evaluate model = compose . Pipeline ( ( 'features' , compose . TransformerUnion ( ( 'date_features' , compose . FuncTransformer ( get_date_features )), ( 'last_7_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 ))), ( 'last_14_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 ))), ( 'last_21_mean' , feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 ))) )), ( 'drop_non_features' , compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' )), ( 'scale' , preprocessing . StandardScaler ()), ( 'lin_reg' , linear_model . LinearRegression ()) ) evaluate . progressive_val_score ( dataset = datasets . Restaurants (), model = model , metric = metrics . MAE ()) MAE: 8.38533 Notice that you couldn't have used the progressive_val_score method if you wrote the model in a procedural manner. Our code is getting shorter, but it's still a bit difficult on the eyes. Indeed there is a lot of boilerplate code associated with pipelines that can get tedious to write. However river has some special tricks up it's sleeve to save you from a lot of pain. The first trick is that the name of each step in the pipeline can be omitted. If no name is given for a step then river automatically infers one. model = compose . Pipeline ( compose . TransformerUnion ( compose . FuncTransformer ( get_date_features ), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )), feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Under the hood a Pipeline inherits from collections.OrderedDict . Indeed this makes sense because if you think about it a Pipeline is simply a sequence of steps where each step has a name. The reason we mention this is because it means you can manipulate a Pipeline the same way you would manipulate an ordinary dict . For instance we can print the name of each step by using the keys method. for name in model . steps : print ( name ) TransformerUnion Discard StandardScaler LinearRegression The first step is a FeatureUnion and it's string representation contains the string representation of each of it's elements. Not having to write names saves up some time and space and is certainly less tedious. The next trick is that we can use mathematical operators to compose our pipeline. For example we can use the + operator to merge Transformer s into a TransformerUnion . model = compose . Pipeline ( compose . FuncTransformer ( get_date_features ) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + \\ feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )), compose . Discard ( 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ), preprocessing . StandardScaler (), linear_model . LinearRegression () ) evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Likewhise we can use the | operator to assemble steps into a Pipeline . model = ( compose . FuncTransformer ( get_date_features ) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 7 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 14 )) + feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( 21 )) ) to_discard = [ 'store_id' , 'date' , 'genre_name' , 'area_name' , 'latitude' , 'longitude' ] model = model | compose . Discard ( * to_discard ) | preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Hopefully you'll agree that this is a powerful way to express machine learning pipelines. For some people this should be quite remeniscent of the UNIX pipe operator. One final trick we want to mention is that functions are automatically wrapped with a FuncTransformer , which can be quite handy. model = get_date_features for n in [ 7 , 14 , 21 ]: model += feature_extraction . TargetAgg ( by = 'store_id' , how = stats . RollingMean ( n )) model |= compose . Discard ( * to_discard ) model |= preprocessing . StandardScaler () model |= linear_model . LinearRegression () evaluate . progressive_val_score ( datasets . Restaurants (), model , metrics . MAE ()) MAE: 8.38533 Naturally some may prefer the procedural style we first used because they find it easier to work with. It all depends on your style and you should use what you feel comfortable with. However we encourage you to use operators because we believe that this will increase the readability of your code, which is very important. To each their own! Before finishing we can take an interactive look at our pipeline. model get_date_features def get_date_features(x): weekday = x['date'].weekday() return {'weekday': weekday, 'is_weekend': weekday in (5, 6)} y_rollingmean_7_by_store_id {'_feature_name': 'y_rollingmean_7_by_store_id', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f830e2024c0>, RollingMean: 0.), {('air_00a91d42b08b08d9',): RollingMean: 31.571429, ('air_0164b9927d20bcc3',): RollingMean: 6.428571, ('air_0241aa3964b7f861',): RollingMean: 11.428571, ('air_0328696196e46f18',): RollingMean: 10., ('air_034a3d5b40d5b1b1',): RollingMean: 28.428571, ('air_036d4f1ee7285390',): RollingMean: 27.142857, ('air_0382c794b73b51ad',): RollingMean: 29.142857, ('air_03963426c9312048',): RollingMean: 45.714286, ('air_04341b588bde96cd',): RollingMean: 32.857143, ('air_049f6d5b402a31b2',): RollingMean: 16.571429, ('air_04cae7c1bc9b2a0b',): RollingMean: 18.571429, ('air_0585011fa179bcce',): RollingMean: 5.571429, ('air_05c325d315cc17f5',): RollingMean: 29.714286, ('air_0647f17b4dc041c8',): RollingMean: 29.714286, ('air_064e203265ee5753',): RollingMean: 19.142857, ('air_066f0221b8a4d533',): RollingMean: 11.428571, ('air_06f95ac5c33aca10',): RollingMean: 27.142857, ('air_0728814bd98f7367',): RollingMean: 8.285714, ('air_0768ab3910f7967f',): RollingMean: 32.571429, ('air_07b314d83059c4d2',): RollingMean: 41.285714, ('air_07bb665f9cdfbdfb',): RollingMean: 24.142857, ('air_082908692355165e',): RollingMean: 48., ('air_083ddc520ea47e1e',): RollingMean: 14.857143, ('air_0845d8395f30c6bb',): RollingMean: 25.285714, ('air_084d98859256acf0',): RollingMean: 12.714286, ('air_0867f7bebad6a649',): RollingMean: 19.142857, ('air_08ba8cd01b3ba010',): RollingMean: 10., ('air_08cb3c4ee6cd6a22',): RollingMean: 10.857143, ('air_08ef81d5b7a0d13f',): RollingMean: 12.857143, ('air_08f994758a1e76d4',): RollingMean: 29.285714, ('air_09040f6df960ddb8',): RollingMean: 17.571429, ('air_0919d54f0c9a24b8',): RollingMean: 37., ('air_09661c0f3259cc04',): RollingMean: 26.428571, ('air_09a845d5b5944b01',): RollingMean: 7.571429, ('air_09fd1f5c58583141',): RollingMean: 8.571429, ('air_0a74a5408a0b8642',): RollingMean: 28.857143, ('air_0b184ec04c741a6a',): RollingMean: 11.857143, ('air_0b1e72d2d4422b20',): RollingMean: 20.857143, ('air_0b9038300f8b2b50',): RollingMean: 13.428571, ('air_0e1eae99b8723bc1',): RollingMean: 12.571429, ('air_0e7c11b9abc50163',): RollingMean: 37., ('air_0ead98dd07e7a82a',): RollingMean: 10.571429, ('air_0f0cdeee6c9bf3d7',): RollingMean: 25.571429, ('air_0f2f96335f274801',): RollingMean: 11.428571, ('air_0f60e1576a7d397d',): RollingMean: 4.857143, ('air_1033310359ceeac1',): RollingMean: 20.857143, ('air_10393f12e9069760',): RollingMean: 13.285714, ('air_105a7954e32dba9b',): RollingMean: 50.714286, ('air_10713fbf3071c361',): RollingMean: 12.857143, ('air_10bbe8acd943d8f6',): RollingMean: 28., ('air_12c4fb7a423df20d',): RollingMean: 21.142857, ('air_138ee734ac79ff90',): RollingMean: 6.285714, ('air_138ff410757b845f',): RollingMean: 49.714286, ('air_1408dd53f31a8a65',): RollingMean: 24.285714, ('air_142e78ba7001da9c',): RollingMean: 14.142857, ('air_1509881b22965b34',): RollingMean: 17., ('air_152c1f08d7d20e07',): RollingMean: 12., ('air_15ae33469e9ea2dd',): RollingMean: 8.285714, ('air_15e6e15c7ea2c162',): RollingMean: 19.571429, ('air_16179d43b6ee5fd8',): RollingMean: 8.428571, ('air_1653a6c513865af3',): RollingMean: 35., ('air_168441ada3e878e1',): RollingMean: 54.571429, ('air_16c4cfddeb2cf69b',): RollingMean: 9.428571, ('air_16cf0a73233896de',): RollingMean: 13., ('air_1707a3f18bb0da07',): RollingMean: 23.142857, ('air_17a6ab40f97fd4d8',): RollingMean: 6.571429, ('air_17bed6dbf7c8b0fc',): RollingMean: 20.428571, ('air_1979eaff8189d086',): RollingMean: 9.857143, ('air_1ab60ce33bfed8a8',): RollingMean: 10.142857, ('air_1ae94f514a0bce13',): RollingMean: 6.571429, ('air_1ba4e87ef7422183',): RollingMean: 35.571429, ('air_1c0b150f9e696a5f',): RollingMean: 100.714286, ('air_1c95a84924d72500',): RollingMean: 9.285714, ('air_1d1e8860ae04f8e9',): RollingMean: 15.142857, ('air_1d25ca6c76df48b4',): RollingMean: 42.857143, ('air_1d3f797dd1f7cf1c',): RollingMean: 39., ('air_1dd8f6f47480d1a2',): RollingMean: 39.142857, ('air_1dea9815ccd36620',): RollingMean: 10.285714, ('air_1e23210b584540e7',): RollingMean: 3.857143, ('air_1e665503b8474c55',): RollingMean: 6.142857, ('air_1eeff462acb24fb7',): RollingMean: 19.571429, ('air_1f1390a8be2272b3',): RollingMean: 19., ('air_1f34e9beded2231a',): RollingMean: 9., ('air_1f7f8fa557bc0d55',): RollingMean: 3.714286, ('air_2009041dbf9264de',): RollingMean: 52.285714, ('air_20619d21192aa571',): RollingMean: 13.285714, ('air_20add8092c9bb51d',): RollingMean: 33.571429, ('air_2195cd5025a98033',): RollingMean: 34.142857, ('air_21f5052d5330528d',): RollingMean: 31.857143, ('air_220cba70c890b119',): RollingMean: 8.714286, ('air_22682e965418936f',): RollingMean: 10.142857, ('air_228f10bec0bda9c8',): RollingMean: 17.142857, ('air_229d7e508d9f1b5e',): RollingMean: 11.428571, ('air_232dcee6f7c51d37',): RollingMean: 6.857143, ('air_234d3dbf7f3d5a50',): RollingMean: 6.428571, ('air_23e1b11aee2a1407',): RollingMean: 46.857143, ('air_23ee674e91469086',): RollingMean: 21.142857, ('air_24b9b2a020826ede',): RollingMean: 32.714286, ('air_24e8414b9b07decb',): RollingMean: 5.857143, ('air_2545dd3a00f265e2',): RollingMean: 56., ('air_256be208a979e023',): RollingMean: 8., ('air_2570ccb93badde68',): RollingMean: 37.428571, ('air_258ad2619d7bff9a',): RollingMean: 38.428571, ('air_258dc112912fc458',): RollingMean: 67.571429, ('air_25c583983246b7b0',): RollingMean: 29.857143, ('air_25d8e5cc57dd87d9',): RollingMean: 26.285714, ('air_25e9888d30b386df',): RollingMean: 5.142857, ('air_2634e41551e9807d',): RollingMean: 18.428571, ('air_26c5bbeb7bb82bf1',): RollingMean: 27.142857, ('air_26f10355d9b4d82a',): RollingMean: 33.285714, ('air_2703dcb33192b181',): RollingMean: 54.142857, ('air_275732a5db46f4d3',): RollingMean: 18.714286, ('air_27e991812b0d9c92',): RollingMean: 42., ('air_28064154614b2e6c',): RollingMean: 22.857143, ('air_287d2de7d3c93406',): RollingMean: 11.857143, ('air_28a9fa1ec0839375',): RollingMean: 34.142857, ('air_28dbe91c4c9656be',): RollingMean: 33.571429, ('air_290e7a57b390f78e',): RollingMean: 14.285714, ('air_298513175efdf261',): RollingMean: 24.857143, ('air_2a184c1745274b2b',): RollingMean: 3.428571, ('air_2a24aec099333f39',): RollingMean: 8.857143, ('air_2a3743e37aab04b4',): RollingMean: 17.428571, ('air_2a485b92210c98b5',): RollingMean: 22.857143, ('air_2a7f14da7fe0f699',): RollingMean: 25., ('air_2aab19554f91ff82',): RollingMean: 43.571429, ('air_2ac361b97630e2df',): RollingMean: 13.285714, ('air_2b8b29ddfd35018e',): RollingMean: 8.714286, ('air_2b9bc9f5f5168ea1',): RollingMean: 21., ('air_2bffb19a24d11729',): RollingMean: 11., ('air_2c505f9ad67d4635',): RollingMean: 16.571429, ('air_2c6c79d597e48096',): RollingMean: 14.714286, ('air_2c6fef1ce0e13a5a',): RollingMean: 28.714286, ('air_2c989829acbd1c6b',): RollingMean: 28.142857, ('air_2cee51fa6fdf6c0d',): RollingMean: 17.142857, ('air_2d3afcb91762fe01',): RollingMean: 51., ('air_2d78d9a1f4dd02ca',): RollingMean: 11.714286, ('air_2e7cb1f1a2a9cd6a',): RollingMean: 31.428571, ('air_2f8ced25216df926',): RollingMean: 12.714286, ('air_2fc149abe33adcb4',): RollingMean: 38.285714, ('air_2fc478dc9f0a6b31',): RollingMean: 12.857143, ('air_2fed81034f8834e5',): RollingMean: 23.857143, ('air_303bac187b53083a',): RollingMean: 9.571429, ('air_310e467e6e625004',): RollingMean: 16.714286, ('air_3155ee23d92202da',): RollingMean: 14.428571, ('air_31c753b48a657b6c',): RollingMean: 21.285714, ('air_32460819c7600037',): RollingMean: 46.857143, ('air_324f7c39a8410e7c',): RollingMean: 12.428571, ('air_326ca454ef3558bc',): RollingMean: 23.714286, ('air_32b02ba5dc2027f4',): RollingMean: 29., ('air_32c61b620a766138',): RollingMean: 28., ('air_32f5d7cd696e3c4a',): RollingMean: 20.714286, ('air_33b01025210d6007',): RollingMean: 12., ('air_3440e0ea1b70a99b',): RollingMean: 30., ('air_346ade7d29230634',): RollingMean: 7., ('air_347be2c4feeb408b',): RollingMean: 22.571429, ('air_349278fa964bb12f',): RollingMean: 19.714286, ('air_3525f11ef0bf0c35',): RollingMean: 44.714286, ('air_35512c42db0868da',): RollingMean: 5.142857, ('air_3561fd1c0bce6a95',): RollingMean: 11.714286, ('air_35c4732dcbfe31be',): RollingMean: 8.714286, ('air_36429b5ca4407b3e',): RollingMean: 20., ('air_36bcf77d3382d36e',): RollingMean: 31.285714, ('air_37189c92b6c761ec',): RollingMean: 20.285714, ('air_375a5241615b5e22',): RollingMean: 7.142857, ('air_382f5ace4e2247b8',): RollingMean: 8.857143, ('air_383f5b2f8d345a49',): RollingMean: 12.714286, ('air_38746ffe9aa20c7e',): RollingMean: 4.571429, ('air_396166d47733d5c9',): RollingMean: 31., ('air_396942e6423a2145',): RollingMean: 24.428571, ('air_397d3f32a7196aa2',): RollingMean: 33.142857, ('air_3980af67be35afdb',): RollingMean: 20., ('air_3982a2c4ea2ed431',): RollingMean: 33.428571, ('air_399904bdb7685ca0',): RollingMean: 29., ('air_39dccf7df20b1c6a',): RollingMean: 26.142857, ('air_3a8a3f8fb5cd7f88',): RollingMean: 22.428571, ('air_3aa839e8e0cb6c87',): RollingMean: 29.857143, ('air_3ac24136722e2291',): RollingMean: 15.142857, ('air_3b20733899b5287f',): RollingMean: 41.857143, ('air_3b6438b125086430',): RollingMean: 13.857143, ('air_3bb99a1fe0583897',): RollingMean: 39.428571, ('air_3bd49f98ab7f36ab',): RollingMean: 15.857143, ('air_3c05c8f26c611eb9',): RollingMean: 22.571429, ('air_3c938075889fc059',): RollingMean: 27.285714, ('air_3cad29d1a23209d2',): RollingMean: 9.142857, ('air_3caef3f76b8f26c5',): RollingMean: 25.428571, ('air_3d3a2b509180e798',): RollingMean: 17., ('air_3e6cea17a9d2c0f1',): RollingMean: 18.714286, ('air_3e93f3c81008696d',): RollingMean: 39.714286, ('air_3f91d592acd6cc0b',): RollingMean: 21.714286, ('air_401b39f97e56b939',): RollingMean: 11.285714, ('air_4043b7ccfbffa732',): RollingMean: 47.857143, ('air_4092cfbd95a3ac1b',): RollingMean: 27.714286, ('air_40953e2d8b4f2857',): RollingMean: 17.428571, ('air_40f6193ea3ed1b91',): RollingMean: 17.857143, ('air_414ff459ed18fa48',): RollingMean: 14.285714, ('air_41bbf6e1d9814c4b',): RollingMean: 7.714286, ('air_421670f21da5ba31',): RollingMean: 18.428571, ('air_4254c3fc3ad078bd',): RollingMean: 12.285714, ('air_42c9aa6d617c5057',): RollingMean: 47., ('air_42d41eb58cad170e',): RollingMean: 33.571429, ('air_43b65e4b05bff2d3',): RollingMean: 19.571429, ('air_43d577e0c9460e64',): RollingMean: 32., ('air_4433ab8e9999915f',): RollingMean: 21.142857, ('air_4481a87c1d7c9896',): RollingMean: 24.142857, ('air_452100f5305dde64',): RollingMean: 7.714286, ('air_45326ebb8dc72cfb',): RollingMean: 22.428571, ('air_4570f52104fe0982',): RollingMean: 8.571429, ('air_4579cb0669fd411b',): RollingMean: 19., ('air_457efe8c3a30ea17',): RollingMean: 6.857143, ('air_464a62de0d57be1e',): RollingMean: 26.428571, ('air_465bddfed3353b23',): RollingMean: 30.285714, ('air_47070be6093f123e',): RollingMean: 44.285714, ('air_472b19e3b5bffa41',): RollingMean: 14., ('air_473cf23b9e7c0a37',): RollingMean: 10.142857, ('air_473f98b212d37b4a',): RollingMean: 27.714286, ('air_47beaffd3806c979',): RollingMean: 18.571429, ('air_483eba479dc9910d',): RollingMean: 19.285714, ('air_48e9fc98b62495a7',): RollingMean: 23.142857, ('air_48f4da6223571da4',): RollingMean: 21.428571, ('air_48ffd31594bc3263',): RollingMean: 4., ('air_49211568cab5fdee',): RollingMean: 25.285714, ('air_4974785f48853db9',): RollingMean: 7.285714, ('air_4b251b9f8373f1ae',): RollingMean: 25.857143, ('air_4b380b4db9d37883',): RollingMean: 25.285714, ('air_4b55d8aea1d2b395',): RollingMean: 36.142857, ('air_4b9085d0d46a6211',): RollingMean: 21.285714, ('air_4beac252540f865e',): RollingMean: 47.571429, ('air_4c2ed28f3f19ca52',): RollingMean: 14.571429, ('air_4c665a2bfff0da3b',): RollingMean: 8.857143, ('air_4c727b55acdee495',): RollingMean: 14.285714, ('air_4cab15ad29c0ffbc',): RollingMean: 19.142857, ('air_4cab91146e3d1897',): RollingMean: 16., ('air_4cca5666eaf5c709',): RollingMean: 37.571429, ('air_4ce7b17062a1bf73',): RollingMean: 6., ('air_4d21676ed11f0bac',): RollingMean: 30.714286, ('air_4d71826793c09b22',): RollingMean: 20.857143, ('air_4d90a22572fa1ec9',): RollingMean: 25.285714, ('air_4de6d887a7b1c1fc',): RollingMean: 16.142857, ('air_4dea8d17f6f59c56',): RollingMean: 27.857143, ('air_4e1c38f68f435596',): RollingMean: 33.285714, ('air_4f762e840b3996e1',): RollingMean: 10., ('air_4feeb8600f131e43',): RollingMean: 55.714286, ('air_500641aca4cf673c',): RollingMean: 18., ('air_506fe758114df773',): RollingMean: 32.571429, ('air_51281cd059d7b89b',): RollingMean: 16.571429, ('air_51319e7acf0438cf',): RollingMean: 13.857143, ('air_52a08ef3efdb4bb0',): RollingMean: 35.428571, ('air_52e2a1fd42bc917a',): RollingMean: 11.142857, ('air_536043fcf1a4f8a4',): RollingMean: 29.571429, ('air_539d693f7317c62d',): RollingMean: 18.571429, ('air_546b353cbea4a45b',): RollingMean: 14.285714, ('air_5485912b44f976de',): RollingMean: 8., ('air_54d6c25d33f5260e',): RollingMean: 45., ('air_54ed43163b7596c4',): RollingMean: 14., ('air_55390f784018349a',): RollingMean: 48.142857, ('air_55c3627912b9c849',): RollingMean: 8.714286, ('air_55e11c33d4758131',): RollingMean: 22.571429, ('air_56cd12f31a0afc04',): RollingMean: 29.571429, ('air_56cebcbd6906e04c',): RollingMean: 24.285714, ('air_56ea46c14b2dd967',): RollingMean: 45.142857, ('air_57013002b912772b',): RollingMean: 6.285714, ('air_573ecdf81b157d22',): RollingMean: 25.857143, ('air_57c9eea1a2b66e65',): RollingMean: 14.285714, ('air_57ed725a1930a5b9',): RollingMean: 14., ('air_5878b6f2a9da12c1',): RollingMean: 14., ('air_59cc9b2b209c6331',): RollingMean: 9.285714, ('air_5a9a6cbeeb434c08',): RollingMean: 23.714286, ('air_5acc13d655a6e8b2',): RollingMean: 23.714286, ('air_5afb1cca48ceaa19',): RollingMean: 51.571429, ('air_5b6d18c470bbfaf9',): RollingMean: 39.285714, ('air_5b704df317ed1962',): RollingMean: 2.142857, ('air_5bd22f9cc1426a90',): RollingMean: 37.285714, ('air_5c65468938c07fa5',): RollingMean: 11.428571, ('air_5c7489c9ec755e2d',): RollingMean: 39.714286, ('air_5c817ef28f236bdf',): RollingMean: 45.428571, ('air_5cb030b9f0b91537',): RollingMean: 11.142857, ('air_5cfc537125d97f16',): RollingMean: 8.428571, ('air_5d7c744c3a2ef624',): RollingMean: 32.428571, ('air_5d945ade487cdf4d',): RollingMean: 17., ('air_5dea8a7a5bf5eb71',): RollingMean: 32.285714, ('air_5e339a1f364cdb00',): RollingMean: 13.571429, ('air_5e34c6fe6fabd10e',): RollingMean: 18.285714, ('air_5e70fe82f9e4fab6',): RollingMean: 17.857143, ('air_5e939e005bd34633',): RollingMean: 1.857143, ('air_5ed3198e4a5eed0f',): RollingMean: 34.571429, ('air_5f3a3ef4cba110a4',): RollingMean: 34.571429, ('air_5f6fa1b897fe80d5',): RollingMean: 26., ('air_5fbda8e9302f7c13',): RollingMean: 26.714286, ('air_602ca92c0db34f8f',): RollingMean: 16.857143, ('air_609050e4e4f79ae1',): RollingMean: 10.571429, ('air_60a7057184ec7ec7',): RollingMean: 30.428571, ('air_60aa54ecbc602348',): RollingMean: 5.714286, ('air_6108821ffafa9b72',): RollingMean: 26., ('air_614e2f7e76dff854',): RollingMean: 11.571429, ('air_61668cc2b0778898',): RollingMean: 9.285714, ('air_61b8d37c33617f21',): RollingMean: 28.857143, ('air_61de73b097513f58',): RollingMean: 8.714286, ('air_622375b4815cf5cb',): RollingMean: 44.857143, ('air_627cabe2fe53f33f',): RollingMean: 14.571429, ('air_629d9935273c82ae',): RollingMean: 27.142857, ('air_629edf21ea38ac2d',): RollingMean: 39.142857, ('air_632ba66e1f75aa28',): RollingMean: 20.142857, ('air_638c35eb25e53eea',): RollingMean: 23.571429, ('air_63a750d8b4b6a976',): RollingMean: 30.142857, ('air_63a88d81295195ed',): RollingMean: 29.571429, ('air_63b13c56b7201bd9',): RollingMean: 26.285714, ('air_63e28ee0b0c955a7',): RollingMean: 25.857143, ('air_640cf4835f0d9ba3',): RollingMean: 30., ('air_6411203a47b5ec77',): RollingMean: 10., ('air_645cb18b33f938cf',): RollingMean: 13.571429, ('air_646b93e336f0dded',): RollingMean: 8.142857, ('air_64a5d5c1381837af',): RollingMean: 38.428571, ('air_64d4491ad8cdb1c6',): RollingMean: 14.714286, ('air_650f9b9de0c5542c',): RollingMean: 23.857143, ('air_657a0748462f85de',): RollingMean: 8.285714, ('air_65e294f1ae6df9c3',): RollingMean: 18.857143, ('air_6607fe3671242ce3',): RollingMean: 44.142857, ('air_670a0c1c4108bcea',): RollingMean: 27.857143, ('air_671b4bea84dafb67',): RollingMean: 26., ('air_673acd9fa5e0dd78',): RollingMean: 7.142857, ('air_67483104fa38ef6c',): RollingMean: 30.428571, ('air_675aa35cba456fd1',): RollingMean: 43.285714, ('air_67f87c159d9e2ee2',): RollingMean: 39.857143, ('air_68147db09287bf74',): RollingMean: 21.285714, ('air_681b0c56328dd2af',): RollingMean: 35.428571, ('air_681f96e6a6595f82',): RollingMean: 35.857143, ('air_68301bcb11e2f389',): RollingMean: 27.142857, ('air_683371d9baabf410',): RollingMean: 31.714286, ('air_6836438b543ba698',): RollingMean: 11.571429, ('air_6873982b9e19c7ad',): RollingMean: 6.285714, ('air_68c1de82037d87e6',): RollingMean: 25., ('air_68cc910e7b307b09',): RollingMean: 9.428571, ('air_68d075113f368946',): RollingMean: 23.857143, ('air_6902e4ec305b3d08',): RollingMean: 38.428571, ('air_694571ea13fb9e0e',): RollingMean: 29.285714, ('air_6a15e4eae523189d',): RollingMean: 17.857143, ('air_6b15edd1b4fbb96a',): RollingMean: 31., ('air_6b2268863b14a2af',): RollingMean: 20.285714, ('air_6b65745d432fd77f',): RollingMean: 23.428571, ('air_6b7678aae65d2d59',): RollingMean: 9., ('air_6b942d5ebbc759c2',): RollingMean: 12.857143, ('air_6b9fa44a9cf504a1',): RollingMean: 4.857143, ('air_6c1128955c58b690',): RollingMean: 14.285714, ('air_6c91a28278a16f64',): RollingMean: 9.142857, ('air_6c952e3c6e590945',): RollingMean: 15.571429, ('air_6ca1d941c8199a67',): RollingMean: 28.571429, ('air_6cbe54f0aa30b615',): RollingMean: 13.714286, ('air_6ced51c24fb54262',): RollingMean: 9.142857, ('air_6d64dba2edd4fc0c',): RollingMean: 5.142857, ('air_6d65542aa43b598b',): RollingMean: 30., ('air_6d65dd11d96e00fb',): RollingMean: 5.285714, ('air_6e06824d0934dd81',): RollingMean: 23.285714, ('air_6e3fd96320d24324',): RollingMean: 7.857143, ('air_6e64fb5821402cd2',): RollingMean: 8.142857, ('air_6ff5fca957798daa',): RollingMean: 7.285714, ('air_707d4b6328f2c2df',): RollingMean: 28.857143, ('air_709262d948dd0b6e',): RollingMean: 14.714286, ('air_70e9e8cd55879414',): RollingMean: 10.857143, ('air_70f834596eb99fee',): RollingMean: 21., ('air_710d6537cb7623df',): RollingMean: 31.714286, ('air_712dd258f7f91b4b',): RollingMean: 20.571429, ('air_71903025d39a4571',): RollingMean: 15.142857, ('air_722297e7f26db91d',): RollingMean: 12.285714, ('air_728ff578acc6ac6e',): RollingMean: 11.857143, ('air_72f5146cf0c49beb',): RollingMean: 13., ('air_735bcbe1763d6e98',): RollingMean: 10.285714, ('air_73f316e6a18d8aa9',): RollingMean: 23.714286, ('air_7420042ff75f9aca',): RollingMean: 33.285714, ('air_746211c0b532e8aa',): RollingMean: 64.142857, ('air_747f375eb3900e1e',): RollingMean: 4.428571, ('air_74cf22153214064c',): RollingMean: 13.714286, ('air_7514d90009613cd6',): RollingMean: 75.714286, ('air_754ae581ad80cc9f',): RollingMean: 10.857143, ('air_75864c80d2fb334a',): RollingMean: 11.571429, ('air_75bd5d1b6dc6670d',): RollingMean: 11.857143, ('air_764f71040a413d4d',): RollingMean: 54.428571, ('air_77488fa378cf98c3',): RollingMean: 6.857143, ('air_77dfc83450cbc89c',): RollingMean: 42.714286, ('air_7831b00996701c0f',): RollingMean: 23.428571, ('air_789103bf53b8096b',): RollingMean: 54., ('air_789466e488705c93',): RollingMean: 22.714286, ('air_78df4dc6a7e83e41',): RollingMean: 16.857143, ('air_79afb3f52b4d062c',): RollingMean: 9., ('air_79f528087f49df06',): RollingMean: 31., ('air_7a81bd7fadcbf3d8',): RollingMean: 4., ('air_7a946aada80376a4',): RollingMean: 16.142857, ('air_7bacc4d36fb094c9',): RollingMean: 6.571429, ('air_7bc6ca04d7b0f3b8',): RollingMean: 8.428571, ('air_7bda6048a4a78837',): RollingMean: 24.857143, ('air_7c7774c66fb237f7',): RollingMean: 7.571429, ('air_7cc17a324ae5c7dc',): RollingMean: 14.714286, ('air_7cf5a02c0e01b647',): RollingMean: 33.857143, ('air_7d65049f9d275c0d',): RollingMean: 11.571429, ('air_7dacea2f22afccfb',): RollingMean: 38.142857, ('air_7db266904cb0d72a',): RollingMean: 13.571429, ('air_7e12c5d27f44a8de',): RollingMean: 25.571429, ('air_7ef9a5ea5c8fe39f',): RollingMean: 10.857143, ('air_7f3dc18494bce98b',): RollingMean: 15.428571, ('air_7f9e15afafcf4c75',): RollingMean: 41.857143, ('air_7fbf7649eb13ad9b',): RollingMean: 19.571429, ('air_800c02226e2e0288',): RollingMean: 15.285714, ('air_8093d0b565e9dbdf',): RollingMean: 39.142857, ('air_8110d68cc869b85e',): RollingMean: 51.857143, ('air_81546875de9c8e78',): RollingMean: 5., ('air_81a12d67c22e012f',): RollingMean: 19.714286, ('air_81bd68142db76f58',): RollingMean: 17.714286, ('air_81c2600146d07d16',): RollingMean: 6.142857, ('air_81c5dff692063446',): RollingMean: 14.857143, ('air_820d1919cbecaa0a',): RollingMean: 32.714286, ('air_82a6ae14151953ba',): RollingMean: 41.714286, ('air_831658500aa7c846',): RollingMean: 31.571429, ('air_832f9dbe9ee4ebd3',): RollingMean: 12.428571, ('air_83db5aff8f50478e',): RollingMean: 6., ('air_84060403939d8216',): RollingMean: 15.571429, ('air_848616680ef061bd',): RollingMean: 29.571429, ('air_84f6876ff7e83ae7',): RollingMean: 18.428571, ('air_8523d6a70de49e6c',): RollingMean: 31.571429, ('air_859feab8e3c9f98d',): RollingMean: 25.285714, ('air_85bd13a49370c392',): RollingMean: 12.571429, ('air_86cfbf2624576fad',): RollingMean: 7.571429, ('air_86f7b2109e4abd65',): RollingMean: 47.571429, ('air_87059630ab6fe47f',): RollingMean: 4.285714, ('air_87078cf7903a648c',): RollingMean: 6.285714, ('air_87467487d21891dd',): RollingMean: 10.142857, ('air_8764b3473ddcceaf',): RollingMean: 4.857143, ('air_876d7a23c47811cb',): RollingMean: 16.571429, ('air_877f79706adbfb06',): RollingMean: 10.285714, ('air_87ca98aa7664de94',): RollingMean: 13.714286, ('air_87f9e1024b951f01',): RollingMean: 12.142857, ('air_883ca28ef0ed3d55',): RollingMean: 13.857143, ('air_88c8e34baa79217b',): RollingMean: 35.571429, ('air_88ca84051ba95339',): RollingMean: 16.428571, ('air_88f31db64991768a',): RollingMean: 8.428571, ('air_890d7e28e8eaaa11',): RollingMean: 9.714286, ('air_89e7328af22efe74',): RollingMean: 41., ('air_8a1d21fad48374e8',): RollingMean: 13.857143, ('air_8a59bb0c497b771e',): RollingMean: 23.857143, ('air_8a906e5801eac81c',): RollingMean: 21.857143, ('air_8b4a46dc521bfcfe',): RollingMean: 31.714286, ('air_8c119d1f16049f20',): RollingMean: 29.857143, ('air_8c3175aa5e4fc569',): RollingMean: 131.714286, ('air_8cc350fd70ee0757',): RollingMean: 37.285714, ('air_8ce035ee1d8a56a6',): RollingMean: 19.571429, ('air_8d50c64692322dff',): RollingMean: 12.571429, ('air_8d61f49aa0373492',): RollingMean: 49.714286, ('air_8e429650fcf7a0ae',): RollingMean: 19.428571, ('air_8e4360a64dbd4c50',): RollingMean: 20., ('air_8e492076a1179383',): RollingMean: 43.571429, ('air_8e8f42f047537154',): RollingMean: 28.285714, ('air_8ec47c0f1e2c879e',): RollingMean: 32., ('air_8f13ef0f5e8c64dd',): RollingMean: 5., ('air_8f273fb9ad2fed6f',): RollingMean: 12.857143, ('air_8f3b563416efc6ad',): RollingMean: 15., ('air_900d755ebd2f7bbd',): RollingMean: 97.285714, ('air_901925b628677c2e',): RollingMean: 8.571429, ('air_90213bcae4afa274',): RollingMean: 29.571429, ('air_90bd5de52c166767',): RollingMean: 21.714286, ('air_90ed0a2f24755533',): RollingMean: 50., ('air_90f0efbb702d77b7',): RollingMean: 30.857143, ('air_9105a29b0eb250d2',): RollingMean: 16.857143, ('air_91236b89d29567af',): RollingMean: 27.428571, ('air_9152d9926e5c4a3a',): RollingMean: 31.142857, ('air_915558a55c2bc56c',): RollingMean: 17.142857, ('air_91beafbba9382b0a',): RollingMean: 36.428571, ('air_91d72e16c4bcba55',): RollingMean: 15.714286, ('air_9241121af22ff1d6',): RollingMean: 27.285714, ('air_929d8513e3cdb423',): RollingMean: 8.285714, ('air_931a8a4321b6e7d1',): RollingMean: 4., ('air_9352c401d5adb01b',): RollingMean: 25.571429, ('air_9387ff95e886ebc7',): RollingMean: 11.857143, ('air_938ef91ecdde6878',): RollingMean: 27., ('air_939964477035ef0b',): RollingMean: 16.857143, ('air_93b9bb641f8fc982',): RollingMean: 24.857143, ('air_93dd7070c9bf5453',): RollingMean: 29.142857, ('air_93ebe490d4abb8e9',): RollingMean: 21.285714, ('air_9438d67241c81314',): RollingMean: 31.714286, ('air_947eb2cae4f3e8f2',): RollingMean: 36.714286, ('air_9483d65e9cc9a6b7',): RollingMean: 15.428571, ('air_950381108f839348',): RollingMean: 32.142857, ('air_95d28905941fd4cb',): RollingMean: 36.428571, ('air_95e917913cd988f3',): RollingMean: 25.714286, ('air_96005f79124e12bf',): RollingMean: 42.714286, ('air_965b2e0cf4119003',): RollingMean: 40., ('air_96743eee94114261',): RollingMean: 15.571429, ('air_96773a6236d279b1',): RollingMean: 25.428571, ('air_968d72c12eed09f0',): RollingMean: 17.285714, ('air_96929a799b12a43e',): RollingMean: 27.428571, ('air_96ec3cfe78cb0652',): RollingMean: 21.285714, ('air_97159fc4e90053fe',): RollingMean: 24.142857, ('air_97958e7fce98b6a3',): RollingMean: 17.857143, ('air_97b2a9f975fc702c',): RollingMean: 40.428571, ('air_97cf68dc1a9beac0',): RollingMean: 14.571429, ('air_97e0f2feec4d577a',): RollingMean: 18.714286, ('air_9828505fefc77d75',): RollingMean: 12.714286, ('air_98b54e32ccddd896',): RollingMean: 17.428571, ('air_990a642a3deb2903',): RollingMean: 33.428571, ('air_99157b6163835eec',): RollingMean: 34.428571, ('air_99a5183695b849f9',): RollingMean: 25.857143, ('air_99b01136f451fc0e',): RollingMean: 43.857143, ('air_99c3eae84130c1cb',): RollingMean: 41.857143, ('air_9a30407764f4ff84',): RollingMean: 20., ('air_9a6f6e7f623003d2',): RollingMean: 2.857143, ('air_9aa32b3db0fab3a5',): RollingMean: 15.857143, ('air_9aa92007e3628dbc',): RollingMean: 36.571429, ('air_9ae7081cb77dc51e',): RollingMean: 32.857143, ('air_9b13c7feb0a0c431',): RollingMean: 12.714286, ('air_9b6af3db40da4ae2',): RollingMean: 29., ('air_9bbc673495e23532',): RollingMean: 4.571429, ('air_9bf0ccac497c4af3',): RollingMean: 47.285714, ('air_9bf595ef095572fb',): RollingMean: 28.142857, ('air_9c6787aa03a45586',): RollingMean: 86., ('air_9ca2767761efff4d',): RollingMean: 9.142857, ('air_9cd5e310f488bced',): RollingMean: 11.571429, ('air_9cf2f1ba86229773',): RollingMean: 34.285714, ('air_9d3482b4680aee88',): RollingMean: 9.571429, ('air_9d452a881f7f2bb7',): RollingMean: 9.285714, ('air_9d474ec2448c700d',): RollingMean: 11.857143, ('air_9d5a980b211e1795',): RollingMean: 11.285714, ('air_9d93d95720f2e831',): RollingMean: 8.857143, ('air_9dc9483f717d73ee',): RollingMean: 4.714286, ('air_9dd7d38b0f1760c4',): RollingMean: 3., ('air_9e920b758503ef54',): RollingMean: 7.285714, ('air_9efaa7ded03c5a71',): RollingMean: 13.857143, ('air_9f277fb7a2c1d842',): RollingMean: 9.857143, ('air_9fc607777ad76b26',): RollingMean: 16.285714, ('air_a083834e7ffe187e',): RollingMean: 20.857143, ('air_a11473cc1eb9a27f',): RollingMean: 31.714286, ('air_a17f0778617c76e2',): RollingMean: 30.285714, ('air_a1fe8c588c8d2f30',): RollingMean: 17.285714, ('air_a218912784bf767d',): RollingMean: 13., ('air_a21ffca0bea1661a',): RollingMean: 1.142857, ('air_a239a44805932bab',): RollingMean: 35.142857, ('air_a24bf50c3e90d583',): RollingMean: 18.285714, ('air_a2567267116a3b75',): RollingMean: 16.285714, ('air_a257c9749d8d0ff6',): RollingMean: 18.142857, ('air_a271c9ba19e81d17',): RollingMean: 29.142857, ('air_a2b29aa7feb4e36f',): RollingMean: 21.571429, ('air_a304330715435390',): RollingMean: 8.142857, ('air_a33461f4392ec62c',): RollingMean: 30.142857, ('air_a373500730e2a9e0',): RollingMean: 10.142857, ('air_a38f25e3399d1b25',): RollingMean: 41.142857, ('air_a41b032371a63427',): RollingMean: 9.428571, ('air_a49f1cf0634f13e5',): RollingMean: 16.857143, ('air_a510dcfe979f09eb',): RollingMean: 12.714286, ('air_a546cbf478a8b6e4',): RollingMean: 28.714286, ('air_a55d17bd3f3033cb',): RollingMean: 12.142857, ('air_a563896da3777078',): RollingMean: 23.142857, ('air_a678e5b144ca24ce',): RollingMean: 18.571429, ('air_a7404a854919e990',): RollingMean: 8.571429, ('air_a8533b7a992bb0ca',): RollingMean: 19.285714, ('air_a85f0c0c889f6b7e',): RollingMean: 50.571429, ('air_a85f8c0bfd61889f',): RollingMean: 17.142857, ('air_a88ac559064dec08',): RollingMean: 28., ('air_a9133955abccf071',): RollingMean: 27., ('air_a9178f19da58fe99',): RollingMean: 7.714286, ('air_a9a380530c1e121f',): RollingMean: 45.285714, ('air_aa0049fe3cc6f4d6',): RollingMean: 11.142857, ('air_ab3ae0e410b20069',): RollingMean: 16.714286, ('air_ab9746a0f83084b7',): RollingMean: 1.142857, ('air_abcdc8115988a010',): RollingMean: 9.857143, ('air_abf06fcca748dca5',): RollingMean: 9., ('air_ac7a7427c9ae12a5',): RollingMean: 63.857143, ('air_ad13e71e21235131',): RollingMean: 10.285714, ('air_ad60f6b76c9df7ed',): RollingMean: 30.571429, ('air_ad7777590c884721',): RollingMean: 9.428571, ('air_add9a575623726c8',): RollingMean: 47.571429, ('air_ade6e836ffd1da64',): RollingMean: 11.571429, ('air_aed3a8b49abe4a48',): RollingMean: 5., ('air_af03c277a167b2bd',): RollingMean: 36.285714, ('air_af24e3e817dea1e5',): RollingMean: 15.285714, ('air_af63df35857b16e6',): RollingMean: 25.714286, ('air_b0a6a4c5e95c74cf',): RollingMean: 19.571429, ('air_b162fb07fbbdea33',): RollingMean: 15.285714, ('air_b192fb5310436005',): RollingMean: 8., ('air_b1a72bf1ebf4b8ef',): RollingMean: 46.285714, ('air_b1bb1fae86617d7a',): RollingMean: 36.428571, ('air_b1d822f75c9fc615',): RollingMean: 10.714286, ('air_b2395df0e874078d',): RollingMean: 6.571429, ('air_b23d0f519291247d',): RollingMean: 34., ('air_b259b4e4a51a690d',): RollingMean: 18.142857, ('air_b28bed4b2e7167b7',): RollingMean: 19.142857, ('air_b2a639cc7e02edf1',): RollingMean: 20.142857, ('air_b2d8bc9c88b85f96',): RollingMean: 8.142857, ('air_b2d97bd2337c5ba7',): RollingMean: 36.142857, ('air_b2dcec37b83e2494',): RollingMean: 7.857143, ('air_b30fffd7ab1e75a5',): RollingMean: 9.428571, ('air_b3180b74332ba886',): RollingMean: 14.285714, ('air_b3a824511477a4ed',): RollingMean: 6.285714, ('air_b439391e72899756',): RollingMean: 20.142857, ('air_b45b8e456f53942a',): RollingMean: 9.285714, ('air_b4f32bcc399da2b9',): RollingMean: 20.428571, ('air_b5598d12d1b84890',): RollingMean: 5.428571, ('air_b5bdd318005d9aa4',): RollingMean: 39.428571, ('air_b60cc7d6aee68194',): RollingMean: 13.285714, ('air_b711b43ae472cb6b',): RollingMean: 22.571429, ('air_b7fa3d2fca744dd2',): RollingMean: 41.428571, ('air_b80fed1a07c817d2',): RollingMean: 4.142857, ('air_b88192b35ac03c24',): RollingMean: 21., ('air_b8925441167c3152',): RollingMean: 1.714286, ('air_b8a5ee69e5fdcc5b',): RollingMean: 31.571429, ('air_b8d9e1624baaadc2',): RollingMean: 6.857143, ('air_b9e27558fb8bd5c4',): RollingMean: 13.714286, ('air_ba495cccc8f0f237',): RollingMean: 18.714286, ('air_ba937bf13d40fb24',): RollingMean: 15.714286, ('air_bac5f4441db21db9',): RollingMean: 45.857143, ('air_baf28ac9f13a307d',): RollingMean: 14.571429, ('air_bb09595bab7d5cfb',): RollingMean: 33.857143, ('air_bb26d6d079594414',): RollingMean: 11.428571, ('air_bb4ff06cd661ee9b',): RollingMean: 33.285714, ('air_bbe1c1a47e09f161',): RollingMean: 1.428571, ('air_bc991c51d6613745',): RollingMean: 19.714286, ('air_bc9a129e11a2efe0',): RollingMean: 30.857143, ('air_bcce1ea4350b7b72',): RollingMean: 26., ('air_bd74a9222edfdfe1',): RollingMean: 13.428571, ('air_bdd32aa407c16335',): RollingMean: 16.714286, ('air_bebd55ed63ab2422',): RollingMean: 10.857143, ('air_bed603c423b7d9d4',): RollingMean: 5.857143, ('air_bedd35489e666605',): RollingMean: 35.857143, ('air_bf13014b6e3e60ca',): RollingMean: 31.857143, ('air_bf21b8350771879b',): RollingMean: 22.142857, ('air_bf617aa68d5f1cfa',): RollingMean: 7.571429, ('air_bf7591560077332d',): RollingMean: 9.142857, ('air_bfafaed35e213fd7',): RollingMean: 14.714286, ('air_bfda7731a6c6fc61',): RollingMean: 20.285714, ('air_c027e2b560442808',): RollingMean: 17.285714, ('air_c0385db498b391e5',): RollingMean: 34.285714, ('air_c1d5d165c055b866',): RollingMean: 30.142857, ('air_c1ff20617c54fee7',): RollingMean: 8.142857, ('air_c225148c0fcc5c72',): RollingMean: 39.428571, ('air_c2626f5f86d57342',): RollingMean: 16.142857, ('air_c26f027b5bc1f081',): RollingMean: 5.857143, ('air_c28983412a7eefcf',): RollingMean: 40.571429, ('air_c2c8435bdb3516d4',): RollingMean: 35., ('air_c31472d14e29cee8',): RollingMean: 16.714286, ('air_c3585b0fba3998d0',): RollingMean: 9.285714, ('air_c3bc011cca3bec65',): RollingMean: 4.285714, ('air_c3dcaf3aeb18e20e',): RollingMean: 15.714286, ('air_c47aa7493b15f297',): RollingMean: 23., ('air_c4fa5c562d5409ca',): RollingMean: 15.857143, ('air_c52c63c781fe48f6',): RollingMean: 29.428571, ('air_c5459218282bedd5',): RollingMean: 21.714286, ('air_c66dbd2c37832d00',): RollingMean: 16.714286, ('air_c6a164dd4060e960',): RollingMean: 15.857143, ('air_c6aa2efba0ffc8eb',): RollingMean: 26.428571, ('air_c6ffd6a93e6b68d6',): RollingMean: 15.714286, ('air_c73d319ffabf287a',): RollingMean: 18.428571, ('air_c759b6abeb552160',): RollingMean: 7.142857, ('air_c77ee2b7d36da265',): RollingMean: 42., ('air_c7d30ab0e07f31d5',): RollingMean: 20.285714, ('air_c7f78b4f3cba33ff',): RollingMean: 25.142857, ('air_c8265ecc116f2284',): RollingMean: 9.142857, ('air_c88467d88b2c8ecd',): RollingMean: 19.428571, ('air_c8a657c8c5c93d69',): RollingMean: 9.142857, ('air_c8c0ef02ed72053f',): RollingMean: 27.428571, ('air_c8fe396d6c46275d',): RollingMean: 18., ('air_c92745dfdd2ec68a',): RollingMean: 21.857143, ('air_c9ed65554b6edffb',): RollingMean: 12.714286, ('air_c9f6de13be8b8f25',): RollingMean: 3.571429, ('air_ca1315af9e073bd1',): RollingMean: 43.714286, ('air_ca6ae8d49a2f1eaf',): RollingMean: 24.142857, ('air_ca957d3a1529fbd3',): RollingMean: 31.285714, ('air_cadf9cfb510a1d78',): RollingMean: 29.714286, ('air_caf996ac27206301',): RollingMean: 4.714286, ('air_cb083b4789a8d3a2',): RollingMean: 18.714286, ('air_cb25551c4cd8d9f3',): RollingMean: 5.714286, ('air_cb7467aed805e7fe',): RollingMean: 40.428571, ('air_cb935ff8610ba3d3',): RollingMean: 4.142857, ('air_cbe139af83feb388',): RollingMean: 10.428571, ('air_cbe867adcf44e14f',): RollingMean: 15.714286, ('air_cc1a0e985ce63711',): RollingMean: 27.285714, ('air_cc35590cd1da8554',): RollingMean: 24.571429, ('air_ccd19a5bc5573ae5',): RollingMean: 34.857143, ('air_cd4b301d5d3918d8',): RollingMean: 5.857143, ('air_cd5f54969be9ed08',): RollingMean: 6.285714, ('air_ced6297e5bdf5130',): RollingMean: 23.428571, ('air_cf2229e64408d9fe',): RollingMean: 20.428571, ('air_cf22e368c1a71d53',): RollingMean: 34.857143, ('air_cf5ab75a0afb8af9',): RollingMean: 48., ('air_cfcc94797d2b5d3d',): RollingMean: 18.285714, ('air_cfdeb326418194ff',): RollingMean: 17.285714, ('air_d00161e19f08290b',): RollingMean: 28.714286, ('air_d00a15343325e5f7',): RollingMean: 21.142857, ('air_d07e57b21109304a',): RollingMean: 11.428571, ('air_d0a1e69685259c92',): RollingMean: 32., ('air_d0a7bd3339c3d12a',): RollingMean: 46.714286, ('air_d0e8a085d8dc83aa',): RollingMean: 6.571429, ('air_d138b593ebda55cc',): RollingMean: 6., ('air_d1418d6fd6d634f2',): RollingMean: 17.714286, ('air_d186b2cb0b9ce022',): RollingMean: 14.428571, ('air_d1f20424f76cc78e',): RollingMean: 19.857143, ('air_d34c0861a2be94cb',): RollingMean: 41.285714, ('air_d3e7b5952cd09ccb',): RollingMean: 17.857143, ('air_d44d210d2994f01b',): RollingMean: 7., ('air_d473620754bf9fc2',): RollingMean: 11., ('air_d477b6339b8ce69f',): RollingMean: 11., ('air_d4981cdde163b172',): RollingMean: 27.142857, ('air_d4b5a4b04c5f2d04',): RollingMean: 15.142857, ('air_d4d218b451f82c3d',): RollingMean: 9.428571, ('air_d500b48a8735fbd3',): RollingMean: 20.142857, ('air_d54d6fcb116fbed3',): RollingMean: 4.714286, ('air_d5e0a20370c325c7',): RollingMean: 33.285714, ('air_d63cfa6d6ab78446',): RollingMean: 20.857143, ('air_d69b08a175bc0387',): RollingMean: 13.571429, ('air_d6b3e67261f07646',): RollingMean: 11.714286, ('air_d8abb9e490abf94f',): RollingMean: 12.714286, ('air_d97dabf7aae60da5',): RollingMean: 34.714286, ('air_d98380a4aeb0290b',): RollingMean: 44.285714, ('air_daa7947e1c47f5ed',): RollingMean: 31.142857, ('air_dabfbd0ec951925a',): RollingMean: 8.142857, ('air_dad0b6a36138f309',): RollingMean: 5.142857, ('air_db1233ad855b34d5',): RollingMean: 25.857143, ('air_db4b38ebe7a7ceff',): RollingMean: 19.714286, ('air_db80363d35f10926',): RollingMean: 36.142857, ('air_dbf64f1ce38c7442',): RollingMean: 14., ('air_dc0e080ba0a5e5af',): RollingMean: 9.428571, ('air_dc71c6cc06cd1aa2',): RollingMean: 6.857143, ('air_de692863bb2dd758',): RollingMean: 22., ('air_de803f7e324936b8',): RollingMean: 24.571429, ('air_de88770300008624',): RollingMean: 21.857143, ('air_dea0655f96947922',): RollingMean: 37., ('air_df507aec929ce5f6',): RollingMean: 24.857143, ('air_df554c4527a1cfe6',): RollingMean: 57.285714, ('air_df5cf5cd03eb68d0',): RollingMean: 7.285714, ('air_df843e6b22e8d540',): RollingMean: 12.285714, ('air_df9355c47c5df9d3',): RollingMean: 32.428571, ('air_dfad598ff642dab7',): RollingMean: 28.285714, ('air_dfe068a1bf85f395',): RollingMean: 41.142857, ('air_e00fe7853c0100d6',): RollingMean: 18.142857, ('air_e0118664da63a2d0',): RollingMean: 15.428571, ('air_e01d99390355408d',): RollingMean: 10.571429, ('air_e053c561f32acc28',): RollingMean: 16.428571, ('air_e08b9cf82057a170',): RollingMean: 34., ('air_e0aee25b56a069f2',): RollingMean: 14.857143, ('air_e0e69668214ff972',): RollingMean: 11.142857, ('air_e0f241bd406810c0',): RollingMean: 34.714286, ('air_e1b76fcb5208fb6b',): RollingMean: 18.714286, ('air_e2208a79e2678432',): RollingMean: 47.428571, ('air_e270aff84ac7e4c8',): RollingMean: 22.714286, ('air_e3020992d5fe5dfd',): RollingMean: 14.285714, ('air_e34c631c766f2766',): RollingMean: 24.857143, ('air_e42bdc3377d1eee7',): RollingMean: 23.428571, ('air_e483f5b3c4f310e0',): RollingMean: 6., ('air_e524c6a9e06cc3a1',): RollingMean: 9., ('air_e55abd740f93ecc4',): RollingMean: 45.285714, ('air_e57dd6884595f60d',): RollingMean: 37.714286, ('air_e58f669b6f1a08ce',): RollingMean: 12.142857, ('air_e5cf003abcc5febb',): RollingMean: 18.285714, ('air_e64de0a6bf0739af',): RollingMean: 38.285714, ('air_e657ca554b0c008c',): RollingMean: 28.285714, ('air_e700e390226d9985',): RollingMean: 18.714286, ('air_e76a668009c5dabc',): RollingMean: 9.285714, ('air_e7d2ac6d53d1b744',): RollingMean: 11.714286, ('air_e7fbee4e3cfe65c5',): RollingMean: 39., ('air_e88bbe2ede3467aa',): RollingMean: 21.285714, ('air_e89735e80d614a7e',): RollingMean: 31.428571, ('air_e8ed9335d0c38333',): RollingMean: 30.142857, ('air_e9ebf7fc520ac76a',): RollingMean: 29.142857, ('air_ea6d0c3acf00b22a',): RollingMean: 25.571429, ('air_ea7c16131980c837',): RollingMean: 7., ('air_eb120e6d384a17a8',): RollingMean: 48.428571, ('air_eb20a89bba7dd3d0',): RollingMean: 3.142857, ('air_eb2d2653586315dd',): RollingMean: 35.285714, ('air_eb5788dba285e725',): RollingMean: 31.142857, ('air_ebd31e812960f517',): RollingMean: 30.571429, ('air_ebe02c3090271fa9',): RollingMean: 11.285714, ('air_ec0fad2def4dcff0',): RollingMean: 16., ('air_eca4a5a191e8d993',): RollingMean: 32.571429, ('air_eca5e0064dc9314a',): RollingMean: 33.714286, ('air_ecab54b57a71b10d',): RollingMean: 13., ('air_eceb97ad6a7d4c07',): RollingMean: 30.714286, ('air_ecf7f141339f1d57',): RollingMean: 20.142857, ('air_eda179770dfa9f91',): RollingMean: 10.428571, ('air_edd5e3d696a5811b',): RollingMean: 38.142857, ('air_ee3a01f0c71a769f',): RollingMean: 28.142857, ('air_ee3ba9af184c6c82',): RollingMean: 21.285714, ('air_eec5e572b9eb9c23',): RollingMean: 15.571429, ('air_eeeadee005c006a2',): RollingMean: 13.714286, ('air_ef47430bcd6f6a89',): RollingMean: 13.857143, ('air_ef789667e2e6fe96',): RollingMean: 36.428571, ('air_ef920fa6f4b085f6',): RollingMean: 32.142857, ('air_efc80d3f96b3aff7',): RollingMean: 8.428571, ('air_efd70b04de878f25',): RollingMean: 30., ('air_efef1e3daecce07e',): RollingMean: 43.428571, ('air_f068442ebb6c246c',): RollingMean: 11.571429, ('air_f0c7272956e62f12',): RollingMean: 5.428571, ('air_f0fb0975bdc2cdf9',): RollingMean: 10.142857, ('air_f1094dbf2aef85d9',): RollingMean: 7.142857, ('air_f180301886c21375',): RollingMean: 18.142857, ('air_f183a514cb8ff4fa',): RollingMean: 38., ('air_f1f9027d4fa8f653',): RollingMean: 22., ('air_f267dd70a6a6b5d3',): RollingMean: 31.857143, ('air_f26f36ec4dc5adb0',): RollingMean: 39.857143, ('air_f2985de32bb792e0',): RollingMean: 24.714286, ('air_f2c5a1f24279c531',): RollingMean: 18.571429, ('air_f3602e4fa2f12993',): RollingMean: 11., ('air_f3f9824b7d70c3cf',): RollingMean: 15.714286, ('air_f4936b91c9addbf0',): RollingMean: 16.142857, ('air_f593fa60ac3541e2',): RollingMean: 8., ('air_f690c42545146e0a',): RollingMean: 11.714286, ('air_f6b2489ccf873c3b',): RollingMean: 16.285714, ('air_f6bfd27e2e174d16',): RollingMean: 14.142857, ('air_f6cdaf7b7fdc6d78',): RollingMean: 12.285714, ('air_f8233ad00755c35c',): RollingMean: 28.714286, ('air_f85e21e543cf44f2',): RollingMean: 5.714286, ('air_f88898cd09f40496',): RollingMean: 7.714286, ('air_f911308e19d64236',): RollingMean: 47., ('air_f9168b23fdfc1e52',): RollingMean: 14.142857, ('air_f927b2da69a82341',): RollingMean: 9.428571, ('air_f957c6d6467d4d90',): RollingMean: 9.285714, ('air_f96765e800907c77',): RollingMean: 38.428571, ('air_fa12b40b02fecfd8',): RollingMean: 14.571429, ('air_fa4ffc9057812fa2',): RollingMean: 6., ('air_fab092c35776a9b1',): RollingMean: 10.571429, ('air_fb44f566d4f64a4e',): RollingMean: 14.857143, ('air_fbadf737162a5ce3',): RollingMean: 15., ('air_fc477473134e9ae5',): RollingMean: 15.714286, ('air_fcd4492c83f1c6b9',): RollingMean: 24.142857, ('air_fcfbdcf7b1f82c6e',): RollingMean: 39.857143, ('air_fd154088b1de6fa7',): RollingMean: 4.428571, ('air_fd6aac1043520e83',): RollingMean: 39.428571, ('air_fdc02ec4a3d21ea4',): RollingMean: 8.142857, ('air_fdcfef8bd859f650',): RollingMean: 3.714286, ('air_fe22ef5a9cbef123',): RollingMean: 24.428571, ('air_fe58c074ec1445ea',): RollingMean: 35., ('air_fea5dc9594450608',): RollingMean: 17.428571, ('air_fee8dcf4d619598e',): RollingMean: 29.571429, ('air_fef9ccb3ba0da2f7',): RollingMean: 8.714286, ('air_ffcc2d5087e1b476',): RollingMean: 24.714286, ('air_fff68b929994bfbd',): RollingMean: 4.142857}), 'by': ['store_id'], 'how': RollingMean: 0., 'on': 'y'} y_rollingmean_14_by_store_id {'_feature_name': 'y_rollingmean_14_by_store_id', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f830e2024c0>, RollingMean: 0.), {('air_00a91d42b08b08d9',): RollingMean: 28.428571, ('air_0164b9927d20bcc3',): RollingMean: 6.571429, ('air_0241aa3964b7f861',): RollingMean: 9.928571, ('air_0328696196e46f18',): RollingMean: 8.142857, ('air_034a3d5b40d5b1b1',): RollingMean: 24.285714, ('air_036d4f1ee7285390',): RollingMean: 22.714286, ('air_0382c794b73b51ad',): RollingMean: 26.571429, ('air_03963426c9312048',): RollingMean: 47.142857, ('air_04341b588bde96cd',): RollingMean: 32.5, ('air_049f6d5b402a31b2',): RollingMean: 13.571429, ('air_04cae7c1bc9b2a0b',): RollingMean: 20., ('air_0585011fa179bcce',): RollingMean: 4.785714, ('air_05c325d315cc17f5',): RollingMean: 28.142857, ('air_0647f17b4dc041c8',): RollingMean: 30.928571, ('air_064e203265ee5753',): RollingMean: 18.714286, ('air_066f0221b8a4d533',): RollingMean: 11.142857, ('air_06f95ac5c33aca10',): RollingMean: 29.714286, ('air_0728814bd98f7367',): RollingMean: 7.785714, ('air_0768ab3910f7967f',): RollingMean: 28.214286, ('air_07b314d83059c4d2',): RollingMean: 38.571429, ('air_07bb665f9cdfbdfb',): RollingMean: 25.785714, ('air_082908692355165e',): RollingMean: 46.071429, ('air_083ddc520ea47e1e',): RollingMean: 12.642857, ('air_0845d8395f30c6bb',): RollingMean: 22.714286, ('air_084d98859256acf0',): RollingMean: 16.142857, ('air_0867f7bebad6a649',): RollingMean: 21., ('air_08ba8cd01b3ba010',): RollingMean: 10.285714, ('air_08cb3c4ee6cd6a22',): RollingMean: 12.642857, ('air_08ef81d5b7a0d13f',): RollingMean: 14.5, ('air_08f994758a1e76d4',): RollingMean: 28., ('air_09040f6df960ddb8',): RollingMean: 15.571429, ('air_0919d54f0c9a24b8',): RollingMean: 35.857143, ('air_09661c0f3259cc04',): RollingMean: 28.857143, ('air_09a845d5b5944b01',): RollingMean: 6.928571, ('air_09fd1f5c58583141',): RollingMean: 8.642857, ('air_0a74a5408a0b8642',): RollingMean: 28.428571, ('air_0b184ec04c741a6a',): RollingMean: 12.857143, ('air_0b1e72d2d4422b20',): RollingMean: 20.928571, ('air_0b9038300f8b2b50',): RollingMean: 11.428571, ('air_0e1eae99b8723bc1',): RollingMean: 10.642857, ('air_0e7c11b9abc50163',): RollingMean: 35.071429, ('air_0ead98dd07e7a82a',): RollingMean: 13.571429, ('air_0f0cdeee6c9bf3d7',): RollingMean: 22.071429, ('air_0f2f96335f274801',): RollingMean: 9.928571, ('air_0f60e1576a7d397d',): RollingMean: 6.214286, ('air_1033310359ceeac1',): RollingMean: 18.642857, ('air_10393f12e9069760',): RollingMean: 13.571429, ('air_105a7954e32dba9b',): RollingMean: 51.5, ('air_10713fbf3071c361',): RollingMean: 12.285714, ('air_10bbe8acd943d8f6',): RollingMean: 30.857143, ('air_12c4fb7a423df20d',): RollingMean: 20.071429, ('air_138ee734ac79ff90',): RollingMean: 7.214286, ('air_138ff410757b845f',): RollingMean: 54.428571, ('air_1408dd53f31a8a65',): RollingMean: 27.857143, ('air_142e78ba7001da9c',): RollingMean: 13.642857, ('air_1509881b22965b34',): RollingMean: 19., ('air_152c1f08d7d20e07',): RollingMean: 11.857143, ('air_15ae33469e9ea2dd',): RollingMean: 10.285714, ('air_15e6e15c7ea2c162',): RollingMean: 18.642857, ('air_16179d43b6ee5fd8',): RollingMean: 7.714286, ('air_1653a6c513865af3',): RollingMean: 32.5, ('air_168441ada3e878e1',): RollingMean: 45.714286, ('air_16c4cfddeb2cf69b',): RollingMean: 12.071429, ('air_16cf0a73233896de',): RollingMean: 11.428571, ('air_1707a3f18bb0da07',): RollingMean: 26.214286, ('air_17a6ab40f97fd4d8',): RollingMean: 8.285714, ('air_17bed6dbf7c8b0fc',): RollingMean: 19.785714, ('air_1979eaff8189d086',): RollingMean: 9.071429, ('air_1ab60ce33bfed8a8',): RollingMean: 9.642857, ('air_1ae94f514a0bce13',): RollingMean: 7., ('air_1ba4e87ef7422183',): RollingMean: 38.714286, ('air_1c0b150f9e696a5f',): RollingMean: 100.785714, ('air_1c95a84924d72500',): RollingMean: 8.714286, ('air_1d1e8860ae04f8e9',): RollingMean: 15.071429, ('air_1d25ca6c76df48b4',): RollingMean: 42.214286, ('air_1d3f797dd1f7cf1c',): RollingMean: 33.571429, ('air_1dd8f6f47480d1a2',): RollingMean: 37.428571, ('air_1dea9815ccd36620',): RollingMean: 10.5, ('air_1e23210b584540e7',): RollingMean: 3.857143, ('air_1e665503b8474c55',): RollingMean: 5.785714, ('air_1eeff462acb24fb7',): RollingMean: 16.428571, ('air_1f1390a8be2272b3',): RollingMean: 18.214286, ('air_1f34e9beded2231a',): RollingMean: 8.214286, ('air_1f7f8fa557bc0d55',): RollingMean: 3.928571, ('air_2009041dbf9264de',): RollingMean: 51.285714, ('air_20619d21192aa571',): RollingMean: 16.785714, ('air_20add8092c9bb51d',): RollingMean: 31.642857, ('air_2195cd5025a98033',): RollingMean: 29.428571, ('air_21f5052d5330528d',): RollingMean: 30.857143, ('air_220cba70c890b119',): RollingMean: 7.928571, ('air_22682e965418936f',): RollingMean: 10., ('air_228f10bec0bda9c8',): RollingMean: 16.785714, ('air_229d7e508d9f1b5e',): RollingMean: 9.571429, ('air_232dcee6f7c51d37',): RollingMean: 5.571429, ('air_234d3dbf7f3d5a50',): RollingMean: 7.642857, ('air_23e1b11aee2a1407',): RollingMean: 46., ('air_23ee674e91469086',): RollingMean: 20.714286, ('air_24b9b2a020826ede',): RollingMean: 31.5, ('air_24e8414b9b07decb',): RollingMean: 6.071429, ('air_2545dd3a00f265e2',): RollingMean: 46.785714, ('air_256be208a979e023',): RollingMean: 7.428571, ('air_2570ccb93badde68',): RollingMean: 39.357143, ('air_258ad2619d7bff9a',): RollingMean: 36.714286, ('air_258dc112912fc458',): RollingMean: 61.428571, ('air_25c583983246b7b0',): RollingMean: 24.428571, ('air_25d8e5cc57dd87d9',): RollingMean: 24.928571, ('air_25e9888d30b386df',): RollingMean: 4.928571, ('air_2634e41551e9807d',): RollingMean: 14.857143, ('air_26c5bbeb7bb82bf1',): RollingMean: 27.071429, ('air_26f10355d9b4d82a',): RollingMean: 33.785714, ('air_2703dcb33192b181',): RollingMean: 52.428571, ('air_275732a5db46f4d3',): RollingMean: 15.928571, ('air_27e991812b0d9c92',): RollingMean: 41.428571, ('air_28064154614b2e6c',): RollingMean: 22.857143, ('air_287d2de7d3c93406',): RollingMean: 13., ('air_28a9fa1ec0839375',): RollingMean: 29.071429, ('air_28dbe91c4c9656be',): RollingMean: 33.571429, ('air_290e7a57b390f78e',): RollingMean: 13.857143, ('air_298513175efdf261',): RollingMean: 26.428571, ('air_2a184c1745274b2b',): RollingMean: 4.214286, ('air_2a24aec099333f39',): RollingMean: 7.285714, ('air_2a3743e37aab04b4',): RollingMean: 20.071429, ('air_2a485b92210c98b5',): RollingMean: 18.142857, ('air_2a7f14da7fe0f699',): RollingMean: 27.214286, ('air_2aab19554f91ff82',): RollingMean: 49.714286, ('air_2ac361b97630e2df',): RollingMean: 12.071429, ('air_2b8b29ddfd35018e',): RollingMean: 10.928571, ('air_2b9bc9f5f5168ea1',): RollingMean: 21.428571, ('air_2bffb19a24d11729',): RollingMean: 12.428571, ('air_2c505f9ad67d4635',): RollingMean: 16.5, ('air_2c6c79d597e48096',): RollingMean: 17.928571, ('air_2c6fef1ce0e13a5a',): RollingMean: 30.785714, ('air_2c989829acbd1c6b',): RollingMean: 28.357143, ('air_2cee51fa6fdf6c0d',): RollingMean: 16.571429, ('air_2d3afcb91762fe01',): RollingMean: 45.142857, ('air_2d78d9a1f4dd02ca',): RollingMean: 11.357143, ('air_2e7cb1f1a2a9cd6a',): RollingMean: 27.571429, ('air_2f8ced25216df926',): RollingMean: 14.142857, ('air_2fc149abe33adcb4',): RollingMean: 35.214286, ('air_2fc478dc9f0a6b31',): RollingMean: 11.428571, ('air_2fed81034f8834e5',): RollingMean: 20.714286, ('air_303bac187b53083a',): RollingMean: 10.428571, ('air_310e467e6e625004',): RollingMean: 15.214286, ('air_3155ee23d92202da',): RollingMean: 16.5, ('air_31c753b48a657b6c',): RollingMean: 24.285714, ('air_32460819c7600037',): RollingMean: 51.071429, ('air_324f7c39a8410e7c',): RollingMean: 10.928571, ('air_326ca454ef3558bc',): RollingMean: 22.214286, ('air_32b02ba5dc2027f4',): RollingMean: 27.5, ('air_32c61b620a766138',): RollingMean: 26.785714, ('air_32f5d7cd696e3c4a',): RollingMean: 23.142857, ('air_33b01025210d6007',): RollingMean: 11.785714, ('air_3440e0ea1b70a99b',): RollingMean: 28., ('air_346ade7d29230634',): RollingMean: 7.857143, ('air_347be2c4feeb408b',): RollingMean: 21.071429, ('air_349278fa964bb12f',): RollingMean: 19.214286, ('air_3525f11ef0bf0c35',): RollingMean: 41.142857, ('air_35512c42db0868da',): RollingMean: 6.071429, ('air_3561fd1c0bce6a95',): RollingMean: 10.714286, ('air_35c4732dcbfe31be',): RollingMean: 6.785714, ('air_36429b5ca4407b3e',): RollingMean: 20., ('air_36bcf77d3382d36e',): RollingMean: 32.5, ('air_37189c92b6c761ec',): RollingMean: 14.857143, ('air_375a5241615b5e22',): RollingMean: 7., ('air_382f5ace4e2247b8',): RollingMean: 7.785714, ('air_383f5b2f8d345a49',): RollingMean: 12.357143, ('air_38746ffe9aa20c7e',): RollingMean: 3.785714, ('air_396166d47733d5c9',): RollingMean: 24.714286, ('air_396942e6423a2145',): RollingMean: 21.857143, ('air_397d3f32a7196aa2',): RollingMean: 35.5, ('air_3980af67be35afdb',): RollingMean: 15.785714, ('air_3982a2c4ea2ed431',): RollingMean: 30.5, ('air_399904bdb7685ca0',): RollingMean: 27.785714, ('air_39dccf7df20b1c6a',): RollingMean: 26.714286, ('air_3a8a3f8fb5cd7f88',): RollingMean: 21.214286, ('air_3aa839e8e0cb6c87',): RollingMean: 27.5, ('air_3ac24136722e2291',): RollingMean: 13.142857, ('air_3b20733899b5287f',): RollingMean: 39.857143, ('air_3b6438b125086430',): RollingMean: 13.285714, ('air_3bb99a1fe0583897',): RollingMean: 40.285714, ('air_3bd49f98ab7f36ab',): RollingMean: 13., ('air_3c05c8f26c611eb9',): RollingMean: 25.285714, ('air_3c938075889fc059',): RollingMean: 30.5, ('air_3cad29d1a23209d2',): RollingMean: 8.357143, ('air_3caef3f76b8f26c5',): RollingMean: 25.642857, ('air_3d3a2b509180e798',): RollingMean: 17.714286, ('air_3e6cea17a9d2c0f1',): RollingMean: 17.071429, ('air_3e93f3c81008696d',): RollingMean: 34.214286, ('air_3f91d592acd6cc0b',): RollingMean: 24.928571, ('air_401b39f97e56b939',): RollingMean: 11.785714, ('air_4043b7ccfbffa732',): RollingMean: 44.571429, ('air_4092cfbd95a3ac1b',): RollingMean: 23., ('air_40953e2d8b4f2857',): RollingMean: 15.428571, ('air_40f6193ea3ed1b91',): RollingMean: 16.714286, ('air_414ff459ed18fa48',): RollingMean: 16., ('air_41bbf6e1d9814c4b',): RollingMean: 8.714286, ('air_421670f21da5ba31',): RollingMean: 17.928571, ('air_4254c3fc3ad078bd',): RollingMean: 11.357143, ('air_42c9aa6d617c5057',): RollingMean: 42.714286, ('air_42d41eb58cad170e',): RollingMean: 32.285714, ('air_43b65e4b05bff2d3',): RollingMean: 20.642857, ('air_43d577e0c9460e64',): RollingMean: 35.142857, ('air_4433ab8e9999915f',): RollingMean: 21.142857, ('air_4481a87c1d7c9896',): RollingMean: 20.928571, ('air_452100f5305dde64',): RollingMean: 7.428571, ('air_45326ebb8dc72cfb',): RollingMean: 29.142857, ('air_4570f52104fe0982',): RollingMean: 7.357143, ('air_4579cb0669fd411b',): RollingMean: 18.071429, ('air_457efe8c3a30ea17',): RollingMean: 6.285714, ('air_464a62de0d57be1e',): RollingMean: 26.857143, ('air_465bddfed3353b23',): RollingMean: 27.071429, ('air_47070be6093f123e',): RollingMean: 46.285714, ('air_472b19e3b5bffa41',): RollingMean: 13.5, ('air_473cf23b9e7c0a37',): RollingMean: 9.357143, ('air_473f98b212d37b4a',): RollingMean: 27.357143, ('air_47beaffd3806c979',): RollingMean: 19.214286, ('air_483eba479dc9910d',): RollingMean: 21.642857, ('air_48e9fc98b62495a7',): RollingMean: 17.071429, ('air_48f4da6223571da4',): RollingMean: 22.571429, ('air_48ffd31594bc3263',): RollingMean: 4.928571, ('air_49211568cab5fdee',): RollingMean: 25., ('air_4974785f48853db9',): RollingMean: 6.928571, ('air_4b251b9f8373f1ae',): RollingMean: 26.928571, ('air_4b380b4db9d37883',): RollingMean: 25.571429, ('air_4b55d8aea1d2b395',): RollingMean: 34.285714, ('air_4b9085d0d46a6211',): RollingMean: 28.142857, ('air_4beac252540f865e',): RollingMean: 41.571429, ('air_4c2ed28f3f19ca52',): RollingMean: 14.642857, ('air_4c665a2bfff0da3b',): RollingMean: 8.857143, ('air_4c727b55acdee495',): RollingMean: 15.357143, ('air_4cab15ad29c0ffbc',): RollingMean: 21.214286, ('air_4cab91146e3d1897',): RollingMean: 15., ('air_4cca5666eaf5c709',): RollingMean: 34.428571, ('air_4ce7b17062a1bf73',): RollingMean: 7.857143, ('air_4d21676ed11f0bac',): RollingMean: 32.857143, ('air_4d71826793c09b22',): RollingMean: 21.642857, ('air_4d90a22572fa1ec9',): RollingMean: 25.785714, ('air_4de6d887a7b1c1fc',): RollingMean: 15.357143, ('air_4dea8d17f6f59c56',): RollingMean: 25.214286, ('air_4e1c38f68f435596',): RollingMean: 34.071429, ('air_4f762e840b3996e1',): RollingMean: 11.285714, ('air_4feeb8600f131e43',): RollingMean: 57.714286, ('air_500641aca4cf673c',): RollingMean: 15.142857, ('air_506fe758114df773',): RollingMean: 28.428571, ('air_51281cd059d7b89b',): RollingMean: 13.928571, ('air_51319e7acf0438cf',): RollingMean: 13.571429, ('air_52a08ef3efdb4bb0',): RollingMean: 47.928571, ('air_52e2a1fd42bc917a',): RollingMean: 11.642857, ('air_536043fcf1a4f8a4',): RollingMean: 30.071429, ('air_539d693f7317c62d',): RollingMean: 18., ('air_546b353cbea4a45b',): RollingMean: 17.357143, ('air_5485912b44f976de',): RollingMean: 8.428571, ('air_54d6c25d33f5260e',): RollingMean: 40.5, ('air_54ed43163b7596c4',): RollingMean: 16.5, ('air_55390f784018349a',): RollingMean: 46., ('air_55c3627912b9c849',): RollingMean: 10., ('air_55e11c33d4758131',): RollingMean: 22.071429, ('air_56cd12f31a0afc04',): RollingMean: 29.785714, ('air_56cebcbd6906e04c',): RollingMean: 17.357143, ('air_56ea46c14b2dd967',): RollingMean: 42.214286, ('air_57013002b912772b',): RollingMean: 5.571429, ('air_573ecdf81b157d22',): RollingMean: 28.285714, ('air_57c9eea1a2b66e65',): RollingMean: 14.357143, ('air_57ed725a1930a5b9',): RollingMean: 15.642857, ('air_5878b6f2a9da12c1',): RollingMean: 13.357143, ('air_59cc9b2b209c6331',): RollingMean: 9.071429, ('air_5a9a6cbeeb434c08',): RollingMean: 23.071429, ('air_5acc13d655a6e8b2',): RollingMean: 24.071429, ('air_5afb1cca48ceaa19',): RollingMean: 42.142857, ('air_5b6d18c470bbfaf9',): RollingMean: 37.285714, ('air_5b704df317ed1962',): RollingMean: 2.214286, ('air_5bd22f9cc1426a90',): RollingMean: 32.357143, ('air_5c65468938c07fa5',): RollingMean: 16.214286, ('air_5c7489c9ec755e2d',): RollingMean: 33.428571, ('air_5c817ef28f236bdf',): RollingMean: 42.428571, ('air_5cb030b9f0b91537',): RollingMean: 11.071429, ('air_5cfc537125d97f16',): RollingMean: 9.571429, ('air_5d7c744c3a2ef624',): RollingMean: 32.428571, ('air_5d945ade487cdf4d',): RollingMean: 13.5, ('air_5dea8a7a5bf5eb71',): RollingMean: 28.285714, ('air_5e339a1f364cdb00',): RollingMean: 11.285714, ('air_5e34c6fe6fabd10e',): RollingMean: 20.357143, ('air_5e70fe82f9e4fab6',): RollingMean: 15.5, ('air_5e939e005bd34633',): RollingMean: 2.571429, ('air_5ed3198e4a5eed0f',): RollingMean: 38.071429, ('air_5f3a3ef4cba110a4',): RollingMean: 32.214286, ('air_5f6fa1b897fe80d5',): RollingMean: 29.785714, ('air_5fbda8e9302f7c13',): RollingMean: 27.928571, ('air_602ca92c0db34f8f',): RollingMean: 19., ('air_609050e4e4f79ae1',): RollingMean: 11.857143, ('air_60a7057184ec7ec7',): RollingMean: 27.857143, ('air_60aa54ecbc602348',): RollingMean: 5.428571, ('air_6108821ffafa9b72',): RollingMean: 24.785714, ('air_614e2f7e76dff854',): RollingMean: 11.857143, ('air_61668cc2b0778898',): RollingMean: 8.428571, ('air_61b8d37c33617f21',): RollingMean: 27.428571, ('air_61de73b097513f58',): RollingMean: 9.714286, ('air_622375b4815cf5cb',): RollingMean: 37.5, ('air_627cabe2fe53f33f',): RollingMean: 14.5, ('air_629d9935273c82ae',): RollingMean: 23.142857, ('air_629edf21ea38ac2d',): RollingMean: 35.214286, ('air_632ba66e1f75aa28',): RollingMean: 19.142857, ('air_638c35eb25e53eea',): RollingMean: 19.5, ('air_63a750d8b4b6a976',): RollingMean: 23.428571, ('air_63a88d81295195ed',): RollingMean: 29.5, ('air_63b13c56b7201bd9',): RollingMean: 22.285714, ('air_63e28ee0b0c955a7',): RollingMean: 22., ('air_640cf4835f0d9ba3',): RollingMean: 26.714286, ('air_6411203a47b5ec77',): RollingMean: 8.928571, ('air_645cb18b33f938cf',): RollingMean: 17.071429, ('air_646b93e336f0dded',): RollingMean: 7.428571, ('air_64a5d5c1381837af',): RollingMean: 40., ('air_64d4491ad8cdb1c6',): RollingMean: 13.714286, ('air_650f9b9de0c5542c',): RollingMean: 22.428571, ('air_657a0748462f85de',): RollingMean: 8., ('air_65e294f1ae6df9c3',): RollingMean: 22.214286, ('air_6607fe3671242ce3',): RollingMean: 42.571429, ('air_670a0c1c4108bcea',): RollingMean: 25., ('air_671b4bea84dafb67',): RollingMean: 26.071429, ('air_673acd9fa5e0dd78',): RollingMean: 6.214286, ('air_67483104fa38ef6c',): RollingMean: 29.571429, ('air_675aa35cba456fd1',): RollingMean: 43.642857, ('air_67f87c159d9e2ee2',): RollingMean: 36.5, ('air_68147db09287bf74',): RollingMean: 24., ('air_681b0c56328dd2af',): RollingMean: 35., ('air_681f96e6a6595f82',): RollingMean: 37.285714, ('air_68301bcb11e2f389',): RollingMean: 26.428571, ('air_683371d9baabf410',): RollingMean: 31.071429, ('air_6836438b543ba698',): RollingMean: 12.928571, ('air_6873982b9e19c7ad',): RollingMean: 5., ('air_68c1de82037d87e6',): RollingMean: 25.785714, ('air_68cc910e7b307b09',): RollingMean: 7.928571, ('air_68d075113f368946',): RollingMean: 20.285714, ('air_6902e4ec305b3d08',): RollingMean: 36.857143, ('air_694571ea13fb9e0e',): RollingMean: 30.571429, ('air_6a15e4eae523189d',): RollingMean: 17.785714, ('air_6b15edd1b4fbb96a',): RollingMean: 31.785714, ('air_6b2268863b14a2af',): RollingMean: 18.857143, ('air_6b65745d432fd77f',): RollingMean: 23.571429, ('air_6b7678aae65d2d59',): RollingMean: 6.928571, ('air_6b942d5ebbc759c2',): RollingMean: 14.714286, ('air_6b9fa44a9cf504a1',): RollingMean: 5.785714, ('air_6c1128955c58b690',): RollingMean: 13., ('air_6c91a28278a16f64',): RollingMean: 8.642857, ('air_6c952e3c6e590945',): RollingMean: 15.642857, ('air_6ca1d941c8199a67',): RollingMean: 26.071429, ('air_6cbe54f0aa30b615',): RollingMean: 15.571429, ('air_6ced51c24fb54262',): RollingMean: 7.785714, ('air_6d64dba2edd4fc0c',): RollingMean: 9.428571, ('air_6d65542aa43b598b',): RollingMean: 27.785714, ('air_6d65dd11d96e00fb',): RollingMean: 4.428571, ('air_6e06824d0934dd81',): RollingMean: 21.928571, ('air_6e3fd96320d24324',): RollingMean: 8.285714, ('air_6e64fb5821402cd2',): RollingMean: 8.357143, ('air_6ff5fca957798daa',): RollingMean: 7.857143, ('air_707d4b6328f2c2df',): RollingMean: 28.5, ('air_709262d948dd0b6e',): RollingMean: 11.071429, ('air_70e9e8cd55879414',): RollingMean: 10.928571, ('air_70f834596eb99fee',): RollingMean: 21.428571, ('air_710d6537cb7623df',): RollingMean: 32.071429, ('air_712dd258f7f91b4b',): RollingMean: 15.714286, ('air_71903025d39a4571',): RollingMean: 14.642857, ('air_722297e7f26db91d',): RollingMean: 11.071429, ('air_728ff578acc6ac6e',): RollingMean: 10.571429, ('air_72f5146cf0c49beb',): RollingMean: 12.214286, ('air_735bcbe1763d6e98',): RollingMean: 8.642857, ('air_73f316e6a18d8aa9',): RollingMean: 22.785714, ('air_7420042ff75f9aca',): RollingMean: 35., ('air_746211c0b532e8aa',): RollingMean: 53.5, ('air_747f375eb3900e1e',): RollingMean: 5.5, ('air_74cf22153214064c',): RollingMean: 10.142857, ('air_7514d90009613cd6',): RollingMean: 66.928571, ('air_754ae581ad80cc9f',): RollingMean: 13.928571, ('air_75864c80d2fb334a',): RollingMean: 10.357143, ('air_75bd5d1b6dc6670d',): RollingMean: 14.142857, ('air_764f71040a413d4d',): RollingMean: 49.428571, ('air_77488fa378cf98c3',): RollingMean: 9., ('air_77dfc83450cbc89c',): RollingMean: 41.571429, ('air_7831b00996701c0f',): RollingMean: 23.5, ('air_789103bf53b8096b',): RollingMean: 55.928571, ('air_789466e488705c93',): RollingMean: 24.928571, ('air_78df4dc6a7e83e41',): RollingMean: 17.5, ('air_79afb3f52b4d062c',): RollingMean: 10., ('air_79f528087f49df06',): RollingMean: 34.071429, ('air_7a81bd7fadcbf3d8',): RollingMean: 5., ('air_7a946aada80376a4',): RollingMean: 16., ('air_7bacc4d36fb094c9',): RollingMean: 6.142857, ('air_7bc6ca04d7b0f3b8',): RollingMean: 12.071429, ('air_7bda6048a4a78837',): RollingMean: 23.857143, ('air_7c7774c66fb237f7',): RollingMean: 8.714286, ('air_7cc17a324ae5c7dc',): RollingMean: 14.714286, ('air_7cf5a02c0e01b647',): RollingMean: 33.214286, ('air_7d65049f9d275c0d',): RollingMean: 10.857143, ('air_7dacea2f22afccfb',): RollingMean: 32.357143, ('air_7db266904cb0d72a',): RollingMean: 13., ('air_7e12c5d27f44a8de',): RollingMean: 23.785714, ('air_7ef9a5ea5c8fe39f',): RollingMean: 11.142857, ('air_7f3dc18494bce98b',): RollingMean: 14.071429, ('air_7f9e15afafcf4c75',): RollingMean: 35.428571, ('air_7fbf7649eb13ad9b',): RollingMean: 18.714286, ('air_800c02226e2e0288',): RollingMean: 13.785714, ('air_8093d0b565e9dbdf',): RollingMean: 37., ('air_8110d68cc869b85e',): RollingMean: 45.642857, ('air_81546875de9c8e78',): RollingMean: 4.642857, ('air_81a12d67c22e012f',): RollingMean: 20.285714, ('air_81bd68142db76f58',): RollingMean: 25.357143, ('air_81c2600146d07d16',): RollingMean: 6.5, ('air_81c5dff692063446',): RollingMean: 11.285714, ('air_820d1919cbecaa0a',): RollingMean: 33.357143, ('air_82a6ae14151953ba',): RollingMean: 37.357143, ('air_831658500aa7c846',): RollingMean: 29.928571, ('air_832f9dbe9ee4ebd3',): RollingMean: 13.285714, ('air_83db5aff8f50478e',): RollingMean: 7.5, ('air_84060403939d8216',): RollingMean: 15.285714, ('air_848616680ef061bd',): RollingMean: 29.857143, ('air_84f6876ff7e83ae7',): RollingMean: 19.214286, ('air_8523d6a70de49e6c',): RollingMean: 33.785714, ('air_859feab8e3c9f98d',): RollingMean: 22.571429, ('air_85bd13a49370c392',): RollingMean: 11.928571, ('air_86cfbf2624576fad',): RollingMean: 6.857143, ('air_86f7b2109e4abd65',): RollingMean: 49.428571, ('air_87059630ab6fe47f',): RollingMean: 3.714286, ('air_87078cf7903a648c',): RollingMean: 6., ('air_87467487d21891dd',): RollingMean: 13.571429, ('air_8764b3473ddcceaf',): RollingMean: 5., ('air_876d7a23c47811cb',): RollingMean: 15.928571, ('air_877f79706adbfb06',): RollingMean: 12.142857, ('air_87ca98aa7664de94',): RollingMean: 10.714286, ('air_87f9e1024b951f01',): RollingMean: 11.285714, ('air_883ca28ef0ed3d55',): RollingMean: 14.142857, ('air_88c8e34baa79217b',): RollingMean: 30.714286, ('air_88ca84051ba95339',): RollingMean: 18.642857, ('air_88f31db64991768a',): RollingMean: 8.785714, ('air_890d7e28e8eaaa11',): RollingMean: 8.071429, ('air_89e7328af22efe74',): RollingMean: 34., ('air_8a1d21fad48374e8',): RollingMean: 11.857143, ('air_8a59bb0c497b771e',): RollingMean: 27.214286, ('air_8a906e5801eac81c',): RollingMean: 23.357143, ('air_8b4a46dc521bfcfe',): RollingMean: 29.071429, ('air_8c119d1f16049f20',): RollingMean: 25.428571, ('air_8c3175aa5e4fc569',): RollingMean: 80.071429, ('air_8cc350fd70ee0757',): RollingMean: 32., ('air_8ce035ee1d8a56a6',): RollingMean: 18.357143, ('air_8d50c64692322dff',): RollingMean: 10.785714, ('air_8d61f49aa0373492',): RollingMean: 45.642857, ('air_8e429650fcf7a0ae',): RollingMean: 19.214286, ('air_8e4360a64dbd4c50',): RollingMean: 20.357143, ('air_8e492076a1179383',): RollingMean: 43.642857, ('air_8e8f42f047537154',): RollingMean: 29.357143, ('air_8ec47c0f1e2c879e',): RollingMean: 30.714286, ('air_8f13ef0f5e8c64dd',): RollingMean: 6.285714, ('air_8f273fb9ad2fed6f',): RollingMean: 13.071429, ('air_8f3b563416efc6ad',): RollingMean: 13.642857, ('air_900d755ebd2f7bbd',): RollingMean: 92.071429, ('air_901925b628677c2e',): RollingMean: 9.142857, ('air_90213bcae4afa274',): RollingMean: 27.357143, ('air_90bd5de52c166767',): RollingMean: 22.071429, ('air_90ed0a2f24755533',): RollingMean: 41.785714, ('air_90f0efbb702d77b7',): RollingMean: 32.214286, ('air_9105a29b0eb250d2',): RollingMean: 18.285714, ('air_91236b89d29567af',): RollingMean: 23.071429, ('air_9152d9926e5c4a3a',): RollingMean: 36.142857, ('air_915558a55c2bc56c',): RollingMean: 17.785714, ('air_91beafbba9382b0a',): RollingMean: 36.5, ('air_91d72e16c4bcba55',): RollingMean: 14.785714, ('air_9241121af22ff1d6',): RollingMean: 29.928571, ('air_929d8513e3cdb423',): RollingMean: 7., ('air_931a8a4321b6e7d1',): RollingMean: 5.142857, ('air_9352c401d5adb01b',): RollingMean: 25.571429, ('air_9387ff95e886ebc7',): RollingMean: 13.214286, ('air_938ef91ecdde6878',): RollingMean: 23.214286, ('air_939964477035ef0b',): RollingMean: 17.928571, ('air_93b9bb641f8fc982',): RollingMean: 28.285714, ('air_93dd7070c9bf5453',): RollingMean: 29.428571, ('air_93ebe490d4abb8e9',): RollingMean: 17.714286, ('air_9438d67241c81314',): RollingMean: 37., ('air_947eb2cae4f3e8f2',): RollingMean: 32.071429, ('air_9483d65e9cc9a6b7',): RollingMean: 15.285714, ('air_950381108f839348',): RollingMean: 28.142857, ('air_95d28905941fd4cb',): RollingMean: 30.785714, ('air_95e917913cd988f3',): RollingMean: 23.642857, ('air_96005f79124e12bf',): RollingMean: 40.428571, ('air_965b2e0cf4119003',): RollingMean: 47.357143, ('air_96743eee94114261',): RollingMean: 13.428571, ('air_96773a6236d279b1',): RollingMean: 24.785714, ('air_968d72c12eed09f0',): RollingMean: 18., ('air_96929a799b12a43e',): RollingMean: 27.214286, ('air_96ec3cfe78cb0652',): RollingMean: 18.5, ('air_97159fc4e90053fe',): RollingMean: 24., ('air_97958e7fce98b6a3',): RollingMean: 16.928571, ('air_97b2a9f975fc702c',): RollingMean: 40.142857, ('air_97cf68dc1a9beac0',): RollingMean: 13.428571, ('air_97e0f2feec4d577a',): RollingMean: 15.071429, ('air_9828505fefc77d75',): RollingMean: 12.5, ('air_98b54e32ccddd896',): RollingMean: 18.214286, ('air_990a642a3deb2903',): RollingMean: 33.5, ('air_99157b6163835eec',): RollingMean: 33.785714, ('air_99a5183695b849f9',): RollingMean: 30.928571, ('air_99b01136f451fc0e',): RollingMean: 41.428571, ('air_99c3eae84130c1cb',): RollingMean: 39.928571, ('air_9a30407764f4ff84',): RollingMean: 17., ('air_9a6f6e7f623003d2',): RollingMean: 3.142857, ('air_9aa32b3db0fab3a5',): RollingMean: 17.142857, ('air_9aa92007e3628dbc',): RollingMean: 31.642857, ('air_9ae7081cb77dc51e',): RollingMean: 29.571429, ('air_9b13c7feb0a0c431',): RollingMean: 10.714286, ('air_9b6af3db40da4ae2',): RollingMean: 29.785714, ('air_9bbc673495e23532',): RollingMean: 5.142857, ('air_9bf0ccac497c4af3',): RollingMean: 44.571429, ('air_9bf595ef095572fb',): RollingMean: 25.642857, ('air_9c6787aa03a45586',): RollingMean: 92.142857, ('air_9ca2767761efff4d',): RollingMean: 8.357143, ('air_9cd5e310f488bced',): RollingMean: 14.642857, ('air_9cf2f1ba86229773',): RollingMean: 34., ('air_9d3482b4680aee88',): RollingMean: 9.785714, ('air_9d452a881f7f2bb7',): RollingMean: 7.857143, ('air_9d474ec2448c700d',): RollingMean: 12.857143, ('air_9d5a980b211e1795',): RollingMean: 11.571429, ('air_9d93d95720f2e831',): RollingMean: 8.285714, ('air_9dc9483f717d73ee',): RollingMean: 5.571429, ('air_9dd7d38b0f1760c4',): RollingMean: 2.5, ('air_9e920b758503ef54',): RollingMean: 5.5, ('air_9efaa7ded03c5a71',): RollingMean: 12.214286, ('air_9f277fb7a2c1d842',): RollingMean: 12.142857, ('air_9fc607777ad76b26',): RollingMean: 15.928571, ('air_a083834e7ffe187e',): RollingMean: 20.285714, ('air_a11473cc1eb9a27f',): RollingMean: 33.071429, ('air_a17f0778617c76e2',): RollingMean: 38., ('air_a1fe8c588c8d2f30',): RollingMean: 15.785714, ('air_a218912784bf767d',): RollingMean: 14.357143, ('air_a21ffca0bea1661a',): RollingMean: 1.071429, ('air_a239a44805932bab',): RollingMean: 34.428571, ('air_a24bf50c3e90d583',): RollingMean: 17.285714, ('air_a2567267116a3b75',): RollingMean: 16.642857, ('air_a257c9749d8d0ff6',): RollingMean: 18.428571, ('air_a271c9ba19e81d17',): RollingMean: 28.857143, ('air_a2b29aa7feb4e36f',): RollingMean: 16.642857, ('air_a304330715435390',): RollingMean: 7.642857, ('air_a33461f4392ec62c',): RollingMean: 28.142857, ('air_a373500730e2a9e0',): RollingMean: 11., ('air_a38f25e3399d1b25',): RollingMean: 41.857143, ('air_a41b032371a63427',): RollingMean: 11.357143, ('air_a49f1cf0634f13e5',): RollingMean: 22.214286, ('air_a510dcfe979f09eb',): RollingMean: 13.714286, ('air_a546cbf478a8b6e4',): RollingMean: 27.5, ('air_a55d17bd3f3033cb',): RollingMean: 12.285714, ('air_a563896da3777078',): RollingMean: 21.571429, ('air_a678e5b144ca24ce',): RollingMean: 16.714286, ('air_a7404a854919e990',): RollingMean: 7.357143, ('air_a8533b7a992bb0ca',): RollingMean: 18.571429, ('air_a85f0c0c889f6b7e',): RollingMean: 47.571429, ('air_a85f8c0bfd61889f',): RollingMean: 15.142857, ('air_a88ac559064dec08',): RollingMean: 32.142857, ('air_a9133955abccf071',): RollingMean: 27.785714, ('air_a9178f19da58fe99',): RollingMean: 7.428571, ('air_a9a380530c1e121f',): RollingMean: 41.285714, ('air_aa0049fe3cc6f4d6',): RollingMean: 10.142857, ('air_ab3ae0e410b20069',): RollingMean: 17.928571, ('air_ab9746a0f83084b7',): RollingMean: 6.714286, ('air_abcdc8115988a010',): RollingMean: 10.857143, ('air_abf06fcca748dca5',): RollingMean: 9.5, ('air_ac7a7427c9ae12a5',): RollingMean: 62.071429, ('air_ad13e71e21235131',): RollingMean: 16.071429, ('air_ad60f6b76c9df7ed',): RollingMean: 23.357143, ('air_ad7777590c884721',): RollingMean: 8.357143, ('air_add9a575623726c8',): RollingMean: 40.285714, ('air_ade6e836ffd1da64',): RollingMean: 10.214286, ('air_aed3a8b49abe4a48',): RollingMean: 6.214286, ('air_af03c277a167b2bd',): RollingMean: 26.642857, ('air_af24e3e817dea1e5',): RollingMean: 15.357143, ('air_af63df35857b16e6',): RollingMean: 23.857143, ('air_b0a6a4c5e95c74cf',): RollingMean: 18.642857, ('air_b162fb07fbbdea33',): RollingMean: 15.285714, ('air_b192fb5310436005',): RollingMean: 8.785714, ('air_b1a72bf1ebf4b8ef',): RollingMean: 52.285714, ('air_b1bb1fae86617d7a',): RollingMean: 34.428571, ('air_b1d822f75c9fc615',): RollingMean: 10.785714, ('air_b2395df0e874078d',): RollingMean: 7.071429, ('air_b23d0f519291247d',): RollingMean: 28.785714, ('air_b259b4e4a51a690d',): RollingMean: 22.785714, ('air_b28bed4b2e7167b7',): RollingMean: 16.928571, ('air_b2a639cc7e02edf1',): RollingMean: 20.714286, ('air_b2d8bc9c88b85f96',): RollingMean: 14.714286, ('air_b2d97bd2337c5ba7',): RollingMean: 28.785714, ('air_b2dcec37b83e2494',): RollingMean: 7.428571, ('air_b30fffd7ab1e75a5',): RollingMean: 9.214286, ('air_b3180b74332ba886',): RollingMean: 13.857143, ('air_b3a824511477a4ed',): RollingMean: 6.214286, ('air_b439391e72899756',): RollingMean: 19.928571, ('air_b45b8e456f53942a',): RollingMean: 10.857143, ('air_b4f32bcc399da2b9',): RollingMean: 29.071429, ('air_b5598d12d1b84890',): RollingMean: 5.857143, ('air_b5bdd318005d9aa4',): RollingMean: 34., ('air_b60cc7d6aee68194',): RollingMean: 11.357143, ('air_b711b43ae472cb6b',): RollingMean: 20.642857, ('air_b7fa3d2fca744dd2',): RollingMean: 40.785714, ('air_b80fed1a07c817d2',): RollingMean: 4.285714, ('air_b88192b35ac03c24',): RollingMean: 17.5, ('air_b8925441167c3152',): RollingMean: 2.071429, ('air_b8a5ee69e5fdcc5b',): RollingMean: 34.142857, ('air_b8d9e1624baaadc2',): RollingMean: 6.214286, ('air_b9e27558fb8bd5c4',): RollingMean: 12.071429, ('air_ba495cccc8f0f237',): RollingMean: 17.357143, ('air_ba937bf13d40fb24',): RollingMean: 15.285714, ('air_bac5f4441db21db9',): RollingMean: 41.785714, ('air_baf28ac9f13a307d',): RollingMean: 13.571429, ('air_bb09595bab7d5cfb',): RollingMean: 29.5, ('air_bb26d6d079594414',): RollingMean: 13.285714, ('air_bb4ff06cd661ee9b',): RollingMean: 34.428571, ('air_bbe1c1a47e09f161',): RollingMean: 1.642857, ('air_bc991c51d6613745',): RollingMean: 18.571429, ('air_bc9a129e11a2efe0',): RollingMean: 30.785714, ('air_bcce1ea4350b7b72',): RollingMean: 20.857143, ('air_bd74a9222edfdfe1',): RollingMean: 14.285714, ('air_bdd32aa407c16335',): RollingMean: 13.785714, ('air_bebd55ed63ab2422',): RollingMean: 8.785714, ('air_bed603c423b7d9d4',): RollingMean: 6.142857, ('air_bedd35489e666605',): RollingMean: 38.642857, ('air_bf13014b6e3e60ca',): RollingMean: 27., ('air_bf21b8350771879b',): RollingMean: 23.857143, ('air_bf617aa68d5f1cfa',): RollingMean: 6.857143, ('air_bf7591560077332d',): RollingMean: 8.357143, ('air_bfafaed35e213fd7',): RollingMean: 12.857143, ('air_bfda7731a6c6fc61',): RollingMean: 19.071429, ('air_c027e2b560442808',): RollingMean: 15.857143, ('air_c0385db498b391e5',): RollingMean: 33.5, ('air_c1d5d165c055b866',): RollingMean: 30.071429, ('air_c1ff20617c54fee7',): RollingMean: 7.785714, ('air_c225148c0fcc5c72',): RollingMean: 34.857143, ('air_c2626f5f86d57342',): RollingMean: 15.928571, ('air_c26f027b5bc1f081',): RollingMean: 5.071429, ('air_c28983412a7eefcf',): RollingMean: 35.285714, ('air_c2c8435bdb3516d4',): RollingMean: 31.214286, ('air_c31472d14e29cee8',): RollingMean: 14.857143, ('air_c3585b0fba3998d0',): RollingMean: 9.357143, ('air_c3bc011cca3bec65',): RollingMean: 5.642857, ('air_c3dcaf3aeb18e20e',): RollingMean: 17.428571, ('air_c47aa7493b15f297',): RollingMean: 21.142857, ('air_c4fa5c562d5409ca',): RollingMean: 13.785714, ('air_c52c63c781fe48f6',): RollingMean: 27.714286, ('air_c5459218282bedd5',): RollingMean: 22.571429, ('air_c66dbd2c37832d00',): RollingMean: 16.714286, ('air_c6a164dd4060e960',): RollingMean: 12.428571, ('air_c6aa2efba0ffc8eb',): RollingMean: 28.857143, ('air_c6ffd6a93e6b68d6',): RollingMean: 17.357143, ('air_c73d319ffabf287a',): RollingMean: 15.285714, ('air_c759b6abeb552160',): RollingMean: 5.071429, ('air_c77ee2b7d36da265',): RollingMean: 42.071429, ('air_c7d30ab0e07f31d5',): RollingMean: 17.142857, ('air_c7f78b4f3cba33ff',): RollingMean: 22.785714, ('air_c8265ecc116f2284',): RollingMean: 9.142857, ('air_c88467d88b2c8ecd',): RollingMean: 18.428571, ('air_c8a657c8c5c93d69',): RollingMean: 7.928571, ('air_c8c0ef02ed72053f',): RollingMean: 26.5, ('air_c8fe396d6c46275d',): RollingMean: 14.357143, ('air_c92745dfdd2ec68a',): RollingMean: 18.428571, ('air_c9ed65554b6edffb',): RollingMean: 12.928571, ('air_c9f6de13be8b8f25',): RollingMean: 4.357143, ('air_ca1315af9e073bd1',): RollingMean: 45.285714, ('air_ca6ae8d49a2f1eaf',): RollingMean: 20.928571, ('air_ca957d3a1529fbd3',): RollingMean: 33.714286, ('air_cadf9cfb510a1d78',): RollingMean: 31.071429, ('air_caf996ac27206301',): RollingMean: 5.642857, ('air_cb083b4789a8d3a2',): RollingMean: 17.214286, ('air_cb25551c4cd8d9f3',): RollingMean: 9., ('air_cb7467aed805e7fe',): RollingMean: 36.571429, ('air_cb935ff8610ba3d3',): RollingMean: 4.857143, ('air_cbe139af83feb388',): RollingMean: 9.928571, ('air_cbe867adcf44e14f',): RollingMean: 15.5, ('air_cc1a0e985ce63711',): RollingMean: 27.785714, ('air_cc35590cd1da8554',): RollingMean: 20.857143, ('air_ccd19a5bc5573ae5',): RollingMean: 37.714286, ('air_cd4b301d5d3918d8',): RollingMean: 6.928571, ('air_cd5f54969be9ed08',): RollingMean: 7.214286, ('air_ced6297e5bdf5130',): RollingMean: 24.428571, ('air_cf2229e64408d9fe',): RollingMean: 17.857143, ('air_cf22e368c1a71d53',): RollingMean: 37.285714, ('air_cf5ab75a0afb8af9',): RollingMean: 45.214286, ('air_cfcc94797d2b5d3d',): RollingMean: 17.285714, ('air_cfdeb326418194ff',): RollingMean: 15.142857, ('air_d00161e19f08290b',): RollingMean: 26., ('air_d00a15343325e5f7',): RollingMean: 18.714286, ('air_d07e57b21109304a',): RollingMean: 10.142857, ('air_d0a1e69685259c92',): RollingMean: 29.285714, ('air_d0a7bd3339c3d12a',): RollingMean: 39.785714, ('air_d0e8a085d8dc83aa',): RollingMean: 7.571429, ('air_d138b593ebda55cc',): RollingMean: 5.714286, ('air_d1418d6fd6d634f2',): RollingMean: 16.285714, ('air_d186b2cb0b9ce022',): RollingMean: 13.357143, ('air_d1f20424f76cc78e',): RollingMean: 20.928571, ('air_d34c0861a2be94cb',): RollingMean: 42.571429, ('air_d3e7b5952cd09ccb',): RollingMean: 18.642857, ('air_d44d210d2994f01b',): RollingMean: 6.071429, ('air_d473620754bf9fc2',): RollingMean: 12.571429, ('air_d477b6339b8ce69f',): RollingMean: 8.857143, ('air_d4981cdde163b172',): RollingMean: 23.428571, ('air_d4b5a4b04c5f2d04',): RollingMean: 12.642857, ('air_d4d218b451f82c3d',): RollingMean: 9.785714, ('air_d500b48a8735fbd3',): RollingMean: 18.071429, ('air_d54d6fcb116fbed3',): RollingMean: 4.214286, ('air_d5e0a20370c325c7',): RollingMean: 29.857143, ('air_d63cfa6d6ab78446',): RollingMean: 18.428571, ('air_d69b08a175bc0387',): RollingMean: 10.857143, ('air_d6b3e67261f07646',): RollingMean: 13.714286, ('air_d8abb9e490abf94f',): RollingMean: 12., ('air_d97dabf7aae60da5',): RollingMean: 33.285714, ('air_d98380a4aeb0290b',): RollingMean: 43.357143, ('air_daa7947e1c47f5ed',): RollingMean: 34.357143, ('air_dabfbd0ec951925a',): RollingMean: 7.642857, ('air_dad0b6a36138f309',): RollingMean: 5.5, ('air_db1233ad855b34d5',): RollingMean: 24.142857, ('air_db4b38ebe7a7ceff',): RollingMean: 24.5, ('air_db80363d35f10926',): RollingMean: 28.785714, ('air_dbf64f1ce38c7442',): RollingMean: 14.928571, ('air_dc0e080ba0a5e5af',): RollingMean: 8.928571, ('air_dc71c6cc06cd1aa2',): RollingMean: 6.285714, ('air_de692863bb2dd758',): RollingMean: 20.857143, ('air_de803f7e324936b8',): RollingMean: 24.285714, ('air_de88770300008624',): RollingMean: 20., ('air_dea0655f96947922',): RollingMean: 38.571429, ('air_df507aec929ce5f6',): RollingMean: 19.071429, ('air_df554c4527a1cfe6',): RollingMean: 53.5, ('air_df5cf5cd03eb68d0',): RollingMean: 7.857143, ('air_df843e6b22e8d540',): RollingMean: 10.285714, ('air_df9355c47c5df9d3',): RollingMean: 30.285714, ('air_dfad598ff642dab7',): RollingMean: 26.071429, ('air_dfe068a1bf85f395',): RollingMean: 36.428571, ('air_e00fe7853c0100d6',): RollingMean: 20.214286, ('air_e0118664da63a2d0',): RollingMean: 16.714286, ('air_e01d99390355408d',): RollingMean: 11.571429, ('air_e053c561f32acc28',): RollingMean: 17.928571, ('air_e08b9cf82057a170',): RollingMean: 34.5, ('air_e0aee25b56a069f2',): RollingMean: 14.214286, ('air_e0e69668214ff972',): RollingMean: 9.785714, ('air_e0f241bd406810c0',): RollingMean: 33.142857, ('air_e1b76fcb5208fb6b',): RollingMean: 14.571429, ('air_e2208a79e2678432',): RollingMean: 45.142857, ('air_e270aff84ac7e4c8',): RollingMean: 25.928571, ('air_e3020992d5fe5dfd',): RollingMean: 13.5, ('air_e34c631c766f2766',): RollingMean: 24.642857, ('air_e42bdc3377d1eee7',): RollingMean: 20.785714, ('air_e483f5b3c4f310e0',): RollingMean: 5.285714, ('air_e524c6a9e06cc3a1',): RollingMean: 8.785714, ('air_e55abd740f93ecc4',): RollingMean: 46., ('air_e57dd6884595f60d',): RollingMean: 39.428571, ('air_e58f669b6f1a08ce',): RollingMean: 11.142857, ('air_e5cf003abcc5febb',): RollingMean: 12.571429, ('air_e64de0a6bf0739af',): RollingMean: 43.214286, ('air_e657ca554b0c008c',): RollingMean: 25., ('air_e700e390226d9985',): RollingMean: 15.928571, ('air_e76a668009c5dabc',): RollingMean: 7.785714, ('air_e7d2ac6d53d1b744',): RollingMean: 9.357143, ('air_e7fbee4e3cfe65c5',): RollingMean: 36., ('air_e88bbe2ede3467aa',): RollingMean: 22.857143, ('air_e89735e80d614a7e',): RollingMean: 33.785714, ('air_e8ed9335d0c38333',): RollingMean: 24.857143, ('air_e9ebf7fc520ac76a',): RollingMean: 28.428571, ('air_ea6d0c3acf00b22a',): RollingMean: 22.285714, ('air_ea7c16131980c837',): RollingMean: 7.071429, ('air_eb120e6d384a17a8',): RollingMean: 42.785714, ('air_eb20a89bba7dd3d0',): RollingMean: 3., ('air_eb2d2653586315dd',): RollingMean: 31.428571, ('air_eb5788dba285e725',): RollingMean: 27.071429, ('air_ebd31e812960f517',): RollingMean: 26.857143, ('air_ebe02c3090271fa9',): RollingMean: 11.142857, ('air_ec0fad2def4dcff0',): RollingMean: 15.142857, ('air_eca4a5a191e8d993',): RollingMean: 28.357143, ('air_eca5e0064dc9314a',): RollingMean: 34.571429, ('air_ecab54b57a71b10d',): RollingMean: 13.071429, ('air_eceb97ad6a7d4c07',): RollingMean: 27.857143, ('air_ecf7f141339f1d57',): RollingMean: 19.857143, ('air_eda179770dfa9f91',): RollingMean: 10.642857, ('air_edd5e3d696a5811b',): RollingMean: 39.357143, ('air_ee3a01f0c71a769f',): RollingMean: 25.285714, ('air_ee3ba9af184c6c82',): RollingMean: 18.642857, ('air_eec5e572b9eb9c23',): RollingMean: 11.142857, ('air_eeeadee005c006a2',): RollingMean: 12.142857, ('air_ef47430bcd6f6a89',): RollingMean: 14.857143, ('air_ef789667e2e6fe96',): RollingMean: 36.357143, ('air_ef920fa6f4b085f6',): RollingMean: 33.928571, ('air_efc80d3f96b3aff7',): RollingMean: 9.428571, ('air_efd70b04de878f25',): RollingMean: 31., ('air_efef1e3daecce07e',): RollingMean: 40.428571, ('air_f068442ebb6c246c',): RollingMean: 10.071429, ('air_f0c7272956e62f12',): RollingMean: 4.285714, ('air_f0fb0975bdc2cdf9',): RollingMean: 10.285714, ('air_f1094dbf2aef85d9',): RollingMean: 6.714286, ('air_f180301886c21375',): RollingMean: 14.428571, ('air_f183a514cb8ff4fa',): RollingMean: 42.071429, ('air_f1f9027d4fa8f653',): RollingMean: 26.5, ('air_f267dd70a6a6b5d3',): RollingMean: 44.5, ('air_f26f36ec4dc5adb0',): RollingMean: 38.785714, ('air_f2985de32bb792e0',): RollingMean: 26.285714, ('air_f2c5a1f24279c531',): RollingMean: 14.357143, ('air_f3602e4fa2f12993',): RollingMean: 11.571429, ('air_f3f9824b7d70c3cf',): RollingMean: 16.642857, ('air_f4936b91c9addbf0',): RollingMean: 16., ('air_f593fa60ac3541e2',): RollingMean: 13.642857, ('air_f690c42545146e0a',): RollingMean: 12.928571, ('air_f6b2489ccf873c3b',): RollingMean: 15.928571, ('air_f6bfd27e2e174d16',): RollingMean: 12.928571, ('air_f6cdaf7b7fdc6d78',): RollingMean: 10., ('air_f8233ad00755c35c',): RollingMean: 29.571429, ('air_f85e21e543cf44f2',): RollingMean: 4.785714, ('air_f88898cd09f40496',): RollingMean: 8.857143, ('air_f911308e19d64236',): RollingMean: 40.571429, ('air_f9168b23fdfc1e52',): RollingMean: 19.5, ('air_f927b2da69a82341',): RollingMean: 8.357143, ('air_f957c6d6467d4d90',): RollingMean: 10.642857, ('air_f96765e800907c77',): RollingMean: 43.857143, ('air_fa12b40b02fecfd8',): RollingMean: 15., ('air_fa4ffc9057812fa2',): RollingMean: 5.142857, ('air_fab092c35776a9b1',): RollingMean: 10.714286, ('air_fb44f566d4f64a4e',): RollingMean: 15.857143, ('air_fbadf737162a5ce3',): RollingMean: 14.571429, ('air_fc477473134e9ae5',): RollingMean: 16.857143, ('air_fcd4492c83f1c6b9',): RollingMean: 22.357143, ('air_fcfbdcf7b1f82c6e',): RollingMean: 35.642857, ('air_fd154088b1de6fa7',): RollingMean: 6.428571, ('air_fd6aac1043520e83',): RollingMean: 36.071429, ('air_fdc02ec4a3d21ea4',): RollingMean: 8.071429, ('air_fdcfef8bd859f650',): RollingMean: 3.642857, ('air_fe22ef5a9cbef123',): RollingMean: 21.714286, ('air_fe58c074ec1445ea',): RollingMean: 32.785714, ('air_fea5dc9594450608',): RollingMean: 15.571429, ('air_fee8dcf4d619598e',): RollingMean: 26.785714, ('air_fef9ccb3ba0da2f7',): RollingMean: 9.714286, ('air_ffcc2d5087e1b476',): RollingMean: 20., ('air_fff68b929994bfbd',): RollingMean: 4.285714}), 'by': ['store_id'], 'how': RollingMean: 0., 'on': 'y'} y_rollingmean_21_by_store_id {'_feature_name': 'y_rollingmean_21_by_store_id', '_groups': defaultdict(functools.partial(<function deepcopy at 0x7f830e2024c0>, RollingMean: 0.), {('air_00a91d42b08b08d9',): RollingMean: 29.190476, ('air_0164b9927d20bcc3',): RollingMean: 8.380952, ('air_0241aa3964b7f861',): RollingMean: 8.904762, ('air_0328696196e46f18',): RollingMean: 8.904762, ('air_034a3d5b40d5b1b1',): RollingMean: 22.52381, ('air_036d4f1ee7285390',): RollingMean: 21.238095, ('air_0382c794b73b51ad',): RollingMean: 27.380952, ('air_03963426c9312048',): RollingMean: 40.428571, ('air_04341b588bde96cd',): RollingMean: 35.333333, ('air_049f6d5b402a31b2',): RollingMean: 12.47619, ('air_04cae7c1bc9b2a0b',): RollingMean: 19.238095, ('air_0585011fa179bcce',): RollingMean: 5.333333, ('air_05c325d315cc17f5',): RollingMean: 27., ('air_0647f17b4dc041c8',): RollingMean: 30.52381, ('air_064e203265ee5753',): RollingMean: 19.47619, ('air_066f0221b8a4d533',): RollingMean: 12.428571, ('air_06f95ac5c33aca10',): RollingMean: 30.047619, ('air_0728814bd98f7367',): RollingMean: 8.095238, ('air_0768ab3910f7967f',): RollingMean: 24.952381, ('air_07b314d83059c4d2',): RollingMean: 36.380952, ('air_07bb665f9cdfbdfb',): RollingMean: 26.333333, ('air_082908692355165e',): RollingMean: 49.52381, ('air_083ddc520ea47e1e',): RollingMean: 13.238095, ('air_0845d8395f30c6bb',): RollingMean: 21.714286, ('air_084d98859256acf0',): RollingMean: 15.761905, ('air_0867f7bebad6a649',): RollingMean: 22.380952, ('air_08ba8cd01b3ba010',): RollingMean: 10.666667, ('air_08cb3c4ee6cd6a22',): RollingMean: 12.666667, ('air_08ef81d5b7a0d13f',): RollingMean: 13.952381, ('air_08f994758a1e76d4',): RollingMean: 27.714286, ('air_09040f6df960ddb8',): RollingMean: 16., ('air_0919d54f0c9a24b8',): RollingMean: 31.714286, ('air_09661c0f3259cc04',): RollingMean: 28.47619, ('air_09a845d5b5944b01',): RollingMean: 6.380952, ('air_09fd1f5c58583141',): RollingMean: 8.333333, ('air_0a74a5408a0b8642',): RollingMean: 28.095238, ('air_0b184ec04c741a6a',): RollingMean: 11.190476, ('air_0b1e72d2d4422b20',): RollingMean: 22.333333, ('air_0b9038300f8b2b50',): RollingMean: 12.380952, ('air_0e1eae99b8723bc1',): RollingMean: 11.952381, ('air_0e7c11b9abc50163',): RollingMean: 36.904762, ('air_0ead98dd07e7a82a',): RollingMean: 13.857143, ('air_0f0cdeee6c9bf3d7',): RollingMean: 25.238095, ('air_0f2f96335f274801',): RollingMean: 10., ('air_0f60e1576a7d397d',): RollingMean: 6.619048, ('air_1033310359ceeac1',): RollingMean: 18.809524, ('air_10393f12e9069760',): RollingMean: 15.714286, ('air_105a7954e32dba9b',): RollingMean: 50.857143, ('air_10713fbf3071c361',): RollingMean: 12.047619, ('air_10bbe8acd943d8f6',): RollingMean: 26.809524, ('air_12c4fb7a423df20d',): RollingMean: 20.857143, ('air_138ee734ac79ff90',): RollingMean: 8.714286, ('air_138ff410757b845f',): RollingMean: 54.285714, ('air_1408dd53f31a8a65',): RollingMean: 25.190476, ('air_142e78ba7001da9c',): RollingMean: 13.619048, ('air_1509881b22965b34',): RollingMean: 16.666667, ('air_152c1f08d7d20e07',): RollingMean: 13.238095, ('air_15ae33469e9ea2dd',): RollingMean: 11.428571, ('air_15e6e15c7ea2c162',): RollingMean: 18.952381, ('air_16179d43b6ee5fd8',): RollingMean: 8.285714, ('air_1653a6c513865af3',): RollingMean: 32.52381, ('air_168441ada3e878e1',): RollingMean: 41.47619, ('air_16c4cfddeb2cf69b',): RollingMean: 11.52381, ('air_16cf0a73233896de',): RollingMean: 10.52381, ('air_1707a3f18bb0da07',): RollingMean: 27.285714, ('air_17a6ab40f97fd4d8',): RollingMean: 6.904762, ('air_17bed6dbf7c8b0fc',): RollingMean: 19.095238, ('air_1979eaff8189d086',): RollingMean: 9.666667, ('air_1ab60ce33bfed8a8',): RollingMean: 9.714286, ('air_1ae94f514a0bce13',): RollingMean: 6.904762, ('air_1ba4e87ef7422183',): RollingMean: 37.619048, ('air_1c0b150f9e696a5f',): RollingMean: 107.238095, ('air_1c95a84924d72500',): RollingMean: 9.619048, ('air_1d1e8860ae04f8e9',): RollingMean: 12.904762, ('air_1d25ca6c76df48b4',): RollingMean: 39.666667, ('air_1d3f797dd1f7cf1c',): RollingMean: 33.428571, ('air_1dd8f6f47480d1a2',): RollingMean: 37.857143, ('air_1dea9815ccd36620',): RollingMean: 10.428571, ('air_1e23210b584540e7',): RollingMean: 4.047619, ('air_1e665503b8474c55',): RollingMean: 5.571429, ('air_1eeff462acb24fb7',): RollingMean: 16.333333, ('air_1f1390a8be2272b3',): RollingMean: 18.095238, ('air_1f34e9beded2231a',): RollingMean: 8.095238, ('air_1f7f8fa557bc0d55',): RollingMean: 3.619048, ('air_2009041dbf9264de',): RollingMean: 50.047619, ('air_20619d21192aa571',): RollingMean: 17.571429, ('air_20add8092c9bb51d',): RollingMean: 30.428571, ('air_2195cd5025a98033',): RollingMean: 28.809524, ('air_21f5052d5330528d',): RollingMean: 32.809524, ('air_220cba70c890b119',): RollingMean: 9.142857, ('air_22682e965418936f',): RollingMean: 8.857143, ('air_228f10bec0bda9c8',): RollingMean: 17.333333, ('air_229d7e508d9f1b5e',): RollingMean: 10.809524, ('air_232dcee6f7c51d37',): RollingMean: 5.571429, ('air_234d3dbf7f3d5a50',): RollingMean: 7.571429, ('air_23e1b11aee2a1407',): RollingMean: 45.571429, ('air_23ee674e91469086',): RollingMean: 21.714286, ('air_24b9b2a020826ede',): RollingMean: 31.666667, ('air_24e8414b9b07decb',): RollingMean: 5.952381, ('air_2545dd3a00f265e2',): RollingMean: 48.761905, ('air_256be208a979e023',): RollingMean: 6.47619, ('air_2570ccb93badde68',): RollingMean: 38.333333, ('air_258ad2619d7bff9a',): RollingMean: 30.666667, ('air_258dc112912fc458',): RollingMean: 61.571429, ('air_25c583983246b7b0',): RollingMean: 20.047619, ('air_25d8e5cc57dd87d9',): RollingMean: 26.190476, ('air_25e9888d30b386df',): RollingMean: 4.285714, ('air_2634e41551e9807d',): RollingMean: 13., ('air_26c5bbeb7bb82bf1',): RollingMean: 28.952381, ('air_26f10355d9b4d82a',): RollingMean: 32.52381, ('air_2703dcb33192b181',): RollingMean: 49.428571, ('air_275732a5db46f4d3',): RollingMean: 14.952381, ('air_27e991812b0d9c92',): RollingMean: 44.238095, ('air_28064154614b2e6c',): RollingMean: 21.714286, ('air_287d2de7d3c93406',): RollingMean: 13.047619, ('air_28a9fa1ec0839375',): RollingMean: 29.571429, ('air_28dbe91c4c9656be',): RollingMean: 34.619048, ('air_290e7a57b390f78e',): RollingMean: 13.714286, ('air_298513175efdf261',): RollingMean: 27.285714, ('air_2a184c1745274b2b',): RollingMean: 3.952381, ('air_2a24aec099333f39',): RollingMean: 6.666667, ('air_2a3743e37aab04b4',): RollingMean: 18.428571, ('air_2a485b92210c98b5',): RollingMean: 21.571429, ('air_2a7f14da7fe0f699',): RollingMean: 28.047619, ('air_2aab19554f91ff82',): RollingMean: 51.285714, ('air_2ac361b97630e2df',): RollingMean: 12., ('air_2b8b29ddfd35018e',): RollingMean: 11.095238, ('air_2b9bc9f5f5168ea1',): RollingMean: 20.190476, ('air_2bffb19a24d11729',): RollingMean: 11.142857, ('air_2c505f9ad67d4635',): RollingMean: 15.428571, ('air_2c6c79d597e48096',): RollingMean: 16.380952, ('air_2c6fef1ce0e13a5a',): RollingMean: 31.190476, ('air_2c989829acbd1c6b',): RollingMean: 29.333333, ('air_2cee51fa6fdf6c0d',): RollingMean: 16.619048, ('air_2d3afcb91762fe01',): RollingMean: 44.857143, ('air_2d78d9a1f4dd02ca',): RollingMean: 11.333333, ('air_2e7cb1f1a2a9cd6a',): RollingMean: 27.666667, ('air_2f8ced25216df926',): RollingMean: 13.714286, ('air_2fc149abe33adcb4',): RollingMean: 34.857143, ('air_2fc478dc9f0a6b31',): RollingMean: 11.714286, ('air_2fed81034f8834e5',): RollingMean: 20.47619, ('air_303bac187b53083a',): RollingMean: 10.047619, ('air_310e467e6e625004',): RollingMean: 15.47619, ('air_3155ee23d92202da',): RollingMean: 16.380952, ('air_31c753b48a657b6c',): RollingMean: 24.904762, ('air_32460819c7600037',): RollingMean: 50.761905, ('air_324f7c39a8410e7c',): RollingMean: 11.809524, ('air_326ca454ef3558bc',): RollingMean: 23.714286, ('air_32b02ba5dc2027f4',): RollingMean: 29.285714, ('air_32c61b620a766138',): RollingMean: 27.380952, ('air_32f5d7cd696e3c4a',): RollingMean: 22.190476, ('air_33b01025210d6007',): RollingMean: 10.285714, ('air_3440e0ea1b70a99b',): RollingMean: 27.904762, ('air_346ade7d29230634',): RollingMean: 7.761905, ('air_347be2c4feeb408b',): RollingMean: 22.047619, ('air_349278fa964bb12f',): RollingMean: 18.666667, ('air_3525f11ef0bf0c35',): RollingMean: 39.761905, ('air_35512c42db0868da',): RollingMean: 6.238095, ('air_3561fd1c0bce6a95',): RollingMean: 12.142857, ('air_35c4732dcbfe31be',): RollingMean: 6.571429, ('air_36429b5ca4407b3e',): RollingMean: 18.904762, ('air_36bcf77d3382d36e',): RollingMean: 32.285714, ('air_37189c92b6c761ec',): RollingMean: 19.47619, ('air_375a5241615b5e22',): RollingMean: 7.428571, ('air_382f5ace4e2247b8',): RollingMean: 8.761905, ('air_383f5b2f8d345a49',): RollingMean: 14.238095, ('air_38746ffe9aa20c7e',): RollingMean: 4., ('air_396166d47733d5c9',): RollingMean: 24.952381, ('air_396942e6423a2145',): RollingMean: 19.333333, ('air_397d3f32a7196aa2',): RollingMean: 31.190476, ('air_3980af67be35afdb',): RollingMean: 17.380952, ('air_3982a2c4ea2ed431',): RollingMean: 31.714286, ('air_399904bdb7685ca0',): RollingMean: 26., ('air_39dccf7df20b1c6a',): RollingMean: 24.809524, ('air_3a8a3f8fb5cd7f88',): RollingMean: 21.285714, ('air_3aa839e8e0cb6c87',): RollingMean: 27.380952, ('air_3ac24136722e2291',): RollingMean: 14., ('air_3b20733899b5287f',): RollingMean: 39.904762, ('air_3b6438b125086430',): RollingMean: 13.380952, ('air_3bb99a1fe0583897',): RollingMean: 37.904762, ('air_3bd49f98ab7f36ab',): RollingMean: 11.809524, ('air_3c05c8f26c611eb9',): RollingMean: 23.380952, ('air_3c938075889fc059',): RollingMean: 28.428571, ('air_3cad29d1a23209d2',): RollingMean: 9.142857, ('air_3caef3f76b8f26c5',): RollingMean: 25.761905, ('air_3d3a2b509180e798',): RollingMean: 17.142857, ('air_3e6cea17a9d2c0f1',): RollingMean: 17.714286, ('air_3e93f3c81008696d',): RollingMean: 34.47619, ('air_3f91d592acd6cc0b',): RollingMean: 24.666667, ('air_401b39f97e56b939',): RollingMean: 12.095238, ('air_4043b7ccfbffa732',): RollingMean: 43.428571, ('air_4092cfbd95a3ac1b',): RollingMean: 26.761905, ('air_40953e2d8b4f2857',): RollingMean: 17.47619, ('air_40f6193ea3ed1b91',): RollingMean: 15.190476, ('air_414ff459ed18fa48',): RollingMean: 16.333333, ('air_41bbf6e1d9814c4b',): RollingMean: 7.714286, ('air_421670f21da5ba31',): RollingMean: 17.52381, ('air_4254c3fc3ad078bd',): RollingMean: 10.904762, ('air_42c9aa6d617c5057',): RollingMean: 43.142857, ('air_42d41eb58cad170e',): RollingMean: 27.571429, ('air_43b65e4b05bff2d3',): RollingMean: 21.952381, ('air_43d577e0c9460e64',): RollingMean: 38.571429, ('air_4433ab8e9999915f',): RollingMean: 19.619048, ('air_4481a87c1d7c9896',): RollingMean: 22.095238, ('air_452100f5305dde64',): RollingMean: 7.571429, ('air_45326ebb8dc72cfb',): RollingMean: 30.714286, ('air_4570f52104fe0982',): RollingMean: 7.285714, ('air_4579cb0669fd411b',): RollingMean: 16.380952, ('air_457efe8c3a30ea17',): RollingMean: 7.142857, ('air_464a62de0d57be1e',): RollingMean: 25.619048, ('air_465bddfed3353b23',): RollingMean: 25.952381, ('air_47070be6093f123e',): RollingMean: 48.52381, ('air_472b19e3b5bffa41',): RollingMean: 14.47619, ('air_473cf23b9e7c0a37',): RollingMean: 8.571429, ('air_473f98b212d37b4a',): RollingMean: 27.142857, ('air_47beaffd3806c979',): RollingMean: 20.47619, ('air_483eba479dc9910d',): RollingMean: 26.095238, ('air_48e9fc98b62495a7',): RollingMean: 18.380952, ('air_48f4da6223571da4',): RollingMean: 22.190476, ('air_48ffd31594bc3263',): RollingMean: 4.857143, ('air_49211568cab5fdee',): RollingMean: 23.380952, ('air_4974785f48853db9',): RollingMean: 6.428571, ('air_4b251b9f8373f1ae',): RollingMean: 27.714286, ('air_4b380b4db9d37883',): RollingMean: 25.571429, ('air_4b55d8aea1d2b395',): RollingMean: 36.904762, ('air_4b9085d0d46a6211',): RollingMean: 29.428571, ('air_4beac252540f865e',): RollingMean: 39.714286, ('air_4c2ed28f3f19ca52',): RollingMean: 13.857143, ('air_4c665a2bfff0da3b',): RollingMean: 8.666667, ('air_4c727b55acdee495',): RollingMean: 14.809524, ('air_4cab15ad29c0ffbc',): RollingMean: 20.047619, ('air_4cab91146e3d1897',): RollingMean: 14.47619, ('air_4cca5666eaf5c709',): RollingMean: 29.714286, ('air_4ce7b17062a1bf73',): RollingMean: 9.047619, ('air_4d21676ed11f0bac',): RollingMean: 30., ('air_4d71826793c09b22',): RollingMean: 21.333333, ('air_4d90a22572fa1ec9',): RollingMean: 26.238095, ('air_4de6d887a7b1c1fc',): RollingMean: 15.52381, ('air_4dea8d17f6f59c56',): RollingMean: 23.285714, ('air_4e1c38f68f435596',): RollingMean: 35.952381, ('air_4f762e840b3996e1',): RollingMean: 11.380952, ('air_4feeb8600f131e43',): RollingMean: 57.428571, ('air_500641aca4cf673c',): RollingMean: 15.666667, ('air_506fe758114df773',): RollingMean: 27.619048, ('air_51281cd059d7b89b',): RollingMean: 12.285714, ('air_51319e7acf0438cf',): RollingMean: 12.952381, ('air_52a08ef3efdb4bb0',): RollingMean: 44.904762, ('air_52e2a1fd42bc917a',): RollingMean: 10.761905, ('air_536043fcf1a4f8a4',): RollingMean: 28.238095, ('air_539d693f7317c62d',): RollingMean: 17.285714, ('air_546b353cbea4a45b',): RollingMean: 16.52381, ('air_5485912b44f976de',): RollingMean: 8.809524, ('air_54d6c25d33f5260e',): RollingMean: 38.47619, ('air_54ed43163b7596c4',): RollingMean: 17.047619, ('air_55390f784018349a',): RollingMean: 47.285714, ('air_55c3627912b9c849',): RollingMean: 9.952381, ('air_55e11c33d4758131',): RollingMean: 22.571429, ('air_56cd12f31a0afc04',): RollingMean: 30.619048, ('air_56cebcbd6906e04c',): RollingMean: 17.857143, ('air_56ea46c14b2dd967',): RollingMean: 39.047619, ('air_57013002b912772b',): RollingMean: 4.52381, ('air_573ecdf81b157d22',): RollingMean: 28.380952, ('air_57c9eea1a2b66e65',): RollingMean: 13.904762, ('air_57ed725a1930a5b9',): RollingMean: 17., ('air_5878b6f2a9da12c1',): RollingMean: 11.809524, ('air_59cc9b2b209c6331',): RollingMean: 10.809524, ('air_5a9a6cbeeb434c08',): RollingMean: 25.142857, ('air_5acc13d655a6e8b2',): RollingMean: 25.238095, ('air_5afb1cca48ceaa19',): RollingMean: 41.333333, ('air_5b6d18c470bbfaf9',): RollingMean: 34.142857, ('air_5b704df317ed1962',): RollingMean: 2.095238, ('air_5bd22f9cc1426a90',): RollingMean: 29.095238, ('air_5c65468938c07fa5',): RollingMean: 14., ('air_5c7489c9ec755e2d',): RollingMean: 40.380952, ('air_5c817ef28f236bdf',): RollingMean: 43.238095, ('air_5cb030b9f0b91537',): RollingMean: 10.238095, ('air_5cfc537125d97f16',): RollingMean: 9.952381, ('air_5d7c744c3a2ef624',): RollingMean: 30.47619, ('air_5d945ade487cdf4d',): RollingMean: 12.714286, ('air_5dea8a7a5bf5eb71',): RollingMean: 31.047619, ('air_5e339a1f364cdb00',): RollingMean: 10.428571, ('air_5e34c6fe6fabd10e',): RollingMean: 18.809524, ('air_5e70fe82f9e4fab6',): RollingMean: 15.857143, ('air_5e939e005bd34633',): RollingMean: 3.190476, ('air_5ed3198e4a5eed0f',): RollingMean: 39.190476, ('air_5f3a3ef4cba110a4',): RollingMean: 31.47619, ('air_5f6fa1b897fe80d5',): RollingMean: 28.809524, ('air_5fbda8e9302f7c13',): RollingMean: 26.47619, ('air_602ca92c0db34f8f',): RollingMean: 21.142857, ('air_609050e4e4f79ae1',): RollingMean: 11.714286, ('air_60a7057184ec7ec7',): RollingMean: 27.761905, ('air_60aa54ecbc602348',): RollingMean: 5.095238, ('air_6108821ffafa9b72',): RollingMean: 25.809524, ('air_614e2f7e76dff854',): RollingMean: 11.285714, ('air_61668cc2b0778898',): RollingMean: 10., ('air_61b8d37c33617f21',): RollingMean: 27.52381, ('air_61de73b097513f58',): RollingMean: 10.714286, ('air_622375b4815cf5cb',): RollingMean: 35.142857, ('air_627cabe2fe53f33f',): RollingMean: 14.904762, ('air_629d9935273c82ae',): RollingMean: 21.428571, ('air_629edf21ea38ac2d',): RollingMean: 37.571429, ('air_632ba66e1f75aa28',): RollingMean: 17.857143, ('air_638c35eb25e53eea',): RollingMean: 20.619048, ('air_63a750d8b4b6a976',): RollingMean: 24.047619, ('air_63a88d81295195ed',): RollingMean: 29.809524, ('air_63b13c56b7201bd9',): RollingMean: 20., ('air_63e28ee0b0c955a7',): RollingMean: 23.571429, ('air_640cf4835f0d9ba3',): RollingMean: 24.47619, ('air_6411203a47b5ec77',): RollingMean: 10.095238, ('air_645cb18b33f938cf',): RollingMean: 16.047619, ('air_646b93e336f0dded',): RollingMean: 6.619048, ('air_64a5d5c1381837af',): RollingMean: 40.571429, ('air_64d4491ad8cdb1c6',): RollingMean: 14.047619, ('air_650f9b9de0c5542c',): RollingMean: 24., ('air_657a0748462f85de',): RollingMean: 7.952381, ('air_65e294f1ae6df9c3',): RollingMean: 23., ('air_6607fe3671242ce3',): RollingMean: 40.190476, ('air_670a0c1c4108bcea',): RollingMean: 25.285714, ('air_671b4bea84dafb67',): RollingMean: 27., ('air_673acd9fa5e0dd78',): RollingMean: 5.857143, ('air_67483104fa38ef6c',): RollingMean: 30.904762, ('air_675aa35cba456fd1',): RollingMean: 46.666667, ('air_67f87c159d9e2ee2',): RollingMean: 39.47619, ('air_68147db09287bf74',): RollingMean: 23.190476, ('air_681b0c56328dd2af',): RollingMean: 33.285714, ('air_681f96e6a6595f82',): RollingMean: 41.952381, ('air_68301bcb11e2f389',): RollingMean: 24., ('air_683371d9baabf410',): RollingMean: 32., ('air_6836438b543ba698',): RollingMean: 13.285714, ('air_6873982b9e19c7ad',): RollingMean: 5.190476, ('air_68c1de82037d87e6',): RollingMean: 23.761905, ('air_68cc910e7b307b09',): RollingMean: 7.428571, ('air_68d075113f368946',): RollingMean: 20.142857, ('air_6902e4ec305b3d08',): RollingMean: 38.761905, ('air_694571ea13fb9e0e',): RollingMean: 30.904762, ('air_6a15e4eae523189d',): RollingMean: 19.285714, ('air_6b15edd1b4fbb96a',): RollingMean: 30.238095, ('air_6b2268863b14a2af',): RollingMean: 18.238095, ('air_6b65745d432fd77f',): RollingMean: 23.571429, ('air_6b7678aae65d2d59',): RollingMean: 6.904762, ('air_6b942d5ebbc759c2',): RollingMean: 13.571429, ('air_6b9fa44a9cf504a1',): RollingMean: 6.142857, ('air_6c1128955c58b690',): RollingMean: 14.095238, ('air_6c91a28278a16f64',): RollingMean: 10.380952, ('air_6c952e3c6e590945',): RollingMean: 15.285714, ('air_6ca1d941c8199a67',): RollingMean: 26.619048, ('air_6cbe54f0aa30b615',): RollingMean: 17., ('air_6ced51c24fb54262',): RollingMean: 8.380952, ('air_6d64dba2edd4fc0c',): RollingMean: 9.857143, ('air_6d65542aa43b598b',): RollingMean: 28.095238, ('air_6d65dd11d96e00fb',): RollingMean: 5.285714, ('air_6e06824d0934dd81',): RollingMean: 21.285714, ('air_6e3fd96320d24324',): RollingMean: 9.190476, ('air_6e64fb5821402cd2',): RollingMean: 8.619048, ('air_6ff5fca957798daa',): RollingMean: 7.190476, ('air_707d4b6328f2c2df',): RollingMean: 29.571429, ('air_709262d948dd0b6e',): RollingMean: 11., ('air_70e9e8cd55879414',): RollingMean: 10.857143, ('air_70f834596eb99fee',): RollingMean: 21.333333, ('air_710d6537cb7623df',): RollingMean: 29.904762, ('air_712dd258f7f91b4b',): RollingMean: 15.142857, ('air_71903025d39a4571',): RollingMean: 14.809524, ('air_722297e7f26db91d',): RollingMean: 11.904762, ('air_728ff578acc6ac6e',): RollingMean: 9.809524, ('air_72f5146cf0c49beb',): RollingMean: 13.238095, ('air_735bcbe1763d6e98',): RollingMean: 8.047619, ('air_73f316e6a18d8aa9',): RollingMean: 23.238095, ('air_7420042ff75f9aca',): RollingMean: 35., ('air_746211c0b532e8aa',): RollingMean: 49.190476, ('air_747f375eb3900e1e',): RollingMean: 5.047619, ('air_74cf22153214064c',): RollingMean: 11.095238, ('air_7514d90009613cd6',): RollingMean: 56.857143, ('air_754ae581ad80cc9f',): RollingMean: 14.380952, ('air_75864c80d2fb334a',): RollingMean: 10.714286, ('air_75bd5d1b6dc6670d',): RollingMean: 12.952381, ('air_764f71040a413d4d',): RollingMean: 51.142857, ('air_77488fa378cf98c3',): RollingMean: 8.904762, ('air_77dfc83450cbc89c',): RollingMean: 43.857143, ('air_7831b00996701c0f',): RollingMean: 25.952381, ('air_789103bf53b8096b',): RollingMean: 58.52381, ('air_789466e488705c93',): RollingMean: 25.285714, ('air_78df4dc6a7e83e41',): RollingMean: 19.238095, ('air_79afb3f52b4d062c',): RollingMean: 9., ('air_79f528087f49df06',): RollingMean: 32.047619, ('air_7a81bd7fadcbf3d8',): RollingMean: 6.190476, ('air_7a946aada80376a4',): RollingMean: 13.952381, ('air_7bacc4d36fb094c9',): RollingMean: 6.285714, ('air_7bc6ca04d7b0f3b8',): RollingMean: 15.52381, ('air_7bda6048a4a78837',): RollingMean: 24.714286, ('air_7c7774c66fb237f7',): RollingMean: 8.714286, ('air_7cc17a324ae5c7dc',): RollingMean: 15.095238, ('air_7cf5a02c0e01b647',): RollingMean: 31.238095, ('air_7d65049f9d275c0d',): RollingMean: 9.380952, ('air_7dacea2f22afccfb',): RollingMean: 29.285714, ('air_7db266904cb0d72a',): RollingMean: 14.047619, ('air_7e12c5d27f44a8de',): RollingMean: 24.714286, ('air_7ef9a5ea5c8fe39f',): RollingMean: 10.666667, ('air_7f3dc18494bce98b',): RollingMean: 13.761905, ('air_7f9e15afafcf4c75',): RollingMean: 35.190476, ('air_7fbf7649eb13ad9b',): RollingMean: 19.333333, ('air_800c02226e2e0288',): RollingMean: 14.952381, ('air_8093d0b565e9dbdf',): RollingMean: 34.809524, ('air_8110d68cc869b85e',): RollingMean: 45.904762, ('air_81546875de9c8e78',): RollingMean: 5.428571, ('air_81a12d67c22e012f',): RollingMean: 19.285714, ('air_81bd68142db76f58',): RollingMean: 28.047619, ('air_81c2600146d07d16',): RollingMean: 8.714286, ('air_81c5dff692063446',): RollingMean: 9.380952, ('air_820d1919cbecaa0a',): RollingMean: 33.619048, ('air_82a6ae14151953ba',): RollingMean: 36.47619, ('air_831658500aa7c846',): RollingMean: 30.428571, ('air_832f9dbe9ee4ebd3',): RollingMean: 13.809524, ('air_83db5aff8f50478e',): RollingMean: 8.190476, ('air_84060403939d8216',): RollingMean: 14.809524, ('air_848616680ef061bd',): RollingMean: 32.238095, ('air_84f6876ff7e83ae7',): RollingMean: 19.380952, ('air_8523d6a70de49e6c',): RollingMean: 31.380952, ('air_859feab8e3c9f98d',): RollingMean: 22.238095, ('air_85bd13a49370c392',): RollingMean: 11.47619, ('air_86cfbf2624576fad',): RollingMean: 7.047619, ('air_86f7b2109e4abd65',): RollingMean: 53.333333, ('air_87059630ab6fe47f',): RollingMean: 4.380952, ('air_87078cf7903a648c',): RollingMean: 6.142857, ('air_87467487d21891dd',): RollingMean: 15.761905, ('air_8764b3473ddcceaf',): RollingMean: 4.333333, ('air_876d7a23c47811cb',): RollingMean: 16.142857, ('air_877f79706adbfb06',): RollingMean: 11.952381, ('air_87ca98aa7664de94',): RollingMean: 13.47619, ('air_87f9e1024b951f01',): RollingMean: 12.380952, ('air_883ca28ef0ed3d55',): RollingMean: 13.619048, ('air_88c8e34baa79217b',): RollingMean: 28.571429, ('air_88ca84051ba95339',): RollingMean: 18.238095, ('air_88f31db64991768a',): RollingMean: 9.47619, ('air_890d7e28e8eaaa11',): RollingMean: 7.333333, ('air_89e7328af22efe74',): RollingMean: 40.857143, ('air_8a1d21fad48374e8',): RollingMean: 12.380952, ('air_8a59bb0c497b771e',): RollingMean: 27.809524, ('air_8a906e5801eac81c',): RollingMean: 25.095238, ('air_8b4a46dc521bfcfe',): RollingMean: 25.714286, ('air_8c119d1f16049f20',): RollingMean: 24.095238, ('air_8c3175aa5e4fc569',): RollingMean: 60.619048, ('air_8cc350fd70ee0757',): RollingMean: 31.571429, ('air_8ce035ee1d8a56a6',): RollingMean: 19., ('air_8d50c64692322dff',): RollingMean: 10.238095, ('air_8d61f49aa0373492',): RollingMean: 45.571429, ('air_8e429650fcf7a0ae',): RollingMean: 20.047619, ('air_8e4360a64dbd4c50',): RollingMean: 20.333333, ('air_8e492076a1179383',): RollingMean: 59.285714, ('air_8e8f42f047537154',): RollingMean: 29.095238, ('air_8ec47c0f1e2c879e',): RollingMean: 30.619048, ('air_8f13ef0f5e8c64dd',): RollingMean: 6.952381, ('air_8f273fb9ad2fed6f',): RollingMean: 15.571429, ('air_8f3b563416efc6ad',): RollingMean: 12.904762, ('air_900d755ebd2f7bbd',): RollingMean: 82.2, ('air_901925b628677c2e',): RollingMean: 9.333333, ('air_90213bcae4afa274',): RollingMean: 26.761905, ('air_90bd5de52c166767',): RollingMean: 23.142857, ('air_90ed0a2f24755533',): RollingMean: 38.952381, ('air_90f0efbb702d77b7',): RollingMean: 30.047619, ('air_9105a29b0eb250d2',): RollingMean: 18.190476, ('air_91236b89d29567af',): RollingMean: 20.571429, ('air_9152d9926e5c4a3a',): RollingMean: 37.47619, ('air_915558a55c2bc56c',): RollingMean: 18.190476, ('air_91beafbba9382b0a',): RollingMean: 34.904762, ('air_91d72e16c4bcba55',): RollingMean: 15.809524, ('air_9241121af22ff1d6',): RollingMean: 31.619048, ('air_929d8513e3cdb423',): RollingMean: 7.619048, ('air_931a8a4321b6e7d1',): RollingMean: 5.714286, ('air_9352c401d5adb01b',): RollingMean: 27.904762, ('air_9387ff95e886ebc7',): RollingMean: 18.380952, ('air_938ef91ecdde6878',): RollingMean: 22.047619, ('air_939964477035ef0b',): RollingMean: 19.571429, ('air_93b9bb641f8fc982',): RollingMean: 27.047619, ('air_93dd7070c9bf5453',): RollingMean: 34.095238, ('air_93ebe490d4abb8e9',): RollingMean: 16.47619, ('air_9438d67241c81314',): RollingMean: 35.666667, ('air_947eb2cae4f3e8f2',): RollingMean: 34., ('air_9483d65e9cc9a6b7',): RollingMean: 14.47619, ('air_950381108f839348',): RollingMean: 30.095238, ('air_95d28905941fd4cb',): RollingMean: 29.47619, ('air_95e917913cd988f3',): RollingMean: 24.428571, ('air_96005f79124e12bf',): RollingMean: 41.619048, ('air_965b2e0cf4119003',): RollingMean: 53.904762, ('air_96743eee94114261',): RollingMean: 13.904762, ('air_96773a6236d279b1',): RollingMean: 25.714286, ('air_968d72c12eed09f0',): RollingMean: 19.285714, ('air_96929a799b12a43e',): RollingMean: 27.761905, ('air_96ec3cfe78cb0652',): RollingMean: 18.047619, ('air_97159fc4e90053fe',): RollingMean: 23.714286, ('air_97958e7fce98b6a3',): RollingMean: 19.095238, ('air_97b2a9f975fc702c',): RollingMean: 34.285714, ('air_97cf68dc1a9beac0',): RollingMean: 12.428571, ('air_97e0f2feec4d577a',): RollingMean: 16.142857, ('air_9828505fefc77d75',): RollingMean: 14.857143, ('air_98b54e32ccddd896',): RollingMean: 17.952381, ('air_990a642a3deb2903',): RollingMean: 34.428571, ('air_99157b6163835eec',): RollingMean: 36.285714, ('air_99a5183695b849f9',): RollingMean: 35.52381, ('air_99b01136f451fc0e',): RollingMean: 40.761905, ('air_99c3eae84130c1cb',): RollingMean: 41.095238, ('air_9a30407764f4ff84',): RollingMean: 17.428571, ('air_9a6f6e7f623003d2',): RollingMean: 3.190476, ('air_9aa32b3db0fab3a5',): RollingMean: 16.095238, ('air_9aa92007e3628dbc',): RollingMean: 31.333333, ('air_9ae7081cb77dc51e',): RollingMean: 28.714286, ('air_9b13c7feb0a0c431',): RollingMean: 10.52381, ('air_9b6af3db40da4ae2',): RollingMean: 28., ('air_9bbc673495e23532',): RollingMean: 4.571429, ('air_9bf0ccac497c4af3',): RollingMean: 43.142857, ('air_9bf595ef095572fb',): RollingMean: 25.571429, ('air_9c6787aa03a45586',): RollingMean: 97.809524, ('air_9ca2767761efff4d',): RollingMean: 10.190476, ('air_9cd5e310f488bced',): RollingMean: 13.666667, ('air_9cf2f1ba86229773',): RollingMean: 32.142857, ('air_9d3482b4680aee88',): RollingMean: 10.190476, ('air_9d452a881f7f2bb7',): RollingMean: 9.142857, ('air_9d474ec2448c700d',): RollingMean: 12.380952, ('air_9d5a980b211e1795',): RollingMean: 11.285714, ('air_9d93d95720f2e831',): RollingMean: 7.52381, ('air_9dc9483f717d73ee',): RollingMean: 5.47619, ('air_9dd7d38b0f1760c4',): RollingMean: 2.428571, ('air_9e920b758503ef54',): RollingMean: 5.571429, ('air_9efaa7ded03c5a71',): RollingMean: 10.238095, ('air_9f277fb7a2c1d842',): RollingMean: 11.571429, ('air_9fc607777ad76b26',): RollingMean: 16.761905, ('air_a083834e7ffe187e',): RollingMean: 19.904762, ('air_a11473cc1eb9a27f',): RollingMean: 35.714286, ('air_a17f0778617c76e2',): RollingMean: 37.571429, ('air_a1fe8c588c8d2f30',): RollingMean: 15., ('air_a218912784bf767d',): RollingMean: 14.809524, ('air_a21ffca0bea1661a',): RollingMean: 1.095238, ('air_a239a44805932bab',): RollingMean: 33.047619, ('air_a24bf50c3e90d583',): RollingMean: 20.142857, ('air_a2567267116a3b75',): RollingMean: 16.142857, ('air_a257c9749d8d0ff6',): RollingMean: 19., ('air_a271c9ba19e81d17',): RollingMean: 27.52381, ('air_a2b29aa7feb4e36f',): RollingMean: 16.761905, ('air_a304330715435390',): RollingMean: 7.714286, ('air_a33461f4392ec62c',): RollingMean: 28.857143, ('air_a373500730e2a9e0',): RollingMean: 10.47619, ('air_a38f25e3399d1b25',): RollingMean: 43.571429, ('air_a41b032371a63427',): RollingMean: 11.571429, ('air_a49f1cf0634f13e5',): RollingMean: 24.238095, ('air_a510dcfe979f09eb',): RollingMean: 14.571429, ('air_a546cbf478a8b6e4',): RollingMean: 28.095238, ('air_a55d17bd3f3033cb',): RollingMean: 12.952381, ('air_a563896da3777078',): RollingMean: 21.714286, ('air_a678e5b144ca24ce',): RollingMean: 15.52381, ('air_a7404a854919e990',): RollingMean: 8., ('air_a8533b7a992bb0ca',): RollingMean: 17.619048, ('air_a85f0c0c889f6b7e',): RollingMean: 42.761905, ('air_a85f8c0bfd61889f',): RollingMean: 12.952381, ('air_a88ac559064dec08',): RollingMean: 33.809524, ('air_a9133955abccf071',): RollingMean: 27.952381, ('air_a9178f19da58fe99',): RollingMean: 6.857143, ('air_a9a380530c1e121f',): RollingMean: 40.52381, ('air_aa0049fe3cc6f4d6',): RollingMean: 9.380952, ('air_ab3ae0e410b20069',): RollingMean: 16.52381, ('air_ab9746a0f83084b7',): RollingMean: 8.857143, ('air_abcdc8115988a010',): RollingMean: 11.809524, ('air_abf06fcca748dca5',): RollingMean: 8.428571, ('air_ac7a7427c9ae12a5',): RollingMean: 59.095238, ('air_ad13e71e21235131',): RollingMean: 19.666667, ('air_ad60f6b76c9df7ed',): RollingMean: 22.809524, ('air_ad7777590c884721',): RollingMean: 8.142857, ('air_add9a575623726c8',): RollingMean: 41.714286, ('air_ade6e836ffd1da64',): RollingMean: 8.857143, ('air_aed3a8b49abe4a48',): RollingMean: 5.857143, ('air_af03c277a167b2bd',): RollingMean: 25.904762, ('air_af24e3e817dea1e5',): RollingMean: 15.095238, ('air_af63df35857b16e6',): RollingMean: 23.142857, ('air_b0a6a4c5e95c74cf',): RollingMean: 17.190476, ('air_b162fb07fbbdea33',): RollingMean: 14.809524, ('air_b192fb5310436005',): RollingMean: 7.666667, ('air_b1a72bf1ebf4b8ef',): RollingMean: 65.095238, ('air_b1bb1fae86617d7a',): RollingMean: 35.333333, ('air_b1d822f75c9fc615',): RollingMean: 10.142857, ('air_b2395df0e874078d',): RollingMean: 6.47619, ('air_b23d0f519291247d',): RollingMean: 26.428571, ('air_b259b4e4a51a690d',): RollingMean: 21.047619, ('air_b28bed4b2e7167b7',): RollingMean: 16., ('air_b2a639cc7e02edf1',): RollingMean: 19.47619, ('air_b2d8bc9c88b85f96',): RollingMean: 16.666667, ('air_b2d97bd2337c5ba7',): RollingMean: 31.952381, ('air_b2dcec37b83e2494',): RollingMean: 7.904762, ('air_b30fffd7ab1e75a5',): RollingMean: 10.047619, ('air_b3180b74332ba886',): RollingMean: 11.52381, ('air_b3a824511477a4ed',): RollingMean: 6.380952, ('air_b439391e72899756',): RollingMean: 19.190476, ('air_b45b8e456f53942a',): RollingMean: 11., ('air_b4f32bcc399da2b9',): RollingMean: 29.190476, ('air_b5598d12d1b84890',): RollingMean: 5.380952, ('air_b5bdd318005d9aa4',): RollingMean: 36.809524, ('air_b60cc7d6aee68194',): RollingMean: 11.52381, ('air_b711b43ae472cb6b',): RollingMean: 19.809524, ('air_b7fa3d2fca744dd2',): RollingMean: 41.333333, ('air_b80fed1a07c817d2',): RollingMean: 4.666667, ('air_b88192b35ac03c24',): RollingMean: 15.666667, ('air_b8925441167c3152',): RollingMean: 2.047619, ('air_b8a5ee69e5fdcc5b',): RollingMean: 38., ('air_b8d9e1624baaadc2',): RollingMean: 5.952381, ('air_b9e27558fb8bd5c4',): RollingMean: 12.47619, ('air_ba495cccc8f0f237',): RollingMean: 15.904762, ('air_ba937bf13d40fb24',): RollingMean: 17.285714, ('air_bac5f4441db21db9',): RollingMean: 40.761905, ('air_baf28ac9f13a307d',): RollingMean: 15.619048, ('air_bb09595bab7d5cfb',): RollingMean: 27.809524, ('air_bb26d6d079594414',): RollingMean: 11.571429, ('air_bb4ff06cd661ee9b',): RollingMean: 34.428571, ('air_bbe1c1a47e09f161',): RollingMean: 1.52381, ('air_bc991c51d6613745',): RollingMean: 20.095238, ('air_bc9a129e11a2efe0',): RollingMean: 31.666667, ('air_bcce1ea4350b7b72',): RollingMean: 18.52381, ('air_bd74a9222edfdfe1',): RollingMean: 12.904762, ('air_bdd32aa407c16335',): RollingMean: 16.428571, ('air_bebd55ed63ab2422',): RollingMean: 8.571429, ('air_bed603c423b7d9d4',): RollingMean: 5.428571, ('air_bedd35489e666605',): RollingMean: 39.714286, ('air_bf13014b6e3e60ca',): RollingMean: 32.952381, ('air_bf21b8350771879b',): RollingMean: 26.809524, ('air_bf617aa68d5f1cfa',): RollingMean: 6.809524, ('air_bf7591560077332d',): RollingMean: 8.904762, ('air_bfafaed35e213fd7',): RollingMean: 11.952381, ('air_bfda7731a6c6fc61',): RollingMean: 19.428571, ('air_c027e2b560442808',): RollingMean: 15., ('air_c0385db498b391e5',): RollingMean: 31.904762, ('air_c1d5d165c055b866',): RollingMean: 30., ('air_c1ff20617c54fee7',): RollingMean: 7.809524, ('air_c225148c0fcc5c72',): RollingMean: 36.52381, ('air_c2626f5f86d57342',): RollingMean: 16.904762, ('air_c26f027b5bc1f081',): RollingMean: 5.142857, ('air_c28983412a7eefcf',): RollingMean: 38.809524, ('air_c2c8435bdb3516d4',): RollingMean: 30.619048, ('air_c31472d14e29cee8',): RollingMean: 13.142857, ('air_c3585b0fba3998d0',): RollingMean: 8.904762, ('air_c3bc011cca3bec65',): RollingMean: 7.666667, ('air_c3dcaf3aeb18e20e',): RollingMean: 17., ('air_c47aa7493b15f297',): RollingMean: 20.571429, ('air_c4fa5c562d5409ca',): RollingMean: 13.52381, ('air_c52c63c781fe48f6',): RollingMean: 27.761905, ('air_c5459218282bedd5',): RollingMean: 23.809524, ('air_c66dbd2c37832d00',): RollingMean: 17.285714, ('air_c6a164dd4060e960',): RollingMean: 12.952381, ('air_c6aa2efba0ffc8eb',): RollingMean: 29.571429, ('air_c6ffd6a93e6b68d6',): RollingMean: 15.571429, ('air_c73d319ffabf287a',): RollingMean: 16.095238, ('air_c759b6abeb552160',): RollingMean: 9.095238, ('air_c77ee2b7d36da265',): RollingMean: 42.095238, ('air_c7d30ab0e07f31d5',): RollingMean: 16.095238, ('air_c7f78b4f3cba33ff',): RollingMean: 23.952381, ('air_c8265ecc116f2284',): RollingMean: 8.428571, ('air_c88467d88b2c8ecd',): RollingMean: 19.952381, ('air_c8a657c8c5c93d69',): RollingMean: 7.142857, ('air_c8c0ef02ed72053f',): RollingMean: 27.190476, ('air_c8fe396d6c46275d',): RollingMean: 16.142857, ('air_c92745dfdd2ec68a',): RollingMean: 18.52381, ('air_c9ed65554b6edffb',): RollingMean: 11.809524, ('air_c9f6de13be8b8f25',): RollingMean: 3.809524, ('air_ca1315af9e073bd1',): RollingMean: 42.380952, ('air_ca6ae8d49a2f1eaf',): RollingMean: 21.380952, ('air_ca957d3a1529fbd3',): RollingMean: 33.619048, ('air_cadf9cfb510a1d78',): RollingMean: 32.666667, ('air_caf996ac27206301',): RollingMean: 4.52381, ('air_cb083b4789a8d3a2',): RollingMean: 17.52381, ('air_cb25551c4cd8d9f3',): RollingMean: 9.428571, ('air_cb7467aed805e7fe',): RollingMean: 36.095238, ('air_cb935ff8610ba3d3',): RollingMean: 5.952381, ('air_cbe139af83feb388',): RollingMean: 10.428571, ('air_cbe867adcf44e14f',): RollingMean: 15.380952, ('air_cc1a0e985ce63711',): RollingMean: 30., ('air_cc35590cd1da8554',): RollingMean: 18.190476, ('air_ccd19a5bc5573ae5',): RollingMean: 35.904762, ('air_cd4b301d5d3918d8',): RollingMean: 6.47619, ('air_cd5f54969be9ed08',): RollingMean: 7.142857, ('air_ced6297e5bdf5130',): RollingMean: 25.809524, ('air_cf2229e64408d9fe',): RollingMean: 16.571429, ('air_cf22e368c1a71d53',): RollingMean: 36.428571, ('air_cf5ab75a0afb8af9',): RollingMean: 45.190476, ('air_cfcc94797d2b5d3d',): RollingMean: 17.333333, ('air_cfdeb326418194ff',): RollingMean: 14.761905, ('air_d00161e19f08290b',): RollingMean: 26.666667, ('air_d00a15343325e5f7',): RollingMean: 17.571429, ('air_d07e57b21109304a',): RollingMean: 11.142857, ('air_d0a1e69685259c92',): RollingMean: 33.190476, ('air_d0a7bd3339c3d12a',): RollingMean: 36.714286, ('air_d0e8a085d8dc83aa',): RollingMean: 7.952381, ('air_d138b593ebda55cc',): RollingMean: 5.380952, ('air_d1418d6fd6d634f2',): RollingMean: 15.714286, ('air_d186b2cb0b9ce022',): RollingMean: 13.380952, ('air_d1f20424f76cc78e',): RollingMean: 19.333333, ('air_d34c0861a2be94cb',): RollingMean: 43.142857, ('air_d3e7b5952cd09ccb',): RollingMean: 19.714286, ('air_d44d210d2994f01b',): RollingMean: 5.714286, ('air_d473620754bf9fc2',): RollingMean: 12.904762, ('air_d477b6339b8ce69f',): RollingMean: 8.047619, ('air_d4981cdde163b172',): RollingMean: 24.714286, ('air_d4b5a4b04c5f2d04',): RollingMean: 12.619048, ('air_d4d218b451f82c3d',): RollingMean: 9.904762, ('air_d500b48a8735fbd3',): RollingMean: 17.47619, ('air_d54d6fcb116fbed3',): RollingMean: 4.428571, ('air_d5e0a20370c325c7',): RollingMean: 29.190476, ('air_d63cfa6d6ab78446',): RollingMean: 18.238095, ('air_d69b08a175bc0387',): RollingMean: 10.809524, ('air_d6b3e67261f07646',): RollingMean: 14.666667, ('air_d8abb9e490abf94f',): RollingMean: 12.380952, ('air_d97dabf7aae60da5',): RollingMean: 33.190476, ('air_d98380a4aeb0290b',): RollingMean: 42.761905, ('air_daa7947e1c47f5ed',): RollingMean: 34., ('air_dabfbd0ec951925a',): RollingMean: 7.142857, ('air_dad0b6a36138f309',): RollingMean: 5.571429, ('air_db1233ad855b34d5',): RollingMean: 25.52381, ('air_db4b38ebe7a7ceff',): RollingMean: 23.714286, ('air_db80363d35f10926',): RollingMean: 28.714286, ('air_dbf64f1ce38c7442',): RollingMean: 15.47619, ('air_dc0e080ba0a5e5af',): RollingMean: 9.047619, ('air_dc71c6cc06cd1aa2',): RollingMean: 6.190476, ('air_de692863bb2dd758',): RollingMean: 21.238095, ('air_de803f7e324936b8',): RollingMean: 25.619048, ('air_de88770300008624',): RollingMean: 17.428571, ('air_dea0655f96947922',): RollingMean: 35.809524, ('air_df507aec929ce5f6',): RollingMean: 23.285714, ('air_df554c4527a1cfe6',): RollingMean: 52.952381, ('air_df5cf5cd03eb68d0',): RollingMean: 7.380952, ('air_df843e6b22e8d540',): RollingMean: 11.952381, ('air_df9355c47c5df9d3',): RollingMean: 27.52381, ('air_dfad598ff642dab7',): RollingMean: 25.952381, ('air_dfe068a1bf85f395',): RollingMean: 37.857143, ('air_e00fe7853c0100d6',): RollingMean: 20.904762, ('air_e0118664da63a2d0',): RollingMean: 16.333333, ('air_e01d99390355408d',): RollingMean: 11.333333, ('air_e053c561f32acc28',): RollingMean: 19.666667, ('air_e08b9cf82057a170',): RollingMean: 33.333333, ('air_e0aee25b56a069f2',): RollingMean: 14.428571, ('air_e0e69668214ff972',): RollingMean: 9.904762, ('air_e0f241bd406810c0',): RollingMean: 32.285714, ('air_e1b76fcb5208fb6b',): RollingMean: 13.52381, ('air_e2208a79e2678432',): RollingMean: 47.714286, ('air_e270aff84ac7e4c8',): RollingMean: 24.571429, ('air_e3020992d5fe5dfd',): RollingMean: 12.190476, ('air_e34c631c766f2766',): RollingMean: 24.47619, ('air_e42bdc3377d1eee7',): RollingMean: 21.190476, ('air_e483f5b3c4f310e0',): RollingMean: 5.380952, ('air_e524c6a9e06cc3a1',): RollingMean: 8.238095, ('air_e55abd740f93ecc4',): RollingMean: 45.666667, ('air_e57dd6884595f60d',): RollingMean: 38.571429, ('air_e58f669b6f1a08ce',): RollingMean: 10.761905, ('air_e5cf003abcc5febb',): RollingMean: 11.428571, ('air_e64de0a6bf0739af',): RollingMean: 45.809524, ('air_e657ca554b0c008c',): RollingMean: 22.571429, ('air_e700e390226d9985',): RollingMean: 16.619048, ('air_e76a668009c5dabc',): RollingMean: 7.952381, ('air_e7d2ac6d53d1b744',): RollingMean: 9.952381, ('air_e7fbee4e3cfe65c5',): RollingMean: 33.095238, ('air_e88bbe2ede3467aa',): RollingMean: 24.380952, ('air_e89735e80d614a7e',): RollingMean: 32.428571, ('air_e8ed9335d0c38333',): RollingMean: 26.52381, ('air_e9ebf7fc520ac76a',): RollingMean: 28.904762, ('air_ea6d0c3acf00b22a',): RollingMean: 21.714286, ('air_ea7c16131980c837',): RollingMean: 7.190476, ('air_eb120e6d384a17a8',): RollingMean: 42.809524, ('air_eb20a89bba7dd3d0',): RollingMean: 2.952381, ('air_eb2d2653586315dd',): RollingMean: 32.380952, ('air_eb5788dba285e725',): RollingMean: 23.52381, ('air_ebd31e812960f517',): RollingMean: 26.47619, ('air_ebe02c3090271fa9',): RollingMean: 11.333333, ('air_ec0fad2def4dcff0',): RollingMean: 15.904762, ('air_eca4a5a191e8d993',): RollingMean: 25.714286, ('air_eca5e0064dc9314a',): RollingMean: 34.571429, ('air_ecab54b57a71b10d',): RollingMean: 13.285714, ('air_eceb97ad6a7d4c07',): RollingMean: 26.571429, ('air_ecf7f141339f1d57',): RollingMean: 18.428571, ('air_eda179770dfa9f91',): RollingMean: 9.428571, ('air_edd5e3d696a5811b',): RollingMean: 42.761905, ('air_ee3a01f0c71a769f',): RollingMean: 26.761905, ('air_ee3ba9af184c6c82',): RollingMean: 16.904762, ('air_eec5e572b9eb9c23',): RollingMean: 14.52381, ('air_eeeadee005c006a2',): RollingMean: 11.952381, ('air_ef47430bcd6f6a89',): RollingMean: 13.809524, ('air_ef789667e2e6fe96',): RollingMean: 33.190476, ('air_ef920fa6f4b085f6',): RollingMean: 37.857143, ('air_efc80d3f96b3aff7',): RollingMean: 9.190476, ('air_efd70b04de878f25',): RollingMean: 31.428571, ('air_efef1e3daecce07e',): RollingMean: 40.666667, ('air_f068442ebb6c246c',): RollingMean: 11.47619, ('air_f0c7272956e62f12',): RollingMean: 3.714286, ('air_f0fb0975bdc2cdf9',): RollingMean: 11.285714, ('air_f1094dbf2aef85d9',): RollingMean: 6.142857, ('air_f180301886c21375',): RollingMean: 14.142857, ('air_f183a514cb8ff4fa',): RollingMean: 43.238095, ('air_f1f9027d4fa8f653',): RollingMean: 28.714286, ('air_f267dd70a6a6b5d3',): RollingMean: 57.714286, ('air_f26f36ec4dc5adb0',): RollingMean: 38.809524, ('air_f2985de32bb792e0',): RollingMean: 31.47619, ('air_f2c5a1f24279c531',): RollingMean: 15.428571, ('air_f3602e4fa2f12993',): RollingMean: 12.52381, ('air_f3f9824b7d70c3cf',): RollingMean: 15.809524, ('air_f4936b91c9addbf0',): RollingMean: 15.666667, ('air_f593fa60ac3541e2',): RollingMean: 12.285714, ('air_f690c42545146e0a',): RollingMean: 12.142857, ('air_f6b2489ccf873c3b',): RollingMean: 15.857143, ('air_f6bfd27e2e174d16',): RollingMean: 12.714286, ('air_f6cdaf7b7fdc6d78',): RollingMean: 8.714286, ('air_f8233ad00755c35c',): RollingMean: 30.333333, ('air_f85e21e543cf44f2',): RollingMean: 5.666667, ('air_f88898cd09f40496',): RollingMean: 7.952381, ('air_f911308e19d64236',): RollingMean: 43.666667, ('air_f9168b23fdfc1e52',): RollingMean: 17.47619, ('air_f927b2da69a82341',): RollingMean: 10.47619, ('air_f957c6d6467d4d90',): RollingMean: 10.47619, ('air_f96765e800907c77',): RollingMean: 45.190476, ('air_fa12b40b02fecfd8',): RollingMean: 15.52381, ('air_fa4ffc9057812fa2',): RollingMean: 4.904762, ('air_fab092c35776a9b1',): RollingMean: 10.809524, ('air_fb44f566d4f64a4e',): RollingMean: 15.809524, ('air_fbadf737162a5ce3',): RollingMean: 15.047619, ('air_fc477473134e9ae5',): RollingMean: 13.333333, ('air_fcd4492c83f1c6b9',): RollingMean: 21.714286, ('air_fcfbdcf7b1f82c6e',): RollingMean: 37.47619, ('air_fd154088b1de6fa7',): RollingMean: 6.52381, ('air_fd6aac1043520e83',): RollingMean: 33.380952, ('air_fdc02ec4a3d21ea4',): RollingMean: 7.619048, ('air_fdcfef8bd859f650',): RollingMean: 3.52381, ('air_fe22ef5a9cbef123',): RollingMean: 23.142857, ('air_fe58c074ec1445ea',): RollingMean: 31.285714, ('air_fea5dc9594450608',): RollingMean: 15.428571, ('air_fee8dcf4d619598e',): RollingMean: 26.190476, ('air_fef9ccb3ba0da2f7',): RollingMean: 8.857143, ('air_ffcc2d5087e1b476',): RollingMean: 19.952381, ('air_fff68b929994bfbd',): RollingMean: 4.428571}), 'by': ['store_id'], 'how': RollingMean: 0., 'on': 'y'} ~['area_name', 'date', 'genre_name', 'latitude', 'longitude', 'store_id'] {'keys': {'area_name', 'date', 'genre_name', 'latitude', 'longitude', 'store_id'}} StandardScaler {'counts': Counter({'y_rollingmean_21_by_store_id': 252108, 'y_rollingmean_14_by_store_id': 252108, 'y_rollingmean_7_by_store_id': 252108, 'weekday': 252108, 'is_weekend': 252108}), 'means': defaultdict(<class 'float'>, {'is_weekend': 0.27469576530693085, 'weekday': 3.0196780744759444, 'y_rollingmean_14_by_store_id': 20.897453818387582, 'y_rollingmean_21_by_store_id': 20.901790561001423, 'y_rollingmean_7_by_store_id': 20.895968753375726}), 'vars': defaultdict(<class 'float'>, {'is_weekend': 0.1992380018293697, 'weekday': 3.7017047339732057, 'y_rollingmean_14_by_store_id': 139.4838567930601, 'y_rollingmean_21_by_store_id': 135.6375578980582, 'y_rollingmean_7_by_store_id': 148.74195644058028}), 'with_std': True} LinearRegression {'_weights': {'y_rollingmean_21_by_store_id': 8.267976730511927, 'y_rollingmean_14_by_store_id': 3.68602087744672, 'y_rollingmean_7_by_store_id': -0.7363408297986024, 'weekday': 6.318523886308725, 'is_weekend': -2.378332613642489}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 19.93106280511352, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 252108})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; }","title":"The art of using pipelines"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/","text":"Part 1 \u00b6 Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning Introduction \u00b6 A recommender system is a software tool designed to generate and suggest items or entities to the users. Popular large scale examples include: Amazon (suggesting products) Facebook (suggesting posts in users' news feeds) Spotify (suggesting music) Social recommendation from graph (mostly used by social networks) are not covered in river . We focus on the general case, item recommendation. This problem can be represented with the user-item matrix: \\[ \\normalsize \\begin{matrix} & \\begin{matrix} _1 & _\\cdots & _\\cdots & _\\cdots & _I \\end{matrix} \\\\ \\begin{matrix} _1 \\\\ _\\vdots \\\\ _\\vdots \\\\ _\\vdots \\\\ _U \\end{matrix} & \\begin{bmatrix} {\\color{Red} ?} & 2 & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & 4.5 \\\\ \\vdots & \\ddots & \\ddots & \\ddots & \\vdots \\\\ 3 & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & 5 & {\\color{Red} ?} \\end{bmatrix} \\end{matrix} \\] Where \\(U\\) and \\(I\\) are the number of user and item of the system, respectively. A matrix entry represents a user's preference for an item, it can be a rating, a like or dislike, etc. Because of the huge number of users and items compared to the number of observed entries, those matrices are very sparsed (usually less than 1% filled). Matrix Factorization (MF) is a class of collaborative filtering algorithms derived from Singular Value Decomposition (SVD) . MF strength lies in its capacity to able to model high cardinality categorical variables interactions. This subfield boomed during the famous Netflix Prize contest in 2006, when numerous novel variants has been invented and became popular thanks to their attractive accuracy and scalability. MF approach seeks to fill the user-item matrix considering the problem as a matrix completion one. MF core idea assume a latent model learning its own representation of the users and the items in a lower latent dimensional space by factorizing the observed parts of the matrix. A factorized user or item is represented as a vector \\(\\mathbf{v}_u\\) or \\(\\mathbf{v}_i\\) composed of \\(k\\) latent factors, with \\(k << U, I\\) . Those learnt latent variables represent, for an item the various aspects describing it, and for a user its interests in terms of those aspects. The model then assume a user's choice or fondness is composed of a sum of preferences about the various aspects of the concerned item. This sum being the dot product between the latent vectors of a given user-item pair: \\[ \\normalsize \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f} \\] MF models weights are learnt in an online fashion, often with stochastic gradient descent as it provides relatively fast running time and good accuracy. There is a great and widely popular library named surprise that implements MF models (and others) but in contrast with river doesn't follow a pure online philosophy (all the data have to be loaded in memory and the API doesn't allow you to update your model with new data). Notes: In recent years, proposed deep learning techniques for recommendation tasks claim state of the art results. However, recent work (August 2019) showed that those promises can't be taken for granted and traditional MF methods are still relevant today. For more information about how the business value of recommender systems is measured and why they are one of the main success stories of machine learning, see the following literature survey (December 2019). Let's start \u00b6 In this tutorial, we are going to explore MF algorithms available in river and test them on a movie recommendation problem with the MovieLens 100K dataset. This latter is a collection of movie ratings (from 1 to 5) that includes various information about both the items and the users. We can access it from the river.datasets module: import json from river import datasets for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } ' ) print ( f 'y = { y } ' ) break x = { \"user\": 259, \"item\": 255, \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 Let's define a routine to evaluate our different models on MovieLens 100K. Mean Absolute Error and Root Mean Squared Error will be our metrics printed alongside model's computation time and memory usage: from river import metrics from river.evaluate import progressive_val_score def evaluate ( model , unpack_user_and_item = True ): X_y = datasets . MovieLens100K ( unpack_user_and_item ) metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True ) Naive prediction \u00b6 It's good practice in machine learning to start with a naive baseline and then iterate from simple things to complex ones observing progress incrementally. Let's start by predicting the target running mean as a first shot: from river import dummy from river import stats model = dummy . StatisticRegressor ( stats . Mean ()) evaluate ( model , unpack_user_and_item = False ) [25,000] MAE: 0.934259, RMSE: 1.124469 \u2013 00:00:00 \u2013 514 B [50,000] MAE: 0.923893, RMSE: 1.105 \u2013 00:00:01 \u2013 514 B [75,000] MAE: 0.937359, RMSE: 1.123696 \u2013 00:00:01 \u2013 514 B [100,000] MAE: 0.942162, RMSE: 1.125783 \u2013 00:00:02 \u2013 514 B Baseline model \u00b6 Now we can do machine learning and explore available models in river.reco module starting with the baseline model. It extends our naive prediction by adding to the global running mean two bias terms characterizing the user and the item discrepancy from the general tendency. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} \\] This baseline model can be viewed as a linear regression where the intercept is replaced by the target running mean with the users and the items one hot encoded. All machine learning models in river expect dicts as input with feature names as keys and feature values as values. Specifically, models from river.reco expect a 'user' and an 'item' entries without any type constraint on their values (i.e. can be strings or numbers), e.g.: x = { 'user' : 'Guido' , 'item' : \"Monty Python's Flying Circus\" } Other entries, if exist, are simply ignored. This is quite useful as we don't need to spend time and storage doing one hot encoding. from river import preprocessing from river import optim from river import reco baseline_params = { 'optimizer' : optim . SGD ( 0.025 ), 'l2' : 0. , 'initializer' : optim . initializers . Zeros () } model = preprocessing . PredClipper ( regressor = reco . Baseline ( ** baseline_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761844, RMSE: 0.960972 \u2013 0:00:00.864336 \u2013 132.26 KB [50,000] MAE: 0.753292, RMSE: 0.951223 \u2013 0:00:01.737809 \u2013 191.78 KB [75,000] MAE: 0.754177, RMSE: 0.953376 \u2013 0:00:02.598330 \u2013 225.88 KB [100,000] MAE: 0.754651, RMSE: 0.954148 \u2013 0:00:03.464756 \u2013 240.29 KB We won two tenth of MAE compared to our naive prediction (0.7546 vs 0.9421) meaning that significant information has been learnt by the model. Funk Matrix Factorization (FunkMF) \u00b6 It's the pure form of matrix factorization consisting of only learning the users and items latent representations as discussed in introduction. Simon Funk popularized its stochastic gradient descent optimization in 2006 during the Netflix Prize. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: FunkMF is sometimes referred as Probabilistic Matrix Factorization which is an extended probabilistic version. funk_mf_params = { 'n_factors' : 10 , 'optimizer' : optim . SGD ( 0.05 ), 'l2' : 0.1 , 'initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ) } model = preprocessing . PredClipper ( regressor = reco . FunkMF ( ** funk_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 1.070136, RMSE: 1.397014 \u2013 0:00:01.705144 \u2013 938.07 KB [50,000] MAE: 0.99174, RMSE: 1.290666 \u2013 0:00:03.466905 \u2013 1.13 MB [75,000] MAE: 0.961072, RMSE: 1.250842 \u2013 0:00:05.205363 \u2013 1.33 MB [100,000] MAE: 0.944883, RMSE: 1.227688 \u2013 0:00:06.934770 \u2013 1.5 MB Results are equivalent to our naive prediction (0.9448 vs 0.9421). By only focusing on the users preferences and the items characteristics, the model is limited in his ability to capture different views of the problem. Despite its poor performance alone, this algorithm is quite useful combined in other models or when we need to build dense representations for other tasks. Biased Matrix Factorization (BiasedMF) \u00b6 It's the combination of the Baseline model and FunkMF. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: Biased Matrix Factorization name is used by some people but some others refer to it by SVD or Funk SVD . It's the case of Yehuda Koren and Robert Bell in Recommender Systems Handbook (Chapter 5 Advances in Collaborative Filtering ) and of surprise library. Nevertheless, SVD could be confused with the original Singular Value Decomposition from which it's derived from, and Funk SVD could also be misleading because of the biased part of the model equation which doesn't come from Simon Funk's work. For those reasons, we chose to side with Biased Matrix Factorization which fits more naturally to it. biased_mf_params = { 'n_factors' : 10 , 'bias_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), 'l2_bias' : 0. , 'l2_latent' : 0. } model = preprocessing . PredClipper ( regressor = reco . BiasedMF ( ** biased_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761818, RMSE: 0.961057 \u2013 0:00:01.917323 \u2013 1.01 MB [50,000] MAE: 0.751667, RMSE: 0.949443 \u2013 0:00:03.825794 \u2013 1.28 MB [75,000] MAE: 0.749653, RMSE: 0.948723 \u2013 0:00:05.737369 \u2013 1.51 MB [100,000] MAE: 0.748559, RMSE: 0.947854 \u2013 0:00:07.666314 \u2013 1.69 MB Results improved (0.7485 vs 0.7546) demonstrating that users and items latent representations bring additional information. To conclude this first tutorial about factorization models, let's review the important parameters to tune when dealing with this family of methods: n_factors : the number of latent factors. The more you set, the more items aspects and users preferences you are going to learn. Too many will cause overfitting, l2 regularization could help. *_optimizer : the optimizers. Classic stochastic gradient descent performs well, finding the good learning rate will make the difference. initializer : the latent weights initialization. Latent vectors have to be initialized with non-constant values. We generally sample them from a zero-mean normal distribution with small standard deviation.","title":"Part 1"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#part-1","text":"Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning","title":"Part 1"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#introduction","text":"A recommender system is a software tool designed to generate and suggest items or entities to the users. Popular large scale examples include: Amazon (suggesting products) Facebook (suggesting posts in users' news feeds) Spotify (suggesting music) Social recommendation from graph (mostly used by social networks) are not covered in river . We focus on the general case, item recommendation. This problem can be represented with the user-item matrix: \\[ \\normalsize \\begin{matrix} & \\begin{matrix} _1 & _\\cdots & _\\cdots & _\\cdots & _I \\end{matrix} \\\\ \\begin{matrix} _1 \\\\ _\\vdots \\\\ _\\vdots \\\\ _\\vdots \\\\ _U \\end{matrix} & \\begin{bmatrix} {\\color{Red} ?} & 2 & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & 4.5 \\\\ \\vdots & \\ddots & \\ddots & \\ddots & \\vdots \\\\ 3 & {\\color{Red} ?} & \\cdots & {\\color{Red} ?} & {\\color{Red} ?} \\\\ {\\color{Red} ?} & {\\color{Red} ?} & \\cdots & 5 & {\\color{Red} ?} \\end{bmatrix} \\end{matrix} \\] Where \\(U\\) and \\(I\\) are the number of user and item of the system, respectively. A matrix entry represents a user's preference for an item, it can be a rating, a like or dislike, etc. Because of the huge number of users and items compared to the number of observed entries, those matrices are very sparsed (usually less than 1% filled). Matrix Factorization (MF) is a class of collaborative filtering algorithms derived from Singular Value Decomposition (SVD) . MF strength lies in its capacity to able to model high cardinality categorical variables interactions. This subfield boomed during the famous Netflix Prize contest in 2006, when numerous novel variants has been invented and became popular thanks to their attractive accuracy and scalability. MF approach seeks to fill the user-item matrix considering the problem as a matrix completion one. MF core idea assume a latent model learning its own representation of the users and the items in a lower latent dimensional space by factorizing the observed parts of the matrix. A factorized user or item is represented as a vector \\(\\mathbf{v}_u\\) or \\(\\mathbf{v}_i\\) composed of \\(k\\) latent factors, with \\(k << U, I\\) . Those learnt latent variables represent, for an item the various aspects describing it, and for a user its interests in terms of those aspects. The model then assume a user's choice or fondness is composed of a sum of preferences about the various aspects of the concerned item. This sum being the dot product between the latent vectors of a given user-item pair: \\[ \\normalsize \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f} \\] MF models weights are learnt in an online fashion, often with stochastic gradient descent as it provides relatively fast running time and good accuracy. There is a great and widely popular library named surprise that implements MF models (and others) but in contrast with river doesn't follow a pure online philosophy (all the data have to be loaded in memory and the API doesn't allow you to update your model with new data). Notes: In recent years, proposed deep learning techniques for recommendation tasks claim state of the art results. However, recent work (August 2019) showed that those promises can't be taken for granted and traditional MF methods are still relevant today. For more information about how the business value of recommender systems is measured and why they are one of the main success stories of machine learning, see the following literature survey (December 2019).","title":"Introduction"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#lets-start","text":"In this tutorial, we are going to explore MF algorithms available in river and test them on a movie recommendation problem with the MovieLens 100K dataset. This latter is a collection of movie ratings (from 1 to 5) that includes various information about both the items and the users. We can access it from the river.datasets module: import json from river import datasets for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } ' ) print ( f 'y = { y } ' ) break x = { \"user\": 259, \"item\": 255, \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 Let's define a routine to evaluate our different models on MovieLens 100K. Mean Absolute Error and Root Mean Squared Error will be our metrics printed alongside model's computation time and memory usage: from river import metrics from river.evaluate import progressive_val_score def evaluate ( model , unpack_user_and_item = True ): X_y = datasets . MovieLens100K ( unpack_user_and_item ) metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True )","title":"Let's start"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#naive-prediction","text":"It's good practice in machine learning to start with a naive baseline and then iterate from simple things to complex ones observing progress incrementally. Let's start by predicting the target running mean as a first shot: from river import dummy from river import stats model = dummy . StatisticRegressor ( stats . Mean ()) evaluate ( model , unpack_user_and_item = False ) [25,000] MAE: 0.934259, RMSE: 1.124469 \u2013 00:00:00 \u2013 514 B [50,000] MAE: 0.923893, RMSE: 1.105 \u2013 00:00:01 \u2013 514 B [75,000] MAE: 0.937359, RMSE: 1.123696 \u2013 00:00:01 \u2013 514 B [100,000] MAE: 0.942162, RMSE: 1.125783 \u2013 00:00:02 \u2013 514 B","title":"Naive prediction"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#baseline-model","text":"Now we can do machine learning and explore available models in river.reco module starting with the baseline model. It extends our naive prediction by adding to the global running mean two bias terms characterizing the user and the item discrepancy from the general tendency. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} \\] This baseline model can be viewed as a linear regression where the intercept is replaced by the target running mean with the users and the items one hot encoded. All machine learning models in river expect dicts as input with feature names as keys and feature values as values. Specifically, models from river.reco expect a 'user' and an 'item' entries without any type constraint on their values (i.e. can be strings or numbers), e.g.: x = { 'user' : 'Guido' , 'item' : \"Monty Python's Flying Circus\" } Other entries, if exist, are simply ignored. This is quite useful as we don't need to spend time and storage doing one hot encoding. from river import preprocessing from river import optim from river import reco baseline_params = { 'optimizer' : optim . SGD ( 0.025 ), 'l2' : 0. , 'initializer' : optim . initializers . Zeros () } model = preprocessing . PredClipper ( regressor = reco . Baseline ( ** baseline_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761844, RMSE: 0.960972 \u2013 0:00:00.864336 \u2013 132.26 KB [50,000] MAE: 0.753292, RMSE: 0.951223 \u2013 0:00:01.737809 \u2013 191.78 KB [75,000] MAE: 0.754177, RMSE: 0.953376 \u2013 0:00:02.598330 \u2013 225.88 KB [100,000] MAE: 0.754651, RMSE: 0.954148 \u2013 0:00:03.464756 \u2013 240.29 KB We won two tenth of MAE compared to our naive prediction (0.7546 vs 0.9421) meaning that significant information has been learnt by the model.","title":"Baseline model"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#funk-matrix-factorization-funkmf","text":"It's the pure form of matrix factorization consisting of only learning the users and items latent representations as discussed in introduction. Simon Funk popularized its stochastic gradient descent optimization in 2006 during the Netflix Prize. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: FunkMF is sometimes referred as Probabilistic Matrix Factorization which is an extended probabilistic version. funk_mf_params = { 'n_factors' : 10 , 'optimizer' : optim . SGD ( 0.05 ), 'l2' : 0.1 , 'initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ) } model = preprocessing . PredClipper ( regressor = reco . FunkMF ( ** funk_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 1.070136, RMSE: 1.397014 \u2013 0:00:01.705144 \u2013 938.07 KB [50,000] MAE: 0.99174, RMSE: 1.290666 \u2013 0:00:03.466905 \u2013 1.13 MB [75,000] MAE: 0.961072, RMSE: 1.250842 \u2013 0:00:05.205363 \u2013 1.33 MB [100,000] MAE: 0.944883, RMSE: 1.227688 \u2013 0:00:06.934770 \u2013 1.5 MB Results are equivalent to our naive prediction (0.9448 vs 0.9421). By only focusing on the users preferences and the items characteristics, the model is limited in his ability to capture different views of the problem. Despite its poor performance alone, this algorithm is quite useful combined in other models or when we need to build dense representations for other tasks.","title":"Funk Matrix Factorization (FunkMF)"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#biased-matrix-factorization-biasedmf","text":"It's the combination of the Baseline model and FunkMF. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] Note: Biased Matrix Factorization name is used by some people but some others refer to it by SVD or Funk SVD . It's the case of Yehuda Koren and Robert Bell in Recommender Systems Handbook (Chapter 5 Advances in Collaborative Filtering ) and of surprise library. Nevertheless, SVD could be confused with the original Singular Value Decomposition from which it's derived from, and Funk SVD could also be misleading because of the biased part of the model equation which doesn't come from Simon Funk's work. For those reasons, we chose to side with Biased Matrix Factorization which fits more naturally to it. biased_mf_params = { 'n_factors' : 10 , 'bias_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), 'l2_bias' : 0. , 'l2_latent' : 0. } model = preprocessing . PredClipper ( regressor = reco . BiasedMF ( ** biased_mf_params ), y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761818, RMSE: 0.961057 \u2013 0:00:01.917323 \u2013 1.01 MB [50,000] MAE: 0.751667, RMSE: 0.949443 \u2013 0:00:03.825794 \u2013 1.28 MB [75,000] MAE: 0.749653, RMSE: 0.948723 \u2013 0:00:05.737369 \u2013 1.51 MB [100,000] MAE: 0.748559, RMSE: 0.947854 \u2013 0:00:07.666314 \u2013 1.69 MB Results improved (0.7485 vs 0.7546) demonstrating that users and items latent representations bring additional information. To conclude this first tutorial about factorization models, let's review the important parameters to tune when dealing with this family of methods: n_factors : the number of latent factors. The more you set, the more items aspects and users preferences you are going to learn. Too many will cause overfitting, l2 regularization could help. *_optimizer : the optimizers. Classic stochastic gradient descent performs well, finding the good learning rate will make the difference. initializer : the latent weights initialization. Latent vectors have to be initialized with non-constant values. We generally sample them from a zero-mean normal distribution with small standard deviation.","title":"Biased Matrix Factorization (BiasedMF)"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/","text":"Part 2 \u00b6 As seen in Part 1 , strength of Matrix Factorization (MF) lies in its ability to deal with sparse and high cardinality categorical variables. In this second tutorial we will have a look at Factorization Machines (FM) algorithm and study how it generalizes the power of MF. Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning Factorization Machines \u00b6 Steffen Rendel came up in 2010 with Factorization Machines , an algorithm able to handle any real valued feature vector, combining the advantages of general predictors with factorization models. It became quite popular in the field of online advertising, notably after winning several Kaggle competitions. The modeling technique starts with a linear regression to capture the effects of each variable individually: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} \\] Then are added interaction terms to learn features relations. Instead of learning a single and specific weight per interaction (as in polynomial regression ), a set of latent factors is learnt per feature (as in MF). An interaction is calculated by multiplying involved features product with their latent vectors dot product. The degree of factorization \u2014 or model order \u2014 represents the maximum number of features per interaction considered. The model equation for a factorization machine of degree \\(d\\) = 2 is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] Where \\(\\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle\\) is the dot product of \\(j\\) and \\(j'\\) latent vectors: \\[ \\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{j, f} \\cdot \\mathbf{v}_{j', f} \\] Higher-order FM will be covered in a following section, just note that factorization models express their power in sparse settings, which is also where higher-order interactions are hard to estimate. Strong emphasis must be placed on feature engineering as it allows FM to mimic most factorization models and significantly impact its performance. High cardinality categorical variables one hot encoding is the most frequent step before feeding the model with data. For more efficiency, river FM implementation considers string values as categorical variables and automatically one hot encode them. FM models have their own module river.facto . ## Mimic Biased Matrix Factorization (BiasedMF) Let's start with a simple example where we want to reproduce the Biased Matrix Factorization model we trained in the previous tutorial. For a fair comparison with Part 1 example , let's set the same evaluation framework: from river import datasets from river import metrics from river.evaluate import progressive_val_score def evaluate ( model ): X_y = datasets . MovieLens100K () metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True ) In order to build an equivalent model we need to use the same hyper-parameters. As we can't replace FM intercept by the global running mean we won't be able to build the exact same model: from river import compose from river import facto from river import preprocessing from river import optim from river import stats fm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'sample_normalization' : False , 'l1_weight' : 0. , 'l2_weight' : 0. , 'l1_latent' : 0. , 'l2_latent' : 0. , 'intercept' : 3 , 'intercept_lr' : .01 , 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor |= facto . FMRegressor ( ** fm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: nan, RMSE: nan \u2013 00:00:04 \u2013 6.55 KB [50,000] MAE: nan, RMSE: nan \u2013 00:00:08 \u2013 6.55 KB [75,000] MAE: nan, RMSE: nan \u2013 00:00:12 \u2013 6.55 KB [100,000] MAE: nan, RMSE: nan \u2013 00:00:16 \u2013 6.55 KB Both MAE are very close to each other (0.7486 vs 0.7485) showing that we almost reproduced reco.BiasedMF algorithm. The cost is a naturally slower running time as FM implementation offers more flexibility. Feature engineering for FM models \u00b6 Let's study the basics of how to properly encode data for FM models. We are going to keep using MovieLens 100K as it provides various feature types: import json for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } \\n y = { y } ' ) break x = { \"user\": 259, \"item\": 255, \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 The features we are going to add to our model don't improve its predictive power. Nevertheless, they are useful to illustrate different methods of data encoding: Set-categorical variables We have seen that categorical variables are one hot encoded automatically if set to strings, in the other hand, set-categorical variables must be encoded explicitly by the user. A good way of doing so is to assign them a value of \\(1/m\\) , where \\(m\\) is the number of elements of the sample set. It gives the feature a constant \"weight\" across all samples preserving model's stability. Let's create a routine to encode movies genres this way: def split_genres ( x ): genres = x [ 'genres' ] . split ( ', ' ) return { f 'genre_ { genre } ' : 1 / len ( genres ) for genre in genres } Numerical variables In practice, transforming numerical features into categorical ones works better in most cases. Feature binning is the natural way, but finding good bins is sometimes more an art than a science. Let's encode users age with something simple: def bin_age ( x ): if x [ 'age' ] <= 18 : return { 'age_0-18' : 1 } elif x [ 'age' ] <= 32 : return { 'age_19-32' : 1 } elif x [ 'age' ] < 55 : return { 'age_33-54' : 1 } else : return { 'age_55-100' : 1 } Let's put everything together: fm_params = { 'n_factors' : 14 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FMRegressor ( ** fm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: nan, RMSE: nan \u2013 00:00:10 \u2013 30.31 KB --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) /var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_36090/4267340742.py in <module> 24 ) 25 ---> 26 evaluate(model) /var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_36090/2127757032.py in evaluate(model) 6 X_y = datasets.MovieLens100K(unpack_user_and_item=False) 7 metric = metrics.MAE() + metrics.RMSE() ----> 8 _ = progressive_val_score(X_y, model, metric, print_every=25_000, show_time=True, show_memory=True) ~/projects/river/river/evaluate/progressive_validation.py in progressive_val_score(dataset, model, metric, moment, delay, print_every, show_time, show_memory, **print_kwargs) 238 ) 239 --> 240 for checkpoint in checkpoints: 241 242 msg = f\"[{checkpoint['Step']:,d}] {metric}\" ~/projects/river/river/evaluate/progressive_validation.py in _progressive_validation(dataset, model, metric, checkpoints, moment, delay, measure_time, measure_memory) 55 metric.update(y_true=y, y_pred=y_pred) 56 if model._supervised: ---> 57 model.learn_one(x=x, y=y, **kwargs) 58 else: 59 model.learn_one(x=x, **kwargs) ~/projects/river/river/preprocessing/pred_clipper.py in learn_one(self, x, y, **kwargs) 54 55 def learn_one(self, x, y, **kwargs): ---> 56 self.regressor.learn_one(x=x, y=y, **kwargs) 57 return self 58 ~/projects/river/river/compose/pipeline.py in learn_one(self, x, y, **params) 502 last_step = next(steps) 503 if last_step._supervised: --> 504 last_step.learn_one(x=x, y=y, **params) 505 else: 506 last_step.learn_one(x, **params) ~/projects/river/river/facto/base.py in learn_one(self, x, y, sample_weight) 75 x = {j: xj / x_l2_norm for j, xj in x.items()} 76 ---> 77 return self._learn_one(x, y, sample_weight=sample_weight) 78 79 def _ohe_cat_features(self, x): ~/projects/river/river/facto/base.py in _learn_one(self, x, y, sample_weight) 105 106 # Update the latent weights --> 107 self._update_latents(x, g_loss) 108 109 return self ~/projects/river/river/facto/fm.py in _update_latents(self, x, g_loss) 91 gradients = {} 92 for j, xj in x.items(): ---> 93 gradients[j] = { 94 f: g_loss * (xj * precomputed_sum[f] - v[j][f] * xj ** 2) 95 + l1 * sign(v[j][f]) ~/projects/river/river/facto/fm.py in <dictcomp>(.0) 91 gradients = {} 92 for j, xj in x.items(): ---> 93 gradients[j] = { 94 f: g_loss * (xj * precomputed_sum[f] - v[j][f] * xj ** 2) 95 + l1 * sign(v[j][f]) KeyboardInterrupt: Note that using more variables involves factorizing a larger latent space, then increasing the number of latent factors \\(k\\) often helps capturing more information. Some other feature engineering tips from 3 idiots' winning solution for Kaggle Criteo display ads competition in 2014: Infrequent modalities often bring noise and little information, transforming them into a special tag can help In some cases, sample-wise normalization seems to make the optimization problem easier to be solved Higher-Order Factorization Machines (HOFM) \u00b6 The model equation generalized to any order \\(d \\geq 2\\) is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right) \\] hofm_params = { 'degree' : 3 , 'n_factors' : 12 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . HOFMRegressor ( ** hofm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761297, RMSE: 0.962054 \u2013 0:00:51.632190 \u2013 2.61 MB [50,000] MAE: 0.751865, RMSE: 0.951499 \u2013 0:01:42.890329 \u2013 3.08 MB [75,000] MAE: 0.750853, RMSE: 0.951526 \u2013 0:02:34.207244 \u2013 3.6 MB [100,000] MAE: 0.750607, RMSE: 0.951982 \u2013 0:03:25.248686 \u2013 4.07 MB As said previously, high-order interactions are often hard to estimate due to too much sparsity, that's why we won't spend too much time here. Field-aware Factorization Machines (FFM) \u00b6 Field-aware variant of FM (FFM) improved the original method by adding the notion of \" fields \". A \" field \" is a group of features that belong to a specific domain (e.g. the \" users \" field, the \" items \" field, or the \" movie genres \" field). FFM restricts itself to pairwise interactions and factorizes separated latent spaces \u2014 one per combination of fields (e.g. users/items, users/movie genres, or items/movie genres) \u2014 instead of a common one shared by all fields. Therefore, each feature has one latent vector per field it can interact with \u2014 so that it can learn the specific effect with each different field. The model equation is defined by: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_{j}} \\rangle x_{j} x_{j'} \\] Where \\(f_j\\) and \\(f_{j'}\\) are the fields corresponding to \\(j\\) and \\(j'\\) features, respectively. ffm_params = { 'n_factors' : 8 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FFMRegressor ( ** ffm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.757718, RMSE: 0.958158 \u2013 0:00:15.781740 \u2013 3.04 MB [50,000] MAE: 0.749502, RMSE: 0.948065 \u2013 0:00:31.431484 \u2013 3.59 MB [75,000] MAE: 0.749275, RMSE: 0.948918 \u2013 0:00:47.079510 \u2013 4.19 MB [100,000] MAE: 0.749542, RMSE: 0.949769 \u2013 0:01:02.776969 \u2013 4.75 MB Note that FFM usually needs to learn smaller number of latent factors \\(k\\) than FM as each latent vector only deals with one field. Field-weighted Factorization Machines (FwFM) \u00b6 Field-weighted Factorization Machines (FwFM) address FFM memory issues caused by its large number of parameters, which is in the order of feature number times field number . As FFM, FwFM is an extension of FM restricted to pairwise interactions, but instead of factorizing separated latent spaces, it learns a specific weight \\(r_{f_j, f_{j'}}\\) for each field combination modelling the interaction strength. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] fwfm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'seed' : 73 , } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FwFMRegressor ( ** fwfm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761539, RMSE: 0.962241 \u2013 0:00:20.963815 \u2013 1.18 MB [50,000] MAE: 0.754089, RMSE: 0.953181 \u2013 0:00:42.057991 \u2013 1.38 MB [75,000] MAE: 0.754806, RMSE: 0.954979 \u2013 0:01:04.051777 \u2013 1.6 MB [100,000] MAE: 0.755404, RMSE: 0.95604 \u2013 0:01:25.823651 \u2013 1.79 MB","title":"Part 2"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#part-2","text":"As seen in Part 1 , strength of Matrix Factorization (MF) lies in its ability to deal with sparse and high cardinality categorical variables. In this second tutorial we will have a look at Factorization Machines (FM) algorithm and study how it generalizes the power of MF. Table of contents of this tutorial series on matrix factorization for recommender systems: Part 1 - Traditional Matrix Factorization methods for Recommender Systems Part 2 - Factorization Machines and Field-aware Factorization Machines Part 3 - Large scale learning and better predictive power with multiple pass learning","title":"Part 2"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#factorization-machines","text":"Steffen Rendel came up in 2010 with Factorization Machines , an algorithm able to handle any real valued feature vector, combining the advantages of general predictors with factorization models. It became quite popular in the field of online advertising, notably after winning several Kaggle competitions. The modeling technique starts with a linear regression to capture the effects of each variable individually: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} \\] Then are added interaction terms to learn features relations. Instead of learning a single and specific weight per interaction (as in polynomial regression ), a set of latent factors is learnt per feature (as in MF). An interaction is calculated by multiplying involved features product with their latent vectors dot product. The degree of factorization \u2014 or model order \u2014 represents the maximum number of features per interaction considered. The model equation for a factorization machine of degree \\(d\\) = 2 is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] Where \\(\\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle\\) is the dot product of \\(j\\) and \\(j'\\) latent vectors: \\[ \\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{j, f} \\cdot \\mathbf{v}_{j', f} \\] Higher-order FM will be covered in a following section, just note that factorization models express their power in sparse settings, which is also where higher-order interactions are hard to estimate. Strong emphasis must be placed on feature engineering as it allows FM to mimic most factorization models and significantly impact its performance. High cardinality categorical variables one hot encoding is the most frequent step before feeding the model with data. For more efficiency, river FM implementation considers string values as categorical variables and automatically one hot encode them. FM models have their own module river.facto . ## Mimic Biased Matrix Factorization (BiasedMF) Let's start with a simple example where we want to reproduce the Biased Matrix Factorization model we trained in the previous tutorial. For a fair comparison with Part 1 example , let's set the same evaluation framework: from river import datasets from river import metrics from river.evaluate import progressive_val_score def evaluate ( model ): X_y = datasets . MovieLens100K () metric = metrics . MAE () + metrics . RMSE () _ = progressive_val_score ( X_y , model , metric , print_every = 25_000 , show_time = True , show_memory = True ) In order to build an equivalent model we need to use the same hyper-parameters. As we can't replace FM intercept by the global running mean we won't be able to build the exact same model: from river import compose from river import facto from river import preprocessing from river import optim from river import stats fm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.025 ), 'latent_optimizer' : optim . SGD ( 0.05 ), 'sample_normalization' : False , 'l1_weight' : 0. , 'l2_weight' : 0. , 'l1_latent' : 0. , 'l2_latent' : 0. , 'intercept' : 3 , 'intercept_lr' : .01 , 'weight_initializer' : optim . initializers . Zeros (), 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.1 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor |= facto . FMRegressor ( ** fm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: nan, RMSE: nan \u2013 00:00:04 \u2013 6.55 KB [50,000] MAE: nan, RMSE: nan \u2013 00:00:08 \u2013 6.55 KB [75,000] MAE: nan, RMSE: nan \u2013 00:00:12 \u2013 6.55 KB [100,000] MAE: nan, RMSE: nan \u2013 00:00:16 \u2013 6.55 KB Both MAE are very close to each other (0.7486 vs 0.7485) showing that we almost reproduced reco.BiasedMF algorithm. The cost is a naturally slower running time as FM implementation offers more flexibility.","title":"Factorization Machines"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#feature-engineering-for-fm-models","text":"Let's study the basics of how to properly encode data for FM models. We are going to keep using MovieLens 100K as it provides various feature types: import json for x , y in datasets . MovieLens100K (): print ( f 'x = { json . dumps ( x , indent = 4 ) } \\n y = { y } ' ) break x = { \"user\": 259, \"item\": 255, \"timestamp\": 874731910000000000, \"title\": \"My Best Friend's Wedding (1997)\", \"release_date\": 866764800000000000, \"genres\": \"comedy, romance\", \"age\": 21.0, \"gender\": \"M\", \"occupation\": \"student\", \"zip_code\": \"48823\" } y = 4.0 The features we are going to add to our model don't improve its predictive power. Nevertheless, they are useful to illustrate different methods of data encoding: Set-categorical variables We have seen that categorical variables are one hot encoded automatically if set to strings, in the other hand, set-categorical variables must be encoded explicitly by the user. A good way of doing so is to assign them a value of \\(1/m\\) , where \\(m\\) is the number of elements of the sample set. It gives the feature a constant \"weight\" across all samples preserving model's stability. Let's create a routine to encode movies genres this way: def split_genres ( x ): genres = x [ 'genres' ] . split ( ', ' ) return { f 'genre_ { genre } ' : 1 / len ( genres ) for genre in genres } Numerical variables In practice, transforming numerical features into categorical ones works better in most cases. Feature binning is the natural way, but finding good bins is sometimes more an art than a science. Let's encode users age with something simple: def bin_age ( x ): if x [ 'age' ] <= 18 : return { 'age_0-18' : 1 } elif x [ 'age' ] <= 32 : return { 'age_19-32' : 1 } elif x [ 'age' ] < 55 : return { 'age_33-54' : 1 } else : return { 'age_55-100' : 1 } Let's put everything together: fm_params = { 'n_factors' : 14 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FMRegressor ( ** fm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: nan, RMSE: nan \u2013 00:00:10 \u2013 30.31 KB --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) /var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_36090/4267340742.py in <module> 24 ) 25 ---> 26 evaluate(model) /var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_36090/2127757032.py in evaluate(model) 6 X_y = datasets.MovieLens100K(unpack_user_and_item=False) 7 metric = metrics.MAE() + metrics.RMSE() ----> 8 _ = progressive_val_score(X_y, model, metric, print_every=25_000, show_time=True, show_memory=True) ~/projects/river/river/evaluate/progressive_validation.py in progressive_val_score(dataset, model, metric, moment, delay, print_every, show_time, show_memory, **print_kwargs) 238 ) 239 --> 240 for checkpoint in checkpoints: 241 242 msg = f\"[{checkpoint['Step']:,d}] {metric}\" ~/projects/river/river/evaluate/progressive_validation.py in _progressive_validation(dataset, model, metric, checkpoints, moment, delay, measure_time, measure_memory) 55 metric.update(y_true=y, y_pred=y_pred) 56 if model._supervised: ---> 57 model.learn_one(x=x, y=y, **kwargs) 58 else: 59 model.learn_one(x=x, **kwargs) ~/projects/river/river/preprocessing/pred_clipper.py in learn_one(self, x, y, **kwargs) 54 55 def learn_one(self, x, y, **kwargs): ---> 56 self.regressor.learn_one(x=x, y=y, **kwargs) 57 return self 58 ~/projects/river/river/compose/pipeline.py in learn_one(self, x, y, **params) 502 last_step = next(steps) 503 if last_step._supervised: --> 504 last_step.learn_one(x=x, y=y, **params) 505 else: 506 last_step.learn_one(x, **params) ~/projects/river/river/facto/base.py in learn_one(self, x, y, sample_weight) 75 x = {j: xj / x_l2_norm for j, xj in x.items()} 76 ---> 77 return self._learn_one(x, y, sample_weight=sample_weight) 78 79 def _ohe_cat_features(self, x): ~/projects/river/river/facto/base.py in _learn_one(self, x, y, sample_weight) 105 106 # Update the latent weights --> 107 self._update_latents(x, g_loss) 108 109 return self ~/projects/river/river/facto/fm.py in _update_latents(self, x, g_loss) 91 gradients = {} 92 for j, xj in x.items(): ---> 93 gradients[j] = { 94 f: g_loss * (xj * precomputed_sum[f] - v[j][f] * xj ** 2) 95 + l1 * sign(v[j][f]) ~/projects/river/river/facto/fm.py in <dictcomp>(.0) 91 gradients = {} 92 for j, xj in x.items(): ---> 93 gradients[j] = { 94 f: g_loss * (xj * precomputed_sum[f] - v[j][f] * xj ** 2) 95 + l1 * sign(v[j][f]) KeyboardInterrupt: Note that using more variables involves factorizing a larger latent space, then increasing the number of latent factors \\(k\\) often helps capturing more information. Some other feature engineering tips from 3 idiots' winning solution for Kaggle Criteo display ads competition in 2014: Infrequent modalities often bring noise and little information, transforming them into a special tag can help In some cases, sample-wise normalization seems to make the optimization problem easier to be solved","title":"Feature engineering for FM models"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#higher-order-factorization-machines-hofm","text":"The model equation generalized to any order \\(d \\geq 2\\) is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right) \\] hofm_params = { 'degree' : 3 , 'n_factors' : 12 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . HOFMRegressor ( ** hofm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761297, RMSE: 0.962054 \u2013 0:00:51.632190 \u2013 2.61 MB [50,000] MAE: 0.751865, RMSE: 0.951499 \u2013 0:01:42.890329 \u2013 3.08 MB [75,000] MAE: 0.750853, RMSE: 0.951526 \u2013 0:02:34.207244 \u2013 3.6 MB [100,000] MAE: 0.750607, RMSE: 0.951982 \u2013 0:03:25.248686 \u2013 4.07 MB As said previously, high-order interactions are often hard to estimate due to too much sparsity, that's why we won't spend too much time here.","title":"Higher-Order Factorization Machines (HOFM)"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#field-aware-factorization-machines-ffm","text":"Field-aware variant of FM (FFM) improved the original method by adding the notion of \" fields \". A \" field \" is a group of features that belong to a specific domain (e.g. the \" users \" field, the \" items \" field, or the \" movie genres \" field). FFM restricts itself to pairwise interactions and factorizes separated latent spaces \u2014 one per combination of fields (e.g. users/items, users/movie genres, or items/movie genres) \u2014 instead of a common one shared by all fields. Therefore, each feature has one latent vector per field it can interact with \u2014 so that it can learn the specific effect with each different field. The model equation is defined by: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_{j}} \\rangle x_{j} x_{j'} \\] Where \\(f_j\\) and \\(f_{j'}\\) are the fields corresponding to \\(j\\) and \\(j'\\) features, respectively. ffm_params = { 'n_factors' : 8 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'latent_initializer' : optim . initializers . Normal ( mu = 0. , sigma = 0.05 , seed = 73 ), } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FFMRegressor ( ** ffm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.757718, RMSE: 0.958158 \u2013 0:00:15.781740 \u2013 3.04 MB [50,000] MAE: 0.749502, RMSE: 0.948065 \u2013 0:00:31.431484 \u2013 3.59 MB [75,000] MAE: 0.749275, RMSE: 0.948918 \u2013 0:00:47.079510 \u2013 4.19 MB [100,000] MAE: 0.749542, RMSE: 0.949769 \u2013 0:01:02.776969 \u2013 4.75 MB Note that FFM usually needs to learn smaller number of latent factors \\(k\\) than FM as each latent vector only deals with one field.","title":"Field-aware Factorization Machines (FFM)"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#field-weighted-factorization-machines-fwfm","text":"Field-weighted Factorization Machines (FwFM) address FFM memory issues caused by its large number of parameters, which is in the order of feature number times field number . As FFM, FwFM is an extension of FM restricted to pairwise interactions, but instead of factorizing separated latent spaces, it learns a specific weight \\(r_{f_j, f_{j'}}\\) for each field combination modelling the interaction strength. The model equation is defined as: \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] fwfm_params = { 'n_factors' : 10 , 'weight_optimizer' : optim . SGD ( 0.01 ), 'latent_optimizer' : optim . SGD ( 0.025 ), 'intercept' : 3 , 'seed' : 73 , } regressor = compose . Select ( 'user' , 'item' ) regressor += ( compose . Select ( 'genres' ) | compose . FuncTransformer ( split_genres ) ) regressor += ( compose . Select ( 'age' ) | compose . FuncTransformer ( bin_age ) ) regressor |= facto . FwFMRegressor ( ** fwfm_params ) model = preprocessing . PredClipper ( regressor = regressor , y_min = 1 , y_max = 5 ) evaluate ( model ) [25,000] MAE: 0.761539, RMSE: 0.962241 \u2013 0:00:20.963815 \u2013 1.18 MB [50,000] MAE: 0.754089, RMSE: 0.953181 \u2013 0:00:42.057991 \u2013 1.38 MB [75,000] MAE: 0.754806, RMSE: 0.954979 \u2013 0:01:04.051777 \u2013 1.6 MB [100,000] MAE: 0.755404, RMSE: 0.95604 \u2013 0:01:25.823651 \u2013 1.79 MB","title":"Field-weighted Factorization Machines (FwFM)"},{"location":"examples/matrix-factorization-for-recommender-systems/part-3/","text":"Part 3 \u00b6 To do.","title":"Part 3"},{"location":"examples/matrix-factorization-for-recommender-systems/part-3/#part-3","text":"To do.","title":"Part 3"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Do all classifiers support multi-class classification? \u00b6 No, they don't. Although binary classification can be seen as a special case of multi-class classification, there are many optimizations that can be performed if we know that there are only two classes. It would be annoying to have to check whether this is the case in an online setting. All in all we find that separating both cases leads to much cleaner code. Note that the multiclass module contains wrapper models that enable you to perform multi-class classification with binary classifiers. How do I know if a classifier supports multi-class classification? \u00b6 Each classifier in river inherits from the base.Classifier class. Each classifier therefore has a _multiclass property which indicates whether or not it can process a non-boolean target value. >>> from river import linear_model >>> classifier = linear_model . LogisticRegression () >>> classifier . _multiclass False Why doesn't river do any input validation? \u00b6 Python encourages a coding style called EAFP , which stands for \"Easier to Ask for Forgiveness than Permission\". The idea is to assume that runtime errors don't occur, and instead use try/expects to catch errors. The great benefit is that we don't have to drown our code with if statements, which is symptomatic of the LBYL style , which stands for \"look before you leap\". This makes our implementations much more readable than, say, scikit-learn, which does a lot of input validation. The catch is that users have to be careful to use sane inputs. As always, there is no free lunch ! What about reinforcement learning? \u00b6 Reinforcement learning works in an online manner because of the nature of the task. Reinforcement learning can be therefore be seen as a subcase of online machine learning. However, we prefer not to support it because there are already many existing opensource libraries dedicated to it. **What are the differences between scikit-learn's online learning algorithm which have a partial_fit method ## d their equivalents in river? The algorithms from sklearn that support incremental learning are mostly meant for mini-batch learning. In a pure streaming context where the observations arrive one by one, then river is much faster than sklearn . This is mostly because sklearn incurs a lot of overhead by performing data checks. Also, sklearn assumes that you're always using the same number of features. This is not the case with river because it use dictionaries which allows you to drop and add features as you wish. How do I save and load models? \u00b6 >>> from river import ensemble >>> import pickle >>> model = ensemble . AdaptiveRandomForestClassifier () # save >>> with open ( 'model.pkl' , 'wb' ) as f : ... pickle . dump ( model , f ) # load >>> with open ( 'model.pkl' , 'rb' ) as f : ... model = pickle . load ( f ) We also encourage you to try out dill and cloudpickle . What about neural networks? \u00b6 There are many great open-source libraries for building neural network models. We don't feel that we can bring anything of value to the existing Python ecosystem. However, we are open to implementing compatibility wrappers for popular libraries such as PyTorch and Keras. Who are the authors of this library? \u00b6 We are research engineers, graduate students, PhDs and machine learning researchers. The members of the develompent team are mainly located in France, Brazil and New Zealand.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#do-all-classifiers-support-multi-class-classification","text":"No, they don't. Although binary classification can be seen as a special case of multi-class classification, there are many optimizations that can be performed if we know that there are only two classes. It would be annoying to have to check whether this is the case in an online setting. All in all we find that separating both cases leads to much cleaner code. Note that the multiclass module contains wrapper models that enable you to perform multi-class classification with binary classifiers.","title":"Do all classifiers support multi-class classification?"},{"location":"faq/#how-do-i-know-if-a-classifier-supports-multi-class-classification","text":"Each classifier in river inherits from the base.Classifier class. Each classifier therefore has a _multiclass property which indicates whether or not it can process a non-boolean target value. >>> from river import linear_model >>> classifier = linear_model . LogisticRegression () >>> classifier . _multiclass False","title":"How do I know if a classifier supports multi-class classification?"},{"location":"faq/#why-doesnt-river-do-any-input-validation","text":"Python encourages a coding style called EAFP , which stands for \"Easier to Ask for Forgiveness than Permission\". The idea is to assume that runtime errors don't occur, and instead use try/expects to catch errors. The great benefit is that we don't have to drown our code with if statements, which is symptomatic of the LBYL style , which stands for \"look before you leap\". This makes our implementations much more readable than, say, scikit-learn, which does a lot of input validation. The catch is that users have to be careful to use sane inputs. As always, there is no free lunch !","title":"Why doesn't river do any input validation?"},{"location":"faq/#what-about-reinforcement-learning","text":"Reinforcement learning works in an online manner because of the nature of the task. Reinforcement learning can be therefore be seen as a subcase of online machine learning. However, we prefer not to support it because there are already many existing opensource libraries dedicated to it. **What are the differences between scikit-learn's online learning algorithm which have a partial_fit method ## d their equivalents in river? The algorithms from sklearn that support incremental learning are mostly meant for mini-batch learning. In a pure streaming context where the observations arrive one by one, then river is much faster than sklearn . This is mostly because sklearn incurs a lot of overhead by performing data checks. Also, sklearn assumes that you're always using the same number of features. This is not the case with river because it use dictionaries which allows you to drop and add features as you wish.","title":"What about reinforcement learning?"},{"location":"faq/#how-do-i-save-and-load-models","text":">>> from river import ensemble >>> import pickle >>> model = ensemble . AdaptiveRandomForestClassifier () # save >>> with open ( 'model.pkl' , 'wb' ) as f : ... pickle . dump ( model , f ) # load >>> with open ( 'model.pkl' , 'rb' ) as f : ... model = pickle . load ( f ) We also encourage you to try out dill and cloudpickle .","title":"How do I save and load models?"},{"location":"faq/#what-about-neural-networks","text":"There are many great open-source libraries for building neural network models. We don't feel that we can bring anything of value to the existing Python ecosystem. However, we are open to implementing compatibility wrappers for popular libraries such as PyTorch and Keras.","title":"What about neural networks?"},{"location":"faq/#who-are-the-authors-of-this-library","text":"We are research engineers, graduate students, PhDs and machine learning researchers. The members of the develompent team are mainly located in France, Brazil and New Zealand.","title":"Who are the authors of this library?"},{"location":"introduction/basic-concepts/","text":"Basic concepts \u00b6 Here are some concepts to give you a feel for what problems River addresses. Data streams \u00b6 River is a library to build online machine learning models. Such models operate on data streams. But a data stream is a bit of a vague concept. In general, a data stream is a sequence of individual elements. In the case of machine learning, each element is a bunch of features. We call these samples, or observations. Each sample might follow a fixed structure and always contain the same features. But features can also appear and disappear over time. That depends on the use case. Reactive and proactive data streams \u00b6 The origin of a data stream can vary, and usually it doesn't matter. You should be able to use River regardless of where your data comes from. It is however important to keep in mind the difference between reactive and proactive data streams. Reactive data streams are ones where the data comes to you. For instance, when a user visits your website, that's out of your control. You have no influence on the event. It just happens and you have to react to it. Proactive data streams are ones where you have control on the data stream. For example, you might be reading the data from a file. You decide at which speed you want to read the data, in what order, etc. If you consider data analysis as a whole, you're realize that the general approach is to turn reactive streams into proactive datasets. Events are usually logged into a database and are processed offline. Be it for building KPIs or training models. The challenge for machine learning is to ensure models you train offline on proactive datasets will perform correctly in production on reactive data streams. Online processing \u00b6 Online processing is the act of processing a data stream one element at a time. In the case of machine learning, that means training a model by teaching it one sample at a time. This is completely opposite to the traditional way of doing machine learning, which is to train a model on a whole batch data at a time. An online model is therefore a stateful, dynamic object. It keeps learning and doesn't have to revisit past data. It's a different way of doing things, and therefore has its own set of pros and cons. Tasks \u00b6 Machine learning encompasses many different tasks: classification, regression, anomaly detection, time series forecasting, etc. The ideology behind River is to be a generic machine learning which allows to perform these tasks in a streaming manner. Indeed, many batch machine learning algorithms have online equivalents. Note that River also supports some more basic tasks. For instance, you might just want to calculate a running average of a data stream. These are usually smaller parts of a whole stream processing pipeline. Dictionaries everywhere \u00b6 River a Python library. It is composed of a bunch of classes which implement various online processing algorithms. Most of these classes are machine learning models which can process a single sample, be it for learning or for inference. We made the choice to use dictionaries as the basic building block. First of all, online processing is different to batch processing, in that vectorization doesn't bring any speedup. Therefore numeric processing libraries such as numpy and PyTorch actually bring too much overhead. Using native Python data structures is faster. Dictionaries are therefore a perfect fit. They're native to Python and have excellent support in the standard library. They allow naming each feature. They can hold any kind of data type. They allow transparent support of JSON payloads, allowing seemless integration with web apps. Datasets \u00b6 In production, you're almost always going to face data streams which you have to react to. Such as users visiting your website. The advantage of online machine learning is that you can design models which make predictions as well as learn from this data stream as it flows. But of course, when you're developping a model, you don't usually have access to a real-time feed on which to evaluate your model. You usually have an offline dataset which you want to evaluate your model on. River provides some datasets which can be read in online manner, one sample at a time. It is however crucial to keep in mind that the goal is to reproduce a production scenario as closely as possible, in order to ensure your model will perform just as well in production. Model evaluation \u00b6 Online model evaluation differs from its traditional batch counterpart. In the latter, you usually perform cross-validation, whereby your training dataset is split into a learning and an evaluation dataset. This is fine, but it doesn't exactly reflect the data generation process that occurs in production. Online model evaluation involves learning and inference in the same order as what would happen in production. Indeed, if you know the order in which your data arrives, then you can process it the exact same order. This allows you to replay a production scenario and evaluate your model with higher fidelity that cross-validation. This is what makes online machine learning powerful. By replaying datasets in the correct order, you ensure you are designing models which will perform as expected in production. Concept drift \u00b6 The main reason why an online model might not perform as expected in production is because of concept drift. But this is true for all machine learning models, be they offline or online. The advantage of online models over offline models is that they can cope with drift. Indeed, because they can keep learning, they usually adapt to concept drift in a seemless manner. As opposed to batch models which have to be retrained from scratch.","title":"Basic concepts"},{"location":"introduction/basic-concepts/#basic-concepts","text":"Here are some concepts to give you a feel for what problems River addresses.","title":"Basic concepts"},{"location":"introduction/basic-concepts/#data-streams","text":"River is a library to build online machine learning models. Such models operate on data streams. But a data stream is a bit of a vague concept. In general, a data stream is a sequence of individual elements. In the case of machine learning, each element is a bunch of features. We call these samples, or observations. Each sample might follow a fixed structure and always contain the same features. But features can also appear and disappear over time. That depends on the use case.","title":"Data streams"},{"location":"introduction/basic-concepts/#reactive-and-proactive-data-streams","text":"The origin of a data stream can vary, and usually it doesn't matter. You should be able to use River regardless of where your data comes from. It is however important to keep in mind the difference between reactive and proactive data streams. Reactive data streams are ones where the data comes to you. For instance, when a user visits your website, that's out of your control. You have no influence on the event. It just happens and you have to react to it. Proactive data streams are ones where you have control on the data stream. For example, you might be reading the data from a file. You decide at which speed you want to read the data, in what order, etc. If you consider data analysis as a whole, you're realize that the general approach is to turn reactive streams into proactive datasets. Events are usually logged into a database and are processed offline. Be it for building KPIs or training models. The challenge for machine learning is to ensure models you train offline on proactive datasets will perform correctly in production on reactive data streams.","title":"Reactive and proactive data streams"},{"location":"introduction/basic-concepts/#online-processing","text":"Online processing is the act of processing a data stream one element at a time. In the case of machine learning, that means training a model by teaching it one sample at a time. This is completely opposite to the traditional way of doing machine learning, which is to train a model on a whole batch data at a time. An online model is therefore a stateful, dynamic object. It keeps learning and doesn't have to revisit past data. It's a different way of doing things, and therefore has its own set of pros and cons.","title":"Online processing"},{"location":"introduction/basic-concepts/#tasks","text":"Machine learning encompasses many different tasks: classification, regression, anomaly detection, time series forecasting, etc. The ideology behind River is to be a generic machine learning which allows to perform these tasks in a streaming manner. Indeed, many batch machine learning algorithms have online equivalents. Note that River also supports some more basic tasks. For instance, you might just want to calculate a running average of a data stream. These are usually smaller parts of a whole stream processing pipeline.","title":"Tasks"},{"location":"introduction/basic-concepts/#dictionaries-everywhere","text":"River a Python library. It is composed of a bunch of classes which implement various online processing algorithms. Most of these classes are machine learning models which can process a single sample, be it for learning or for inference. We made the choice to use dictionaries as the basic building block. First of all, online processing is different to batch processing, in that vectorization doesn't bring any speedup. Therefore numeric processing libraries such as numpy and PyTorch actually bring too much overhead. Using native Python data structures is faster. Dictionaries are therefore a perfect fit. They're native to Python and have excellent support in the standard library. They allow naming each feature. They can hold any kind of data type. They allow transparent support of JSON payloads, allowing seemless integration with web apps.","title":"Dictionaries everywhere"},{"location":"introduction/basic-concepts/#datasets","text":"In production, you're almost always going to face data streams which you have to react to. Such as users visiting your website. The advantage of online machine learning is that you can design models which make predictions as well as learn from this data stream as it flows. But of course, when you're developping a model, you don't usually have access to a real-time feed on which to evaluate your model. You usually have an offline dataset which you want to evaluate your model on. River provides some datasets which can be read in online manner, one sample at a time. It is however crucial to keep in mind that the goal is to reproduce a production scenario as closely as possible, in order to ensure your model will perform just as well in production.","title":"Datasets"},{"location":"introduction/basic-concepts/#model-evaluation","text":"Online model evaluation differs from its traditional batch counterpart. In the latter, you usually perform cross-validation, whereby your training dataset is split into a learning and an evaluation dataset. This is fine, but it doesn't exactly reflect the data generation process that occurs in production. Online model evaluation involves learning and inference in the same order as what would happen in production. Indeed, if you know the order in which your data arrives, then you can process it the exact same order. This allows you to replay a production scenario and evaluate your model with higher fidelity that cross-validation. This is what makes online machine learning powerful. By replaying datasets in the correct order, you ensure you are designing models which will perform as expected in production.","title":"Model evaluation"},{"location":"introduction/basic-concepts/#concept-drift","text":"The main reason why an online model might not perform as expected in production is because of concept drift. But this is true for all machine learning models, be they offline or online. The advantage of online models over offline models is that they can cope with drift. Indeed, because they can keep learning, they usually adapt to concept drift in a seemless manner. As opposed to batch models which have to be retrained from scratch.","title":"Concept drift"},{"location":"introduction/installation/","text":"Installation \u00b6 River is meant to work with Python 3.8 and above. Installation can be done via pip : pip install river You can install the latest development version from GitHub, as so: pip install git+https://github.com/online-ml/river --upgrade Or, through SSH: pip install git+ssh://git@github.com/online-ml/river.git --upgrade Feel welcome to open an issue on GitHub if you are having any trouble.","title":"Installation"},{"location":"introduction/installation/#installation","text":"River is meant to work with Python 3.8 and above. Installation can be done via pip : pip install river You can install the latest development version from GitHub, as so: pip install git+https://github.com/online-ml/river --upgrade Or, through SSH: pip install git+ssh://git@github.com/online-ml/river.git --upgrade Feel welcome to open an issue on GitHub if you are having any trouble.","title":"Installation"},{"location":"introduction/next-steps/","text":"Next steps \u00b6 The Recipes \ud83c\udf71 section is made up of small tutorials. Each one explains how to perform mundane tasks, such as measuring the performance of a model, selecting hyperparameters, etc. The Examples \ud83c\udf36\ufe0f section contains more involved notebooks with less explanations. Each notebook addresses a particular machine learning problem. The API \ud83d\udcda section references all the modules, classes, and functions in River. It is automatically generated from the codebase's Python docstrings. Feel welcome to open a discussion if you have a question. Before that you can check out the FAQ \ud83d\ude4b , which has answers to recurring questions. The released versions are listed in the Releases \ud83c\udfd7 section. Changes that will be part of the next release are listed in the unreleased section of the documentation's development version, which you may find here . We recommend checking out Awesome Online Machine Learning if you want to go deeper. There you will find online machine learning related content: research papers, alternative and complementary software, blog posts, etc.","title":"Next steps"},{"location":"introduction/next-steps/#next-steps","text":"The Recipes \ud83c\udf71 section is made up of small tutorials. Each one explains how to perform mundane tasks, such as measuring the performance of a model, selecting hyperparameters, etc. The Examples \ud83c\udf36\ufe0f section contains more involved notebooks with less explanations. Each notebook addresses a particular machine learning problem. The API \ud83d\udcda section references all the modules, classes, and functions in River. It is automatically generated from the codebase's Python docstrings. Feel welcome to open a discussion if you have a question. Before that you can check out the FAQ \ud83d\ude4b , which has answers to recurring questions. The released versions are listed in the Releases \ud83c\udfd7 section. Changes that will be part of the next release are listed in the unreleased section of the documentation's development version, which you may find here . We recommend checking out Awesome Online Machine Learning if you want to go deeper. There you will find online machine learning related content: research papers, alternative and complementary software, blog posts, etc.","title":"Next steps"},{"location":"introduction/why-use-river/","text":"Why use River? \u00b6 Processing one sample at a time \u00b6 All the tools in the library can be updated with a single observation at a time. They can therefore be used to process streaming data. Depending on your use case, this might be more convenient than using a batch model. Adapting to drift \u00b6 In the streaming setting, data can evolve. Adaptive methods are specifically designed to be robust against concept drift in dynamic environments. Many of River's models can cope with concept drift. General purpose \u00b6 River supports different machine learning tasks, including regression, classification, and unsupervised learning. It can also be used for adhoc tasks, such as computing online metrics, as well as concept drift detection. User experience \u00b6 River is not the only library allowing you to do online machine learning. But it might just the simplest one to use in the Python ecosystem. River plays nicely with Python dictionaries, therefore making it easy to use in the context of web applications where JSON payloads are aplenty.","title":"Why use River?"},{"location":"introduction/why-use-river/#why-use-river","text":"","title":"Why use River?"},{"location":"introduction/why-use-river/#processing-one-sample-at-a-time","text":"All the tools in the library can be updated with a single observation at a time. They can therefore be used to process streaming data. Depending on your use case, this might be more convenient than using a batch model.","title":"Processing one sample at a time"},{"location":"introduction/why-use-river/#adapting-to-drift","text":"In the streaming setting, data can evolve. Adaptive methods are specifically designed to be robust against concept drift in dynamic environments. Many of River's models can cope with concept drift.","title":"Adapting to drift"},{"location":"introduction/why-use-river/#general-purpose","text":"River supports different machine learning tasks, including regression, classification, and unsupervised learning. It can also be used for adhoc tasks, such as computing online metrics, as well as concept drift detection.","title":"General purpose"},{"location":"introduction/why-use-river/#user-experience","text":"River is not the only library allowing you to do online machine learning. But it might just the simplest one to use in the Python ecosystem. River plays nicely with Python dictionaries, therefore making it easy to use in the context of web applications where JSON payloads are aplenty.","title":"User experience"},{"location":"introduction/getting-started/binary-classification/","text":"Binary classification \u00b6 Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome. A labeled classification sample is made up of a bunch of features and a class. The class is a boolean in the case of binary classification. We'll use the image segments dataset as an example. from river import datasets dataset = datasets . ImageSegments () dataset Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass. Name ImageSegments Task Multi-class classification Samples 2,310 Features 18 Sparse False Path /Users/max.halford/projects/river/river/datasets/segment.csv.zip This dataset is a streaming dataset which can be looped over. for x , y in dataset : pass Let's take a look at the first sample. x , y = next ( iter ( dataset )) x {'empty_server_form_handler': 0.0, 'popup_window': 0.0, 'https': 0.0, 'request_from_other_domain': 0.0, 'anchor_from_other_domain': 0.0, 'is_popular': 0.5, 'long_url': 1.0, 'age_of_domain': 1, 'ip_in_url': 1} y True A binary classifier's goal is to learn to predict a binary target y from some given features x . We'll try to do this with a logistic regression. from river import linear_model model = linear_model . LogisticRegression () model . predict_proba_one ( x ) {False: 0.5, True: 0.5} The model hasn't been trained on any data, and therefore outputs a default probability of 50% for each class. The model can be trained on the sample, which will update the model's state. model = model . learn_one ( x , y ) If we try to make a prediction on the same sample, we can see that the probabilities are different, because the model has learned something. model . predict_proba_one ( x ) {False: 0.5068745667645342, True: 0.4931254332354657} Note that there is also a predict_one if you're only interested in the most likely class rather than the probability distribution. model . predict_one ( x ) False Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation. from river import metrics model = linear_model . LogisticRegression () metric = metrics . ROCAUC () for x , y in dataset : y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric ROCAUC: 89.36% This is a common way to evaluate an online model. In fact, there is a dedicated evaluate.progressive_val_score function that does this for you. from river import evaluate model = linear_model . LogisticRegression () metric = metrics . ROCAUC () evaluate . progressive_val_score ( dataset , model , metric ) ROCAUC: 89.36% A common way to improve the performance of a logistic regression is to scale the data. This can be done by using a preprocessing.StandardScaler . In particular, we can define a pipeline to organise our model into a sequence of steps: from river import compose from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) model --------------------------------------------------------------------------- NameError Traceback (most recent call last) /var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_41345/3672127869.py in <module> 4 model = compose.Pipeline( 5 preprocessing.StandardScaler(), ----> 6 linear_model.LogisticRegression() 7 ) 8 NameError: name 'linear_model' is not defined metric = metrics . ROCAUC () evaluate . progressive_val_score ( dataset , model , metric ) ROCAUC: 95.04% That concludes the getting started introduction to binary classification! You can now move on to the next steps .","title":"Binary classification"},{"location":"introduction/getting-started/binary-classification/#binary-classification","text":"Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome. A labeled classification sample is made up of a bunch of features and a class. The class is a boolean in the case of binary classification. We'll use the image segments dataset as an example. from river import datasets dataset = datasets . ImageSegments () dataset Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass. Name ImageSegments Task Multi-class classification Samples 2,310 Features 18 Sparse False Path /Users/max.halford/projects/river/river/datasets/segment.csv.zip This dataset is a streaming dataset which can be looped over. for x , y in dataset : pass Let's take a look at the first sample. x , y = next ( iter ( dataset )) x {'empty_server_form_handler': 0.0, 'popup_window': 0.0, 'https': 0.0, 'request_from_other_domain': 0.0, 'anchor_from_other_domain': 0.0, 'is_popular': 0.5, 'long_url': 1.0, 'age_of_domain': 1, 'ip_in_url': 1} y True A binary classifier's goal is to learn to predict a binary target y from some given features x . We'll try to do this with a logistic regression. from river import linear_model model = linear_model . LogisticRegression () model . predict_proba_one ( x ) {False: 0.5, True: 0.5} The model hasn't been trained on any data, and therefore outputs a default probability of 50% for each class. The model can be trained on the sample, which will update the model's state. model = model . learn_one ( x , y ) If we try to make a prediction on the same sample, we can see that the probabilities are different, because the model has learned something. model . predict_proba_one ( x ) {False: 0.5068745667645342, True: 0.4931254332354657} Note that there is also a predict_one if you're only interested in the most likely class rather than the probability distribution. model . predict_one ( x ) False Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation. from river import metrics model = linear_model . LogisticRegression () metric = metrics . ROCAUC () for x , y in dataset : y_pred = model . predict_proba_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric ROCAUC: 89.36% This is a common way to evaluate an online model. In fact, there is a dedicated evaluate.progressive_val_score function that does this for you. from river import evaluate model = linear_model . LogisticRegression () metric = metrics . ROCAUC () evaluate . progressive_val_score ( dataset , model , metric ) ROCAUC: 89.36% A common way to improve the performance of a logistic regression is to scale the data. This can be done by using a preprocessing.StandardScaler . In particular, we can define a pipeline to organise our model into a sequence of steps: from river import compose from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) model --------------------------------------------------------------------------- NameError Traceback (most recent call last) /var/folders/9z/dgt2y49d2qx_hkgt7qj8mc240000gn/T/ipykernel_41345/3672127869.py in <module> 4 model = compose.Pipeline( 5 preprocessing.StandardScaler(), ----> 6 linear_model.LogisticRegression() 7 ) 8 NameError: name 'linear_model' is not defined metric = metrics . ROCAUC () evaluate . progressive_val_score ( dataset , model , metric ) ROCAUC: 95.04% That concludes the getting started introduction to binary classification! You can now move on to the next steps .","title":"Binary classification"},{"location":"introduction/getting-started/multiclass-classification/","text":"Multi-class classification \u00b6 Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome. A labeled classification sample is made up of a bunch of features and a class. The class is a usually a string or a number in the case of multiclass classification. We'll use the image segments dataset as an example. from river import datasets dataset = datasets . ImageSegments () dataset Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass. Name ImageSegments Task Multi-class classification Samples 2,310 Features 18 Sparse False Path /Users/max.halford/projects/river/river/datasets/segment.csv.zip This dataset is a streaming dataset which can be looped over. for x , y in dataset : pass Let's take a look at the first sample. x , y = next ( iter ( dataset )) x {'region-centroid-col': 218, 'region-centroid-row': 178, 'short-line-density-5': 0.11111111, 'short-line-density-2': 0.0, 'vedge-mean': 0.8333326999999999, 'vegde-sd': 0.54772234, 'hedge-mean': 1.1111094, 'hedge-sd': 0.5443307, 'intensity-mean': 59.629630000000006, 'rawred-mean': 52.44444300000001, 'rawblue-mean': 75.22222, 'rawgreen-mean': 51.22222, 'exred-mean': -21.555555, 'exblue-mean': 46.77778, 'exgreen-mean': -25.222220999999998, 'value-mean': 75.22222, 'saturation-mean': 0.31899637, 'hue-mean': -2.0405545} y 'path' A multiclass classifier's goal is to learn how to predict a class y from a bunch of features x . We'll attempt to do this with a decision tree. from river import tree model = tree . HoeffdingTreeClassifier () model . predict_proba_one ( x ) {} The reason why the output dictionary is empty is because the model hasn't seen any data yet. It isn't aware of the dataset whatsoever. If this were a binary classifier, then it would output a probability of 50% for True and False because the classes are implicit. But in this case we're doing multiclass classification. Likewise, the predict_one method initially returns None because the model hasn't seen any labeled data yet. print ( model . predict_one ( x )) None If we update the model and try again, then we see that a probability of 100% is assigned to the 'path' class because that's the only one the model is aware of. model . learn_one ( x , y ) model . predict_proba_one ( x ) {'path': 1.0} This is a strength of online classifiers: they're able to deal with new classes appearing in the data stream. Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation. from river import metrics model = tree . HoeffdingTreeClassifier () metric = metrics . ClassificationReport () for x , y in dataset : y_pred = model . predict_one ( x ) model . learn_one ( x , y ) if y_pred is not None : metric . update ( y , y_pred ) metric Precision Recall F1 Support brickface 77.13% 84.85% 80.81% 33 cement 78.92% 83.94% 81.35% 33 foliage 67.00% 20.30% 31.16% 33 grass 100.00% 96.97% 98.46% 33 path 90.39% 91.49% 90.94% 329 sky 99.08% 98.18% 98.63% 33 window 43.50% 67.88% 53.02% 33 Macro 79.43% 77.66% 76.34% Micro 77.65% 77.65% 77.65% Weighted 79.43% 77.65% 76.33% 77.65% accuracy This is a common way to evaluate an online model. In fact, there is a dedicated evaluate.progressive_val_score function that does this for you. from river import evaluate model = tree . HoeffdingTreeClassifier () metric = metrics . ClassificationReport () evaluate . progressive_val_score ( dataset , model , metric ) Precision Recall F1 Support brickface 77.13% 84.85% 80.81% 33 cement 78.92% 83.94% 81.35% 33 foliage 67.00% 20.30% 31.16% 33 grass 100.00% 96.97% 98.46% 33 path 90.39% 91.49% 90.94% 329 sky 99.08% 98.18% 98.63% 33 window 43.50% 67.88% 53.02% 33 Macro 79.43% 77.66% 76.34% Micro 77.65% 77.65% 77.65% Weighted 79.43% 77.65% 76.33% 77.65% accuracy That concludes the getting started introduction to multiclass classification! You can now move on to the next steps .","title":"Multi-class classification"},{"location":"introduction/getting-started/multiclass-classification/#multi-class-classification","text":"Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome. A labeled classification sample is made up of a bunch of features and a class. The class is a usually a string or a number in the case of multiclass classification. We'll use the image segments dataset as an example. from river import datasets dataset = datasets . ImageSegments () dataset Image segments classification. This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass. Name ImageSegments Task Multi-class classification Samples 2,310 Features 18 Sparse False Path /Users/max.halford/projects/river/river/datasets/segment.csv.zip This dataset is a streaming dataset which can be looped over. for x , y in dataset : pass Let's take a look at the first sample. x , y = next ( iter ( dataset )) x {'region-centroid-col': 218, 'region-centroid-row': 178, 'short-line-density-5': 0.11111111, 'short-line-density-2': 0.0, 'vedge-mean': 0.8333326999999999, 'vegde-sd': 0.54772234, 'hedge-mean': 1.1111094, 'hedge-sd': 0.5443307, 'intensity-mean': 59.629630000000006, 'rawred-mean': 52.44444300000001, 'rawblue-mean': 75.22222, 'rawgreen-mean': 51.22222, 'exred-mean': -21.555555, 'exblue-mean': 46.77778, 'exgreen-mean': -25.222220999999998, 'value-mean': 75.22222, 'saturation-mean': 0.31899637, 'hue-mean': -2.0405545} y 'path' A multiclass classifier's goal is to learn how to predict a class y from a bunch of features x . We'll attempt to do this with a decision tree. from river import tree model = tree . HoeffdingTreeClassifier () model . predict_proba_one ( x ) {} The reason why the output dictionary is empty is because the model hasn't seen any data yet. It isn't aware of the dataset whatsoever. If this were a binary classifier, then it would output a probability of 50% for True and False because the classes are implicit. But in this case we're doing multiclass classification. Likewise, the predict_one method initially returns None because the model hasn't seen any labeled data yet. print ( model . predict_one ( x )) None If we update the model and try again, then we see that a probability of 100% is assigned to the 'path' class because that's the only one the model is aware of. model . learn_one ( x , y ) model . predict_proba_one ( x ) {'path': 1.0} This is a strength of online classifiers: they're able to deal with new classes appearing in the data stream. Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation. from river import metrics model = tree . HoeffdingTreeClassifier () metric = metrics . ClassificationReport () for x , y in dataset : y_pred = model . predict_one ( x ) model . learn_one ( x , y ) if y_pred is not None : metric . update ( y , y_pred ) metric Precision Recall F1 Support brickface 77.13% 84.85% 80.81% 33 cement 78.92% 83.94% 81.35% 33 foliage 67.00% 20.30% 31.16% 33 grass 100.00% 96.97% 98.46% 33 path 90.39% 91.49% 90.94% 329 sky 99.08% 98.18% 98.63% 33 window 43.50% 67.88% 53.02% 33 Macro 79.43% 77.66% 76.34% Micro 77.65% 77.65% 77.65% Weighted 79.43% 77.65% 76.33% 77.65% accuracy This is a common way to evaluate an online model. In fact, there is a dedicated evaluate.progressive_val_score function that does this for you. from river import evaluate model = tree . HoeffdingTreeClassifier () metric = metrics . ClassificationReport () evaluate . progressive_val_score ( dataset , model , metric ) Precision Recall F1 Support brickface 77.13% 84.85% 80.81% 33 cement 78.92% 83.94% 81.35% 33 foliage 67.00% 20.30% 31.16% 33 grass 100.00% 96.97% 98.46% 33 path 90.39% 91.49% 90.94% 329 sky 99.08% 98.18% 98.63% 33 window 43.50% 67.88% 53.02% 33 Macro 79.43% 77.66% 76.34% Micro 77.65% 77.65% 77.65% Weighted 79.43% 77.65% 76.33% 77.65% accuracy That concludes the getting started introduction to multiclass classification! You can now move on to the next steps .","title":"Multi-class classification"},{"location":"introduction/getting-started/regression/","text":"Regression \u00b6 Regression is about predicting a numeric output for a given sample. A labeled regression sample is made up of a bunch of features and a number. The number is usually continuous, but it may also be discrete. We'll use the Trump approval rating dataset as an example. from river import datasets dataset = datasets . TrumpApproval () dataset Donald Trump approval ratings. This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model. Name TrumpApproval Task Regression Samples 1,001 Features 6 Sparse False Path /Users/max.halford/projects/river/river/datasets/trump_approval.csv.gz This dataset is a streaming dataset which can be looped over. for x , y in dataset : pass Let's take a look at the first sample. x , y = next ( iter ( dataset )) x {'ordinal_date': 736389, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004} A regression model's goal is to learn to predict a numeric target y from a bunch of features x . We'll attempt to do this with a nearest neighbors model. from river import neighbors model = neighbors . KNNRegressor () model . predict_one ( x ) 0.0 The model hasn't been trained on any data, and therefore outputs a default value of 0. The model can be trained on the sample, which will update the model's state. model = model . learn_one ( x , y ) If we try to make a prediction on the same sample, we can see that the output is different, because the model has learned something. model . predict_one ( x ) 43.75505 Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation. from river import metrics model = neighbors . KNNRegressor () metric = metrics . MAE () for x , y in dataset : y_pred = model . predict_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric MAE: 0.31039 This is a common way to evaluate an online model. In fact, there is a dedicated evaluate.progressive_val_score function that does this for you. from river import evaluate model = neighbors . KNNRegressor () metric = metrics . MAE () evaluate . progressive_val_score ( dataset , model , metric ) MAE: 0.31039 That concludes the getting started introduction to regression! You can now move on to the next steps .","title":"Regression"},{"location":"introduction/getting-started/regression/#regression","text":"Regression is about predicting a numeric output for a given sample. A labeled regression sample is made up of a bunch of features and a number. The number is usually continuous, but it may also be discrete. We'll use the Trump approval rating dataset as an example. from river import datasets dataset = datasets . TrumpApproval () dataset Donald Trump approval ratings. This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model. Name TrumpApproval Task Regression Samples 1,001 Features 6 Sparse False Path /Users/max.halford/projects/river/river/datasets/trump_approval.csv.gz This dataset is a streaming dataset which can be looped over. for x , y in dataset : pass Let's take a look at the first sample. x , y = next ( iter ( dataset )) x {'ordinal_date': 736389, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004} A regression model's goal is to learn to predict a numeric target y from a bunch of features x . We'll attempt to do this with a nearest neighbors model. from river import neighbors model = neighbors . KNNRegressor () model . predict_one ( x ) 0.0 The model hasn't been trained on any data, and therefore outputs a default value of 0. The model can be trained on the sample, which will update the model's state. model = model . learn_one ( x , y ) If we try to make a prediction on the same sample, we can see that the output is different, because the model has learned something. model . predict_one ( x ) 43.75505 Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation. from river import metrics model = neighbors . KNNRegressor () metric = metrics . MAE () for x , y in dataset : y_pred = model . predict_one ( x ) model . learn_one ( x , y ) metric . update ( y , y_pred ) metric MAE: 0.31039 This is a common way to evaluate an online model. In fact, there is a dedicated evaluate.progressive_val_score function that does this for you. from river import evaluate model = neighbors . KNNRegressor () metric = metrics . MAE () evaluate . progressive_val_score ( dataset , model , metric ) MAE: 0.31039 That concludes the getting started introduction to regression! You can now move on to the next steps .","title":"Regression"},{"location":"recipes/feature-extraction/","text":"Feature extraction \u00b6 To do.","title":"Feature extraction"},{"location":"recipes/feature-extraction/#feature-extraction","text":"To do.","title":"Feature extraction"},{"location":"recipes/hyperparameter-tuning/","text":"Hyperparameter tuning \u00b6 To do.","title":"Hyperparameter tuning"},{"location":"recipes/hyperparameter-tuning/#hyperparameter-tuning","text":"To do.","title":"Hyperparameter tuning"},{"location":"recipes/mini-batching/","text":"Mini-batching \u00b6 In its purest form, online machine learning encompasses models which learn with one sample at a time. This is the design which is used in river . The main downside of single-instance processing is that it doesn't scale to big data, at least not in the sense of traditional batch learning. Indeed, processing one sample at a time means that we are unable to fully take advantage of vectorisation and other computational tools that are taken for granted in batch learning. On top of this, processing a large dataset in river essentially involves a Python for loop, which might be too slow for some usecases. However, this doesn't mean that river is slow. In fact, for processing a single instance, river is actually a couple of orders of magnitude faster than libraries such as scikit-learn, PyTorch, and Tensorflow. The reason why is because river is designed from the ground up to process a single instance, whereas the majority of other libraries choose to care about batches of data. Both approaches offer different compromises, and the best choice depends on your usecase. In order to propose the best of both worlds, river offers some limited support for mini-batch learning. Some of river 's estimators implement *_many methods on top of their *_one counterparts. For instance, preprocessing.StandardScaler has a learn_many method as well as a transform_many method, in addition to learn_one and transform_one . Each mini-batch method takes as input a pandas.DataFrame . Supervised estimators also take as input a pandas.Series of target values. We choose to use pandas.DataFrames over numpy.ndarrays because of the simple fact that the former allows us to name each feature. This in turn allows us to offer a uniform interface for both single instance and mini-batch learning. As an example, we will build a simple pipeline that scales the data and trains a logistic regression. Indeed, the compose.Pipeline class can be applied to mini-batches, as long as each step is able to do so. from river import compose from river import linear_model from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) For this example, we will use datasets.Higgs . from river import datasets dataset = datasets . Higgs () if not dataset . is_downloaded : dataset . download () dataset Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes. Name Higgs Task Binary classification Samples 11,000,000 Features 28 Sparse False Path /Users/max.halford/river_data/Higgs/HIGGS.csv.gz URL https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz Size 2.62 GB Downloaded True The easiest way to read the data in a mini-batch fashion is to use the read_csv from pandas . import pandas as pd names = [ 'target' , 'lepton pT' , 'lepton eta' , 'lepton phi' , 'missing energy magnitude' , 'missing energy phi' , 'jet 1 pt' , 'jet 1 eta' , 'jet 1 phi' , 'jet 1 b-tag' , 'jet 2 pt' , 'jet 2 eta' , 'jet 2 phi' , 'jet 2 b-tag' , 'jet 3 pt' , 'jet 3 eta' , 'jet 3 phi' , 'jet 3 b-tag' , 'jet 4 pt' , 'jet 4 eta' , 'jet 4 phi' , 'jet 4 b-tag' , 'm_jj' , 'm_jjj' , 'm_lv' , 'm_jlv' , 'm_bb' , 'm_wbb' , 'm_wwbb' ] for x in pd . read_csv ( dataset . path , names = names , chunksize = 8096 , nrows = 3e5 ): y = x . pop ( 'target' ) y_pred = model . predict_proba_many ( x ) model . learn_many ( x , y ) If you are familiar with scikit-learn, you might be aware that some of their estimators have a partial_fit method, which is similar to river's learn_many method. Here are some advantages that river has over scikit-learn: We guarantee that river's is just as fast, if not faster than scikit-learn. The differences are negligeable, but are slightly in favor of river. We take as input dataframes, which allows us to name each feature. The benefit is that you can add/remove/permute features between batches and everything will keep working. Estimators that support mini-batches also support single instance learning. This means that you can enjoy the best of both worlds. For instance, you can train with mini-batches and use predict_one to make predictions. Note that you can check which estimators can process mini-batches programmatically: import importlib import inspect def can_mini_batch ( obj ): return hasattr ( obj , 'learn_many' ) for module in importlib . import_module ( 'river' ) . __all__ : if module in [ 'datasets' , 'synth' ]: continue for name , obj in inspect . getmembers ( importlib . import_module ( f 'river. { module } ' ), can_mini_batch ): print ( name ) OneClassSVM MiniBatchClassifier MiniBatchRegressor SKL2RiverClassifier SKL2RiverRegressor Pipeline BagOfWords TFIDF LinearRegression LogisticRegression Perceptron OneVsRestClassifier BernoulliNB ComplementNB MultinomialNB MLPRegressor StandardScaler Because mini-batch learning isn't treated as a first-class citizen, some of the river's functionalities require some work in order to play nicely with mini-batches. For instance, the objects from the metrics module have an update method that take as input a single pair (y_true, y_pred) . This might change in the future, depending on the demand. We plan to promote more models to the mini-batch regime. However, we will only be doing so for the methods that benefit the most from it, as well as those that are most popular. Indeed, river 's core philosophy will remain to cater to single instance learning.","title":"Mini-batching"},{"location":"recipes/mini-batching/#mini-batching","text":"In its purest form, online machine learning encompasses models which learn with one sample at a time. This is the design which is used in river . The main downside of single-instance processing is that it doesn't scale to big data, at least not in the sense of traditional batch learning. Indeed, processing one sample at a time means that we are unable to fully take advantage of vectorisation and other computational tools that are taken for granted in batch learning. On top of this, processing a large dataset in river essentially involves a Python for loop, which might be too slow for some usecases. However, this doesn't mean that river is slow. In fact, for processing a single instance, river is actually a couple of orders of magnitude faster than libraries such as scikit-learn, PyTorch, and Tensorflow. The reason why is because river is designed from the ground up to process a single instance, whereas the majority of other libraries choose to care about batches of data. Both approaches offer different compromises, and the best choice depends on your usecase. In order to propose the best of both worlds, river offers some limited support for mini-batch learning. Some of river 's estimators implement *_many methods on top of their *_one counterparts. For instance, preprocessing.StandardScaler has a learn_many method as well as a transform_many method, in addition to learn_one and transform_one . Each mini-batch method takes as input a pandas.DataFrame . Supervised estimators also take as input a pandas.Series of target values. We choose to use pandas.DataFrames over numpy.ndarrays because of the simple fact that the former allows us to name each feature. This in turn allows us to offer a uniform interface for both single instance and mini-batch learning. As an example, we will build a simple pipeline that scales the data and trains a logistic regression. Indeed, the compose.Pipeline class can be applied to mini-batches, as long as each step is able to do so. from river import compose from river import linear_model from river import preprocessing model = compose . Pipeline ( preprocessing . StandardScaler (), linear_model . LogisticRegression () ) For this example, we will use datasets.Higgs . from river import datasets dataset = datasets . Higgs () if not dataset . is_downloaded : dataset . download () dataset Higgs dataset. The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes. Name Higgs Task Binary classification Samples 11,000,000 Features 28 Sparse False Path /Users/max.halford/river_data/Higgs/HIGGS.csv.gz URL https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz Size 2.62 GB Downloaded True The easiest way to read the data in a mini-batch fashion is to use the read_csv from pandas . import pandas as pd names = [ 'target' , 'lepton pT' , 'lepton eta' , 'lepton phi' , 'missing energy magnitude' , 'missing energy phi' , 'jet 1 pt' , 'jet 1 eta' , 'jet 1 phi' , 'jet 1 b-tag' , 'jet 2 pt' , 'jet 2 eta' , 'jet 2 phi' , 'jet 2 b-tag' , 'jet 3 pt' , 'jet 3 eta' , 'jet 3 phi' , 'jet 3 b-tag' , 'jet 4 pt' , 'jet 4 eta' , 'jet 4 phi' , 'jet 4 b-tag' , 'm_jj' , 'm_jjj' , 'm_lv' , 'm_jlv' , 'm_bb' , 'm_wbb' , 'm_wwbb' ] for x in pd . read_csv ( dataset . path , names = names , chunksize = 8096 , nrows = 3e5 ): y = x . pop ( 'target' ) y_pred = model . predict_proba_many ( x ) model . learn_many ( x , y ) If you are familiar with scikit-learn, you might be aware that some of their estimators have a partial_fit method, which is similar to river's learn_many method. Here are some advantages that river has over scikit-learn: We guarantee that river's is just as fast, if not faster than scikit-learn. The differences are negligeable, but are slightly in favor of river. We take as input dataframes, which allows us to name each feature. The benefit is that you can add/remove/permute features between batches and everything will keep working. Estimators that support mini-batches also support single instance learning. This means that you can enjoy the best of both worlds. For instance, you can train with mini-batches and use predict_one to make predictions. Note that you can check which estimators can process mini-batches programmatically: import importlib import inspect def can_mini_batch ( obj ): return hasattr ( obj , 'learn_many' ) for module in importlib . import_module ( 'river' ) . __all__ : if module in [ 'datasets' , 'synth' ]: continue for name , obj in inspect . getmembers ( importlib . import_module ( f 'river. { module } ' ), can_mini_batch ): print ( name ) OneClassSVM MiniBatchClassifier MiniBatchRegressor SKL2RiverClassifier SKL2RiverRegressor Pipeline BagOfWords TFIDF LinearRegression LogisticRegression Perceptron OneVsRestClassifier BernoulliNB ComplementNB MultinomialNB MLPRegressor StandardScaler Because mini-batch learning isn't treated as a first-class citizen, some of the river's functionalities require some work in order to play nicely with mini-batches. For instance, the objects from the metrics module have an update method that take as input a single pair (y_true, y_pred) . This might change in the future, depending on the demand. We plan to promote more models to the mini-batch regime. However, we will only be doing so for the methods that benefit the most from it, as well as those that are most popular. Indeed, river 's core philosophy will remain to cater to single instance learning.","title":"Mini-batching"},{"location":"recipes/model-evaluation/","text":"Model evaluation \u00b6 To do.","title":"Model evaluation"},{"location":"recipes/model-evaluation/#model-evaluation","text":"To do.","title":"Model evaluation"},{"location":"recipes/on-hoeffding-trees/","text":"Incremental decision trees in river: the Hoeffding Tree case \u00b6 Decision trees (DT) are popular learning models due to their inherently simplicity, flexibility and self-explainable structure. Moreover, when aggregated in ensembles, high predictive power might be achieved. Bagging and gradient boosting-based tree ensembles are very popular solutions in competition platforms such as Kaggle, and also among researchers. Although fairly lightweight, traditional batch DTs cannot cope with data stream mining/online learning requirements, as they do multiple passes over the data and have to be retrained from scratch every time a new observation appears. The data stream literature has plenty of incremental DT (iDT) families that are better suited to online learning. Nonetheless, Hoeffding Trees (HT) are historically the most popular family of iDTs to date. In fact, HTs have some nice properties: one-pass learning regime; theoretical guarantees to converge to the batch DT model given enough observations and a stationary data distribution; small memory and running time footprint (in most cases); some of their variations can deal with non-stationary distributions. And the previous list goes on and on. Besides that, HTs also have the same advantages as batch DTs ( C4.5 / J48 , CART , M5 , etc.) do. We can inspect the structure of a HT to understand how decisions were made, which is a nice feature to have in online learning tasks. In river , HTs are first-class citizens, so we have multiple realizations of this framework that are suited to different learning tasks and scenarios. This brief introduction to HT does not aims at being extensive nor delving into algorithmic or implementation details of the HTs. Instead, we intend to provide a high-level overview of the HTs as they are envisioned in river , as well as their shared properties and important hyperparameters. In this guide, we are going to: summarize the differences accross the multiple HT versions available; learn how to inspect tree models; learn how to manage the memory usage of HTs; compare numerical tree splitters and understand their impact on the iDT induction process. Well, without further ado, let's go! First things first, we are going to start with some imports. import matplotlib.pyplot as plt from river import datasets from river import evaluate from river import metrics from river import preprocessing # we are going to use that later from river import synth # we are going to use some synthetic datasets too from river import tree 1. Trees, trees everywhere: gardening 101 with river \u00b6 At first glance, the amount of iDT algorithms in river might seem too much to handle, but in reality the distinction among them is easy to grasp. To facilitate our lives, here's a neat table listing the available HT models and summarizing their differences: Name Acronym Task Non-stationary? Comments Source Hoeffding Tree Classifier HTC Classification No Basic HT for classification tasks [1] Hoeffding Adaptive Tree Classifier HATC Classification Yes Modifies HTC by adding an instance of ADWIN to each node to detect and react to drift detection [2] Extremely Fast Decision Tree Classifier EFDT Classification No Deploys split decisions as soon as possible and periodically revisit decisions and redo them if necessary. Not as fast in practice as the name implies, but it tends to converge faster than HTC to the model generated by a batch DT [3] Hoeffding Tree Regressor HTR Regression No Basic HT for regression tasks. It is an adaptation of the FIRT/FIMT algorithm that bears some semblance to HTC [4] Hoeffding Adaptive Tree Regressor HATR Regression Yes Modifies HTR by adding an instance of ADWIN to each node to detect and react to drift detection - incremental Structured-Output Prediction Tree Regressor iSOUPT Multi-target regression No Multi-target version of HTR [5] Label Combination Hoeffding Tree Classifier LCHTC Multi-label classification No Creates a numerical code for each combination of the binary labels and uses HTC to learn from this encoded representation. At prediction time, decodes the modified representation to obtain the original label set - As we can see, although their application fields might overlap sometimes, the HT variations have specific situations in which they are better suited to work. Moreover, in river we provide a standardized API access to all the HT variants since they share many properties in common. 2. How to inspect tree models? \u00b6 We provide a handful of tools to inspect trained HTs in river . Here, we will provide some examples of how to access their inner structures, get useful information, and plot the iDT structure. Firstly, let's pick a toy dataset from which our tree will learn from. Here we are going to focus on the classification case, but the same operations apply to other learning tasks. We will select the Phishing dataset from the datasets module to exemplify the HTs' capabilities. dataset = datasets . Phishing () dataset Phishing websites. This dataset contains features from web pages that are classified as phishing or not. Name Phishing Task Binary classification Samples 1,250 Features 9 Sparse False Path /Users/max.halford/projects/river/river/datasets/phishing.csv.gz We are going to train an instance of HoeffdingTreeClassifier using this dataset. As everything else in river , training an iDT is a piece of cake! %% time model = tree . HoeffdingTreeClassifier ( grace_period = 50 ) for x , y in dataset : model . learn_one ( x , y ) model CPU times: user 129 ms, sys: 2.77 ms, total: 132 ms Wall time: 133 ms HoeffdingTreeClassifier ( grace_period=50 max_depth=inf split_criterion=\"info_gain\" split_confidence=1e-07 tie_threshold=0.05 leaf_prediction=\"nba\" nb_threshold=0 nominal_attributes=None splitter=GaussianSplitter ( n_splits=10 ) binary_split=False max_size=100 memory_estimate_period=1000000 stop_mem_management=False remove_poor_attrs=False merit_preprune=True ) That's it! We are not going to enter into details about some of the available parameters of HTC here. The user can refer to the documentation page for more information about that. Let's talk about model inspection :D At any time, we can easily get some statistics about our trained model by using the summary property: model . summary {'n_nodes': 5, 'n_branches': 2, 'n_leaves': 3, 'n_active_leaves': 3, 'n_inactive_leaves': 0, 'height': 3, 'total_observed_weight': 1250.0} This property show us the internal structure of the tree, including data concerning the memory-management routines that we are going to check later in this guide. We can also get a representation of the tree model as a pandas.DataFrame object: model . to_dataframe () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } parent is_leaf depth stats feature threshold splitter splitters _disabled_attrs _last_split_attempt_at _mc_correct_weight _nb_correct_weight node 0 <NA> False 0 {True: 260.0, False: 390.0} empty_server_form_handler 0.545455 NaN NaN NaN NaN NaN NaN 1 0 True 1 {True: 443.4163997711022, False: 59.8769131081... NaN NaN GaussianSplitter {'empty_server_form_handler': GaussianSplitter... {} 474.293313 249.0 248.0 2 0 False 1 {True: 71.58360022889781, False: 404.123086891... popup_window 0.090909 NaN NaN NaN NaN NaN NaN 3 2 True 2 {False: 31.426538522574834, True: 33.0} NaN NaN GaussianSplitter {'empty_server_form_handler': GaussianSplitter... {} 59.426539 23.0 36.0 4 2 True 2 {False: 250.57346147742516, True: 6.0} NaN NaN GaussianSplitter {'empty_server_form_handler': GaussianSplitter... {} 241.573461 210.0 196.0 Hmm, maybe not the clearest of the representations. What about drawing the tree structure instead? model . draw () Much better, huh? Lastly, we can check how the tree predicts one specific instance by using the debug_one method: x , y = next ( iter ( dataset )) # Let's select the first example in the stream x , y ({'empty_server_form_handler': 0.0, 'popup_window': 0.0, 'https': 0.0, 'request_from_other_domain': 0.0, 'anchor_from_other_domain': 0.0, 'is_popular': 0.5, 'long_url': 1.0, 'age_of_domain': 1, 'ip_in_url': 1}, True) print ( model . debug_one ( x )) empty_server_form_handler \u2264 0.5454545454545454 Class True: P(False) = 0.1 P(True) = 0.9 Our tree got this one right! The method debug_one is especially useful when we are dealing with a big tree model where drawing might not be the wisest of the choices (we will end up with a tree chart that has too much information to visually understand). Some additional hints: the max_depth parameter is our friend when building HTs that need to be constantly inspected. This parameter, which is available for every HT variant, triggers a pre-pruning mechanism that stops tree growth when the given depth is reached. we can also limit the depth when using the draw method. in the case of tree ensembles, individual trees can be accessed using the [index] operator. Then, the same set of inspection tools are available to play with! 3. Advanced gardening with river: grab your pruning shears and let's limit memory usage \u00b6 Online learning is well-suited to highly scalable processing centers with petabytes of data arriving intermittently, but it can also work with Internet of Things (IoT) devices operating at low power and with limited processing capability. Hence, making sure our trees are not going to use too much memory is a nice feature that can impact on both energy usage and the running time. HTs have memory-management routines that put the user in the control of computational resources that are available. In this brief guide, we are going to use a regression tree, since this kind of iDT typically spends more memory than the classification counterparts. However, the user can control the memory usage in the exact same way in river , regardless of the HT variant! We will rely on the Friedman synthetic dataset (data generator) from the synth module in our evaluation. To avoid doing tedious stuff, let's use the Track class from the evaluate module. Tracks are the standard way of benchmarking learning models in river . Since data generators can produce instances indefinitely, we will select a sample of size 10K for our tests. def friedman_track ( n_samples = 10_000 ): dataset = synth . Friedman ( seed = 42 ) . take ( n_samples ) track = evaluate . Track ( \"10K Friedman + MAE\" , dataset , metrics . MAE (), n_samples ) return track We are almost ready to go. Let's first define a simple function that parses the data generated by our tracks and plots it in a nice way. def plot_track ( track , metric_name , models , n_samples , n_checkpoints ): fig , ax = plt . subplots ( figsize = ( 5 , 5 ), nrows = 3 , dpi = 300 ) for model_name , model in models . items (): step = [] error = [] r_time = [] memory = [] for checkpoint in track ( n_samples ) . run ( model , n_checkpoints ): step . append ( checkpoint [ \"Step\" ]) error . append ( checkpoint [ metric_name ] . get ()) # Convert timedelta object into seconds r_time . append ( checkpoint [ \"Time\" ] . total_seconds ()) # Make sure the memory measurements are in MB raw_memory , unit = float ( checkpoint [ \"Memory\" ][: - 3 ]), checkpoint [ \"Memory\" ][ - 2 :] memory . append ( raw_memory * 2 **- 10 if unit == 'KB' else raw_memory ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) ax [ 2 ] . grid ( True ) ax [ 0 ] . plot ( step , error , label = model_name ) ax [ 0 ] . set_ylabel ( metric_name ) ax [ 1 ] . plot ( step , r_time , label = model_name ) ax [ 1 ] . set_ylabel ( 'Time (seconds)' ) ax [ 2 ] . plot ( step , memory , label = model_name ) ax [ 2 ] . set_ylabel ( 'Memory (MB)' ) ax [ 2 ] . set_xlabel ( 'Instances' ) plt . legend () plt . tight_layout () plt . close () return fig plot_track ( friedman_track , \"MAE\" , { \"Unbounded HTR\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ())}, 10_000 , 100 ) [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000, 3100, 3200, 3300, 3400, 3500, 3600, 3700, 3800, 3900, 4000, 4100, 4200, 4300, 4400, 4500, 4600, 4700, 4800, 4900, 5000, 5100, 5200, 5300, 5400, 5500, 5600, 5700, 5800, 5900, 6000, 6100, 6200, 6300, 6400, 6500, 6600, 6700, 6800, 6900, 7000, 7100, 7200, 7300, 7400, 7500, 7600, 7700, 7800, 7900, 8000, 8100, 8200, 8300, 8400, 8500, 8600, 8700, 8800, 8900, 9000, 9100, 9200, 9300, 9400, 9500, 9600, 9700, 9800, 9900, 10000] [6.311936135605157, 4.426916277623943, 3.73235813142122, 3.3473428046148133, 3.130360658908175, 2.972692298348939, 2.817017637680579, 2.696179164634299, 2.63709303340789, 2.5566140161009447, 2.4937505469971324, 2.4371064440381973, 2.3987113035752614, 2.3609733473352295, 2.3381353138143943, 2.3194348576470287, 2.282226645299219, 2.2542334920848406, 2.2343625977975, 2.2178015281841166, 2.1834977649678318, 2.1531220972043585, 2.134676620751594, 2.1138849232248, 2.1019286980821055, 2.1042079251674215, 2.097925056455068, 2.084323908804759, 2.0714670190131135, 2.0705003322426436, 2.0552509010674473, 2.048484532008886, 2.033028358661703, 2.0263620862292595, 2.020823699681305, 2.0155642661224142, 2.0054633342111963, 1.9990365488688657, 1.9941001534967844, 1.9867407115187592, 1.9854599856579107, 1.9807035981982755, 1.9809803074696384, 1.9737005713616294, 1.9710292083747358, 1.9705759483713436, 1.9692307919722092, 1.9703311394214822, 1.9656243399539601, 1.967410063166392, 1.9613071559583721, 1.9634497255414836, 1.9653181059482623, 1.9636911356903617, 1.9593072042760353, 1.9587268700311737, 1.960482982627088, 1.9610614326336027, 1.957276133863555, 1.9550666111730721, 1.955606619358126, 1.9529361938108516, 1.9527382302874101, 1.9526135381384593, 1.9497421585163321, 1.9467881840140944, 1.9392583842434707, 1.936378853393644, 1.9370919519884757, 1.9352084113724375, 1.9339703151885246, 1.9333780192289418, 1.9308839551446142, 1.9303444353390795, 1.932093603469563, 1.9298811956165787, 1.926942156850576, 1.9241555532138186, 1.9206024084677338, 1.9195204998624347, 1.9149284363791255, 1.91471767334126, 1.9145856556453265, 1.9131725360709422, 1.9105749006422819, 1.9101627403460366, 1.9097330501127028, 1.9096186797090573, 1.9079813149104223, 1.9054177923042632, 1.9011385190369439, 1.90055515383512, 1.8979358270743927, 1.8956528123559242, 1.8958429257588902, 1.8921638474993872, 1.8891663307392776, 1.8873871016982733, 1.884230814735786, 1.885090436697188] Unbounded HTR As we can see, our tree uses more than 10 MB to keep its structure. Let's say we wanted to limit our memory usage to 5 MB. How could we do that? Note that we are using a illustration case here. In real applications, data may be unbounded, so the trees might grow indefinitely. HTs expose some parameters related to memory management. The user can refer to the documentation for more details on that matter. Here, we are going to focus on two parameters: max_size : determines the maximum amount of memory (in MB) that the HT can use. memory_estimate_period : intervals after which the memory-management is triggered. We are going to limit our HTR to 5 MB and perform memory checks at intervals of 500 instances. plot_track ( friedman_track , \"MAE\" , { \"Restricted HTR\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( max_size = 5 , memory_estimate_period = 500 ) ) }, 10_000 , 100 ) Note that as soon the memory usage reaches the limit that we determined (at the memory check intervals), HTR starts managing its resource usage to reduce the size. As a consequence, the running time also decreases. For more accurate management, the intervals between memory checks should be decreased. This action, however, has costs since the tree stops the learning process to estimate its size and alter its own structure. Too frequent memory checks might end up result in a slow learning process. Besides, by using fewer resources, the predictive performance can be negatively impacted. So, use this tool with caution! But how that works at all? HTs monitor the incoming feature values to perform split attempts. To do so, they rely on a class of algorithms called Attribute Observers (AO) or Splitters (spoiler alert!). Each leaf node in an HT keeps one AO per incoming feature. After pre-determined intervals ( grace_period parameter), leaves query their AOs for split candidates. Well, there are costs to monitor input features (mainly the numerical ones). In fact, AOs correspond to one of the most time and memory-consuming portions of the HTs. To manage memory usage, an HT firstly determines its least promising leaves, w.r.t. how likely they will be split. Then, these leaves' AOs are removed, and the tree nodes are said to be \"deactivated.\" That's it! The deactivated leaves do not perform split attempts anymore, but they continue to be updated to provide responses. They will be kept as leaves as long as there are not available resources to enable tree growth. These leaves can be activated again (meaning that new AOs will be created for them) if there is available memory, so don't worry! Hint: another indirect way to bound memory usage is to limit the tree depth. By default, the trees can grow indefinitely, but the max_depth parameter can control this behavior. plot_track ( friedman_track , \"MAE\" , { \"HTR with at most 5 levels\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( max_depth = 5 ) ) }, 10_000 , 100 ) 4. Branching and growth: splitters, the heart of the trees \u00b6 As previously stated, one of the core operations of iDT is, well, to grow. Plants and gardening-related jokes apart, growth in HTs is guided by their AOs or splitters, as mentioned in the end of Section 3. Nominal features can be easily monitored, since the feature partitions are well-defined beforehand. Numerical features, on the other hand, do not have an explicit best cut point. Still, numerical features are typically split by using a binary test: \\(\\le\\) or \\(>\\) . Therefore, numerical splitters must somehow summarize the incoming feature values and be able to evaluate the merit of split point candidates. There are diverse strategies to monitor numerical features and choices related to them, including which data structure will be used to keep a summary of the incoming feature and also how many split points are going to be evaluated during split attempts. Again, this guide does not intend to be an exhaustive delve into the iDT subject. In fact, each of the following aspects of the iDTs could be considered a separate research area: AOs, intervals between split attempts, split heuristics (e.g., info gain, variance reduction, and so on), tree depth and max size, and much more! Let's focus a bit into the AO matter. River provides a handful of splitters for classification and regression trees, which can be chosen using the parameter splitter . We will list the available tree splitters in the following sections and compare some of their chacteristics. Some notation: \\(n\\) : Number of observations seen so far. \\(c\\) : the number of classes. \\(s\\) : the number of split points to evaluate (which means that this is a user-given parameter). \\(h\\) : the number of histogram bins or hash slots. Tipically, \\(h \\ll n\\) . 4.1. Classification tree splitters \u00b6 The following table summarizes the available classification splitters. The user might refer to the documentation of each splitter for more details about their functioning. Splitter Description Insertion Memory Split candidate query Works with Naive Bayes leaves? Exhaustive Keeps all the observed input values and class counts in a Binary Search Tree (BST) \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\) No Histogram Builds a histogram for each class in order to discretize the input feature \\(O(\\log h)\\) \\(O(c h)\\) \\(O(c h)\\) Yes Gaussian Approximates the class distributions using Gaussian distributions \\(O(1)\\) \\(O(c)\\) \\(O(cs)\\) Yes Note that some of the splitters have configurable parameters that directly impact not only on their time and memory costs, but also on the final predictive performance. Examples: The number of split points can be configured in the Gaussian splitter. Increasing this number makes this splitter slower, but it also potentially increases the quality of the obtained query points, implying enhanced tree accuracy. The number of stored bins can be selected in the Histogram splitter. Increasing this number increases the memory footprint and running time of this splitter, but it also potentially makes its split candidates more accurate and positively impacts on the tree's final predictive performance. Next, we provide a brief comparison of the classification splitters using 10K instances of the Random RBF synthetic dataset. Note that the tree equiped with the Exhaustive splitter does not use Naive Bayes leaves. def random_rbf_track ( n_samples = 10_000 ): dataset = synth . RandomRBF ( seed_model = 7 , seed_sample = 42 ) . take ( n_samples ) track = evaluate . Track ( \"10K Random RBF + Accuracy\" , dataset , metrics . Accuracy (), n_samples ) return track plot_track ( random_rbf_track , \"Accuracy\" , { \"HTC + Exhaustive splitter\" : tree . HoeffdingTreeClassifier ( splitter = tree . splitter . ExhaustiveSplitter (), leaf_prediction = \"mc\" ), \"HTC + Histogram splitter\" : tree . HoeffdingTreeClassifier ( splitter = tree . splitter . HistogramSplitter () ), \"HTC + Gaussian splitter\" : tree . HoeffdingTreeClassifier ( splitter = tree . splitter . GaussianSplitter () ) }, 10_000 , 100 ) 4.2 Regression tree splitters \u00b6 The available regression tree splitters are summarized in the next table. The TE-BST costs are expressed in terms of \\(n^*\\) because the number of stored elements can be smaller than or equal to \\(n\\) . Splitter Description Insertion Memory Split candidate query Extended Binary Search Tree (E-BST) Stores all the observations and target statistics in a BST \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\) Truncated E-BST (TE-BST) Rounds the incoming data before passing it to the BST \\(O(\\log n^*)\\) (average) or \\(O(n^*)\\) (worst case) \\(O(n^*)\\) \\(O(n^*)\\) Quantization Observer (QO) Uses a hash-like structure to quantize the incoming data \\(O(1)\\) \\(O(h)\\) \\(O(h \\log h)\\) E-BST is an exhaustive algorithm, i.e., it works as batch solutions usually do, which might be prohibitive in real-world online scenarios. TE-BST and QO apply approximations to alleviate the costs involved in monitoring numerical data and performing split attempts. The number of desired decimal places to round the data (TE-BST) and the quantization radius (QO) are directly related to the running time, memory footprint, and error of the resulting tree model. We present a brief comparison of the available regression tree splitters using the 10K instances of the Friedman synthetic dataset. plot_track ( friedman_track , \"MAE\" , { \"HTR + E-BST\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( splitter = tree . splitter . EBSTSplitter () ) ), \"HTR + TE-BST\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( splitter = tree . splitter . TEBSTSplitter ( digits = 2 ) ) ), \"HTR + QO\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( splitter = tree . splitter . QOSplitter () ) ), }, 10_000 , 100 ) Wrapping up \u00b6 This guide provides a walkthrough in the HTs available in river . We discussed about model inspection, memory management, and feature splits. Keep in mind that each HT variant has specific details and capabilities that are out-of-the-scope of this introductory material. The user is advised to check the documentation page of the tree models for detailed information.","title":"Incremental decision trees in river: the Hoeffding Tree case"},{"location":"recipes/on-hoeffding-trees/#incremental-decision-trees-in-river-the-hoeffding-tree-case","text":"Decision trees (DT) are popular learning models due to their inherently simplicity, flexibility and self-explainable structure. Moreover, when aggregated in ensembles, high predictive power might be achieved. Bagging and gradient boosting-based tree ensembles are very popular solutions in competition platforms such as Kaggle, and also among researchers. Although fairly lightweight, traditional batch DTs cannot cope with data stream mining/online learning requirements, as they do multiple passes over the data and have to be retrained from scratch every time a new observation appears. The data stream literature has plenty of incremental DT (iDT) families that are better suited to online learning. Nonetheless, Hoeffding Trees (HT) are historically the most popular family of iDTs to date. In fact, HTs have some nice properties: one-pass learning regime; theoretical guarantees to converge to the batch DT model given enough observations and a stationary data distribution; small memory and running time footprint (in most cases); some of their variations can deal with non-stationary distributions. And the previous list goes on and on. Besides that, HTs also have the same advantages as batch DTs ( C4.5 / J48 , CART , M5 , etc.) do. We can inspect the structure of a HT to understand how decisions were made, which is a nice feature to have in online learning tasks. In river , HTs are first-class citizens, so we have multiple realizations of this framework that are suited to different learning tasks and scenarios. This brief introduction to HT does not aims at being extensive nor delving into algorithmic or implementation details of the HTs. Instead, we intend to provide a high-level overview of the HTs as they are envisioned in river , as well as their shared properties and important hyperparameters. In this guide, we are going to: summarize the differences accross the multiple HT versions available; learn how to inspect tree models; learn how to manage the memory usage of HTs; compare numerical tree splitters and understand their impact on the iDT induction process. Well, without further ado, let's go! First things first, we are going to start with some imports. import matplotlib.pyplot as plt from river import datasets from river import evaluate from river import metrics from river import preprocessing # we are going to use that later from river import synth # we are going to use some synthetic datasets too from river import tree","title":"Incremental decision trees in river: the Hoeffding Tree case"},{"location":"recipes/on-hoeffding-trees/#1-trees-trees-everywhere-gardening-101-with-river","text":"At first glance, the amount of iDT algorithms in river might seem too much to handle, but in reality the distinction among them is easy to grasp. To facilitate our lives, here's a neat table listing the available HT models and summarizing their differences: Name Acronym Task Non-stationary? Comments Source Hoeffding Tree Classifier HTC Classification No Basic HT for classification tasks [1] Hoeffding Adaptive Tree Classifier HATC Classification Yes Modifies HTC by adding an instance of ADWIN to each node to detect and react to drift detection [2] Extremely Fast Decision Tree Classifier EFDT Classification No Deploys split decisions as soon as possible and periodically revisit decisions and redo them if necessary. Not as fast in practice as the name implies, but it tends to converge faster than HTC to the model generated by a batch DT [3] Hoeffding Tree Regressor HTR Regression No Basic HT for regression tasks. It is an adaptation of the FIRT/FIMT algorithm that bears some semblance to HTC [4] Hoeffding Adaptive Tree Regressor HATR Regression Yes Modifies HTR by adding an instance of ADWIN to each node to detect and react to drift detection - incremental Structured-Output Prediction Tree Regressor iSOUPT Multi-target regression No Multi-target version of HTR [5] Label Combination Hoeffding Tree Classifier LCHTC Multi-label classification No Creates a numerical code for each combination of the binary labels and uses HTC to learn from this encoded representation. At prediction time, decodes the modified representation to obtain the original label set - As we can see, although their application fields might overlap sometimes, the HT variations have specific situations in which they are better suited to work. Moreover, in river we provide a standardized API access to all the HT variants since they share many properties in common.","title":"1. Trees, trees everywhere: gardening 101 with river"},{"location":"recipes/on-hoeffding-trees/#2-how-to-inspect-tree-models","text":"We provide a handful of tools to inspect trained HTs in river . Here, we will provide some examples of how to access their inner structures, get useful information, and plot the iDT structure. Firstly, let's pick a toy dataset from which our tree will learn from. Here we are going to focus on the classification case, but the same operations apply to other learning tasks. We will select the Phishing dataset from the datasets module to exemplify the HTs' capabilities. dataset = datasets . Phishing () dataset Phishing websites. This dataset contains features from web pages that are classified as phishing or not. Name Phishing Task Binary classification Samples 1,250 Features 9 Sparse False Path /Users/max.halford/projects/river/river/datasets/phishing.csv.gz We are going to train an instance of HoeffdingTreeClassifier using this dataset. As everything else in river , training an iDT is a piece of cake! %% time model = tree . HoeffdingTreeClassifier ( grace_period = 50 ) for x , y in dataset : model . learn_one ( x , y ) model CPU times: user 129 ms, sys: 2.77 ms, total: 132 ms Wall time: 133 ms HoeffdingTreeClassifier ( grace_period=50 max_depth=inf split_criterion=\"info_gain\" split_confidence=1e-07 tie_threshold=0.05 leaf_prediction=\"nba\" nb_threshold=0 nominal_attributes=None splitter=GaussianSplitter ( n_splits=10 ) binary_split=False max_size=100 memory_estimate_period=1000000 stop_mem_management=False remove_poor_attrs=False merit_preprune=True ) That's it! We are not going to enter into details about some of the available parameters of HTC here. The user can refer to the documentation page for more information about that. Let's talk about model inspection :D At any time, we can easily get some statistics about our trained model by using the summary property: model . summary {'n_nodes': 5, 'n_branches': 2, 'n_leaves': 3, 'n_active_leaves': 3, 'n_inactive_leaves': 0, 'height': 3, 'total_observed_weight': 1250.0} This property show us the internal structure of the tree, including data concerning the memory-management routines that we are going to check later in this guide. We can also get a representation of the tree model as a pandas.DataFrame object: model . to_dataframe () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } parent is_leaf depth stats feature threshold splitter splitters _disabled_attrs _last_split_attempt_at _mc_correct_weight _nb_correct_weight node 0 <NA> False 0 {True: 260.0, False: 390.0} empty_server_form_handler 0.545455 NaN NaN NaN NaN NaN NaN 1 0 True 1 {True: 443.4163997711022, False: 59.8769131081... NaN NaN GaussianSplitter {'empty_server_form_handler': GaussianSplitter... {} 474.293313 249.0 248.0 2 0 False 1 {True: 71.58360022889781, False: 404.123086891... popup_window 0.090909 NaN NaN NaN NaN NaN NaN 3 2 True 2 {False: 31.426538522574834, True: 33.0} NaN NaN GaussianSplitter {'empty_server_form_handler': GaussianSplitter... {} 59.426539 23.0 36.0 4 2 True 2 {False: 250.57346147742516, True: 6.0} NaN NaN GaussianSplitter {'empty_server_form_handler': GaussianSplitter... {} 241.573461 210.0 196.0 Hmm, maybe not the clearest of the representations. What about drawing the tree structure instead? model . draw () Much better, huh? Lastly, we can check how the tree predicts one specific instance by using the debug_one method: x , y = next ( iter ( dataset )) # Let's select the first example in the stream x , y ({'empty_server_form_handler': 0.0, 'popup_window': 0.0, 'https': 0.0, 'request_from_other_domain': 0.0, 'anchor_from_other_domain': 0.0, 'is_popular': 0.5, 'long_url': 1.0, 'age_of_domain': 1, 'ip_in_url': 1}, True) print ( model . debug_one ( x )) empty_server_form_handler \u2264 0.5454545454545454 Class True: P(False) = 0.1 P(True) = 0.9 Our tree got this one right! The method debug_one is especially useful when we are dealing with a big tree model where drawing might not be the wisest of the choices (we will end up with a tree chart that has too much information to visually understand). Some additional hints: the max_depth parameter is our friend when building HTs that need to be constantly inspected. This parameter, which is available for every HT variant, triggers a pre-pruning mechanism that stops tree growth when the given depth is reached. we can also limit the depth when using the draw method. in the case of tree ensembles, individual trees can be accessed using the [index] operator. Then, the same set of inspection tools are available to play with!","title":"2. How to inspect tree models?"},{"location":"recipes/on-hoeffding-trees/#3-advanced-gardening-with-river-grab-your-pruning-shears-and-lets-limit-memory-usage","text":"Online learning is well-suited to highly scalable processing centers with petabytes of data arriving intermittently, but it can also work with Internet of Things (IoT) devices operating at low power and with limited processing capability. Hence, making sure our trees are not going to use too much memory is a nice feature that can impact on both energy usage and the running time. HTs have memory-management routines that put the user in the control of computational resources that are available. In this brief guide, we are going to use a regression tree, since this kind of iDT typically spends more memory than the classification counterparts. However, the user can control the memory usage in the exact same way in river , regardless of the HT variant! We will rely on the Friedman synthetic dataset (data generator) from the synth module in our evaluation. To avoid doing tedious stuff, let's use the Track class from the evaluate module. Tracks are the standard way of benchmarking learning models in river . Since data generators can produce instances indefinitely, we will select a sample of size 10K for our tests. def friedman_track ( n_samples = 10_000 ): dataset = synth . Friedman ( seed = 42 ) . take ( n_samples ) track = evaluate . Track ( \"10K Friedman + MAE\" , dataset , metrics . MAE (), n_samples ) return track We are almost ready to go. Let's first define a simple function that parses the data generated by our tracks and plots it in a nice way. def plot_track ( track , metric_name , models , n_samples , n_checkpoints ): fig , ax = plt . subplots ( figsize = ( 5 , 5 ), nrows = 3 , dpi = 300 ) for model_name , model in models . items (): step = [] error = [] r_time = [] memory = [] for checkpoint in track ( n_samples ) . run ( model , n_checkpoints ): step . append ( checkpoint [ \"Step\" ]) error . append ( checkpoint [ metric_name ] . get ()) # Convert timedelta object into seconds r_time . append ( checkpoint [ \"Time\" ] . total_seconds ()) # Make sure the memory measurements are in MB raw_memory , unit = float ( checkpoint [ \"Memory\" ][: - 3 ]), checkpoint [ \"Memory\" ][ - 2 :] memory . append ( raw_memory * 2 **- 10 if unit == 'KB' else raw_memory ) ax [ 0 ] . grid ( True ) ax [ 1 ] . grid ( True ) ax [ 2 ] . grid ( True ) ax [ 0 ] . plot ( step , error , label = model_name ) ax [ 0 ] . set_ylabel ( metric_name ) ax [ 1 ] . plot ( step , r_time , label = model_name ) ax [ 1 ] . set_ylabel ( 'Time (seconds)' ) ax [ 2 ] . plot ( step , memory , label = model_name ) ax [ 2 ] . set_ylabel ( 'Memory (MB)' ) ax [ 2 ] . set_xlabel ( 'Instances' ) plt . legend () plt . tight_layout () plt . close () return fig plot_track ( friedman_track , \"MAE\" , { \"Unbounded HTR\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ())}, 10_000 , 100 ) [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000, 3100, 3200, 3300, 3400, 3500, 3600, 3700, 3800, 3900, 4000, 4100, 4200, 4300, 4400, 4500, 4600, 4700, 4800, 4900, 5000, 5100, 5200, 5300, 5400, 5500, 5600, 5700, 5800, 5900, 6000, 6100, 6200, 6300, 6400, 6500, 6600, 6700, 6800, 6900, 7000, 7100, 7200, 7300, 7400, 7500, 7600, 7700, 7800, 7900, 8000, 8100, 8200, 8300, 8400, 8500, 8600, 8700, 8800, 8900, 9000, 9100, 9200, 9300, 9400, 9500, 9600, 9700, 9800, 9900, 10000] [6.311936135605157, 4.426916277623943, 3.73235813142122, 3.3473428046148133, 3.130360658908175, 2.972692298348939, 2.817017637680579, 2.696179164634299, 2.63709303340789, 2.5566140161009447, 2.4937505469971324, 2.4371064440381973, 2.3987113035752614, 2.3609733473352295, 2.3381353138143943, 2.3194348576470287, 2.282226645299219, 2.2542334920848406, 2.2343625977975, 2.2178015281841166, 2.1834977649678318, 2.1531220972043585, 2.134676620751594, 2.1138849232248, 2.1019286980821055, 2.1042079251674215, 2.097925056455068, 2.084323908804759, 2.0714670190131135, 2.0705003322426436, 2.0552509010674473, 2.048484532008886, 2.033028358661703, 2.0263620862292595, 2.020823699681305, 2.0155642661224142, 2.0054633342111963, 1.9990365488688657, 1.9941001534967844, 1.9867407115187592, 1.9854599856579107, 1.9807035981982755, 1.9809803074696384, 1.9737005713616294, 1.9710292083747358, 1.9705759483713436, 1.9692307919722092, 1.9703311394214822, 1.9656243399539601, 1.967410063166392, 1.9613071559583721, 1.9634497255414836, 1.9653181059482623, 1.9636911356903617, 1.9593072042760353, 1.9587268700311737, 1.960482982627088, 1.9610614326336027, 1.957276133863555, 1.9550666111730721, 1.955606619358126, 1.9529361938108516, 1.9527382302874101, 1.9526135381384593, 1.9497421585163321, 1.9467881840140944, 1.9392583842434707, 1.936378853393644, 1.9370919519884757, 1.9352084113724375, 1.9339703151885246, 1.9333780192289418, 1.9308839551446142, 1.9303444353390795, 1.932093603469563, 1.9298811956165787, 1.926942156850576, 1.9241555532138186, 1.9206024084677338, 1.9195204998624347, 1.9149284363791255, 1.91471767334126, 1.9145856556453265, 1.9131725360709422, 1.9105749006422819, 1.9101627403460366, 1.9097330501127028, 1.9096186797090573, 1.9079813149104223, 1.9054177923042632, 1.9011385190369439, 1.90055515383512, 1.8979358270743927, 1.8956528123559242, 1.8958429257588902, 1.8921638474993872, 1.8891663307392776, 1.8873871016982733, 1.884230814735786, 1.885090436697188] Unbounded HTR As we can see, our tree uses more than 10 MB to keep its structure. Let's say we wanted to limit our memory usage to 5 MB. How could we do that? Note that we are using a illustration case here. In real applications, data may be unbounded, so the trees might grow indefinitely. HTs expose some parameters related to memory management. The user can refer to the documentation for more details on that matter. Here, we are going to focus on two parameters: max_size : determines the maximum amount of memory (in MB) that the HT can use. memory_estimate_period : intervals after which the memory-management is triggered. We are going to limit our HTR to 5 MB and perform memory checks at intervals of 500 instances. plot_track ( friedman_track , \"MAE\" , { \"Restricted HTR\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( max_size = 5 , memory_estimate_period = 500 ) ) }, 10_000 , 100 ) Note that as soon the memory usage reaches the limit that we determined (at the memory check intervals), HTR starts managing its resource usage to reduce the size. As a consequence, the running time also decreases. For more accurate management, the intervals between memory checks should be decreased. This action, however, has costs since the tree stops the learning process to estimate its size and alter its own structure. Too frequent memory checks might end up result in a slow learning process. Besides, by using fewer resources, the predictive performance can be negatively impacted. So, use this tool with caution! But how that works at all? HTs monitor the incoming feature values to perform split attempts. To do so, they rely on a class of algorithms called Attribute Observers (AO) or Splitters (spoiler alert!). Each leaf node in an HT keeps one AO per incoming feature. After pre-determined intervals ( grace_period parameter), leaves query their AOs for split candidates. Well, there are costs to monitor input features (mainly the numerical ones). In fact, AOs correspond to one of the most time and memory-consuming portions of the HTs. To manage memory usage, an HT firstly determines its least promising leaves, w.r.t. how likely they will be split. Then, these leaves' AOs are removed, and the tree nodes are said to be \"deactivated.\" That's it! The deactivated leaves do not perform split attempts anymore, but they continue to be updated to provide responses. They will be kept as leaves as long as there are not available resources to enable tree growth. These leaves can be activated again (meaning that new AOs will be created for them) if there is available memory, so don't worry! Hint: another indirect way to bound memory usage is to limit the tree depth. By default, the trees can grow indefinitely, but the max_depth parameter can control this behavior. plot_track ( friedman_track , \"MAE\" , { \"HTR with at most 5 levels\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( max_depth = 5 ) ) }, 10_000 , 100 )","title":"3. Advanced gardening with river: grab your pruning shears and let's limit memory usage"},{"location":"recipes/on-hoeffding-trees/#4-branching-and-growth-splitters-the-heart-of-the-trees","text":"As previously stated, one of the core operations of iDT is, well, to grow. Plants and gardening-related jokes apart, growth in HTs is guided by their AOs or splitters, as mentioned in the end of Section 3. Nominal features can be easily monitored, since the feature partitions are well-defined beforehand. Numerical features, on the other hand, do not have an explicit best cut point. Still, numerical features are typically split by using a binary test: \\(\\le\\) or \\(>\\) . Therefore, numerical splitters must somehow summarize the incoming feature values and be able to evaluate the merit of split point candidates. There are diverse strategies to monitor numerical features and choices related to them, including which data structure will be used to keep a summary of the incoming feature and also how many split points are going to be evaluated during split attempts. Again, this guide does not intend to be an exhaustive delve into the iDT subject. In fact, each of the following aspects of the iDTs could be considered a separate research area: AOs, intervals between split attempts, split heuristics (e.g., info gain, variance reduction, and so on), tree depth and max size, and much more! Let's focus a bit into the AO matter. River provides a handful of splitters for classification and regression trees, which can be chosen using the parameter splitter . We will list the available tree splitters in the following sections and compare some of their chacteristics. Some notation: \\(n\\) : Number of observations seen so far. \\(c\\) : the number of classes. \\(s\\) : the number of split points to evaluate (which means that this is a user-given parameter). \\(h\\) : the number of histogram bins or hash slots. Tipically, \\(h \\ll n\\) .","title":"4. Branching and growth: splitters, the heart of the trees"},{"location":"recipes/on-hoeffding-trees/#41-classification-tree-splitters","text":"The following table summarizes the available classification splitters. The user might refer to the documentation of each splitter for more details about their functioning. Splitter Description Insertion Memory Split candidate query Works with Naive Bayes leaves? Exhaustive Keeps all the observed input values and class counts in a Binary Search Tree (BST) \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\) No Histogram Builds a histogram for each class in order to discretize the input feature \\(O(\\log h)\\) \\(O(c h)\\) \\(O(c h)\\) Yes Gaussian Approximates the class distributions using Gaussian distributions \\(O(1)\\) \\(O(c)\\) \\(O(cs)\\) Yes Note that some of the splitters have configurable parameters that directly impact not only on their time and memory costs, but also on the final predictive performance. Examples: The number of split points can be configured in the Gaussian splitter. Increasing this number makes this splitter slower, but it also potentially increases the quality of the obtained query points, implying enhanced tree accuracy. The number of stored bins can be selected in the Histogram splitter. Increasing this number increases the memory footprint and running time of this splitter, but it also potentially makes its split candidates more accurate and positively impacts on the tree's final predictive performance. Next, we provide a brief comparison of the classification splitters using 10K instances of the Random RBF synthetic dataset. Note that the tree equiped with the Exhaustive splitter does not use Naive Bayes leaves. def random_rbf_track ( n_samples = 10_000 ): dataset = synth . RandomRBF ( seed_model = 7 , seed_sample = 42 ) . take ( n_samples ) track = evaluate . Track ( \"10K Random RBF + Accuracy\" , dataset , metrics . Accuracy (), n_samples ) return track plot_track ( random_rbf_track , \"Accuracy\" , { \"HTC + Exhaustive splitter\" : tree . HoeffdingTreeClassifier ( splitter = tree . splitter . ExhaustiveSplitter (), leaf_prediction = \"mc\" ), \"HTC + Histogram splitter\" : tree . HoeffdingTreeClassifier ( splitter = tree . splitter . HistogramSplitter () ), \"HTC + Gaussian splitter\" : tree . HoeffdingTreeClassifier ( splitter = tree . splitter . GaussianSplitter () ) }, 10_000 , 100 )","title":"4.1. Classification tree splitters"},{"location":"recipes/on-hoeffding-trees/#42-regression-tree-splitters","text":"The available regression tree splitters are summarized in the next table. The TE-BST costs are expressed in terms of \\(n^*\\) because the number of stored elements can be smaller than or equal to \\(n\\) . Splitter Description Insertion Memory Split candidate query Extended Binary Search Tree (E-BST) Stores all the observations and target statistics in a BST \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\) Truncated E-BST (TE-BST) Rounds the incoming data before passing it to the BST \\(O(\\log n^*)\\) (average) or \\(O(n^*)\\) (worst case) \\(O(n^*)\\) \\(O(n^*)\\) Quantization Observer (QO) Uses a hash-like structure to quantize the incoming data \\(O(1)\\) \\(O(h)\\) \\(O(h \\log h)\\) E-BST is an exhaustive algorithm, i.e., it works as batch solutions usually do, which might be prohibitive in real-world online scenarios. TE-BST and QO apply approximations to alleviate the costs involved in monitoring numerical data and performing split attempts. The number of desired decimal places to round the data (TE-BST) and the quantization radius (QO) are directly related to the running time, memory footprint, and error of the resulting tree model. We present a brief comparison of the available regression tree splitters using the 10K instances of the Friedman synthetic dataset. plot_track ( friedman_track , \"MAE\" , { \"HTR + E-BST\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( splitter = tree . splitter . EBSTSplitter () ) ), \"HTR + TE-BST\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( splitter = tree . splitter . TEBSTSplitter ( digits = 2 ) ) ), \"HTR + QO\" : ( preprocessing . StandardScaler () | tree . HoeffdingTreeRegressor ( splitter = tree . splitter . QOSplitter () ) ), }, 10_000 , 100 )","title":"4.2 Regression tree splitters"},{"location":"recipes/on-hoeffding-trees/#wrapping-up","text":"This guide provides a walkthrough in the HTs available in river . We discussed about model inspection, memory management, and feature splits. Keep in mind that each HT variant has specific details and capabilities that are out-of-the-scope of this introductory material. The user is advised to check the documentation page of the tree models for detailed information.","title":"Wrapping up"},{"location":"recipes/pipelines/","text":"Pipelines \u00b6 Pipelines are an integral part of river. We encourage their usage and apply them in many of their examples. The compose.Pipeline contains all the logic for building and applying pipelines. A pipeline is essentially a list of estimators that are applied in sequence. The only requirement is that the first n - 1 steps be transformers. The last step can be a regressor, a classifier, a clusterer, a transformer, etc. Here is an example: from river import compose from river import linear_model from river import preprocessing from river import feature_extraction model = compose . Pipeline ( preprocessing . StandardScaler (), feature_extraction . PolynomialExtender (), linear_model . LinearRegression () ) You can also use the | operator, as so: model = ( preprocessing . StandardScaler () | feature_extraction . PolynomialExtender () | linear_model . LinearRegression () ) Or, equally: model = preprocessing . StandardScaler () model |= feature_extraction . PolynomialExtender () model |= linear_model . LinearRegression () A pipeline has a draw method that can be used to visualize it: model StandardScaler {'counts': Counter(), 'means': defaultdict(<class 'float'>, {}), 'vars': defaultdict(<class 'float'>, {}), 'with_std': True} PolynomialExtender {'bias_name': 'bias', 'degree': 2, 'include_bias': False, 'interaction_only': False} LinearRegression {'_weights': {}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 0.0, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 0})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } compose.Pipeline inherits from base.Estimator , which means that it has a learn_one method. You would expect learn_one to update each estimator, but that's not actually what happens . Instead, the transformers are updated when predict_one (or predict_proba_one for that matter) is called. Indeed, in online machine learning, we can update the unsupervised parts of our model when a sample arrives. We don't have to wait for the ground truth to arrive in order to update unsupervised estimators that don't depend on it. In other words, in a pipeline, learn_one updates the supervised parts, whilst predict_one updates the unsupervised parts. It's important to be aware of this behavior, as it is quite different to what is done in other libraries that rely on batch machine learning. Here is a small example to illustrate the previous point: from river import datasets dataset = datasets . TrumpApproval () x , y = next ( iter ( dataset )) x , y ({'ordinal_date': 736389, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}, 43.75505) Let us call predict_one , which will update each transformer, but won't update the linear regression. model . predict_one ( x ) 0.0 The prediction is nil because each weight of the linear regression is equal to 0. model [ 'StandardScaler' ] . means defaultdict(float, {'ordinal_date': 736389.0, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}) As we can see, the means of each feature have been updated, even though we called predict_one and not learn_one . Note that if you call transform_one with a pipeline who's last step is not a transformer, then the output from the last transformer (which is thus the penultimate step) will be returned: model . transform_one ( x ) {'ordinal_date': 0.0, 'gallup': 0.0, 'ipsos': 0.0, 'morning_consult': 0.0, 'rasmussen': 0.0, 'you_gov': 0.0, 'ordinal_date*ordinal_date': 0.0, 'gallup*ordinal_date': 0.0, 'ipsos*ordinal_date': 0.0, 'morning_consult*ordinal_date': 0.0, 'ordinal_date*rasmussen': 0.0, 'ordinal_date*you_gov': 0.0, 'gallup*gallup': 0.0, 'gallup*ipsos': 0.0, 'gallup*morning_consult': 0.0, 'gallup*rasmussen': 0.0, 'gallup*you_gov': 0.0, 'ipsos*ipsos': 0.0, 'ipsos*morning_consult': 0.0, 'ipsos*rasmussen': 0.0, 'ipsos*you_gov': 0.0, 'morning_consult*morning_consult': 0.0, 'morning_consult*rasmussen': 0.0, 'morning_consult*you_gov': 0.0, 'rasmussen*rasmussen': 0.0, 'rasmussen*you_gov': 0.0, 'you_gov*you_gov': 0.0} In many cases, you might want to connect a step to multiple steps. For instance, you might to extract different kinds of features from a single input. An elegant way to do this is to use a compose.TransformerUnion . Essentially, the latter is a list of transformers who's results will be merged into a single dict when transform_one is called. As an example let's say that we want to apply a feature_extraction.RBFSampler as well as the feature_extraction.PolynomialExtender . This may be done as so: model = ( preprocessing . StandardScaler () | ( feature_extraction . PolynomialExtender () + feature_extraction . RBFSampler ()) | linear_model . LinearRegression () ) model StandardScaler {'counts': Counter(), 'means': defaultdict(<class 'float'>, {}), 'vars': defaultdict(<class 'float'>, {}), 'with_std': True} PolynomialExtender {'bias_name': 'bias', 'degree': 2, 'include_bias': False, 'interaction_only': False} RBFSampler {'gamma': 1.0, 'n_components': 100, 'offsets': [3.3510532411100926, 1.190142184105075, 4.758468173807059, 2.102487972776319, 1.480660275522741, 5.366729269710237, 5.070416334382951, 1.277733738266996, 2.207119719491707, 2.1426794957848565, 1.8225710193657765, 0.053985537083313495, 2.6438259461961584, 0.8971767883543308, 3.471297218403341, 2.6459033776328047, 1.9757793978738034, 5.087466036691654, 3.518448810009812, 5.758687368535289, 4.79849237290909, 5.743603500595328, 3.8577593701336594, 2.992220690658145, 4.6122186296260645, 2.1072783802275836, 3.2587620363834997, 4.18188290647669, 3.789865875963889, 1.3166941816528979, 2.1496598890995253, 0.5514213256928427, 6.133866289278633, 5.464360858865711, 4.291124096688779, 5.030631537283815, 0.9257361562479935, 6.114310134092216, 2.5412321682182526, 4.822019847592126, 0.49289853038336945, 5.662322515846727, 1.1066734350932208, 2.7859787189161023, 1.0923831484478823, 3.862364264034545, 4.57817015349273, 4.879251535793154, 3.2389588917501846, 0.8671594208818371, 0.3928381887147743, 0.8367553042176593, 5.487324628228967, 1.754506781747617, 1.4467895315220585, 4.95057422570524, 1.515646570633651, 0.7141957541762096, 2.6802165231715596, 3.1143643491751765, 3.2887707754133637, 4.698780590052855, 2.628523813897675, 3.051845846553334, 0.7137935763683448, 0.8668790249131346, 4.55066107913964, 5.448264849218835, 0.6859224016931418, 3.7014814797697153, 1.4690127755832323, 4.680232230781756, 2.1073009522234694, 3.8794879419289177, 0.9006462860416513, 2.682015494386968, 2.52991503710204, 2.2535812651434344, 5.407510051438392, 2.8275014865565486, 0.5645870178898392, 5.242344945410286, 1.609719168544174, 4.340295048969955, 2.927344299721854, 2.1090856426673503, 2.698017694795121, 5.749312469665515, 3.6999265064358733, 3.280883125056919, 5.481053451883993, 1.77331580361824, 0.0858416295646753, 5.316833856722039, 1.8426572018482168, 5.347342560277715, 5.1189679745176475, 1.2592524362712572, 3.637660524181257, 2.393108047753942], 'rng': <random.Random object at 0x7ff61a344210>, 'seed': None, 'weights': defaultdict(<bound method RBFSampler._random_weights of RBFSampler ( gamma=1. n_components=100 seed=None )>, {})} LinearRegression {'_weights': {}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 0.0, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 0})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } Note that the + symbol acts as a shorthand notation for creating a compose.TransformerUnion , which means that we could have declared the above pipeline as so: model = ( preprocessing . StandardScaler () | compose . TransformerUnion ( feature_extraction . PolynomialExtender (), feature_extraction . RBFSampler () ) | linear_model . LinearRegression () ) Pipelines provide the benefit of removing a lot of cruft by taking care of tedious details for you. They also enable to clearly define what steps your model is made of. Finally, having your model in a single object means that you can move it around more easily. Note that you can include user-defined functions in a pipeline by using a compose.FuncTransformer .","title":"Pipelines"},{"location":"recipes/pipelines/#pipelines","text":"Pipelines are an integral part of river. We encourage their usage and apply them in many of their examples. The compose.Pipeline contains all the logic for building and applying pipelines. A pipeline is essentially a list of estimators that are applied in sequence. The only requirement is that the first n - 1 steps be transformers. The last step can be a regressor, a classifier, a clusterer, a transformer, etc. Here is an example: from river import compose from river import linear_model from river import preprocessing from river import feature_extraction model = compose . Pipeline ( preprocessing . StandardScaler (), feature_extraction . PolynomialExtender (), linear_model . LinearRegression () ) You can also use the | operator, as so: model = ( preprocessing . StandardScaler () | feature_extraction . PolynomialExtender () | linear_model . LinearRegression () ) Or, equally: model = preprocessing . StandardScaler () model |= feature_extraction . PolynomialExtender () model |= linear_model . LinearRegression () A pipeline has a draw method that can be used to visualize it: model StandardScaler {'counts': Counter(), 'means': defaultdict(<class 'float'>, {}), 'vars': defaultdict(<class 'float'>, {}), 'with_std': True} PolynomialExtender {'bias_name': 'bias', 'degree': 2, 'include_bias': False, 'interaction_only': False} LinearRegression {'_weights': {}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 0.0, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 0})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } compose.Pipeline inherits from base.Estimator , which means that it has a learn_one method. You would expect learn_one to update each estimator, but that's not actually what happens . Instead, the transformers are updated when predict_one (or predict_proba_one for that matter) is called. Indeed, in online machine learning, we can update the unsupervised parts of our model when a sample arrives. We don't have to wait for the ground truth to arrive in order to update unsupervised estimators that don't depend on it. In other words, in a pipeline, learn_one updates the supervised parts, whilst predict_one updates the unsupervised parts. It's important to be aware of this behavior, as it is quite different to what is done in other libraries that rely on batch machine learning. Here is a small example to illustrate the previous point: from river import datasets dataset = datasets . TrumpApproval () x , y = next ( iter ( dataset )) x , y ({'ordinal_date': 736389, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}, 43.75505) Let us call predict_one , which will update each transformer, but won't update the linear regression. model . predict_one ( x ) 0.0 The prediction is nil because each weight of the linear regression is equal to 0. model [ 'StandardScaler' ] . means defaultdict(float, {'ordinal_date': 736389.0, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004}) As we can see, the means of each feature have been updated, even though we called predict_one and not learn_one . Note that if you call transform_one with a pipeline who's last step is not a transformer, then the output from the last transformer (which is thus the penultimate step) will be returned: model . transform_one ( x ) {'ordinal_date': 0.0, 'gallup': 0.0, 'ipsos': 0.0, 'morning_consult': 0.0, 'rasmussen': 0.0, 'you_gov': 0.0, 'ordinal_date*ordinal_date': 0.0, 'gallup*ordinal_date': 0.0, 'ipsos*ordinal_date': 0.0, 'morning_consult*ordinal_date': 0.0, 'ordinal_date*rasmussen': 0.0, 'ordinal_date*you_gov': 0.0, 'gallup*gallup': 0.0, 'gallup*ipsos': 0.0, 'gallup*morning_consult': 0.0, 'gallup*rasmussen': 0.0, 'gallup*you_gov': 0.0, 'ipsos*ipsos': 0.0, 'ipsos*morning_consult': 0.0, 'ipsos*rasmussen': 0.0, 'ipsos*you_gov': 0.0, 'morning_consult*morning_consult': 0.0, 'morning_consult*rasmussen': 0.0, 'morning_consult*you_gov': 0.0, 'rasmussen*rasmussen': 0.0, 'rasmussen*you_gov': 0.0, 'you_gov*you_gov': 0.0} In many cases, you might want to connect a step to multiple steps. For instance, you might to extract different kinds of features from a single input. An elegant way to do this is to use a compose.TransformerUnion . Essentially, the latter is a list of transformers who's results will be merged into a single dict when transform_one is called. As an example let's say that we want to apply a feature_extraction.RBFSampler as well as the feature_extraction.PolynomialExtender . This may be done as so: model = ( preprocessing . StandardScaler () | ( feature_extraction . PolynomialExtender () + feature_extraction . RBFSampler ()) | linear_model . LinearRegression () ) model StandardScaler {'counts': Counter(), 'means': defaultdict(<class 'float'>, {}), 'vars': defaultdict(<class 'float'>, {}), 'with_std': True} PolynomialExtender {'bias_name': 'bias', 'degree': 2, 'include_bias': False, 'interaction_only': False} RBFSampler {'gamma': 1.0, 'n_components': 100, 'offsets': [3.3510532411100926, 1.190142184105075, 4.758468173807059, 2.102487972776319, 1.480660275522741, 5.366729269710237, 5.070416334382951, 1.277733738266996, 2.207119719491707, 2.1426794957848565, 1.8225710193657765, 0.053985537083313495, 2.6438259461961584, 0.8971767883543308, 3.471297218403341, 2.6459033776328047, 1.9757793978738034, 5.087466036691654, 3.518448810009812, 5.758687368535289, 4.79849237290909, 5.743603500595328, 3.8577593701336594, 2.992220690658145, 4.6122186296260645, 2.1072783802275836, 3.2587620363834997, 4.18188290647669, 3.789865875963889, 1.3166941816528979, 2.1496598890995253, 0.5514213256928427, 6.133866289278633, 5.464360858865711, 4.291124096688779, 5.030631537283815, 0.9257361562479935, 6.114310134092216, 2.5412321682182526, 4.822019847592126, 0.49289853038336945, 5.662322515846727, 1.1066734350932208, 2.7859787189161023, 1.0923831484478823, 3.862364264034545, 4.57817015349273, 4.879251535793154, 3.2389588917501846, 0.8671594208818371, 0.3928381887147743, 0.8367553042176593, 5.487324628228967, 1.754506781747617, 1.4467895315220585, 4.95057422570524, 1.515646570633651, 0.7141957541762096, 2.6802165231715596, 3.1143643491751765, 3.2887707754133637, 4.698780590052855, 2.628523813897675, 3.051845846553334, 0.7137935763683448, 0.8668790249131346, 4.55066107913964, 5.448264849218835, 0.6859224016931418, 3.7014814797697153, 1.4690127755832323, 4.680232230781756, 2.1073009522234694, 3.8794879419289177, 0.9006462860416513, 2.682015494386968, 2.52991503710204, 2.2535812651434344, 5.407510051438392, 2.8275014865565486, 0.5645870178898392, 5.242344945410286, 1.609719168544174, 4.340295048969955, 2.927344299721854, 2.1090856426673503, 2.698017694795121, 5.749312469665515, 3.6999265064358733, 3.280883125056919, 5.481053451883993, 1.77331580361824, 0.0858416295646753, 5.316833856722039, 1.8426572018482168, 5.347342560277715, 5.1189679745176475, 1.2592524362712572, 3.637660524181257, 2.393108047753942], 'rng': <random.Random object at 0x7ff61a344210>, 'seed': None, 'weights': defaultdict(<bound method RBFSampler._random_weights of RBFSampler ( gamma=1. n_components=100 seed=None )>, {})} LinearRegression {'_weights': {}, '_y_name': None, 'clip_gradient': 1000000000000.0, 'initializer': Zeros (), 'intercept': 0.0, 'intercept_init': 0.0, 'intercept_lr': Constant({'learning_rate': 0.01}), 'l2': 0.0, 'loss': Squared({}), 'optimizer': SGD({'lr': Constant({'learning_rate': 0.01}), 'n_iterations': 0})} .estimator { padding: 1em; border-style: solid; background: white; } .pipeline { display: flex; flex-direction: column; align-items: center; background: linear-gradient(#000, #000) no-repeat center / 3px 100%; } .union { display: flex; flex-direction: row; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white } .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1em; border-style: solid; background: white; } .wrapper > .estimator { margin-top: 1em; } /* Vertical spacing between steps */ .component + .component { margin-top: 2em; } .union > .estimator { margin-top: 0; } .union > .pipeline { margin-top: 0; } /* Spacing within a union of estimators */ .union > .component + .component { margin-left: 1em; } /* Typography */ .estimator-params { display: block; white-space: pre-wrap; font-size: 120%; margin-bottom: -1em; } .estimator > code, .wrapper > details > code { background-color: white !important; } .estimator-name { display: inline; margin: 0; font-size: 130%; } /* Toggle */ summary { display: flex; align-items:center; cursor: pointer; } summary > div { width: 100%; } Note that the + symbol acts as a shorthand notation for creating a compose.TransformerUnion , which means that we could have declared the above pipeline as so: model = ( preprocessing . StandardScaler () | compose . TransformerUnion ( feature_extraction . PolynomialExtender (), feature_extraction . RBFSampler () ) | linear_model . LinearRegression () ) Pipelines provide the benefit of removing a lot of cruft by taking care of tedious details for you. They also enable to clearly define what steps your model is made of. Finally, having your model in a single object means that you can move it around more easily. Note that you can include user-defined functions in a pipeline by using a compose.FuncTransformer .","title":"Pipelines"},{"location":"recipes/reading-data/","text":"Reading data \u00b6 In river , the features of a sample are stored inside a dictionary, which in Python is called a dict and is a native data structure. In other words, we don't use any sophisticated data structure, such as a numpy.ndarray or a pandas.DataFrame . The main advantage of using plain dict s is that it removes the overhead that comes with using the aforementioned data structures. This is important in a streaming context because we want to be able to process many individual samples in rapid succession. Another advantage is that dict s allow us to give names to our features. Finally, dict s are not typed, and can therefore store heterogeneous data. Another advantage which we haven't mentioned is that dict s play nicely with Python's standard library. Indeed, Python contains many tools that allow manipulating dict s. For instance, the csv.DictReader can be used to read a CSV file and convert each row to a dict . In fact, the stream.iter_csv method from river is just a wrapper on top of csv.DictReader that adds a few bells and whistles. river provides some out-of-the-box datasets to get you started. from river import datasets dataset = datasets . Bikes () dataset Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse. Name Bikes Task Regression Samples 182,470 Features 8 Sparse False Path /Users/max.halford/river_data/Bikes/toulouse_bikes.csv URL https://maxhalford.github.io/files/datasets/toulouse_bikes.zip Size 12.52 MB Downloaded True Note that when we say \"loaded\", we don't mean that the actual data is read from the disk. On the contrary, the dataset is a streaming data that can be iterated over one sample at a time. In Python lingo, it's a generator . Let's take a look at the first sample: x , y = next ( iter ( dataset )) x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} Each dataset is iterable, which means we can also do: for x , y in dataset : break x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} As we can see, the values have different types. Under the hood, calling for x, y in dataset simply iterates over a file and parses each value appropriately. We can do this ourselves by using stream.iter_csv : from river import stream X_y = stream . iter_csv ( dataset . path ) x , y = next ( X_y ) x , y ({'moment': '2016-04-01 00:00:07', 'bikes': '1', 'station': 'metro-canal-du-midi', 'clouds': '75', 'description': 'light rain', 'humidity': '81', 'pressure': '1017.0', 'temperature': '6.54', 'wind': '9.3'}, None) There are a couple things that are wrong. First of all, the numeric features have not been casted into numbers. Indeed, by default, stream.iter_csv assumes that everything is a string. A related issue is that the moment field hasn't been parsed into a datetime . Finally, the target field, which is bikes , hasn't been separated from the rest of the features. We can remedy to these issues by setting a few parameters: X_y = stream . iter_csv ( dataset . path , converters = { 'bikes' : int , 'clouds' : int , 'humidity' : int , 'pressure' : float , 'temperature' : float , 'wind' : float }, parse_dates = { 'moment' : '%Y-%m- %d %H:%M:%S' }, target = 'bikes' ) x , y = next ( X_y ) x , y ({'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3}, 1) That's much better. We invite you to take a look at the stream module to see for yourself what other methods are available. Note that river is first and foremost a machine learning library, and therefore isn't as much concerned about reading data as it is about statistical algorithms. We do however believe that the fact that we use dictionary gives you, the user, a lot of freedom and flexibility. The stream module provides helper functions to read data from different formats. For instance, you can use the stream.iter_sklearn_dataset function to turn any scikit-learn dataset into a stream. from sklearn import datasets dataset = datasets . load_diabetes () for x , y in stream . iter_sklearn_dataset ( dataset ): break x , y ({'age': 0.0380759064334241, 'sex': 0.0506801187398187, 'bmi': 0.0616962065186885, 'bp': 0.0218723549949558, 's1': -0.0442234984244464, 's2': -0.0348207628376986, 's3': -0.0434008456520269, 's4': -0.00259226199818282, 's5': 0.0199084208763183, 's6': -0.0176461251598052}, 151.0) To conclude, let us shortly mention the difference between proactive learning and reactive learning in the specific context of online machine learning. When we loop over a data with a for loop, we have the control over the data and the order in which it arrives. We are proactive in the sense that we, the user, are asking for the data to arrive. In contract, in a reactive situation, we don't have control on the data arrival. A typical example of such a situation is a web server, where web requests arrive in an arbitrary order. This is a situation where river shines. For instance, in a Flask application, you could define a route to make predictions with a river model as so: import flask app = flask . Flask ( __name__ ) @app . route ( '/' , methods = [ 'GET' ]) def predict (): payload = flask . request . json river_model = load_model () return river_model . predict_proba_one ( payload ) Likewise, a model can be updated whenever a request arrives as so: @app . route ( '/' , methods = [ 'POST' ]) def learn (): payload = flask . request . json river_model = load_model () river_model . learn_one ( payload [ 'features' ], payload [ 'target' ]) return {}, 201 To summarize, river can be used in many different ways. The fact that it uses dictionaries to represent features provides a lot of flexibility and space for creativity.","title":"Reading data"},{"location":"recipes/reading-data/#reading-data","text":"In river , the features of a sample are stored inside a dictionary, which in Python is called a dict and is a native data structure. In other words, we don't use any sophisticated data structure, such as a numpy.ndarray or a pandas.DataFrame . The main advantage of using plain dict s is that it removes the overhead that comes with using the aforementioned data structures. This is important in a streaming context because we want to be able to process many individual samples in rapid succession. Another advantage is that dict s allow us to give names to our features. Finally, dict s are not typed, and can therefore store heterogeneous data. Another advantage which we haven't mentioned is that dict s play nicely with Python's standard library. Indeed, Python contains many tools that allow manipulating dict s. For instance, the csv.DictReader can be used to read a CSV file and convert each row to a dict . In fact, the stream.iter_csv method from river is just a wrapper on top of csv.DictReader that adds a few bells and whistles. river provides some out-of-the-box datasets to get you started. from river import datasets dataset = datasets . Bikes () dataset Bike sharing station information from the city of Toulouse. The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse. Name Bikes Task Regression Samples 182,470 Features 8 Sparse False Path /Users/max.halford/river_data/Bikes/toulouse_bikes.csv URL https://maxhalford.github.io/files/datasets/toulouse_bikes.zip Size 12.52 MB Downloaded True Note that when we say \"loaded\", we don't mean that the actual data is read from the disk. On the contrary, the dataset is a streaming data that can be iterated over one sample at a time. In Python lingo, it's a generator . Let's take a look at the first sample: x , y = next ( iter ( dataset )) x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} Each dataset is iterable, which means we can also do: for x , y in dataset : break x {'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3} As we can see, the values have different types. Under the hood, calling for x, y in dataset simply iterates over a file and parses each value appropriately. We can do this ourselves by using stream.iter_csv : from river import stream X_y = stream . iter_csv ( dataset . path ) x , y = next ( X_y ) x , y ({'moment': '2016-04-01 00:00:07', 'bikes': '1', 'station': 'metro-canal-du-midi', 'clouds': '75', 'description': 'light rain', 'humidity': '81', 'pressure': '1017.0', 'temperature': '6.54', 'wind': '9.3'}, None) There are a couple things that are wrong. First of all, the numeric features have not been casted into numbers. Indeed, by default, stream.iter_csv assumes that everything is a string. A related issue is that the moment field hasn't been parsed into a datetime . Finally, the target field, which is bikes , hasn't been separated from the rest of the features. We can remedy to these issues by setting a few parameters: X_y = stream . iter_csv ( dataset . path , converters = { 'bikes' : int , 'clouds' : int , 'humidity' : int , 'pressure' : float , 'temperature' : float , 'wind' : float }, parse_dates = { 'moment' : '%Y-%m- %d %H:%M:%S' }, target = 'bikes' ) x , y = next ( X_y ) x , y ({'moment': datetime.datetime(2016, 4, 1, 0, 0, 7), 'station': 'metro-canal-du-midi', 'clouds': 75, 'description': 'light rain', 'humidity': 81, 'pressure': 1017.0, 'temperature': 6.54, 'wind': 9.3}, 1) That's much better. We invite you to take a look at the stream module to see for yourself what other methods are available. Note that river is first and foremost a machine learning library, and therefore isn't as much concerned about reading data as it is about statistical algorithms. We do however believe that the fact that we use dictionary gives you, the user, a lot of freedom and flexibility. The stream module provides helper functions to read data from different formats. For instance, you can use the stream.iter_sklearn_dataset function to turn any scikit-learn dataset into a stream. from sklearn import datasets dataset = datasets . load_diabetes () for x , y in stream . iter_sklearn_dataset ( dataset ): break x , y ({'age': 0.0380759064334241, 'sex': 0.0506801187398187, 'bmi': 0.0616962065186885, 'bp': 0.0218723549949558, 's1': -0.0442234984244464, 's2': -0.0348207628376986, 's3': -0.0434008456520269, 's4': -0.00259226199818282, 's5': 0.0199084208763183, 's6': -0.0176461251598052}, 151.0) To conclude, let us shortly mention the difference between proactive learning and reactive learning in the specific context of online machine learning. When we loop over a data with a for loop, we have the control over the data and the order in which it arrives. We are proactive in the sense that we, the user, are asking for the data to arrive. In contract, in a reactive situation, we don't have control on the data arrival. A typical example of such a situation is a web server, where web requests arrive in an arbitrary order. This is a situation where river shines. For instance, in a Flask application, you could define a route to make predictions with a river model as so: import flask app = flask . Flask ( __name__ ) @app . route ( '/' , methods = [ 'GET' ]) def predict (): payload = flask . request . json river_model = load_model () return river_model . predict_proba_one ( payload ) Likewise, a model can be updated whenever a request arrives as so: @app . route ( '/' , methods = [ 'POST' ]) def learn (): payload = flask . request . json river_model = load_model () river_model . learn_one ( payload [ 'features' ], payload [ 'target' ]) return {}, 201 To summarize, river can be used in many different ways. The fact that it uses dictionaries to represent features provides a lot of flexibility and space for creativity.","title":"Reading data"},{"location":"releases/0.0.2/","text":"0.0.2 - 2019-02-13 \u00b6 PyPI GitHub compat \u00b6 Added sklearn wrappers. ensemble \u00b6 Added ensemble.HedgeClassifier . feature_selection \u00b6 Added feature_selection.RandomDiscarder . feature_extraction \u00b6 Added feature_extraction.TargetEncoder . impute \u00b6 Added impute.NumericImputer . optim \u00b6 Added optim.AbsoluteLoss . Added optim.HingeLoss . Added optim.EpsilonInsensitiveHingeLoss . stats \u00b6 Added stats.NUnique . Added stats.Min . Added stats.Max . Added stats.PeakToPeak . Added stats.Kurtosis . Added stats.Skew . Added stats.Sum . Added stats.EWMean . Made sure the running statistics produce the same results as pandas.DataFrame.rolling method.","title":"0.0.2 - 2019-02-13"},{"location":"releases/0.0.2/#002-2019-02-13","text":"PyPI GitHub","title":"0.0.2 - 2019-02-13"},{"location":"releases/0.0.2/#compat","text":"Added sklearn wrappers.","title":"compat"},{"location":"releases/0.0.2/#ensemble","text":"Added ensemble.HedgeClassifier .","title":"ensemble"},{"location":"releases/0.0.2/#feature_selection","text":"Added feature_selection.RandomDiscarder .","title":"feature_selection"},{"location":"releases/0.0.2/#feature_extraction","text":"Added feature_extraction.TargetEncoder .","title":"feature_extraction"},{"location":"releases/0.0.2/#impute","text":"Added impute.NumericImputer .","title":"impute"},{"location":"releases/0.0.2/#optim","text":"Added optim.AbsoluteLoss . Added optim.HingeLoss . Added optim.EpsilonInsensitiveHingeLoss .","title":"optim"},{"location":"releases/0.0.2/#stats","text":"Added stats.NUnique . Added stats.Min . Added stats.Max . Added stats.PeakToPeak . Added stats.Kurtosis . Added stats.Skew . Added stats.Sum . Added stats.EWMean . Made sure the running statistics produce the same results as pandas.DataFrame.rolling method.","title":"stats"},{"location":"releases/0.0.3/","text":"0.0.3 - 2019-03-21 \u00b6 PyPI GitHub base \u00b6 Calling fit_one now returns the calling instance, not the out-of-fold prediction/transform; fit_predict_one , fit_predict_proba_one , and fit_transform_one are available to reproduce the previous behavior. Binary classifiers now output a dict with probabilities for False and True when calling predict_proba_one , which solves the interface issues of having multi-class classifiers do binary classification. compat \u00b6 Added compat.convert_river_to_sklearn . compose \u00b6 Added compose.BoxCoxTransformRegressor . Added compose.TargetModifierRegressor . datasets \u00b6 Added datasets.fetch_restaurants . Added datasets.load_airline . dist \u00b6 Added dist.Multinomial . Added dist.Normal . ensemble \u00b6 Added ensemble.BaggingRegressor . feature_extraction \u00b6 Added feature_extraction.TargetGroupBy . impute \u00b6 Added impute.CategoricalImputer . linear_model \u00b6 Added linear_model.FMRegressor . Removed all the passive-aggressive estimators. metrics \u00b6 Added metrics.Accuracy . Added metrics.MAE . Added metrics.MSE . Added metrics.RMSE . Added metrics.RMSLE . Added metrics.SMAPE . Added metrics.Precision . Added metrics.Recall . Added metrics.F1 . model_selection \u00b6 model_selection.online_score can now be passed a metrics.Metric instead of an sklearn metric; it also checks that the provided metric can be used with the accompanying model. naive_bayes \u00b6 Added naive_bayes.GaussianNB . optim \u00b6 Added optim.PassiveAggressiveI . Added optim.PassiveAggressiveII . preprocessing \u00b6 Added preprocessing.Discarder . Added preprocessing.PolynomialExtender . Added preprocessing.FuncTransformer . reco \u00b6 Added reco.SVD . stats \u00b6 Added stats.Mode . Added stats.Quantile . Added stats.RollingQuantile . Added stats.Entropy . Added stats.RollingMin . Added stats.RollingMax . Added stats.RollingMode . Added stats.RollingSum . Added stats.RollingPeakToPeak . stream \u00b6 Added stream.iter_csv . tree \u00b6 Added tree.MondrianTreeClassifier . Added tree.MondrianTreeRegressor .","title":"0.0.3 - 2019-03-21"},{"location":"releases/0.0.3/#003-2019-03-21","text":"PyPI GitHub","title":"0.0.3 - 2019-03-21"},{"location":"releases/0.0.3/#base","text":"Calling fit_one now returns the calling instance, not the out-of-fold prediction/transform; fit_predict_one , fit_predict_proba_one , and fit_transform_one are available to reproduce the previous behavior. Binary classifiers now output a dict with probabilities for False and True when calling predict_proba_one , which solves the interface issues of having multi-class classifiers do binary classification.","title":"base"},{"location":"releases/0.0.3/#compat","text":"Added compat.convert_river_to_sklearn .","title":"compat"},{"location":"releases/0.0.3/#compose","text":"Added compose.BoxCoxTransformRegressor . Added compose.TargetModifierRegressor .","title":"compose"},{"location":"releases/0.0.3/#datasets","text":"Added datasets.fetch_restaurants . Added datasets.load_airline .","title":"datasets"},{"location":"releases/0.0.3/#dist","text":"Added dist.Multinomial . Added dist.Normal .","title":"dist"},{"location":"releases/0.0.3/#ensemble","text":"Added ensemble.BaggingRegressor .","title":"ensemble"},{"location":"releases/0.0.3/#feature_extraction","text":"Added feature_extraction.TargetGroupBy .","title":"feature_extraction"},{"location":"releases/0.0.3/#impute","text":"Added impute.CategoricalImputer .","title":"impute"},{"location":"releases/0.0.3/#linear_model","text":"Added linear_model.FMRegressor . Removed all the passive-aggressive estimators.","title":"linear_model"},{"location":"releases/0.0.3/#metrics","text":"Added metrics.Accuracy . Added metrics.MAE . Added metrics.MSE . Added metrics.RMSE . Added metrics.RMSLE . Added metrics.SMAPE . Added metrics.Precision . Added metrics.Recall . Added metrics.F1 .","title":"metrics"},{"location":"releases/0.0.3/#model_selection","text":"model_selection.online_score can now be passed a metrics.Metric instead of an sklearn metric; it also checks that the provided metric can be used with the accompanying model.","title":"model_selection"},{"location":"releases/0.0.3/#naive_bayes","text":"Added naive_bayes.GaussianNB .","title":"naive_bayes"},{"location":"releases/0.0.3/#optim","text":"Added optim.PassiveAggressiveI . Added optim.PassiveAggressiveII .","title":"optim"},{"location":"releases/0.0.3/#preprocessing","text":"Added preprocessing.Discarder . Added preprocessing.PolynomialExtender . Added preprocessing.FuncTransformer .","title":"preprocessing"},{"location":"releases/0.0.3/#reco","text":"Added reco.SVD .","title":"reco"},{"location":"releases/0.0.3/#stats","text":"Added stats.Mode . Added stats.Quantile . Added stats.RollingQuantile . Added stats.Entropy . Added stats.RollingMin . Added stats.RollingMax . Added stats.RollingMode . Added stats.RollingSum . Added stats.RollingPeakToPeak .","title":"stats"},{"location":"releases/0.0.3/#stream","text":"Added stream.iter_csv .","title":"stream"},{"location":"releases/0.0.3/#tree","text":"Added tree.MondrianTreeClassifier . Added tree.MondrianTreeRegressor .","title":"tree"},{"location":"releases/0.1.0/","text":"0.1.0 - 2019-05-08 \u00b6 PyPI GitHub base \u00b6 Removed the fit_predict_one estimator method. Removed the fit_predict_proba_one estimator method. Removed the fit_transform_one estimator method. compat \u00b6 Added compat.convert_sklearn_to_river . compat.convert_river_to_sklearn now returns an sklearn.pipeline.Pipeline when provided with a compose.Pipeline . compose \u00b6 Added compose.Discard . Added compose.Select . Added compose.SplitRegressor . The draw method of compose.Pipeline now works properly for arbitrary amounts of nesting, including multiple nested compose.FeatureUnion . datasets \u00b6 Added datasets.fetch_electricity . dummy \u00b6 Added dummy.NoChangeClassifier . Added dummy.PriorClassifier . Added dummy.StatisticRegressor . feature_extraction \u00b6 Added feature_extraction.Differ . Renamed feature_extraction.GroupBy to feature_extraction.Agg . Renamed feature_extraction.TargetGroupBy to feature_extraction.TargetAgg . feature_selection \u00b6 Added feature_selection.SelectKBest . Added feature_selection.VarianceThreshold . impute \u00b6 Added impute.StatImputer . Removed impute.CategoricalImputer . Removed impute.NumericImputer . linear_model \u00b6 Added linear_model.PAClassifier . Added linear_model.PARegressor . Added linear_model.SoftmaxRegression . metrics \u00b6 Added metrics.ConfusionMatrix . Added metrics.CrossEntropy . Added metrics.MacroF1 . Added metrics.MacroPrecision . Added metrics.MacroRecall . Added metrics.MicroF1 . Added metrics.MicroPrecision . Added metrics.MicroRecall . Each metric now has a bigger_is_better property to indicate if a high value is better than a low one or not. optim \u00b6 Added optim.OptimalLR . Added optim.CrossEntropy . Removed optim.PassiveAggressiveI . Removed optim.PassiveAggressiveII . preprocessing \u00b6 Removed preprocessing.Discarder . Added on and sparse parameters to preprocessing.OneHotEncoder . stats \u00b6 Added stats.Covariance . Added stats.PearsonCorrelation . Added stats.SmoothMean . utils \u00b6 Added utils.check_estimator . Added utils.Histogram . Added utils.SortedWindow . Added utils.Window .","title":"0.1.0 - 2019-05-08"},{"location":"releases/0.1.0/#010-2019-05-08","text":"PyPI GitHub","title":"0.1.0 - 2019-05-08"},{"location":"releases/0.1.0/#base","text":"Removed the fit_predict_one estimator method. Removed the fit_predict_proba_one estimator method. Removed the fit_transform_one estimator method.","title":"base"},{"location":"releases/0.1.0/#compat","text":"Added compat.convert_sklearn_to_river . compat.convert_river_to_sklearn now returns an sklearn.pipeline.Pipeline when provided with a compose.Pipeline .","title":"compat"},{"location":"releases/0.1.0/#compose","text":"Added compose.Discard . Added compose.Select . Added compose.SplitRegressor . The draw method of compose.Pipeline now works properly for arbitrary amounts of nesting, including multiple nested compose.FeatureUnion .","title":"compose"},{"location":"releases/0.1.0/#datasets","text":"Added datasets.fetch_electricity .","title":"datasets"},{"location":"releases/0.1.0/#dummy","text":"Added dummy.NoChangeClassifier . Added dummy.PriorClassifier . Added dummy.StatisticRegressor .","title":"dummy"},{"location":"releases/0.1.0/#feature_extraction","text":"Added feature_extraction.Differ . Renamed feature_extraction.GroupBy to feature_extraction.Agg . Renamed feature_extraction.TargetGroupBy to feature_extraction.TargetAgg .","title":"feature_extraction"},{"location":"releases/0.1.0/#feature_selection","text":"Added feature_selection.SelectKBest . Added feature_selection.VarianceThreshold .","title":"feature_selection"},{"location":"releases/0.1.0/#impute","text":"Added impute.StatImputer . Removed impute.CategoricalImputer . Removed impute.NumericImputer .","title":"impute"},{"location":"releases/0.1.0/#linear_model","text":"Added linear_model.PAClassifier . Added linear_model.PARegressor . Added linear_model.SoftmaxRegression .","title":"linear_model"},{"location":"releases/0.1.0/#metrics","text":"Added metrics.ConfusionMatrix . Added metrics.CrossEntropy . Added metrics.MacroF1 . Added metrics.MacroPrecision . Added metrics.MacroRecall . Added metrics.MicroF1 . Added metrics.MicroPrecision . Added metrics.MicroRecall . Each metric now has a bigger_is_better property to indicate if a high value is better than a low one or not.","title":"metrics"},{"location":"releases/0.1.0/#optim","text":"Added optim.OptimalLR . Added optim.CrossEntropy . Removed optim.PassiveAggressiveI . Removed optim.PassiveAggressiveII .","title":"optim"},{"location":"releases/0.1.0/#preprocessing","text":"Removed preprocessing.Discarder . Added on and sparse parameters to preprocessing.OneHotEncoder .","title":"preprocessing"},{"location":"releases/0.1.0/#stats","text":"Added stats.Covariance . Added stats.PearsonCorrelation . Added stats.SmoothMean .","title":"stats"},{"location":"releases/0.1.0/#utils","text":"Added utils.check_estimator . Added utils.Histogram . Added utils.SortedWindow . Added utils.Window .","title":"utils"},{"location":"releases/0.10.0/","text":"0.10.0 - 2022-02-04 \u00b6 base \u00b6 Introduce base.MiniBatchTransformer . Add support for mini-batches to compose.TransformerUnion , compose.Select , and preprocessing.OneHotEncoder . checks \u00b6 Created this module to store estimator unit testing, rather than having it in the utils module. compose \u00b6 Split compose.Renamer into compose.Prefixer and compose.Suffixer that respectively prepend and append a string to the features' name. Changed compose.Renamer to allow feature renaming following a mapping. evaluate \u00b6 Refactored evaluate.progressive_validation to work with base.AnomalyDetector s. facto \u00b6 Added debug_one method to BaseFM . feature_extraction \u00b6 Make the by parameter in feature_extraction.Agg and feature_extraction.TargetAgg to be optional, allowing to calculate aggregates over the whole data. Removed feature_extraction.Lagger and feature_extraction.TargetLagger . Their functionality can be reproduced by combining feature_extraction.Agg and stats.Shift . feature_extraction.Agg and feature_extraction.Target now have a state property. It returns a pandas.Series representing the current aggregates values within each group. metrics \u00b6 metrics.ROCAUC works with base.AnomalyDetectors s. misc \u00b6 Created this module to store some stuff that was in the utils module but wasn't necessarily shared between modules. Implement misc.CovMatrix . reco \u00b6 Renamed the Recommender base class into Ranker . Added a rank method to each recommender. Removed reco.SurpriseWrapper as it wasn't really useful. Added an is_contextual property to each ranker to indicate if a model makes use of contextual features or not. stats \u00b6 stats.Mean , stats.Var , and stats.Cov each now have an update_many method which accepts numpy arrays. utils \u00b6 Removed utils.Window and use collections.deque instead where necessary.","title":"0.10.0 - 2022-02-04"},{"location":"releases/0.10.0/#0100-2022-02-04","text":"","title":"0.10.0 - 2022-02-04"},{"location":"releases/0.10.0/#base","text":"Introduce base.MiniBatchTransformer . Add support for mini-batches to compose.TransformerUnion , compose.Select , and preprocessing.OneHotEncoder .","title":"base"},{"location":"releases/0.10.0/#checks","text":"Created this module to store estimator unit testing, rather than having it in the utils module.","title":"checks"},{"location":"releases/0.10.0/#compose","text":"Split compose.Renamer into compose.Prefixer and compose.Suffixer that respectively prepend and append a string to the features' name. Changed compose.Renamer to allow feature renaming following a mapping.","title":"compose"},{"location":"releases/0.10.0/#evaluate","text":"Refactored evaluate.progressive_validation to work with base.AnomalyDetector s.","title":"evaluate"},{"location":"releases/0.10.0/#facto","text":"Added debug_one method to BaseFM .","title":"facto"},{"location":"releases/0.10.0/#feature_extraction","text":"Make the by parameter in feature_extraction.Agg and feature_extraction.TargetAgg to be optional, allowing to calculate aggregates over the whole data. Removed feature_extraction.Lagger and feature_extraction.TargetLagger . Their functionality can be reproduced by combining feature_extraction.Agg and stats.Shift . feature_extraction.Agg and feature_extraction.Target now have a state property. It returns a pandas.Series representing the current aggregates values within each group.","title":"feature_extraction"},{"location":"releases/0.10.0/#metrics","text":"metrics.ROCAUC works with base.AnomalyDetectors s.","title":"metrics"},{"location":"releases/0.10.0/#misc","text":"Created this module to store some stuff that was in the utils module but wasn't necessarily shared between modules. Implement misc.CovMatrix .","title":"misc"},{"location":"releases/0.10.0/#reco","text":"Renamed the Recommender base class into Ranker . Added a rank method to each recommender. Removed reco.SurpriseWrapper as it wasn't really useful. Added an is_contextual property to each ranker to indicate if a model makes use of contextual features or not.","title":"reco"},{"location":"releases/0.10.0/#stats","text":"stats.Mean , stats.Var , and stats.Cov each now have an update_many method which accepts numpy arrays.","title":"stats"},{"location":"releases/0.10.0/#utils","text":"Removed utils.Window and use collections.deque instead where necessary.","title":"utils"},{"location":"releases/0.10.1/","text":"0.10.1 - 2022-02-05 \u00b6 evaluate \u00b6 evaluate.progressive_val_score can now handle models which use **kwargs in their learn_one and predict_one methods. For instance, this is useful for reco.Ranker models which require passing a user and an item.","title":"0.10.1 - 2022-02-05"},{"location":"releases/0.10.1/#0101-2022-02-05","text":"","title":"0.10.1 - 2022-02-05"},{"location":"releases/0.10.1/#evaluate","text":"evaluate.progressive_val_score can now handle models which use **kwargs in their learn_one and predict_one methods. For instance, this is useful for reco.Ranker models which require passing a user and an item.","title":"evaluate"},{"location":"releases/0.11.0/","text":"0.11.0 - 2022-05-28 \u00b6 Moved all metrics in metrics.cluster except metrics.Silhouette to river-extra . anomaly \u00b6 There is now a anomaly.base.SupervisedAnomalyDetector base class for supervised anomaly detection. Added anomaly.GaussianScorer , which is the first supervised anomaly detector. There is now a anomaly.base.AnomalyFilter base class for anomaly filtering methods. These allow to classify anomaly scores. They can also prevent models from learning on anomalous data, for instance by putting them as an initial step of a pipeline. Added anomaly.ConstantFilter and QuantileFilter , which are the first anomaly filters. Removed anomaly.ConstantThresholder and anomaly.QuantileThresholder , as they overlap with the new anomaly filtering mechanism. base \u00b6 Fixed an issue where the _raw_memory_usage property would spin into an infinite loop if a model's property was an itertools.count . dataset \u00b6 Added the datasets.WaterFlow dataset. dist \u00b6 A revert method has been added to stats.Gaussian . A revert method has been added to stats.Multinomial . Added dist.TimeRolling to measure probability distributions over windows of time. drift \u00b6 Add the PeriodicTrigger detector, a baseline capable of producing drift signals in regular or random intervals. The numpy usage was removed in drift.KSWIN in favor of collections.deque . Appending or deleting elements to numpy arrays imply creating another object. Added the seed parameter to drift.KSWIN to control reproducibility. The Kolmogorov-Smirnov test mode was changed to the default ( \"auto\" ) to suppress warnings ( drift.KSWIN ). Unnecessary usage of numpy was also removed in other concept drift detectors. ensemble \u00b6 Streamline SRP{Classifier,Regressor} , remove unneeded numpy usage, make SRP variants robust against missing features, and fix bugs. Remove unneeded numpy usage AdaptiveRandomForest{Classifier,Regressor} . evaluate \u00b6 Added a iter_progressive_val_score function, which does the same as progressive_val_score , except that it yields rather than prints results at each step, which give more control to the user. imblearn \u00b6 Added imblearn.ChebyshevUnderSampler and imblearn.ChebyshevOverSampler for imbalanced regression. linear_model \u00b6 linear_model.LinearRegression and linear_model.LogisticRegression now correctly apply the l2 regularization when their learn_many method is used. Added l1 regularization (implementation with cumulative penalty, see paper ) for linear_model.LinearRegression and linear_model.LogisticRegression neighbors \u00b6 neighbors.KNNADWINClassifier and neighbors.SAMKNNClassifier have been deprecated. Introduced neighbors.NearestNeighbors for searching nearest neighbors. Vastly refactored and simplified the nearest neighbors logic. proba \u00b6 Added proba.Rolling to measure a probability distribution over a window. rules \u00b6 AMRules's debug_one explicitly indicates the prediction strategy used by each rule. Fix bug in debug_one (AMRules) where prediction explanations were incorrectly displayed when ordered_rule_set=True . time_series \u00b6 Added an iter_evaluate function to trace the evaluation at each sample in a dataset. tree \u00b6 Fix bug in Naive Bayes-based leaf prediction. Remove unneeded numpy usage in HoeffdingAdaptiveTree{Classifier,Regressor} . stats \u00b6 A revert method has been added to stats.Var .","title":"0.11.0 - 2022-05-28"},{"location":"releases/0.11.0/#0110-2022-05-28","text":"Moved all metrics in metrics.cluster except metrics.Silhouette to river-extra .","title":"0.11.0 - 2022-05-28"},{"location":"releases/0.11.0/#anomaly","text":"There is now a anomaly.base.SupervisedAnomalyDetector base class for supervised anomaly detection. Added anomaly.GaussianScorer , which is the first supervised anomaly detector. There is now a anomaly.base.AnomalyFilter base class for anomaly filtering methods. These allow to classify anomaly scores. They can also prevent models from learning on anomalous data, for instance by putting them as an initial step of a pipeline. Added anomaly.ConstantFilter and QuantileFilter , which are the first anomaly filters. Removed anomaly.ConstantThresholder and anomaly.QuantileThresholder , as they overlap with the new anomaly filtering mechanism.","title":"anomaly"},{"location":"releases/0.11.0/#base","text":"Fixed an issue where the _raw_memory_usage property would spin into an infinite loop if a model's property was an itertools.count .","title":"base"},{"location":"releases/0.11.0/#dataset","text":"Added the datasets.WaterFlow dataset.","title":"dataset"},{"location":"releases/0.11.0/#dist","text":"A revert method has been added to stats.Gaussian . A revert method has been added to stats.Multinomial . Added dist.TimeRolling to measure probability distributions over windows of time.","title":"dist"},{"location":"releases/0.11.0/#drift","text":"Add the PeriodicTrigger detector, a baseline capable of producing drift signals in regular or random intervals. The numpy usage was removed in drift.KSWIN in favor of collections.deque . Appending or deleting elements to numpy arrays imply creating another object. Added the seed parameter to drift.KSWIN to control reproducibility. The Kolmogorov-Smirnov test mode was changed to the default ( \"auto\" ) to suppress warnings ( drift.KSWIN ). Unnecessary usage of numpy was also removed in other concept drift detectors.","title":"drift"},{"location":"releases/0.11.0/#ensemble","text":"Streamline SRP{Classifier,Regressor} , remove unneeded numpy usage, make SRP variants robust against missing features, and fix bugs. Remove unneeded numpy usage AdaptiveRandomForest{Classifier,Regressor} .","title":"ensemble"},{"location":"releases/0.11.0/#evaluate","text":"Added a iter_progressive_val_score function, which does the same as progressive_val_score , except that it yields rather than prints results at each step, which give more control to the user.","title":"evaluate"},{"location":"releases/0.11.0/#imblearn","text":"Added imblearn.ChebyshevUnderSampler and imblearn.ChebyshevOverSampler for imbalanced regression.","title":"imblearn"},{"location":"releases/0.11.0/#linear_model","text":"linear_model.LinearRegression and linear_model.LogisticRegression now correctly apply the l2 regularization when their learn_many method is used. Added l1 regularization (implementation with cumulative penalty, see paper ) for linear_model.LinearRegression and linear_model.LogisticRegression","title":"linear_model"},{"location":"releases/0.11.0/#neighbors","text":"neighbors.KNNADWINClassifier and neighbors.SAMKNNClassifier have been deprecated. Introduced neighbors.NearestNeighbors for searching nearest neighbors. Vastly refactored and simplified the nearest neighbors logic.","title":"neighbors"},{"location":"releases/0.11.0/#proba","text":"Added proba.Rolling to measure a probability distribution over a window.","title":"proba"},{"location":"releases/0.11.0/#rules","text":"AMRules's debug_one explicitly indicates the prediction strategy used by each rule. Fix bug in debug_one (AMRules) where prediction explanations were incorrectly displayed when ordered_rule_set=True .","title":"rules"},{"location":"releases/0.11.0/#time_series","text":"Added an iter_evaluate function to trace the evaluation at each sample in a dataset.","title":"time_series"},{"location":"releases/0.11.0/#tree","text":"Fix bug in Naive Bayes-based leaf prediction. Remove unneeded numpy usage in HoeffdingAdaptiveTree{Classifier,Regressor} .","title":"tree"},{"location":"releases/0.11.0/#stats","text":"A revert method has been added to stats.Var .","title":"stats"},{"location":"releases/0.2.0/","text":"0.2.0 - 2019-05-27 \u00b6 PyPI GitHub compose \u00b6 compose.Pipeline now has a debug_one . compose.Discard and compose.Select now take variadic inputs, which means you don't have to provide a list of features to exclude/include. datasets \u00b6 Added datasets.fetch_bikes feature_extraction \u00b6 Classes that inherit from feature_extraction.VectorizerMixin can now directly be passed str instances instead of dict instances. feature_extraction.Agg and feature_extraction.TargetAgg can now aggregate on multiple attributes. metrics \u00b6 Added RollingAccuracy Added RollingCrossEntropy Added RollingF1 Added RollingLogLoss Added RollingMacroF1 Added RollingMacroPrecision Added RollingMacroRecall Added RollingMAE Added RollingMicroF1 Added RollingMicroPrecision Added RollingMicroRecall Added RollingMSE Added RollingPrecision Added RollingRecall Added RollingRMSE Added RollingRMSLE Added RollingSMAPE model_selection \u00b6 Added model_selection.online_qa_score . proba \u00b6 The dist module has been renamed to proba and is now public, for the moment it contains a single distribution called proba.Gaussian . naive_bayes \u00b6 Added naive_bayes.BernoulliNB . Added naive_bayes.ComplementNB . optim \u00b6 Added optim.AdaBound . tree \u00b6 Added tree.DecisionTreeClassifier . Removed tree.MondrianTreeClassifier and tree.MondrianTreeRegressor because their performance wasn't good enough. stats \u00b6 Added stats.AutoCorrelation . Added stats.EWVar . Rename stats.Variance to stats.Var and stats.RollingVariance to stats.RollingVar . stream \u00b6 Added stream.simulate_qa . utils \u00b6 Added utils.SDFT . Added utils.Skyline . Renamed the window_size parameter to size in utils.Window and utils.SortedWindow .","title":"0.2.0 - 2019-05-27"},{"location":"releases/0.2.0/#020-2019-05-27","text":"PyPI GitHub","title":"0.2.0 - 2019-05-27"},{"location":"releases/0.2.0/#compose","text":"compose.Pipeline now has a debug_one . compose.Discard and compose.Select now take variadic inputs, which means you don't have to provide a list of features to exclude/include.","title":"compose"},{"location":"releases/0.2.0/#datasets","text":"Added datasets.fetch_bikes","title":"datasets"},{"location":"releases/0.2.0/#feature_extraction","text":"Classes that inherit from feature_extraction.VectorizerMixin can now directly be passed str instances instead of dict instances. feature_extraction.Agg and feature_extraction.TargetAgg can now aggregate on multiple attributes.","title":"feature_extraction"},{"location":"releases/0.2.0/#metrics","text":"Added RollingAccuracy Added RollingCrossEntropy Added RollingF1 Added RollingLogLoss Added RollingMacroF1 Added RollingMacroPrecision Added RollingMacroRecall Added RollingMAE Added RollingMicroF1 Added RollingMicroPrecision Added RollingMicroRecall Added RollingMSE Added RollingPrecision Added RollingRecall Added RollingRMSE Added RollingRMSLE Added RollingSMAPE","title":"metrics"},{"location":"releases/0.2.0/#model_selection","text":"Added model_selection.online_qa_score .","title":"model_selection"},{"location":"releases/0.2.0/#proba","text":"The dist module has been renamed to proba and is now public, for the moment it contains a single distribution called proba.Gaussian .","title":"proba"},{"location":"releases/0.2.0/#naive_bayes","text":"Added naive_bayes.BernoulliNB . Added naive_bayes.ComplementNB .","title":"naive_bayes"},{"location":"releases/0.2.0/#optim","text":"Added optim.AdaBound .","title":"optim"},{"location":"releases/0.2.0/#tree","text":"Added tree.DecisionTreeClassifier . Removed tree.MondrianTreeClassifier and tree.MondrianTreeRegressor because their performance wasn't good enough.","title":"tree"},{"location":"releases/0.2.0/#stats","text":"Added stats.AutoCorrelation . Added stats.EWVar . Rename stats.Variance to stats.Var and stats.RollingVariance to stats.RollingVar .","title":"stats"},{"location":"releases/0.2.0/#stream","text":"Added stream.simulate_qa .","title":"stream"},{"location":"releases/0.2.0/#utils","text":"Added utils.SDFT . Added utils.Skyline . Renamed the window_size parameter to size in utils.Window and utils.SortedWindow .","title":"utils"},{"location":"releases/0.3.0/","text":"0.3.0 - 2019-06-23 \u00b6 PyPI GitHub datasets \u00b6 Added datasets.load_chick_weights . decomposition \u00b6 Added decomposition.LDA . ensemble \u00b6 Added ensemble.HedgeRegressor . Added ensemble.StackingBinaryClassifier . metrics \u00b6 Added metrics.FBeta Added metrics.MacroFBeta Added metrics.MicroFBeta Added metrics.MultiFBeta Added metrics.RollingFBeta Added metrics.RollingMacroFBeta Added metrics.RollingMicroFBeta Added metrics.RollingMultiFBeta Added metrics.Jaccard Added metrics.RollingConfusionMatrix Added metrics.RegressionMultiOutput Added metrics.MCC Added metrics.RollingMCC Added metrics.ROCAUC Renamed metrics.F1Score to metrics.F1 . multioutput \u00b6 Added multioutput.ClassifierChain . Added multioutput.RegressorChain . optim \u00b6 Added optim.QuantileLoss Added optim.MiniBatcher . preprocessing \u00b6 Added preprocessing.Normalizer . proba \u00b6 Added proba.Multinomial .","title":"0.3.0 - 2019-06-23"},{"location":"releases/0.3.0/#030-2019-06-23","text":"PyPI GitHub","title":"0.3.0 - 2019-06-23"},{"location":"releases/0.3.0/#datasets","text":"Added datasets.load_chick_weights .","title":"datasets"},{"location":"releases/0.3.0/#decomposition","text":"Added decomposition.LDA .","title":"decomposition"},{"location":"releases/0.3.0/#ensemble","text":"Added ensemble.HedgeRegressor . Added ensemble.StackingBinaryClassifier .","title":"ensemble"},{"location":"releases/0.3.0/#metrics","text":"Added metrics.FBeta Added metrics.MacroFBeta Added metrics.MicroFBeta Added metrics.MultiFBeta Added metrics.RollingFBeta Added metrics.RollingMacroFBeta Added metrics.RollingMicroFBeta Added metrics.RollingMultiFBeta Added metrics.Jaccard Added metrics.RollingConfusionMatrix Added metrics.RegressionMultiOutput Added metrics.MCC Added metrics.RollingMCC Added metrics.ROCAUC Renamed metrics.F1Score to metrics.F1 .","title":"metrics"},{"location":"releases/0.3.0/#multioutput","text":"Added multioutput.ClassifierChain . Added multioutput.RegressorChain .","title":"multioutput"},{"location":"releases/0.3.0/#optim","text":"Added optim.QuantileLoss Added optim.MiniBatcher .","title":"optim"},{"location":"releases/0.3.0/#preprocessing","text":"Added preprocessing.Normalizer .","title":"preprocessing"},{"location":"releases/0.3.0/#proba","text":"Added proba.Multinomial .","title":"proba"},{"location":"releases/0.4.1/","text":"0.4.1 - 2019-10-23 \u00b6 PyPI GitHub base \u00b6 Tests are now much more extensive, thanks mostly to the newly added estimator tags. compose \u00b6 Added compose.Renamer . datasets \u00b6 Added fetch_kdd99_http . Added fetch_sms . Added fetch_trec07p . ensemble \u00b6 Removed ensemble.HedgeBinaryClassifier because it's performance was subpar. Removed ensemble.GroupRegressor , as this should be a special case of ensemble.StackingRegressor . feature_extraction \u00b6 Fixed a bug where feature_extraction.CountVectorizer and feature_extraction.TFIDFVectorizer couldn't be pickled. linear_model \u00b6 linear_model.LogisticRegression and linear_model.LinearRegression now have an intercept_lr parameter. metrics \u00b6 Metrics can now be composed using the + operator, which is useful for evaluating multiple metrics at the same time. Added metrics.Rolling , which eliminates the need for a specific rolling implementation for each metric. Each metric can now be passed a sample_weight argument. Added metrics.WeightedF1 . Added metrics.WeightedFBeta . Added metrics.WeightedPrecision . Added metrics.WeightedRecall . neighbors \u00b6 Added neighbors.KNeighborsRegressor . Added neighbors.KNeighborsClassifier . optim \u00b6 Added optim.AdaMax . The optim module has been reorganized into submodules; namely optim.schedulers , optim.initializers , and optim.losses . The top-level now only contains optimizers. Some classes have been renamed accordingly. See the documentation for details. Renamed optim.VanillaSGD to optim.SGD . stats \u00b6 Added stats.IQR . Added stats.RollingIQR . Cythonized stats.Mean and stats.Var . stream \u00b6 Added stream.shuffle . stream.iter_csv now has fraction and seed parameters to sample rows, deterministically or not. Renamed stream.iter_numpy to stream.iter_array . stream.iter_csv can now read from gzipped files. time_series \u00b6 time_series.Detrender now has a window_size parameter for detrending with a rolling mean. tree \u00b6 Added tree.RandomForestClassifier . utils \u00b6 Fixed a bug where utils.dot could take longer than necessary.","title":"0.4.1 - 2019-10-23"},{"location":"releases/0.4.1/#041-2019-10-23","text":"PyPI GitHub","title":"0.4.1 - 2019-10-23"},{"location":"releases/0.4.1/#base","text":"Tests are now much more extensive, thanks mostly to the newly added estimator tags.","title":"base"},{"location":"releases/0.4.1/#compose","text":"Added compose.Renamer .","title":"compose"},{"location":"releases/0.4.1/#datasets","text":"Added fetch_kdd99_http . Added fetch_sms . Added fetch_trec07p .","title":"datasets"},{"location":"releases/0.4.1/#ensemble","text":"Removed ensemble.HedgeBinaryClassifier because it's performance was subpar. Removed ensemble.GroupRegressor , as this should be a special case of ensemble.StackingRegressor .","title":"ensemble"},{"location":"releases/0.4.1/#feature_extraction","text":"Fixed a bug where feature_extraction.CountVectorizer and feature_extraction.TFIDFVectorizer couldn't be pickled.","title":"feature_extraction"},{"location":"releases/0.4.1/#linear_model","text":"linear_model.LogisticRegression and linear_model.LinearRegression now have an intercept_lr parameter.","title":"linear_model"},{"location":"releases/0.4.1/#metrics","text":"Metrics can now be composed using the + operator, which is useful for evaluating multiple metrics at the same time. Added metrics.Rolling , which eliminates the need for a specific rolling implementation for each metric. Each metric can now be passed a sample_weight argument. Added metrics.WeightedF1 . Added metrics.WeightedFBeta . Added metrics.WeightedPrecision . Added metrics.WeightedRecall .","title":"metrics"},{"location":"releases/0.4.1/#neighbors","text":"Added neighbors.KNeighborsRegressor . Added neighbors.KNeighborsClassifier .","title":"neighbors"},{"location":"releases/0.4.1/#optim","text":"Added optim.AdaMax . The optim module has been reorganized into submodules; namely optim.schedulers , optim.initializers , and optim.losses . The top-level now only contains optimizers. Some classes have been renamed accordingly. See the documentation for details. Renamed optim.VanillaSGD to optim.SGD .","title":"optim"},{"location":"releases/0.4.1/#stats","text":"Added stats.IQR . Added stats.RollingIQR . Cythonized stats.Mean and stats.Var .","title":"stats"},{"location":"releases/0.4.1/#stream","text":"Added stream.shuffle . stream.iter_csv now has fraction and seed parameters to sample rows, deterministically or not. Renamed stream.iter_numpy to stream.iter_array . stream.iter_csv can now read from gzipped files.","title":"stream"},{"location":"releases/0.4.1/#time_series","text":"time_series.Detrender now has a window_size parameter for detrending with a rolling mean.","title":"time_series"},{"location":"releases/0.4.1/#tree","text":"Added tree.RandomForestClassifier .","title":"tree"},{"location":"releases/0.4.1/#utils","text":"Fixed a bug where utils.dot could take longer than necessary.","title":"utils"},{"location":"releases/0.4.3/","text":"0.4.3 - 2019-10-27 \u00b6 PyPI GitHub base \u00b6 Model that inherit from base.Wrapper (e.g. tree.RandomForestClassifier ) can now be pickled. datasets \u00b6 Added datasets.fetch_credit_card . utils \u00b6 Added the utils.math sub-module. tree \u00b6 Fixed the debug_one method of tree.DecisionTreeClassifier .","title":"0.4.3 - 2019-10-27"},{"location":"releases/0.4.3/#043-2019-10-27","text":"PyPI GitHub","title":"0.4.3 - 2019-10-27"},{"location":"releases/0.4.3/#base","text":"Model that inherit from base.Wrapper (e.g. tree.RandomForestClassifier ) can now be pickled.","title":"base"},{"location":"releases/0.4.3/#datasets","text":"Added datasets.fetch_credit_card .","title":"datasets"},{"location":"releases/0.4.3/#utils","text":"Added the utils.math sub-module.","title":"utils"},{"location":"releases/0.4.3/#tree","text":"Fixed the debug_one method of tree.DecisionTreeClassifier .","title":"tree"},{"location":"releases/0.4.4/","text":"0.4.4 - 2019-11-11 \u00b6 PyPI GitHub This release was mainly made to provide access to wheels <https://pythonwheels.com/> _ for Windows and MacOS. ensemble \u00b6 Added ensemble.AdaBoostClassifier . linear_model \u00b6 Added a clip_gradient parameter to linear_model.LinearRegression and linear_model.LogisticRegression . Gradient clipping was already implemented, but the maximum absolute value can now be set by the user. The intercept_lr parameter of linear_model.LinearRegression and linear_model.LogisticRegression can now be passed an instance of optim.schedulers.Scheduler as well as a float . metrics \u00b6 Fixed metrics.SMAPE , the implementation was missing a multiplication by 2. optim \u00b6 Added optim.schedulers.Optimal produces results that are identical to sklearn.linear_model.SGDRegressor and sklearn.linear_model.SGDClassifier when setting their learning_rate parameter to 'optimal' . time_series \u00b6 Added time_series.SNARIMAX , a generic model which encompasses well-known time series models such as ARIMA and NARX.","title":"0.4.4 - 2019-11-11"},{"location":"releases/0.4.4/#044-2019-11-11","text":"PyPI GitHub This release was mainly made to provide access to wheels <https://pythonwheels.com/> _ for Windows and MacOS.","title":"0.4.4 - 2019-11-11"},{"location":"releases/0.4.4/#ensemble","text":"Added ensemble.AdaBoostClassifier .","title":"ensemble"},{"location":"releases/0.4.4/#linear_model","text":"Added a clip_gradient parameter to linear_model.LinearRegression and linear_model.LogisticRegression . Gradient clipping was already implemented, but the maximum absolute value can now be set by the user. The intercept_lr parameter of linear_model.LinearRegression and linear_model.LogisticRegression can now be passed an instance of optim.schedulers.Scheduler as well as a float .","title":"linear_model"},{"location":"releases/0.4.4/#metrics","text":"Fixed metrics.SMAPE , the implementation was missing a multiplication by 2.","title":"metrics"},{"location":"releases/0.4.4/#optim","text":"Added optim.schedulers.Optimal produces results that are identical to sklearn.linear_model.SGDRegressor and sklearn.linear_model.SGDClassifier when setting their learning_rate parameter to 'optimal' .","title":"optim"},{"location":"releases/0.4.4/#time_series","text":"Added time_series.SNARIMAX , a generic model which encompasses well-known time series models such as ARIMA and NARX.","title":"time_series"},{"location":"releases/0.5.0/","text":"0.5.0 - 2020-03-13 \u00b6 PyPI GitHub compat \u00b6 Added compat.PyTorch2CremeRegressor . compat.SKL2CremeRegressor and compat.SKL2CremeClassifier now have an optional batch_size parameter in order to perform mini-batching. compose \u00b6 Renamed compose.Whitelister to compose.Select . Renamed compose.Blacklister to compose.Discard . facto \u00b6 Added facto.FFMClassifier . Added facto.FFMRegressor . Added facto.FwFMClassifier . Added facto.FwFMRegressor . Added facto.HOFMClassifier . Added facto.HOFMRegressor . Refactored facto.FMClassifier . Refactored facto.FMRegressor . feature_selection \u00b6 Added feature_selection.PoissonInclusion . Removed feature_selection.RandomDiscarder as it didn't make much sense. feature_extraction \u00b6 Renamed feature_extraction.CountVectorizer to feature_extraction.BagOfWords . Renamed feature_extraction.TFIDFVectorizer to feature_extraction.TFIDF . Added preprocessor and ngram_range parameters to feature_extraction.BagOfWords . Added preprocessor and ngram_range parameters to feature_extraction.TFIDF . datasets \u00b6 The datasets module has been overhauled. Each dataset is now a class (e.g. fetch_electricity has become datasets.Elec2 ). Added datasets.TrumpApproval . Added datasets.MaliciousURL . Added datasets.gen.SEA . Added datasets.Higgs . Added datasets.MovieLens100K . Added datasets.Bananas . Added datasets.Taxis . Added datasets.ImageSegments . Added datasets.SMTP impute \u00b6 Added impute.PreviousImputer . linear_model \u00b6 linear_model.FMClassifier has been moved to the facto module. linear_model.FMRegressor has been moved to the facto module. Added linear_model.ALMAClassifier . metrics \u00b6 Added metrics.ClassificationReport . Added metrics.TimeRolling . The implementation of metrics.ROCAUC was incorrect. Using the trapezoidal rule instead of Simpson's rule seems to be more robust. metrics.PerClass has been removed; it is recommended that you use metrics.ClassificationReport instead as it gives a better overview. meta \u00b6 Moved meta.TransformedTargetRegressor and meta.BoxCoxRegressor to this module (they were previously in the compose module). Added meta.PredClipper model_selection \u00b6 Added model_selection.expand_param_grid to generate a list of models from a grid of parameters. Added the model_selection.successive_halving method for selecting hyperparameters. The online_score and online_qa_score methods have been merged into a single method named model_selection.progressive_val_score . preprocessing \u00b6 Added preprocessing.RBFSampler . Added preprocessing.MaxAbsScaler . Added preprocessing.RobustScaler . Added preprocessing.Binarizer . Added with_mean and with_std parameters to preprocessing.StandardScaler . optim \u00b6 Added optim.losses.BinaryFocalLoss . Added the optim.AMSGrad optimizer. Added the optim.Nadam optimizer. Added optim.losses.Poisson . Fixed a performance bug in optim.NesterovMomentum . reco \u00b6 Added reco.FunkMF . Renamed reco.SVD to reco.BiasedMF . Renamed reco.SGDBaseline to reco.Baseline . Models now expect a dict input with user and item fields. sampling \u00b6 Added sampling.RandomUnderSampler . Added sampling.RandomOverSampler . Added sampling.RandomSampler . Added sampling.HardSamplingClassifier . Added sampling.HardSamplingRegressor . stats \u00b6 Added stats.AbsMax . Added stats.RollingAbsMax . stream \u00b6 Added stream.iter_libsvm . stream.iter_csv now supports reading from '.zip' files. Added stream.Cache . Added a drop parameter to stream.iter_csv to discard fields.","title":"0.5.0 - 2020-03-13"},{"location":"releases/0.5.0/#050-2020-03-13","text":"PyPI GitHub","title":"0.5.0 - 2020-03-13"},{"location":"releases/0.5.0/#compat","text":"Added compat.PyTorch2CremeRegressor . compat.SKL2CremeRegressor and compat.SKL2CremeClassifier now have an optional batch_size parameter in order to perform mini-batching.","title":"compat"},{"location":"releases/0.5.0/#compose","text":"Renamed compose.Whitelister to compose.Select . Renamed compose.Blacklister to compose.Discard .","title":"compose"},{"location":"releases/0.5.0/#facto","text":"Added facto.FFMClassifier . Added facto.FFMRegressor . Added facto.FwFMClassifier . Added facto.FwFMRegressor . Added facto.HOFMClassifier . Added facto.HOFMRegressor . Refactored facto.FMClassifier . Refactored facto.FMRegressor .","title":"facto"},{"location":"releases/0.5.0/#feature_selection","text":"Added feature_selection.PoissonInclusion . Removed feature_selection.RandomDiscarder as it didn't make much sense.","title":"feature_selection"},{"location":"releases/0.5.0/#feature_extraction","text":"Renamed feature_extraction.CountVectorizer to feature_extraction.BagOfWords . Renamed feature_extraction.TFIDFVectorizer to feature_extraction.TFIDF . Added preprocessor and ngram_range parameters to feature_extraction.BagOfWords . Added preprocessor and ngram_range parameters to feature_extraction.TFIDF .","title":"feature_extraction"},{"location":"releases/0.5.0/#datasets","text":"The datasets module has been overhauled. Each dataset is now a class (e.g. fetch_electricity has become datasets.Elec2 ). Added datasets.TrumpApproval . Added datasets.MaliciousURL . Added datasets.gen.SEA . Added datasets.Higgs . Added datasets.MovieLens100K . Added datasets.Bananas . Added datasets.Taxis . Added datasets.ImageSegments . Added datasets.SMTP","title":"datasets"},{"location":"releases/0.5.0/#impute","text":"Added impute.PreviousImputer .","title":"impute"},{"location":"releases/0.5.0/#linear_model","text":"linear_model.FMClassifier has been moved to the facto module. linear_model.FMRegressor has been moved to the facto module. Added linear_model.ALMAClassifier .","title":"linear_model"},{"location":"releases/0.5.0/#metrics","text":"Added metrics.ClassificationReport . Added metrics.TimeRolling . The implementation of metrics.ROCAUC was incorrect. Using the trapezoidal rule instead of Simpson's rule seems to be more robust. metrics.PerClass has been removed; it is recommended that you use metrics.ClassificationReport instead as it gives a better overview.","title":"metrics"},{"location":"releases/0.5.0/#meta","text":"Moved meta.TransformedTargetRegressor and meta.BoxCoxRegressor to this module (they were previously in the compose module). Added meta.PredClipper","title":"meta"},{"location":"releases/0.5.0/#model_selection","text":"Added model_selection.expand_param_grid to generate a list of models from a grid of parameters. Added the model_selection.successive_halving method for selecting hyperparameters. The online_score and online_qa_score methods have been merged into a single method named model_selection.progressive_val_score .","title":"model_selection"},{"location":"releases/0.5.0/#preprocessing","text":"Added preprocessing.RBFSampler . Added preprocessing.MaxAbsScaler . Added preprocessing.RobustScaler . Added preprocessing.Binarizer . Added with_mean and with_std parameters to preprocessing.StandardScaler .","title":"preprocessing"},{"location":"releases/0.5.0/#optim","text":"Added optim.losses.BinaryFocalLoss . Added the optim.AMSGrad optimizer. Added the optim.Nadam optimizer. Added optim.losses.Poisson . Fixed a performance bug in optim.NesterovMomentum .","title":"optim"},{"location":"releases/0.5.0/#reco","text":"Added reco.FunkMF . Renamed reco.SVD to reco.BiasedMF . Renamed reco.SGDBaseline to reco.Baseline . Models now expect a dict input with user and item fields.","title":"reco"},{"location":"releases/0.5.0/#sampling","text":"Added sampling.RandomUnderSampler . Added sampling.RandomOverSampler . Added sampling.RandomSampler . Added sampling.HardSamplingClassifier . Added sampling.HardSamplingRegressor .","title":"sampling"},{"location":"releases/0.5.0/#stats","text":"Added stats.AbsMax . Added stats.RollingAbsMax .","title":"stats"},{"location":"releases/0.5.0/#stream","text":"Added stream.iter_libsvm . stream.iter_csv now supports reading from '.zip' files. Added stream.Cache . Added a drop parameter to stream.iter_csv to discard fields.","title":"stream"},{"location":"releases/0.5.1/","text":"0.5.1 - 2020-03-29 \u00b6 PyPI GitHub compose \u00b6 compose.Pipeline and compose.TransformerUnion now variadic arguments as input instead of a list. This doesn't change anything when using the shorthand operators | and + . model_selection \u00b6 Removed model_selection.successive_halving Added model_selection.SuccessiveHalvingRegressor and model_selection.SuccessiveHalvingClassifier stream \u00b6 Added a copy parameter to stream.simulate_qa in order to handle unwanted feature modifications. tree \u00b6 Added a curtail_under parameter to tree.DecisionTreeClassifier . The speed and accuracy of both tree.DecisionTreeClassifier and tree.RandomForestClassifier has been slightly improved for numerical attributes. The esthetics of the tree.DecisionTreeClassifier.draw method have been improved.","title":"0.5.1 - 2020-03-29"},{"location":"releases/0.5.1/#051-2020-03-29","text":"PyPI GitHub","title":"0.5.1 - 2020-03-29"},{"location":"releases/0.5.1/#compose","text":"compose.Pipeline and compose.TransformerUnion now variadic arguments as input instead of a list. This doesn't change anything when using the shorthand operators | and + .","title":"compose"},{"location":"releases/0.5.1/#model_selection","text":"Removed model_selection.successive_halving Added model_selection.SuccessiveHalvingRegressor and model_selection.SuccessiveHalvingClassifier","title":"model_selection"},{"location":"releases/0.5.1/#stream","text":"Added a copy parameter to stream.simulate_qa in order to handle unwanted feature modifications.","title":"stream"},{"location":"releases/0.5.1/#tree","text":"Added a curtail_under parameter to tree.DecisionTreeClassifier . The speed and accuracy of both tree.DecisionTreeClassifier and tree.RandomForestClassifier has been slightly improved for numerical attributes. The esthetics of the tree.DecisionTreeClassifier.draw method have been improved.","title":"tree"},{"location":"releases/0.6.0/","text":"0.6.0 - 2020-06-09 \u00b6 base \u00b6 Added a new base class called SupervisedTransformer from which supervised transformers inherit from. Before this, supervised transformers has a is_supervised property. compose \u00b6 Added compose.SelectType , which allows selecting feature subsets based on their type. Added a score_one method to compose.Pipeline so that estimators from the anomaly module can be pipelined. Added compose.Grouper , which allows applying transformers within different subgroups. datasets \u00b6 Added datasets.Music , which is a dataset for multi-output binary classification. Added datasets.synth.Friedman , which is synthetic regression dataset. The datasets.gen module has been renamed to datasets.synth Each dataset now has a __repr__ method which displays some descriptive information. Added datasets.Insects , which has 10 variants. feature_extraction \u00b6 feature_extraction.Differ has been deprecated. We might put it back in a future if we find a better design. impute \u00b6 impute.StatImputer has been completely refactored. metrics \u00b6 In metrics.SMAPE , instead of raising a ZeroDivisionError , the convention is now to use 0 when both y_true and y_pred are equal to 0. model_selection \u00b6 Added the possibility to configure how the progress is printed in model_selection.progressive_val_score . For instance, the progress can now be printed to a file by providing the file argument. multiclass \u00b6 Added multiclass.OutputCodeClassifier . Added multiclass.OneVsOneClassifier . multioutput \u00b6 Fixed a bug where multioutput.ClassifierChain and multioutput.RegressorChain could not be pickled. stats \u00b6 Added stats.Shift , which can be used to compute statistics over a shifted version of a variable. Added stats.Link , which can be used to compose univariate statistics. Univariate statistics can now be composed via the | operator. Renamed stats.Covariance to stats.Cov . Renamed stats.PearsonCorrelation to stats.PearsonCorr . Renamed stats.AutoCorrelation to stats.AutoCorr . Added stats.RollingCov , which computes covariance between two variables over a window. Added stats.RollingPearsonCorr , which computes the Pearson correlation over a window. stream \u00b6 Added a stream.iter_sql utility method to work with SQLAlchemy. The target_name parameter of stream.iter_csv has been renamed to target . It can now be passed a list of values in order to support multi-output scenarios. Added stream.iter_arff for handling ARFF files. tree \u00b6 Cancelled the behavior where tree.DecisionTreeRegressor would raise an exception when no split was found.","title":"0.6.0 - 2020-06-09"},{"location":"releases/0.6.0/#060-2020-06-09","text":"","title":"0.6.0 - 2020-06-09"},{"location":"releases/0.6.0/#base","text":"Added a new base class called SupervisedTransformer from which supervised transformers inherit from. Before this, supervised transformers has a is_supervised property.","title":"base"},{"location":"releases/0.6.0/#compose","text":"Added compose.SelectType , which allows selecting feature subsets based on their type. Added a score_one method to compose.Pipeline so that estimators from the anomaly module can be pipelined. Added compose.Grouper , which allows applying transformers within different subgroups.","title":"compose"},{"location":"releases/0.6.0/#datasets","text":"Added datasets.Music , which is a dataset for multi-output binary classification. Added datasets.synth.Friedman , which is synthetic regression dataset. The datasets.gen module has been renamed to datasets.synth Each dataset now has a __repr__ method which displays some descriptive information. Added datasets.Insects , which has 10 variants.","title":"datasets"},{"location":"releases/0.6.0/#feature_extraction","text":"feature_extraction.Differ has been deprecated. We might put it back in a future if we find a better design.","title":"feature_extraction"},{"location":"releases/0.6.0/#impute","text":"impute.StatImputer has been completely refactored.","title":"impute"},{"location":"releases/0.6.0/#metrics","text":"In metrics.SMAPE , instead of raising a ZeroDivisionError , the convention is now to use 0 when both y_true and y_pred are equal to 0.","title":"metrics"},{"location":"releases/0.6.0/#model_selection","text":"Added the possibility to configure how the progress is printed in model_selection.progressive_val_score . For instance, the progress can now be printed to a file by providing the file argument.","title":"model_selection"},{"location":"releases/0.6.0/#multiclass","text":"Added multiclass.OutputCodeClassifier . Added multiclass.OneVsOneClassifier .","title":"multiclass"},{"location":"releases/0.6.0/#multioutput","text":"Fixed a bug where multioutput.ClassifierChain and multioutput.RegressorChain could not be pickled.","title":"multioutput"},{"location":"releases/0.6.0/#stats","text":"Added stats.Shift , which can be used to compute statistics over a shifted version of a variable. Added stats.Link , which can be used to compose univariate statistics. Univariate statistics can now be composed via the | operator. Renamed stats.Covariance to stats.Cov . Renamed stats.PearsonCorrelation to stats.PearsonCorr . Renamed stats.AutoCorrelation to stats.AutoCorr . Added stats.RollingCov , which computes covariance between two variables over a window. Added stats.RollingPearsonCorr , which computes the Pearson correlation over a window.","title":"stats"},{"location":"releases/0.6.0/#stream","text":"Added a stream.iter_sql utility method to work with SQLAlchemy. The target_name parameter of stream.iter_csv has been renamed to target . It can now be passed a list of values in order to support multi-output scenarios. Added stream.iter_arff for handling ARFF files.","title":"stream"},{"location":"releases/0.6.0/#tree","text":"Cancelled the behavior where tree.DecisionTreeRegressor would raise an exception when no split was found.","title":"tree"},{"location":"releases/0.6.1/","text":"0.6.1 - 2020-06-10 \u00b6 compose \u00b6 Fixed a bug that occurred when part of a compose.Transformer was a compose.Pipeline and wasn't properly handled.","title":"0.6.1 - 2020-06-10"},{"location":"releases/0.6.1/#061-2020-06-10","text":"","title":"0.6.1 - 2020-06-10"},{"location":"releases/0.6.1/#compose","text":"Fixed a bug that occurred when part of a compose.Transformer was a compose.Pipeline and wasn't properly handled.","title":"compose"},{"location":"releases/0.7.0/","text":"0.7.0 - 2021-04-16 \u00b6 Alas, no release notes for this one.","title":"0.7.0 - 2021-04-16"},{"location":"releases/0.7.0/#070-2021-04-16","text":"Alas, no release notes for this one.","title":"0.7.0 - 2021-04-16"},{"location":"releases/0.7.1/","text":"0.7.1 - 2021-06-13 \u00b6 Fixed an issue where scikit-learn was imported in sam_knn.py but wasn't specified as a dependency. stream \u00b6 Added drop_nones parameter to stream.iter_csv .","title":"0.7.1 - 2021-06-13"},{"location":"releases/0.7.1/#071-2021-06-13","text":"Fixed an issue where scikit-learn was imported in sam_knn.py but wasn't specified as a dependency.","title":"0.7.1 - 2021-06-13"},{"location":"releases/0.7.1/#stream","text":"Added drop_nones parameter to stream.iter_csv .","title":"stream"},{"location":"releases/0.7.2/","text":"0.7.2 \u00b6 expert \u00b6 Each expert model will now raise a NotEnoughModels exception if only a single model is passed.","title":"0.7.2"},{"location":"releases/0.7.2/#072","text":"","title":"0.7.2"},{"location":"releases/0.7.2/#expert","text":"Each expert model will now raise a NotEnoughModels exception if only a single model is passed.","title":"expert"},{"location":"releases/0.8.0/","text":"0.8.0 - 2021-08-31 \u00b6 base \u00b6 The predict_many and predict_proba_many methods have been removed from base.Classifier . They're part of base.MiniBatchClassifier . ensemble \u00b6 Implemented ensemble.VotingClassifier . Implemented ensemble.SRPRegressor . meta \u00b6 Renamed meta.TransformedTargetRegressor to meta.TargetTransformRegressor . Added meta.TargetStandardScaler . preprocessing \u00b6 Added a with_std parameter to StandardScaler . rules \u00b6 Added rules.AMRules stats \u00b6 Make stats.RollingQuantile match the default behavior of Numpy's quantile function. tree \u00b6 Unifed base class structure applied to all tree models. Bug fixes. Added tree.SGTClassifier and tree.SGTRegressor .","title":"0.8.0 - 2021-08-31"},{"location":"releases/0.8.0/#080-2021-08-31","text":"","title":"0.8.0 - 2021-08-31"},{"location":"releases/0.8.0/#base","text":"The predict_many and predict_proba_many methods have been removed from base.Classifier . They're part of base.MiniBatchClassifier .","title":"base"},{"location":"releases/0.8.0/#ensemble","text":"Implemented ensemble.VotingClassifier . Implemented ensemble.SRPRegressor .","title":"ensemble"},{"location":"releases/0.8.0/#meta","text":"Renamed meta.TransformedTargetRegressor to meta.TargetTransformRegressor . Added meta.TargetStandardScaler .","title":"meta"},{"location":"releases/0.8.0/#preprocessing","text":"Added a with_std parameter to StandardScaler .","title":"preprocessing"},{"location":"releases/0.8.0/#rules","text":"Added rules.AMRules","title":"rules"},{"location":"releases/0.8.0/#stats","text":"Make stats.RollingQuantile match the default behavior of Numpy's quantile function.","title":"stats"},{"location":"releases/0.8.0/#tree","text":"Unifed base class structure applied to all tree models. Bug fixes. Added tree.SGTClassifier and tree.SGTRegressor .","title":"tree"},{"location":"releases/0.9.0/","text":"0.9.0 - 2021-11-30 \u00b6 Wheels for Python 3.6 have been dropped. Wheels for Python 3.9 have been added. anomaly \u00b6 Moved base.AnomalyDetector to anomaly.AnomalyDetector . Implemented anomaly.ConstantThresholder . Implemented anomaly.QuantileThresholder . Implemented anomaly.OneClassSVM . base \u00b6 Renamed base.WrapperMixin to base.Wrapper . Introduced base.WrapperEnsemble . Clarified the difference between a base.typing.Dataset and a base.typing.Stream . A Stream is an instance of a Dataset and is stateful. A Dataset is stateless. It's essentially the same difference between an Iterable and an Iterator in the Python standard library. compat \u00b6 Added compat.PyTorch2RiverClassifier Implemented median absolute deviation in stats.MAD . Refactored compat.PyTorch2RiverRegressor Fixed an issue where some statistics could not be printed if they had not seen any data yet. compose \u00b6 You can now use a list as a shorthand to build a TransformerUnion . Fixed a visualization issue when using a pipeline with multiple feature unions. The prejudiced terms blacklist and whitelist have both been renamed to keys . Removed learn_unsupervised parameter from pipeline methods. Implemented compose.TransformerProduct . datasets \u00b6 Added datasets.Keystroke . ensemble \u00b6 Bug fixes in ensemble.SRPClassifier and ensemble.SRPRegressor . Some estimators have been moved into the ensemble module. feature_extraction \u00b6 Implemented feature_extraction.Lagger . Implemented feature_extraction.TargetLagger . meta \u00b6 This module has been deleted. Move meta.PredClipper to the preprocessing module. Removed meta.BoxCoxRegressor . Moved meta.TargetTransformRegressor to compose.TargetTransformRegressor . Moved meta.TargetStandardScaler to preprocessing.TargetStandardScaler . model_selection \u00b6 This new module replaces the expert module. Implemented model_selection.GreedyRegressor . Added ModelSelector base class. optim \u00b6 optim.Adam and optim.RMSProp now work with utils.VectorDict s as well as numpy.ndarray s. Added optim.losses.Huber . preprocessing \u00b6 Enabled preprocessing.OneHotEncoder to one-hot encode values that are list or sets. reco \u00b6 Added a debug_one method to reco.FMRegressor . selection \u00b6 This new module replaces the expert module. Implemented selection.GreedyExpertRegressor . stats \u00b6 Fixed an issue where some statistics could not be printed if they had not seen any data yet. Implemented median absolute deviation in stats.MAD . The stats.Mean and stats.Var implementations have been made more numerically stable. time_series \u00b6 time_series.Detrender and time_series.GroupDetrender have been removed as they overlap with preprocessing.TargetStandardScaler . Implemented a time_series.evaluate method, which performs progressive validation for time series scenarios. Implemented time_series.HorizonMetric class to evaluate the performance of a forecasting model at each time step along a horizon. Implemented time_series.HoltWinters . utils \u00b6 Moved model_selection.expand_param_grid to utils.expand_param_grid . Added utils.poisson . Added the utils.log_method_calls context manager. Added the utils.warm_up_mode context manager. Added the utils.pure_inference_model context manager.","title":"0.9.0 - 2021-11-30"},{"location":"releases/0.9.0/#090-2021-11-30","text":"Wheels for Python 3.6 have been dropped. Wheels for Python 3.9 have been added.","title":"0.9.0 - 2021-11-30"},{"location":"releases/0.9.0/#anomaly","text":"Moved base.AnomalyDetector to anomaly.AnomalyDetector . Implemented anomaly.ConstantThresholder . Implemented anomaly.QuantileThresholder . Implemented anomaly.OneClassSVM .","title":"anomaly"},{"location":"releases/0.9.0/#base","text":"Renamed base.WrapperMixin to base.Wrapper . Introduced base.WrapperEnsemble . Clarified the difference between a base.typing.Dataset and a base.typing.Stream . A Stream is an instance of a Dataset and is stateful. A Dataset is stateless. It's essentially the same difference between an Iterable and an Iterator in the Python standard library.","title":"base"},{"location":"releases/0.9.0/#compat","text":"Added compat.PyTorch2RiverClassifier Implemented median absolute deviation in stats.MAD . Refactored compat.PyTorch2RiverRegressor Fixed an issue where some statistics could not be printed if they had not seen any data yet.","title":"compat"},{"location":"releases/0.9.0/#compose","text":"You can now use a list as a shorthand to build a TransformerUnion . Fixed a visualization issue when using a pipeline with multiple feature unions. The prejudiced terms blacklist and whitelist have both been renamed to keys . Removed learn_unsupervised parameter from pipeline methods. Implemented compose.TransformerProduct .","title":"compose"},{"location":"releases/0.9.0/#datasets","text":"Added datasets.Keystroke .","title":"datasets"},{"location":"releases/0.9.0/#ensemble","text":"Bug fixes in ensemble.SRPClassifier and ensemble.SRPRegressor . Some estimators have been moved into the ensemble module.","title":"ensemble"},{"location":"releases/0.9.0/#feature_extraction","text":"Implemented feature_extraction.Lagger . Implemented feature_extraction.TargetLagger .","title":"feature_extraction"},{"location":"releases/0.9.0/#meta","text":"This module has been deleted. Move meta.PredClipper to the preprocessing module. Removed meta.BoxCoxRegressor . Moved meta.TargetTransformRegressor to compose.TargetTransformRegressor . Moved meta.TargetStandardScaler to preprocessing.TargetStandardScaler .","title":"meta"},{"location":"releases/0.9.0/#model_selection","text":"This new module replaces the expert module. Implemented model_selection.GreedyRegressor . Added ModelSelector base class.","title":"model_selection"},{"location":"releases/0.9.0/#optim","text":"optim.Adam and optim.RMSProp now work with utils.VectorDict s as well as numpy.ndarray s. Added optim.losses.Huber .","title":"optim"},{"location":"releases/0.9.0/#preprocessing","text":"Enabled preprocessing.OneHotEncoder to one-hot encode values that are list or sets.","title":"preprocessing"},{"location":"releases/0.9.0/#reco","text":"Added a debug_one method to reco.FMRegressor .","title":"reco"},{"location":"releases/0.9.0/#selection","text":"This new module replaces the expert module. Implemented selection.GreedyExpertRegressor .","title":"selection"},{"location":"releases/0.9.0/#stats","text":"Fixed an issue where some statistics could not be printed if they had not seen any data yet. Implemented median absolute deviation in stats.MAD . The stats.Mean and stats.Var implementations have been made more numerically stable.","title":"stats"},{"location":"releases/0.9.0/#time_series","text":"time_series.Detrender and time_series.GroupDetrender have been removed as they overlap with preprocessing.TargetStandardScaler . Implemented a time_series.evaluate method, which performs progressive validation for time series scenarios. Implemented time_series.HorizonMetric class to evaluate the performance of a forecasting model at each time step along a horizon. Implemented time_series.HoltWinters .","title":"time_series"},{"location":"releases/0.9.0/#utils","text":"Moved model_selection.expand_param_grid to utils.expand_param_grid . Added utils.poisson . Added the utils.log_method_calls context manager. Added the utils.warm_up_mode context manager. Added the utils.pure_inference_model context manager.","title":"utils"}]}