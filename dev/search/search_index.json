{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/overview/","title":"Overview","text":""},{"location":"api/overview/#active","title":"active","text":"<p>Online active learning.</p> <ul> <li>EntropySampler</li> </ul>"},{"location":"api/overview/#base","title":"base","text":"<ul> <li>ActiveLearningClassifier</li> </ul>"},{"location":"api/overview/#anomaly","title":"anomaly","text":"<p>Anomaly detection.</p> <p>Estimators in the <code>anomaly</code> module have a bespoke API. Each anomaly detector has a <code>score_one</code> method instead of a <code>predict_one</code> method. This method returns an anomaly score. Normal observations should have a low score, whereas anomalous observations should have a high score. The range of the scores is relative to each estimator.</p> <p>Anomaly detectors are usually unsupervised, in that they analyze the distribution of the features they are shown. But River also has a notion of supervised anomaly detectors. These analyze the distribution of a target variable, and optionally include the distribution of the features as well. They are useful for detecting labelling anomalies, which can be detrimental if they learned by a model.</p> <ul> <li>GaussianScorer</li> <li>HalfSpaceTrees</li> <li>LocalOutlierFactor</li> <li>OneClassSVM</li> <li>PredictiveAnomalyDetection</li> <li>QuantileFilter</li> <li>StandardAbsoluteDeviation</li> <li>ThresholdFilter</li> </ul>"},{"location":"api/overview/#base_1","title":"base","text":"<ul> <li>AnomalyDetector</li> <li>AnomalyFilter</li> <li>SupervisedAnomalyDetector</li> </ul>"},{"location":"api/overview/#bandit","title":"bandit","text":"<p>Multi-armed bandit (MAB) policies.</p> <p>The bandit policies in River have a generic API. This allows them to be used in a variety of situations. For instance, they can be used for model selection (see <code>model_selection.BanditRegressor</code>).</p> <p>Classes</p> <ul> <li>BayesUCB</li> <li>EpsilonGreedy</li> <li>Exp3</li> <li>LinUCBDisjoint</li> <li>RandomPolicy</li> <li>ThompsonSampling</li> <li>UCB</li> </ul> <p>Functions</p> <ul> <li>evaluate</li> <li>evaluate_offline</li> </ul>"},{"location":"api/overview/#base_2","title":"base","text":"<ul> <li>ContextualPolicy</li> <li>Policy</li> </ul>"},{"location":"api/overview/#datasets","title":"datasets","text":"<ul> <li>BanditDataset</li> <li>NewsArticles</li> </ul>"},{"location":"api/overview/#envs","title":"envs","text":"<ul> <li>CandyCaneContest</li> <li>KArmedTestbed</li> </ul>"},{"location":"api/overview/#base_3","title":"base","text":"<p>Base interfaces.</p> <p>Every estimator in River is a class, and as such inherits from at least one base interface. These are used to categorize, organize, and standardize the many estimators that River contains.</p> <p>This module contains mixin classes, which are all suffixed by <code>Mixin</code>. Their purpose is to provide additional functionality to an estimator, and thus need to be used in conjunction with a non-mixin base class.</p> <p>This module also contains utilities for type hinting and tagging estimators.</p> <ul> <li>Base</li> <li>BaseTransformer</li> <li>BinaryDriftAndWarningDetector</li> <li>BinaryDriftDetector</li> <li>Classifier</li> <li>Clusterer</li> <li>DriftAndWarningDetector</li> <li>DriftDetector</li> <li>Ensemble</li> <li>Estimator</li> <li>MiniBatchClassifier</li> <li>MiniBatchRegressor</li> <li>MiniBatchSupervisedTransformer</li> <li>MiniBatchTransformer</li> <li>MultiLabelClassifier</li> <li>MultiTargetRegressor</li> <li>Regressor</li> <li>SupervisedTransformer</li> <li>Transformer</li> <li>Wrapper</li> <li>WrapperEnsemble</li> </ul>"},{"location":"api/overview/#cluster","title":"cluster","text":"<p>Unsupervised clustering.</p> <ul> <li>CluStream</li> <li>DBSTREAM</li> <li>DenStream</li> <li>KMeans</li> <li>ODAC</li> <li>STREAMKMeans</li> <li>TextClust</li> </ul>"},{"location":"api/overview/#compat","title":"compat","text":"<p>Compatibility tools.</p> <p>This module contains adapters for making River estimators compatible with other libraries, and vice-versa whenever possible. The relevant adapters will only be usable if you have installed the necessary library. For instance, you have to install scikit-learn in order to use the <code>compat.convert_sklearn_to_river</code> function.</p> <p>Classes</p> <ul> <li>River2SKLClassifier</li> <li>River2SKLClusterer</li> <li>River2SKLRegressor</li> <li>River2SKLTransformer</li> <li>SKL2RiverClassifier</li> <li>SKL2RiverRegressor</li> </ul> <p>Functions</p> <ul> <li>convert_river_to_sklearn</li> <li>convert_sklearn_to_river</li> </ul>"},{"location":"api/overview/#compose","title":"compose","text":"<p>Model composition.</p> <p>This module contains utilities for merging multiple modeling steps into a single pipeline. Although pipelines are not the only way to process a stream of data, we highly encourage you to use them.</p> <p>Classes</p> <ul> <li>Discard</li> <li>FuncTransformer</li> <li>Grouper</li> <li>Pipeline</li> <li>Prefixer</li> <li>Renamer</li> <li>Select</li> <li>SelectType</li> <li>Suffixer</li> <li>TargetTransformRegressor</li> <li>TransformerProduct</li> <li>TransformerUnion</li> </ul> <p>Functions</p> <ul> <li>learn_during_predict</li> </ul>"},{"location":"api/overview/#conf","title":"conf","text":"<p>Conformal predictions. This modules contains wrappers to enable conformal predictions on any regressor or classifier.</p> <ul> <li>Interval</li> <li>RegressionJackknife</li> </ul>"},{"location":"api/overview/#covariance","title":"covariance","text":"<p>Online estimation of covariance and precision matrices.</p> <ul> <li>EmpiricalCovariance</li> <li>EmpiricalPrecision</li> </ul>"},{"location":"api/overview/#datasets_1","title":"datasets","text":"<p>Datasets.</p> <p>This module contains a collection of datasets for multiple tasks: classification, regression, etc. The data corresponds to popular datasets and are conveniently wrapped to easily iterate over the data in a stream fashion. All datasets have fixed size. Please refer to <code>river.synth</code> if you are interested in infinite synthetic data generators.</p> <p>Regression</p> Name Samples Features AirlinePassengers 144 1 Bikes 182,470 8 ChickWeights 578 3 MovieLens100K 100,000 10 Restaurants 252,108 7 Taxis 1,458,644 8 TrumpApproval 1,001 6 WaterFlow 1,268 1 <p>Binary classification</p> Name Samples Features Sparse Bananas 5,300 2 CreditCard 284,807 30 Elec2 45,312 8 Higgs 11,000,000 28 HTTP 567,498 3 MaliciousURL 2,396,130 3,231,961 \u2714\ufe0f Phishing 1,250 9 SMSSpam 5,574 1 SMTP 95,156 3 TREC07 75,419 5 <p>Multi-class classification</p> Name Samples Features Classes ImageSegments 2,310 18 7 Insects 52,848 33 6 Keystroke 20,400 31 51 <p>Multi-output binary classification</p> Name Samples Features Outputs Music 593 72 6 <p>Multi-output regression</p> Name Samples Features Outputs SolarFlare 1,066 10 3 WebTraffic 44,160 3 2"},{"location":"api/overview/#base_4","title":"base","text":"<ul> <li>Dataset</li> <li>FileDataset</li> <li>RemoteDataset</li> <li>SyntheticDataset</li> </ul>"},{"location":"api/overview/#synth","title":"synth","text":"<p>Synthetic datasets.</p> <p>Each synthetic dataset is a stream generator. The benefit of using a generator is that they do not store the data and each data sample is generated on the fly. Except for a couple of methods, the majority of these methods are infinite data generators.</p> <p>Binary classification</p> Name Features Agrawal 9 AnomalySine 2 ConceptDriftStream 9 Hyperplane 10 Mixed 4 SEA 3 Sine 2 STAGGER 3 <p>Regression</p> Name Features Friedman 10 FriedmanDrift 10 Mv 10 Planes2D 10 <p>Multi-class classification</p> Name Features Classes LED 7 10 LEDDrift 7 10 RandomRBF 10 2 RandomRBFDrift 10 2 RandomTree 10 2 Waveform 21 3 <p>Multi-output binary classification</p> Name Features Outputs Logical 2 3"},{"location":"api/overview/#drift","title":"drift","text":"<p>Concept Drift Detection.</p> <p>This module contains concept drift detection methods. The purpose of a drift detector is to raise an alarm if the data distribution changes. A good drift detector method is the one that maximizes the true positives while keeping the number of false positives to a minimum.</p> <ul> <li>ADWIN</li> <li>DriftRetrainingClassifier</li> <li>DummyDriftDetector</li> <li>KSWIN</li> <li>NoDrift</li> <li>PageHinkley</li> </ul>"},{"location":"api/overview/#binary","title":"binary","text":"<p>Drift detection for binary data.</p> <ul> <li>DDM</li> <li>EDDM</li> <li>FHDDM</li> <li>HDDM_A</li> <li>HDDM_W</li> </ul>"},{"location":"api/overview/#datasets_2","title":"datasets","text":"<ul> <li>AirlinePassengers</li> <li>Apple</li> <li>Bitcoin</li> <li>BrentSpotPrice</li> <li>Occupancy</li> <li>RunLog</li> <li>UKCoalEmploy</li> </ul>"},{"location":"api/overview/#dummy","title":"dummy","text":"<p>Dummy estimators.</p> <p>This module is here for testing purposes, as well as providing baseline performances.</p> <ul> <li>NoChangeClassifier</li> <li>PriorClassifier</li> <li>StatisticRegressor</li> </ul>"},{"location":"api/overview/#ensemble","title":"ensemble","text":"<p>Ensemble learning.</p> <p>Broadly speaking, there are two kinds of ensemble approaches. There are those that copy a single model several times and aggregate the predictions of said copies. This includes bagging as well as boosting. Then there are those that are composed of an arbitrary list of models, and can therefore aggregate predictions from different kinds of models.</p> <ul> <li>ADWINBaggingClassifier</li> <li>ADWINBoostingClassifier</li> <li>AdaBoostClassifier</li> <li>BOLEClassifier</li> <li>BaggingClassifier</li> <li>BaggingRegressor</li> <li>EWARegressor</li> <li>LeveragingBaggingClassifier</li> <li>SRPClassifier</li> <li>SRPRegressor</li> <li>StackingClassifier</li> <li>VotingClassifier</li> </ul>"},{"location":"api/overview/#evaluate","title":"evaluate","text":"<p>Model evaluation.</p> <p>This module provides utilities to evaluate an online model. The goal is to reproduce a real-world scenario with high fidelity. The core function of this module is <code>progressive_val_score</code>, which allows to evaluate a model via progressive validation.</p> <p>This module also exposes \"tracks\". A track is a predefined combination of a dataset and one or more metrics. This allows a principled manner to compare models with each other. For instance, the <code>RegressionTrack</code> contains several datasets and metrics to evaluate regression models. There is also a bare <code>Track</code> class to implement a custom track. The <code>benchmarks</code> directory at the root of the River repository uses these tracks.</p> <p>Classes</p> <ul> <li>BinaryClassificationTrack</li> <li>MultiClassClassificationTrack</li> <li>RegressionTrack</li> <li>Track</li> </ul> <p>Functions</p> <ul> <li>iter_progressive_val_score</li> <li>progressive_val_score</li> </ul>"},{"location":"api/overview/#facto","title":"facto","text":"<p>Factorization machines.</p> <ul> <li>FFMClassifier</li> <li>FFMRegressor</li> <li>FMClassifier</li> <li>FMRegressor</li> <li>FwFMClassifier</li> <li>FwFMRegressor</li> <li>HOFMClassifier</li> <li>HOFMRegressor</li> </ul>"},{"location":"api/overview/#feature_extraction","title":"feature_extraction","text":"<p>Feature extraction.</p> <p>This module can be used to extract information from raw features. This includes encoding categorical data as well as looking at interactions between existing features. This differs from the <code>preprocessing</code> module, in that the latter's purpose is rather to clean the data so that it may be processed by a particular machine learning algorithm.</p> <ul> <li>Agg</li> <li>BagOfWords</li> <li>PolynomialExtender</li> <li>RBFSampler</li> <li>TFIDF</li> <li>TargetAgg</li> </ul>"},{"location":"api/overview/#feature_selection","title":"feature_selection","text":"<p>Feature selection.</p> <ul> <li>PoissonInclusion</li> <li>SelectKBest</li> <li>VarianceThreshold</li> </ul>"},{"location":"api/overview/#forest","title":"forest","text":"<p>This module implements forest-based classifiers and regressors.</p> <ul> <li>AMFClassifier</li> <li>AMFRegressor</li> <li>ARFClassifier</li> <li>ARFRegressor</li> <li>OXTRegressor</li> </ul>"},{"location":"api/overview/#imblearn","title":"imblearn","text":"<p>Sampling methods.</p> <ul> <li>ChebyshevOverSampler</li> <li>ChebyshevUnderSampler</li> <li>HardSamplingClassifier</li> <li>HardSamplingRegressor</li> <li>RandomOverSampler</li> <li>RandomSampler</li> <li>RandomUnderSampler</li> </ul>"},{"location":"api/overview/#linear_model","title":"linear_model","text":"<p>Linear models.</p> <ul> <li>ALMAClassifier</li> <li>BayesianLinearRegression</li> <li>LinearRegression</li> <li>LogisticRegression</li> <li>PAClassifier</li> <li>PARegressor</li> <li>Perceptron</li> <li>SoftmaxRegression</li> </ul>"},{"location":"api/overview/#base_5","title":"base","text":"<ul> <li>GLM</li> </ul>"},{"location":"api/overview/#metrics","title":"metrics","text":"<p>Evaluation metrics.</p> <p>All the metrics are updated one sample at a time. This way we can track performance of predictive methods over time.</p> <p>Note that all metrics have a <code>revert</code> method, enabling them to be wrapped in <code>utils.Rolling</code>. This allows computirng rolling metrics:</p> <pre><code>from river import metrics, utils\n\ny_true = [True, False, True, True]\ny_pred = [False, False, True, True]\n\nmetric = utils.Rolling(metrics.Accuracy(), window_size=3)\n\nfor yt, yp in zip(y_true, y_pred):\n    print(metric.update(yt, yp))\n</code></pre> <pre><code>Accuracy: 0.00%\nAccuracy: 50.00%\nAccuracy: 66.67%\nAccuracy: 100.00%\n</code></pre> <ul> <li>Accuracy</li> <li>AdjustedMutualInfo</li> <li>AdjustedRand</li> <li>BalancedAccuracy</li> <li>ClassificationReport</li> <li>CohenKappa</li> <li>Completeness</li> <li>ConfusionMatrix</li> <li>CrossEntropy</li> <li>F1</li> <li>FBeta</li> <li>FowlkesMallows</li> <li>GeometricMean</li> <li>Homogeneity</li> <li>Jaccard</li> <li>LogLoss</li> <li>MAE</li> <li>MAPE</li> <li>MCC</li> <li>MSE</li> <li>MacroF1</li> <li>MacroFBeta</li> <li>MacroJaccard</li> <li>MacroPrecision</li> <li>MacroRecall</li> <li>MicroF1</li> <li>MicroFBeta</li> <li>MicroJaccard</li> <li>MicroPrecision</li> <li>MicroRecall</li> <li>MultiFBeta</li> <li>MutualInfo</li> <li>NormalizedMutualInfo</li> <li>Precision</li> <li>R2</li> <li>RMSE</li> <li>RMSLE</li> <li>ROCAUC</li> <li>Rand</li> <li>Recall</li> <li>RollingROCAUC</li> <li>SMAPE</li> <li>Silhouette</li> <li>VBeta</li> <li>WeightedF1</li> <li>WeightedFBeta</li> <li>WeightedJaccard</li> <li>WeightedPrecision</li> <li>WeightedRecall</li> </ul>"},{"location":"api/overview/#base_6","title":"base","text":"<ul> <li>BinaryMetric</li> <li>ClassificationMetric</li> <li>Metric</li> <li>Metrics</li> <li>MultiClassMetric</li> <li>RegressionMetric</li> <li>WrapperMetric</li> </ul>"},{"location":"api/overview/#multioutput","title":"multioutput","text":"<p>Metrics for multi-output learning.</p> <ul> <li>ExactMatch</li> <li>MacroAverage</li> <li>MicroAverage</li> <li>MultiLabelConfusionMatrix</li> <li>PerOutput</li> <li>SampleAverage</li> </ul>"},{"location":"api/overview/#base_7","title":"base","text":"<ul> <li>MultiOutputClassificationMetric</li> <li>MultiOutputRegressionMetric</li> </ul>"},{"location":"api/overview/#misc","title":"misc","text":"<p>Miscellaneous.</p> <p>This module essentially regroups some implementations that have nowhere else to go.</p> <ul> <li>SDFT</li> <li>Skyline</li> </ul>"},{"location":"api/overview/#model_selection","title":"model_selection","text":"<p>Model selection.</p> <p>This module regroups a variety of methods that may be used for performing model selection. An model selector is provided with a list of models. These are called \"experts\" in the expert learning literature. The model selector's goal is to perform at least as well as the best model. Indeed, initially, the best model is not known. The performance of each model becomes more apparent as time goes by. Different strategies are possible, each one offering a different tradeoff in terms of accuracy and computational performance.</p> <p>Model selection can be used for tuning the hyperparameters of a model. This may be done by creating a copy of the model for each set of hyperparameters, and treating each copy as a separate model. The <code>utils.expand_param_grid</code> function can be used for this purpose.</p> <ul> <li>BanditClassifier</li> <li>BanditRegressor</li> <li>GreedyRegressor</li> <li>SuccessiveHalvingClassifier</li> <li>SuccessiveHalvingRegressor</li> </ul>"},{"location":"api/overview/#base_8","title":"base","text":"<ul> <li>ModelSelectionClassifier</li> <li>ModelSelectionRegressor</li> </ul>"},{"location":"api/overview/#multiclass","title":"multiclass","text":"<p>Multi-class classification.</p> <ul> <li>OneVsOneClassifier</li> <li>OneVsRestClassifier</li> <li>OutputCodeClassifier</li> </ul>"},{"location":"api/overview/#multioutput_1","title":"multioutput","text":"<p>Multi-output models.</p> <ul> <li>ClassifierChain</li> <li>MonteCarloClassifierChain</li> <li>MultiClassEncoder</li> <li>ProbabilisticClassifierChain</li> <li>RegressorChain</li> </ul>"},{"location":"api/overview/#naive_bayes","title":"naive_bayes","text":"<p>Naive Bayes algorithms.</p> <ul> <li>BernoulliNB</li> <li>ComplementNB</li> <li>GaussianNB</li> <li>MultinomialNB</li> </ul>"},{"location":"api/overview/#neighbors","title":"neighbors","text":"<p>Neighbors-based learning.</p> <p>Also known as lazy methods. In these methods, generalisation of the training data is delayed until a query is received.</p> <ul> <li>KNNClassifier</li> <li>KNNRegressor</li> <li>LazySearch</li> <li>SWINN</li> </ul>"},{"location":"api/overview/#neural_net","title":"neural_net","text":"<p>Neural networks.</p> <ul> <li>MLPRegressor</li> </ul>"},{"location":"api/overview/#activations","title":"activations","text":"<ul> <li>Identity</li> <li>ReLU</li> <li>Sigmoid</li> </ul>"},{"location":"api/overview/#optim","title":"optim","text":"<p>Stochastic optimization.</p> <ul> <li>AMSGrad</li> <li>AdaBound</li> <li>AdaDelta</li> <li>AdaGrad</li> <li>AdaMax</li> <li>Adam</li> <li>Averager</li> <li>FTRLProximal</li> <li>Momentum</li> <li>Nadam</li> <li>NesterovMomentum</li> <li>RMSProp</li> <li>SGD</li> </ul>"},{"location":"api/overview/#base_9","title":"base","text":"<ul> <li>Initializer</li> <li>Loss</li> <li>Optimizer</li> <li>Scheduler</li> </ul>"},{"location":"api/overview/#initializers","title":"initializers","text":"<p>Weight initializers.</p> <ul> <li>Constant</li> <li>Normal</li> <li>Zeros</li> </ul>"},{"location":"api/overview/#losses","title":"losses","text":"<p>Loss functions.</p> <p>Each loss function is intended to work with both single values as well as numpy vectors.</p> <ul> <li>Absolute</li> <li>BinaryFocalLoss</li> <li>BinaryLoss</li> <li>Cauchy</li> <li>CrossEntropy</li> <li>EpsilonInsensitiveHinge</li> <li>Hinge</li> <li>Huber</li> <li>Log</li> <li>MultiClassLoss</li> <li>Poisson</li> <li>Quantile</li> <li>RegressionLoss</li> <li>Squared</li> </ul>"},{"location":"api/overview/#schedulers","title":"schedulers","text":"<p>Learning rate schedulers.</p> <ul> <li>Constant</li> <li>InverseScaling</li> <li>Optimal</li> </ul>"},{"location":"api/overview/#preprocessing","title":"preprocessing","text":"<p>Feature preprocessing.</p> <p>The purpose of this module is to modify an existing set of features so that they can be processed by a machine learning algorithm. This may be done by scaling numeric parts of the data or by one-hot encoding categorical features. The difference with the <code>feature_extraction</code> module is that the latter extracts new information from the data</p> <ul> <li>AdaptiveStandardScaler</li> <li>Binarizer</li> <li>FeatureHasher</li> <li>GaussianRandomProjector</li> <li>LDA</li> <li>MaxAbsScaler</li> <li>MinMaxScaler</li> <li>Normalizer</li> <li>OneHotEncoder</li> <li>OrdinalEncoder</li> <li>PredClipper</li> <li>PreviousImputer</li> <li>RobustScaler</li> <li>SparseRandomProjector</li> <li>StandardScaler</li> <li>StatImputer</li> <li>TargetMinMaxScaler</li> <li>TargetStandardScaler</li> </ul>"},{"location":"api/overview/#proba","title":"proba","text":"<p>Probability distributions.</p> <ul> <li>Beta</li> <li>Gaussian</li> <li>Multinomial</li> <li>MultivariateGaussian</li> </ul>"},{"location":"api/overview/#base_10","title":"base","text":"<ul> <li>BinaryDistribution</li> <li>ContinuousDistribution</li> <li>DiscreteDistribution</li> <li>Distribution</li> </ul>"},{"location":"api/overview/#reco","title":"reco","text":"<p>Recommender systems module.</p> <p>Recommender systems (recsys for short) is a large topic. This module is far from comprehensive. It simply provides models which can contribute towards building a recommender system.</p> <p>A typical recommender system is made up of a retrieval phase, followed by a ranking phase. The output of the retrieval phase is a shortlist of the catalogue of items. The items in the shortlist are then usually ranked according to the expected preference the user will have for each item. This module focuses on the ranking phase.</p> <p>Models which inherit from the <code>Ranker</code> class have a <code>rank</code> method. This allows sorting a set of items for a given user. Each model also has a <code>learn_one(user, item, y, context)</code> which allows learning user preferences. The <code>y</code> parameter is a reward value, the nature of which depends is specific to each and every recommendation task. Typically the reward is a number or a boolean value. It is up to the user to determine how to translate a user session into training data.</p> <ul> <li>Baseline</li> <li>BiasedMF</li> <li>FunkMF</li> <li>RandomNormal</li> </ul>"},{"location":"api/overview/#base_11","title":"base","text":"<ul> <li>Ranker</li> </ul>"},{"location":"api/overview/#rules","title":"rules","text":"<p>Decision rules-based algorithms.</p> <ul> <li>AMRules</li> </ul>"},{"location":"api/overview/#sketch","title":"sketch","text":"<p>Data containers and collections for sequential data.</p> <p>This module has summary and sketch structures that operate with constrained amounts of memory and processing time.</p> <ul> <li>Counter</li> <li>HeavyHitters</li> <li>Histogram</li> <li>Set</li> </ul>"},{"location":"api/overview/#stats","title":"stats","text":"<p>Running statistics</p> <ul> <li>AbsMax</li> <li>AutoCorr</li> <li>BayesianMean</li> <li>Count</li> <li>Cov</li> <li>EWMean</li> <li>EWVar</li> <li>Entropy</li> <li>IQR</li> <li>KolmogorovSmirnov</li> <li>Kurtosis</li> <li>Link</li> <li>MAD</li> <li>Max</li> <li>Mean</li> <li>Min</li> <li>Mode</li> <li>NUnique</li> <li>PeakToPeak</li> <li>PearsonCorr</li> <li>Quantile</li> <li>RollingAbsMax</li> <li>RollingIQR</li> <li>RollingMax</li> <li>RollingMin</li> <li>RollingMode</li> <li>RollingPeakToPeak</li> <li>RollingQuantile</li> <li>SEM</li> <li>Shift</li> <li>Skew</li> <li>Sum</li> <li>Var</li> </ul>"},{"location":"api/overview/#base_12","title":"base","text":"<ul> <li>Bivariate</li> <li>Univariate</li> </ul>"},{"location":"api/overview/#stream","title":"stream","text":"<p>Streaming utilities.</p> <p>The module includes tools to iterate over data streams.</p> <p>Classes</p> <ul> <li>Cache</li> <li>TwitchChatStream</li> <li>TwitterLiveStream</li> </ul> <p>Functions</p> <ul> <li>iter_arff</li> <li>iter_array</li> <li>iter_csv</li> <li>iter_libsvm</li> <li>iter_pandas</li> <li>iter_polars</li> <li>iter_sklearn_dataset</li> <li>iter_sql</li> <li>shuffle</li> <li>simulate_qa</li> </ul>"},{"location":"api/overview/#time_series","title":"time_series","text":"<p>Time series forecasting.</p> <p>Classes</p> <ul> <li>ForecastingMetric</li> <li>HoltWinters</li> <li>HorizonAggMetric</li> <li>HorizonMetric</li> <li>SNARIMAX</li> </ul> <p>Functions</p> <ul> <li>evaluate</li> <li>iter_evaluate</li> </ul>"},{"location":"api/overview/#base_13","title":"base","text":"<ul> <li>Forecaster</li> </ul>"},{"location":"api/overview/#tree","title":"tree","text":"<p>This module implements incremental Decision Tree (iDT) algorithms for handling classification and regression tasks.</p> <p>Each family of iDT will be presented in a dedicated section.</p> <p>At any moment, iDT might face situations where an input feature previously used to make a split decision is missing in an incoming sample. In this case, the most traversed path is selected to pass down the instance. Moreover, in the case of nominal features, if a new category arises and the feature is used in a decision node, a new branch is created to accommodate the new value.</p> <p>1. Hoeffding Trees</p> <p>This family of iDT algorithms use the Hoeffding Bound to determine whether or not the incrementally computed best split candidates would be equivalent to the ones obtained in a batch-processing fashion.</p> <p>All the available Hoeffding Tree (HT) implementation share some common functionalities:</p> <ul> <li> <p>Set the maximum tree depth allowed (<code>max_depth</code>).</p> </li> <li> <p>Handle Active and Inactive nodes: Active learning nodes update their own internal state to improve predictions and monitor input features to perform split attempts. Inactive learning nodes do not update their internal state and only keep the predictors; they are used to save memory in the tree (<code>max_size</code>).</p> </li> <li> <p>Enable/disable memory management.</p> </li> <li> <p>Define strategies to sort leaves according to how likely they are going to be split. This enables deactivating non-promising leaves to save memory.</p> </li> <li> <p>Disabling \u2018poor\u2019 attributes to save memory and speed up tree construction. A poor attribute is an input feature whose split merit is much smaller than the current best candidate. Once a feature is disabled, the tree stops saving statistics necessary to split such a feature.</p> </li> <li> <p>Define properties to access leaf prediction strategies, split criteria, and other relevant characteristics.</p> </li> </ul> <p>2. Stochastic Gradient Trees</p> <p>Stochastic Gradient Trees (SGT) directly optimize a loss function, rather than relying on split heuristics to guide the tree growth. F-tests are performed do decide whether a leaf should be expanded or its prediction value should be updated.</p> <p>SGTs can deal with binary classification and single-target regression. They also support dynamic and static feature quantizers to deal with numerical inputs.</p> <ul> <li>ExtremelyFastDecisionTreeClassifier</li> <li>HoeffdingAdaptiveTreeClassifier</li> <li>HoeffdingAdaptiveTreeRegressor</li> <li>HoeffdingTreeClassifier</li> <li>HoeffdingTreeRegressor</li> <li>LASTClassifier</li> <li>SGTClassifier</li> <li>SGTRegressor</li> <li>iSOUPTreeRegressor</li> </ul>"},{"location":"api/overview/#base_14","title":"base","text":"<p>This module defines generic branch and leaf implementations. These should be used in River by each tree-based model. Using these classes makes the code more DRY. The only exception for not doing so would be for performance, whereby a tree-based model uses a bespoke implementation.</p> <p>This module defines a bunch of methods to ease the manipulation and diagnostic of trees. Its intention is to provide utilities for walking over a tree and visualizing it.</p> <ul> <li>Branch</li> <li>Leaf</li> </ul>"},{"location":"api/overview/#splitter","title":"splitter","text":"<p>This module implements the Attribute Observers (AO) (or tree splitters) that are used by the Hoeffding Trees (HT). It also implements the feature quantizers (FQ) used by Stochastic Gradient Trees (SGT). AOs are a core aspect of the HTs construction, and might represent one of the major bottlenecks when building the trees. The same holds for SGTs and FQs. The correct choice and setup of a splitter might result in significant differences in the running time and memory usage of the incremental decision trees.</p> <p>AOs for classification and regression trees can be differentiated by using the property <code>is_target_class</code> (<code>True</code> for splitters designed to classification tasks). An error will be raised if one tries to use a classification splitter in a regression tree and vice-versa. Lastly, AOs cannot be used in SGT and FQs cannot be used in Hoeffding Trees. So, care must be taken when choosing the correct feature splitter.</p> <ul> <li>DynamicQuantizer</li> <li>EBSTSplitter</li> <li>ExhaustiveSplitter</li> <li>GaussianSplitter</li> <li>HistogramSplitter</li> <li>QOSplitter</li> <li>Quantizer</li> <li>Splitter</li> <li>StaticQuantizer</li> <li>TEBSTSplitter</li> </ul>"},{"location":"api/overview/#utils","title":"utils","text":"<p>Shared utility classes and functions</p> <p>Classes</p> <ul> <li>Rolling</li> <li>SortedWindow</li> <li>TimeRolling</li> <li>VectorDict</li> </ul> <p>Functions</p> <ul> <li>expand_param_grid</li> <li>log_method_calls</li> </ul>"},{"location":"api/overview/#math","title":"math","text":"<p>Mathematical utility functions (intended for internal purposes).</p> <p>A lot of this is experimental and has a high probability of changing in the future.</p> <ul> <li>argmax</li> <li>chain_dot</li> <li>clamp</li> <li>dot</li> <li>dotvecmat</li> <li>log_sum_2_exp</li> <li>matmul2d</li> <li>minkowski_distance</li> <li>norm</li> <li>outer</li> <li>prod</li> <li>sherman_morrison</li> <li>sigmoid</li> <li>sign</li> <li>softmax</li> <li>woodbury_matrix</li> </ul>"},{"location":"api/overview/#norm","title":"norm","text":"<ul> <li>normalize_values_in_dict</li> <li>scale_values_in_dict</li> </ul>"},{"location":"api/overview/#pretty","title":"pretty","text":"<p>Helper functions for making things readable by humans.</p> <ul> <li>humanize_bytes</li> <li>print_table</li> </ul>"},{"location":"api/overview/#random","title":"random","text":"<ul> <li>exponential</li> <li>poisson</li> </ul>"},{"location":"api/active/EntropySampler/","title":"EntropySampler","text":"<p>Active learning classifier based on entropy measures.</p> <p>The entropy sampler selects samples for labeling based on the entropy of the prediction. The higher the entropy, the more likely the sample will be selected for labeling. The entropy measure is normalized to [0, 1] and then raised to the power of the discount factor.</p>"},{"location":"api/active/EntropySampler/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to wrap.</p> </li> <li> <p>discount_factor</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>3</code></p> <p>The discount factor to apply to the entropy measure. A value of 1 won't affect the entropy. The higher the discount factor, the more the entropy will be discounted, and the less likely samples will be selected for labeling. A value of 0 will select all samples for labeling. The discount factor is thus a way to control how many samples are selected for labeling.</p> </li> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/active/EntropySampler/#examples","title":"Examples","text":"<p><pre><code>from river import active\nfrom river import datasets\nfrom river import feature_extraction\nfrom river import linear_model\nfrom river import metrics\n\ndataset = datasets.SMSSpam()\nmetric = metrics.Accuracy()\nmodel = (\n    feature_extraction.TFIDF(on='body') |\n    linear_model.LogisticRegression()\n)\nmodel = active.EntropySampler(model, seed=42)\n\nn_samples_used = 0\nfor x, y in dataset:\n    y_pred, ask = model.predict_one(x)\n    metric.update(y, y_pred)\n    if ask:\n        n_samples_used += 1\n        model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>Accuracy: 86.60%\n</code></pre></p> <p><pre><code>dataset.n_samples, n_samples_used\n</code></pre> <pre><code>(5574, 1921)\n</code></pre></p> <p><pre><code>print(f\"{n_samples_used / dataset.n_samples:.2%}\")\n</code></pre> <pre><code>34.46%\n</code></pre></p>"},{"location":"api/active/EntropySampler/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of <code>x</code> and indicate whether a label is needed.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for <code>x</code> and indicate whether a label is needed.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/active/base/ActiveLearningClassifier/","title":"ActiveLearningClassifier","text":"<p>Base class for active learning classifiers.</p>"},{"location":"api/active/base/ActiveLearningClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to wrap.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/active/base/ActiveLearningClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of <code>x</code> and indicate whether a label is needed.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for <code>x</code> and indicate whether a label is needed.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/anomaly/GaussianScorer/","title":"GaussianScorer","text":"<p>Univariate Gaussian anomaly detector.</p> <p>This is a supervised anomaly detector. It fits a Gaussian distribution to the target values. The anomaly score is then computed as so: </p> \\[score = 2 \\mid CDF(y) - 0.5 \\mid\\] <p>This makes it so that the anomaly score is between 0 and 1.</p>"},{"location":"api/anomaly/GaussianScorer/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Default \u2192 <code>None</code></p> <p>Set this to fit the Gaussian distribution over a window of recent values.</p> </li> <li> <p>grace_period</p> <p>Default \u2192 <code>100</code></p> <p>Number of samples before which a 0 is always returned. This is handy because the Gaussian distribution needs time to stabilize, and will likely produce overly high anomaly score for the first samples.</p> </li> </ul>"},{"location":"api/anomaly/GaussianScorer/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import anomaly\n\nrng = random.Random(42)\ndetector = anomaly.GaussianScorer()\n\nfor y in (rng.gauss(0, 1) for _ in range(100)):\n    detector.learn_one(None, y)\n\ndetector.score_one(None, -3)\n</code></pre> <pre><code>0.999477...\n</code></pre></p> <p><pre><code>detector.score_one(None, 3)\n</code></pre> <pre><code>0.999153...\n</code></pre></p> <p><pre><code>detector.score_one(None, 0)\n</code></pre> <pre><code>0.052665...\n</code></pre></p> <p><pre><code>detector.score_one(None, 0.5)\n</code></pre> <pre><code>0.383717...\n</code></pre></p>"},{"location":"api/anomaly/GaussianScorer/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds a normal observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p>"},{"location":"api/anomaly/HalfSpaceTrees/","title":"HalfSpaceTrees","text":"<p>Half-Space Trees (HST).</p> <p>Half-space trees are an online variant of isolation forests. They work well when anomalies are spread out. However, they do not work well if anomalies are packed together in windows. </p> <p>By default, this implementation assumes that each feature has values that are comprised between 0 and 1. If this isn't the case, then you can manually specify the limits via the <code>limits</code> argument. If you do not know the limits in advance, then you can use a <code>preprocessing.MinMaxScaler</code> as an initial preprocessing step. </p> <p>The current implementation builds the trees the first time the <code>learn_one</code> method is called. Therefore, the first <code>learn_one</code> call might be slow, whereas subsequent calls will be very fast in comparison. In general, the computation time of both <code>learn_one</code> and <code>score_one</code> scales linearly with the number of trees, and exponentially with the height of each tree. </p> <p>Note that high scores indicate anomalies, whereas low scores indicate normal observations.</p>"},{"location":"api/anomaly/HalfSpaceTrees/#parameters","title":"Parameters","text":"<ul> <li> <p>n_trees</p> <p>Default \u2192 <code>10</code></p> <p>Number of trees to use.</p> </li> <li> <p>height</p> <p>Default \u2192 <code>8</code></p> <p>Height of each tree. Note that a tree of height <code>h</code> is made up of <code>h + 1</code> levels and therefore contains <code>2 ** (h + 1) - 1</code> nodes.</p> </li> <li> <p>window_size</p> <p>Default \u2192 <code>250</code></p> <p>Number of observations to use for calculating the mass at each node in each tree.</p> </li> <li> <p>limits</p> <p>Type \u2192 dict[base.typing.FeatureName, tuple[float, float]] | None</p> <p>Default \u2192 <code>None</code></p> <p>Specifies the range of each feature. By default each feature is assumed to be in range <code>[0, 1]</code>.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number seed.</p> </li> </ul>"},{"location":"api/anomaly/HalfSpaceTrees/#attributes","title":"Attributes","text":"<ul> <li> <p>size_limit</p> <p>This is the threshold under which the node search stops during the scoring phase.  The value .1 is a magic constant indicated in the original paper.</p> </li> </ul>"},{"location":"api/anomaly/HalfSpaceTrees/#examples","title":"Examples","text":"<p><pre><code>from river import anomaly\n\nX = [0.5, 0.45, 0.43, 0.44, 0.445, 0.45, 0.0]\nhst = anomaly.HalfSpaceTrees(\n    n_trees=5,\n    height=3,\n    window_size=3,\n    seed=42\n)\n\nfor x in X[:3]:\n    hst.learn_one({'x': x})  # Warming up\n\nfor x in X:\n    features = {'x': x}\n    hst.learn_one(features)\n    print(f'Anomaly score for x={x:.3f}: {hst.score_one(features):.3f}')\n</code></pre> <pre><code>Anomaly score for x=0.500: 0.107\nAnomaly score for x=0.450: 0.071\nAnomaly score for x=0.430: 0.107\nAnomaly score for x=0.440: 0.107\nAnomaly score for x=0.445: 0.107\nAnomaly score for x=0.450: 0.071\nAnomaly score for x=0.000: 0.853\n</code></pre></p> <p>The feature values are all comprised between 0 and 1. This is what is assumed by the model by default. In the following example, we construct a pipeline that scales the data online and ensures that the values of each feature are comprised between 0 and 1.</p> <p><pre><code>from river import compose\nfrom river import datasets\nfrom river import metrics\nfrom river import preprocessing\n\nmodel = compose.Pipeline(\n    preprocessing.MinMaxScaler(),\n    anomaly.HalfSpaceTrees(seed=42)\n)\n\nauc = metrics.ROCAUC()\n\nfor x, y in datasets.CreditCard().take(2500):\n    score = model.score_one(x)\n    model.learn_one(x)\n    auc.update(y, score)\n\nauc\n</code></pre> <pre><code>ROCAUC: 91.15%\n</code></pre></p> <p>You can also use the <code>evaluate.progressive_val_score</code> function to evaluate the model on a data stream.</p> <p><pre><code>from river import evaluate\n\nmodel = model.clone()\n\nevaluate.progressive_val_score(\n    dataset=datasets.CreditCard().take(2500),\n    model=model,\n    metric=metrics.ROCAUC(),\n    print_every=1000\n)\n</code></pre> <pre><code>[1,000] ROCAUC: 88.43%\n[2,000] ROCAUC: 89.28%\n[2,500] ROCAUC: 91.15%\nROCAUC: 91.15%\n</code></pre></p>"},{"location":"api/anomaly/HalfSpaceTrees/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p> <ol> <li> <p>Tan, S.C., Ting, K.M. and Liu, T.F., 2011, June. Fast anomaly detection for streaming data. In Twenty-Second International Joint Conference on Artificial Intelligence. \u21a9</p> </li> </ol>"},{"location":"api/anomaly/LocalOutlierFactor/","title":"LocalOutlierFactor","text":"<p>Incremental Local Outlier Factor (Incremental LOF).</p> <p>The Incremental Local Outlier Factor (ILOF) is an online version of the Local Outlier Factor (LOF), proposed by Pokrajac et al. (2017),  and is used to identify outliers based on density of local neighbors. </p> <p>The algorithm take into account the following elements:     - <code>NewPoints</code>: new points;</p> <pre><code>- `kNN(p)`: the k-nearest neighbors of `p` (the k-closest points to `p`);\n\n- `RkNN(p)`: the reverse-k-nearest neighbors of `p` (points that have `p` as one of their neighbors);\n\n- `set_upd_lrd`: Set of points that need to have the local reachability distance updated;\n\n- `set_upd_lof`: Set of points that need to have the local outlier factor updated.\n</code></pre> <p>This current implementation within <code>River</code>, based on the original one in the paper, follows the following steps:     1) Insert new data points (<code>NewPoints</code>) and calculate its distance to existing points;     2) Update the nearest neighbors and reverse nearest neighbors of all the points;     3) Define sets of affected points that required updates;     4) Calculate the reachability-distance from new point to neighbors (<code>NewPoints</code> -&gt; <code>kNN(NewPoints)</code>)        and from rev-neighbors to new point (<code>RkNN(NewPoints)</code> -&gt; <code>NewPoints</code>);     5) Update the reachability-distance for affected points: <code>RkNN(RkNN(NewPoints))</code> -&gt; <code>RkNN(NewPoints)</code>     6) Update local reachability distance of affected points: <code>lrd(set_upd_lrd)</code>;     7) Update local outlier factor: <code>lof(set_upd_lof)</code>. </p> <p>The incremental LOF algorithm is expected to provide equivalent detection performance as the iterated static LOF algroithm (applied after insertion of each data record), while requiring significantly less computational time. Moreover, the insertion of a new data point as well as deletion of an old data point influence only a limited number of their closest neighbors, which means that the number of updates per such insertion/deletion does not depend on the total number of instances learned/in the data set.</p>"},{"location":"api/anomaly/LocalOutlierFactor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_neighbors</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of nearest neighbors to use for density estimation.</p> </li> <li> <p>distance_func</p> <p>Type \u2192 DistanceFunc | None</p> <p>Default \u2192 <code>None</code></p> <p>Distance function to be used. By default, the Euclidean distance is used.</p> </li> </ul>"},{"location":"api/anomaly/LocalOutlierFactor/#attributes","title":"Attributes","text":"<ul> <li> <p>x_list</p> <p>A list of stored observations.</p> </li> <li> <p>x_batch</p> <p>A buffer to hold incoming observations until it's time to update the model.</p> </li> <li> <p>x_scores</p> <p>A buffer to hold incoming observations until it's time to score them.</p> </li> <li> <p>dist_dict</p> <p>A dictionary to hold distances between observations.</p> </li> <li> <p>neighborhoods</p> <p>A dictionary to hold neighborhoods for each observation.</p> </li> <li> <p>rev_neighborhoods</p> <p>A dictionary to hold reverse neighborhoods for each observation.</p> </li> <li> <p>k_dist</p> <p>A dictionary to hold k-distances for each observation.</p> </li> <li> <p>reach_dist</p> <p>A dictionary to hold reachability distances for each observation.</p> </li> <li> <p>lof</p> <p>A dictionary to hold Local Outlier Factors for each observation.</p> </li> <li> <p>local_reach</p> <p>A dictionary to hold local reachability distances for each observation.</p> </li> </ul>"},{"location":"api/anomaly/LocalOutlierFactor/#examples","title":"Examples","text":"<p><pre><code>import pandas as pd\nfrom river import anomaly\nfrom river import datasets\n\ncc_df = pd.DataFrame(datasets.CreditCard())\n\nlof = anomaly.LocalOutlierFactor(n_neighbors=20)\n\nfor x, _ in datasets.CreditCard().take(200):\n    lof.learn_one(x)\n\nlof.learn_many(cc_df[201:401])\n\nscores = []\nfor x in cc_df[0][401:406]:\n    scores.append(lof.score_one(x))\n\n[round(score, 3) for score in scores]\n</code></pre> <pre><code>[1.802, 1.936, 1.566, 1.181, 1.272]\n</code></pre></p> <p><pre><code>X = [0.5, 0.45, 0.43, 0.44, 0.445, 0.45, 0.0]\nlof = anomaly.LocalOutlierFactor()\n\nfor x in X[:3]:\n    lof.learn_one({'x': x})  # Warming up\n\nfor x in X:\n    features = {'x': x}\n    print(\n        f'Anomaly score for x={x:.3f}: {lof.score_one(features):.3f}')\n    lof.learn_one(features)\n</code></pre> <pre><code>Anomaly score for x=0.500: 0.000\nAnomaly score for x=0.450: 0.000\nAnomaly score for x=0.430: 0.000\nAnomaly score for x=0.440: 1.020\nAnomaly score for x=0.445: 1.032\nAnomaly score for x=0.450: 0.000\nAnomaly score for x=0.000: 0.980\n</code></pre></p>"},{"location":"api/anomaly/LocalOutlierFactor/#methods","title":"Methods","text":"learn learn_many learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p> David Pokrajac, Aleksandar Lazarevic, and Longin Jan Latecki (2007). Incremental Local Outlier Detection for Data Streams. In: Proceedings of the 2007 IEEE Symposium on Computational Intelligence and Data Mining (CIDM 2007). 504-515. DOI: 10.1109/CIDM.2007.368917.</p>"},{"location":"api/anomaly/OneClassSVM/","title":"OneClassSVM","text":"<p>One-class SVM for anomaly detection.</p> <p>This is a stochastic implementation of the one-class SVM algorithm, and will not exactly match its batch formulation. </p> <p>It is encouraged to scale the data upstream with <code>preprocessing.StandardScaler</code>, as well as use <code>feature_extraction.RBFSampler</code> to capture non-linearities.</p>"},{"location":"api/anomaly/OneClassSVM/#parameters","title":"Parameters","text":"<ul> <li> <p>nu</p> <p>Default \u2192 <code>0.1</code></p> <p>An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. You can think of it as the expected fraction of anomalies.</p> </li> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the weights.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer</p> <p>Type \u2192 optim.base.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/anomaly/OneClassSVM/#attributes","title":"Attributes","text":"<ul> <li>weights</li> </ul>"},{"location":"api/anomaly/OneClassSVM/#examples","title":"Examples","text":"<p><pre><code>from river import anomaly\nfrom river import compose\nfrom river import datasets\nfrom river import metrics\nfrom river import preprocessing\n\nmodel = anomaly.QuantileFilter(\n    anomaly.OneClassSVM(nu=0.2),\n    q=0.995\n)\n\nauc = metrics.ROCAUC()\n\nfor x, y in datasets.CreditCard().take(2500):\n    score = model.score_one(x)\n    is_anomaly = model.classify(score)\n    model.learn_one(x)\n    auc.update(y, is_anomaly)\n\nauc\n</code></pre> <pre><code>ROCAUC: 74.68%\n</code></pre></p> <p>You can also use the <code>evaluate.progressive_val_score</code> function to evaluate the model on a data stream.</p> <p><pre><code>from river import evaluate\n\nmodel = model.clone()\n\nevaluate.progressive_val_score(\n    dataset=datasets.CreditCard().take(2500),\n    model=model,\n    metric=metrics.ROCAUC(),\n    print_every=1000\n)\n</code></pre> <pre><code>[1,000] ROCAUC: 74.40%\n[2,000] ROCAUC: 74.60%\n[2,500] ROCAUC: 74.68%\nROCAUC: 74.68%\n</code></pre></p>"},{"location":"api/anomaly/OneClassSVM/#methods","title":"Methods","text":"learn_many learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p>"},{"location":"api/anomaly/PredictiveAnomalyDetection/","title":"PredictiveAnomalyDetection","text":"<p>Predictive Anomaly Detection.</p> <p>This semi-supervised technique to anomaly detection employs a predictive model to learn the normal behavior of a dataset. It forecasts future data points and compares these predictions with actual values to determine anomalies. An anomaly score is calculated based on the deviation of the prediction from the actual value, with higher scores indicating a higher probability of an anomaly. </p> <p>The actual anomaly score is calculated by comparing the squared-error to a dynamic threshold. If the error is larger than this threshold, the score will be 1.0; else, the score will be linearly distributed within the range (0.0, 1.0), with a higher score indicating a higher squared error compared to the threshold.</p>"},{"location":"api/anomaly/PredictiveAnomalyDetection/#parameters","title":"Parameters","text":"<ul> <li> <p>predictive_model</p> <p>Type \u2192 base.Estimator | None</p> <p>Default \u2192 <code>None</code></p> <p>The underlying model that learns the normal behavior of the data and makes predictions on future behavior. This can be an estimator of any type, depending on the type of problem (e.g. some Forecaster for Time-Series Data).</p> </li> <li> <p>horizon</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1</code></p> <p>When a Forecaster is used as a predictive model, this is the horizon of its forecasts.</p> </li> <li> <p>n_std</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>3.0</code></p> <p>Number of Standard Deviations to calculate the threshold. A larger number of standard deviation will result in a higher threshold, resulting in the model being less sensitive.</p> </li> <li> <p>warmup_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Duration for the model to warm up. Since the model starts with zero knowledge, the first instances will have very high anomaly scores, resulting in bad predictions (or high error). As such, a warm-up period is necessary to discard the first seen instances. While the model is within the warm-up period, no score will be calculated and the score_one method will return 0.0.</p> </li> </ul>"},{"location":"api/anomaly/PredictiveAnomalyDetection/#attributes","title":"Attributes","text":"<ul> <li> <p>dynamic_mae (stats.Mean)</p> <p>The running mean of the (squared) errors from the predictions of the model to update the dynamic threshold.</p> </li> <li> <p>dynamic_se_variance (stats.Var)</p> <p>The running variance of the (squared) errors from the predictions of the model to update the dynamic threshold.</p> </li> <li> <p>iter (int)</p> <p>The number of iterations (data points) passed.</p> </li> </ul>"},{"location":"api/anomaly/PredictiveAnomalyDetection/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import time_series\nfrom river import anomaly\nfrom river import preprocessing\nfrom river import linear_model\nfrom river import optim\n\nperiod = 12\npredictive_model = time_series.SNARIMAX(\n    p=period,\n    d=1,\n    q=period,\n    m=period,\n    sd=1,\n    regressor=(\n        preprocessing.StandardScaler()\n        | linear_model.LinearRegression(\n            optimizer=optim.SGD(0.005),\n        )\n    ),\n)\n\nPAD = anomaly.PredictiveAnomalyDetection(\n    predictive_model,\n    horizon=1,\n    n_std=3.5,\n    warmup_period=15\n)\n\nscores = []\n\nfor t, (x, y) in enumerate(datasets.AirlinePassengers()):\n    score = PAD.score_one(None, y)\n    PAD.learn_one(None, y)\n    scores.append(score)\n\nprint(scores[-1])\n</code></pre> <pre><code>0.05329236123455621\n</code></pre></p>"},{"location":"api/anomaly/PredictiveAnomalyDetection/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict | None' </li> <li>y     \u2014 'base.typing.Target | float' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds a normal observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p> <ol> <li> <p>Laptev N, Amizadeh S, Flint I. Generic and scalable framework for Automated Time-series Anomaly Detection. Proceedings of the 21st ACM SIGKDD International Conference on Knowledge Discovery and Data Mining 2015. doi:10.1145/2783258.2788611.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/anomaly/QuantileFilter/","title":"QuantileFilter","text":"<p>Threshold anomaly filter.</p>"},{"location":"api/anomaly/QuantileFilter/#parameters","title":"Parameters","text":"<ul> <li> <p>anomaly_detector</p> <p>An anomaly detector.</p> </li> <li> <p>q</p> <p>Type \u2192 float</p> <p>The quantile level above which to classify an anomaly score as anomalous.</p> </li> <li> <p>protect_anomaly_detector</p> <p>Default \u2192 <code>True</code></p> <p>Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift.</p> </li> </ul>"},{"location":"api/anomaly/QuantileFilter/#attributes","title":"Attributes","text":"<ul> <li>q</li> </ul>"},{"location":"api/anomaly/QuantileFilter/#examples","title":"Examples","text":"<p><pre><code>from river import anomaly\nfrom river import compose\nfrom river import datasets\nfrom river import metrics\nfrom river import preprocessing\n\nmodel = compose.Pipeline(\n    preprocessing.MinMaxScaler(),\n    anomaly.QuantileFilter(\n        anomaly.HalfSpaceTrees(seed=42),\n        q=0.95\n    )\n)\n\nreport = metrics.ClassificationReport()\n\nfor x, y in datasets.CreditCard().take(2000):\n    score = model.score_one(x)\n    is_anomaly = model['QuantileFilter'].classify(score)\n    model.learn_one(x)\n    report.update(y, is_anomaly)\n\nreport\n</code></pre> <pre><code>               Precision   Recall   F1       Support\n&lt;BLANKLINE&gt;\n       0      99.95%   94.49%   97.14%      1998\n       1       0.90%   50.00%    1.77%         2\n&lt;BLANKLINE&gt;\n   Macro      50.42%   72.25%   49.46%\n   Micro      94.45%   94.45%   94.45%\nWeighted      99.85%   94.45%   97.05%\n&lt;BLANKLINE&gt;\n                 94.45% accuracy\n</code></pre></p>"},{"location":"api/anomaly/QuantileFilter/#methods","title":"Methods","text":"classify <p>Classify an anomaly score as anomalous or not.</p> <p>Parameters</p> <ul> <li>score     \u2014 'float' </li> </ul> <p>Returns</p> <p>bool:     A boolean value indicating whether the anomaly score is anomalous or not.</p> <p></p> learn_one <p>Update the anomaly filter and the underlying anomaly detector.</p> <p>Parameters</p> <ul> <li>args </li> <li>learn_kwargs </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>args </li> <li>kwargs </li> </ul> <p>Returns</p> <p>An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p>"},{"location":"api/anomaly/StandardAbsoluteDeviation/","title":"StandardAbsoluteDeviation","text":"<p>Standard Absolute Deviation (SAD).</p> <p>SAD is the model that calculates the anomaly score by using the deviation from the mean/median, divided by the standard deviation of all the points seen within the data stream. The idea of this model is based on the \\(3 \\times \\sigma\\) rule described in <sup>1</sup>. </p> <p>This implementation is adapted from the implementation within PySAD (Python Streaming Anomaly Detection) <sup>2</sup>. </p> <p>As a univariate anomaly detection algorithm, this implementation is adapted to <code>River</code> in a similar way as that of the <code>GaussianScorer</code> algorithm, with the variable taken into the account at the learning phase and scoring phase under variable <code>y</code>, ignoring <code>x</code>.</p>"},{"location":"api/anomaly/StandardAbsoluteDeviation/#parameters","title":"Parameters","text":"<ul> <li> <p>sub_stat</p> <p>Type \u2192 stats.base.Univariate | None</p> <p>Default \u2192 <code>None</code></p> <p>The statistic to be subtracted, then divided by the standard deviation for scoring. Defaults to <code>stats.Mean</code>()`.</p> </li> </ul>"},{"location":"api/anomaly/StandardAbsoluteDeviation/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import anomaly\nfrom river import stats\nfrom river import stream\n\nrng = random.Random(42)\n\nmodel = anomaly.StandardAbsoluteDeviation(sub_stat=stats.Mean())\n\nfor _ in range(150):\n    y = rng.gauss(0, 1)\n    model.learn_one(None, y)\n\nmodel.score_one(None, 2)\n</code></pre> <pre><code>2.057...\n</code></pre></p> <p><pre><code>model.score_one(None, 0)\n</code></pre> <pre><code>0.084...\n</code></pre></p> <p><pre><code>model.score_one(None, 1)\n</code></pre> <pre><code>0.986...\n</code></pre></p>"},{"location":"api/anomaly/StandardAbsoluteDeviation/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds a normal observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p> <ol> <li> <p>Hochenbaum, J., Vallis, O.S., Kejariwal, A., 2017. Automatic Anomaly Detection in the Cloud Via Statistical Learning. https://doi.org/10.48550/ARXIV.1704.07706.\u00a0\u21a9</p> </li> <li> <p>Yilmaz, S.F., Kozat, S.S., 2020. PySAD: A Streaming Anomaly Detection Framework in Python. https://doi.org/10.48550/ARXIV.2009.02572.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/anomaly/ThresholdFilter/","title":"ThresholdFilter","text":"<p>Threshold anomaly filter.</p>"},{"location":"api/anomaly/ThresholdFilter/#parameters","title":"Parameters","text":"<ul> <li> <p>anomaly_detector</p> <p>An anomaly detector.</p> </li> <li> <p>threshold</p> <p>Type \u2192 float</p> <p>A threshold above which to classify an anomaly score as anomalous.</p> </li> <li> <p>protect_anomaly_detector</p> <p>Default \u2192 <code>True</code></p> <p>Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift.</p> </li> </ul>"},{"location":"api/anomaly/ThresholdFilter/#examples","title":"Examples","text":"<p>Anomaly filters can be used as part of a pipeline. For instance, we might want to filter out anomalous observations so as not to corrupt a supervised model. As an example, let's take the <code>datasets.WaterFlow</code> dataset. Some of the samples have anomalous target variables because of human interventions. We don't want our model to learn these values.</p> <p><pre><code>from river import datasets\nfrom river import metrics\nfrom river import time_series\n\ndataset = datasets.WaterFlow()\nmetric = metrics.SMAPE()\n\nperiod = 24  # 24 samples per day\n\nmodel = (\n    anomaly.ThresholdFilter(\n        anomaly.GaussianScorer(\n            window_size=period * 7,  # 7 days\n            grace_period=30\n        ),\n        threshold=0.995\n    ) |\n    time_series.HoltWinters(\n        alpha=0.3,\n        beta=0.1,\n        multiplicative=False\n    )\n)\n\ntime_series.evaluate(\n    dataset,\n    model,\n    metric,\n    horizon=period\n)\n</code></pre> <pre><code>+1  SMAPE: 4.220171\n+2  SMAPE: 4.322648\n+3  SMAPE: 4.418546\n+4  SMAPE: 4.504986\n+5  SMAPE: 4.57924\n+6  SMAPE: 4.64123\n+7  SMAPE: 4.694042\n+8  SMAPE: 4.740753\n+9  SMAPE: 4.777291\n+10 SMAPE: 4.804558\n+11 SMAPE: 4.828114\n+12 SMAPE: 4.849823\n+13 SMAPE: 4.865871\n+14 SMAPE: 4.871972\n+15 SMAPE: 4.866274\n+16 SMAPE: 4.842614\n+17 SMAPE: 4.806214\n+18 SMAPE: 4.763355\n+19 SMAPE: 4.713455\n+20 SMAPE: 4.672062\n+21 SMAPE: 4.659102\n+22 SMAPE: 4.693496\n+23 SMAPE: 4.773707\n+24 SMAPE: 4.880654\n</code></pre></p>"},{"location":"api/anomaly/ThresholdFilter/#methods","title":"Methods","text":"classify <p>Classify an anomaly score as anomalous or not.</p> <p>Parameters</p> <ul> <li>score     \u2014 'float' </li> </ul> <p>Returns</p> <p>bool:     A boolean value indicating whether the anomaly score is anomalous or not.</p> <p></p> learn_one <p>Update the anomaly filter and the underlying anomaly detector.</p> <p>Parameters</p> <ul> <li>args </li> <li>learn_kwargs </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>args </li> <li>kwargs </li> </ul> <p>Returns</p> <p>An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p>"},{"location":"api/anomaly/base/AnomalyDetector/","title":"AnomalyDetector","text":"<p>An anomaly detector.</p>"},{"location":"api/anomaly/base/AnomalyDetector/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p>"},{"location":"api/anomaly/base/AnomalyFilter/","title":"AnomalyFilter","text":"<p>Anomaly filter base class.</p> <p>An anomaly filter has the ability to classify an anomaly score as anomalous or not. It can then be used to filter anomalies, in particular as part of a pipeline.</p>"},{"location":"api/anomaly/base/AnomalyFilter/#parameters","title":"Parameters","text":"<ul> <li> <p>anomaly_detector</p> <p>Type \u2192 AnomalyDetector</p> <p>An anomaly detector wrapped by the anomaly filter.</p> </li> <li> <p>protect_anomaly_detector</p> <p>Default \u2192 <code>True</code></p> <p>Indicates whether or not the anomaly detector should be updated when the anomaly score is anomalous. If the data contains sporadic anomalies, then the anomaly detector should likely not be updated. Indeed, if it learns the anomaly score, then it will slowly start to consider anomalous anomaly scores as normal. This might be desirable, for instance in the case of drift.</p> </li> </ul>"},{"location":"api/anomaly/base/AnomalyFilter/#methods","title":"Methods","text":"classify <p>Classify an anomaly score as anomalous or not.</p> <p>Parameters</p> <ul> <li>score     \u2014 'float' </li> </ul> <p>Returns</p> <p>bool:     A boolean value indicating whether the anomaly score is anomalous or not.</p> <p></p> learn_one <p>Update the anomaly filter and the underlying anomaly detector.</p> <p>Parameters</p> <ul> <li>args </li> <li>learn_kwargs </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds to a normal observation.</p> <p>Parameters</p> <ul> <li>args </li> <li>kwargs </li> </ul> <p>Returns</p> <p>An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p>"},{"location":"api/anomaly/base/SupervisedAnomalyDetector/","title":"SupervisedAnomalyDetector","text":"<p>A supervised anomaly detector.</p>"},{"location":"api/anomaly/base/SupervisedAnomalyDetector/#methods","title":"Methods","text":"learn_one <p>Update the model.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p></p> score_one <p>Return an outlier score.</p> <p>A high score is indicative of an anomaly. A low score corresponds a normal observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p>Returns</p> <p>float:     An anomaly score. A high score is indicative of an anomaly. A low score corresponds a</p> <p></p>"},{"location":"api/bandit/BayesUCB/","title":"BayesUCB","text":"<p>Bayes-UCB bandit policy.</p> <p>Bayes-UCB is a Bayesian algorithm for the multi-armed bandit problem. It uses the posterior distribution of the reward of each arm to compute an upper confidence bound (UCB) on the expected reward of each arm. The arm with the highest UCB is then pulled. The posterior distribution is updated after each pull. The algorithm is described in <sup>1</sup>.</p>"},{"location":"api/bandit/BayesUCB/#parameters","title":"Parameters","text":"<ul> <li> <p>reward_obj</p> <p>Default \u2192 <code>None</code></p> <p>The reward object that is used to update the posterior distribution.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>Number of initial observations per arm before using the posterior distribution.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/BayesUCB/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/BayesUCB/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import bandit\nfrom river import proba\nfrom river import stats\n\nenv = gym.make(\n    'river_bandits/CandyCaneContest-v0'\n)\n_ = env.reset(seed=42)\n_ = env.action_space.seed(123)\n\npolicy = bandit.BayesUCB(seed=123)\n\nmetric = stats.Sum()\nwhile True:\n    action = policy.pull(range(env.action_space.n))\n    observation, reward, terminated, truncated, info = env.step(action)\n    policy.update(action, reward)\n    metric.update(reward)\n    if terminated or truncated:\n        break\n\nmetric\n</code></pre> <pre><code>Sum: 841.\n</code></pre></p>"},{"location":"api/bandit/BayesUCB/#methods","title":"Methods","text":"compute_index <p>the p-th quantile of the beta distribution for the arm</p> <p>Parameters</p> <ul> <li>arm_id </li> </ul> <p></p> pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Rewrite update function</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p> <ol> <li> <p>Kaufmann, Emilie, Olivier Capp\u00e9, and Aur\u00e9lien Garivier. \"On Bayesian upper confidence bounds for bandit problems.\" Artificial intelligence and statistics. PMLR, 2012. \u21a9</p> </li> </ol>"},{"location":"api/bandit/EpsilonGreedy/","title":"EpsilonGreedy","text":"<p>\\(\\varepsilon\\)-greedy bandit policy.</p> <p>Performs arm selection by using an \\(\\varepsilon\\)-greedy bandit strategy. An arm is selected at each step. The best arm is selected (1 - \\(\\varepsilon\\))% of the time. </p> <p>Selection bias is a common problem when using bandits. This bias can be mitigated by using burn-in phase. Each model is given the chance to learn during the first <code>burn_in</code> steps.</p>"},{"location":"api/bandit/EpsilonGreedy/#parameters","title":"Parameters","text":"<ul> <li> <p>epsilon</p> <p>Type \u2192 float</p> <p>The probability of exploring.</p> </li> <li> <p>decay</p> <p>Default \u2192 <code>0.0</code></p> <p>The decay rate of epsilon.</p> </li> <li> <p>reward_obj</p> <p>Default \u2192 <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/EpsilonGreedy/#attributes","title":"Attributes","text":"<ul> <li> <p>current_epsilon</p> <p>The value of epsilon after factoring in the decay rate.</p> </li> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/EpsilonGreedy/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import bandit\nfrom river import stats\n\nenv = gym.make(\n    'river_bandits/CandyCaneContest-v0'\n)\n_ = env.reset(seed=42)\n_ = env.action_space.seed(123)\n\npolicy = bandit.EpsilonGreedy(epsilon=0.9, seed=101)\n\nmetric = stats.Sum()\nwhile True:\n    arm = policy.pull(range(env.action_space.n))\n    observation, reward, terminated, truncated, info = env.step(arm)\n    policy.update(arm, reward)\n    metric.update(reward)\n    if terminated or truncated:\n        break\n\nmetric\n</code></pre> <pre><code>Sum: 775.\n</code></pre></p>"},{"location":"api/bandit/EpsilonGreedy/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p> <ol> <li> <p>\u03b5-Greedy Algorithm - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9</p> </li> </ol>"},{"location":"api/bandit/Exp3/","title":"Exp3","text":"<p>Exp3 bandit policy.</p> <p>This policy works by maintaining a weight for each arm. These weights are used to randomly decide which arm to pull. The weights are increased or decreased, depending on the reward. An egalitarianism factor \\(\\gamma \\in [0, 1]\\) is included, to tune the desire to pick an arm uniformly at random. That is, if \\(\\gamma = 1\\), the arms are picked uniformly at random.</p>"},{"location":"api/bandit/Exp3/#parameters","title":"Parameters","text":"<ul> <li> <p>gamma</p> <p>Type \u2192 float</p> <p>The egalitarianism factor. Setting this to 0 leads to what is called the EXP3 policy.</p> </li> <li> <p>reward_obj</p> <p>Default \u2192 <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>reward_scaler</p> <p>Default \u2192 <code>None</code></p> <p>A reward scaler used to scale the rewards before they are fed to the reward object. This can be useful to scale the rewards to a (0, 1) range for instance.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/Exp3/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/Exp3/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import bandit\nfrom river import proba\nfrom river import stats\n\nenv = gym.make(\n    'river_bandits/CandyCaneContest-v0'\n)\n_ = env.reset(seed=42)\n_ = env.action_space.seed(123)\n\npolicy = bandit.Exp3(gamma=0.5, seed=42)\n\nmetric = stats.Sum()\nwhile True:\n    action = policy.pull(range(env.action_space.n))\n    observation, reward, terminated, truncated, info = env.step(action)\n    policy.update(action, reward)\n    metric.update(reward)\n    if terminated or truncated:\n        break\n\nmetric\n</code></pre> <pre><code>Sum: 799.\n</code></pre></p>"},{"location":"api/bandit/Exp3/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p> <ol> <li> <p>Auer, P., Cesa-Bianchi, N., Freund, Y. and Schapire, R.E., 2002. The nonstochastic multiarmed bandit problem. SIAM journal on computing, 32(1), pp.48-77. \u21a9</p> </li> <li> <p>Adversarial Bandits and the Exp3 Algorithm \u2014 Jeremy Kun \u21a9</p> </li> </ol>"},{"location":"api/bandit/LinUCBDisjoint/","title":"LinUCBDisjoint","text":"<p>LinUCB, disjoint variant.</p> <p>Although it works, as of yet it is too slow to realistically be used in practice. </p> <p>The way this works is that each arm is assigned a <code>linear_model.BayesianLinearRegression</code> instance. This instance is updated every time the arm is pulled. The context is used as features for the regression. The reward is used as the target. The posterior distribution is used to compute the upper confidence bound. The arm with the highest upper confidence bound is pulled.</p>"},{"location":"api/bandit/LinUCBDisjoint/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>Parameter used in each Bayesian linear regression.</p> </li> <li> <p>beta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>Parameter used in each Bayesian linear regression.</p> </li> <li> <p>smoothing</p> <p>Type \u2192 float | None</p> <p>Default \u2192 <code>None</code></p> <p>Parameter used in each Bayesian linear regression.</p> </li> <li> <p>reward_obj</p> <p>Default \u2192 <code>None</code></p> <p>The reward object used to measure the performance of each arm.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>The number of time steps during which each arm is pulled once.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/LinUCBDisjoint/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/LinUCBDisjoint/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> <li>context     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Rewrite update function</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>context </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p> <ol> <li> <p>A Contextual-Bandit Approach to Personalized News Article Recommendation [^2:] Contextual Bandits Analysis of LinUCB Disjoint Algorithm with Dataset \u21a9</p> </li> </ol>"},{"location":"api/bandit/RandomPolicy/","title":"RandomPolicy","text":"<p>Random bandit policy.</p> <p>This policy simply pulls a random arm at each time step. It is useful as a baseline.</p>"},{"location":"api/bandit/RandomPolicy/#parameters","title":"Parameters","text":"<ul> <li> <p>reward_obj</p> <p>Default \u2192 <code>None</code></p> <p>The reward object that is used to update the posterior distribution.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>Number of initial observations per arm before using the posterior distribution.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/RandomPolicy/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/RandomPolicy/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import bandit\nfrom river import proba\nfrom river import stats\n\nenv = gym.make(\n    'river_bandits/CandyCaneContest-v0'\n)\n_ = env.reset(seed=42)\n_ = env.action_space.seed(123)\n\npolicy = bandit.RandomPolicy(seed=123)\n\nmetric = stats.Sum()\nwhile True:\n    action = policy.pull(range(env.action_space.n))\n    observation, reward, terminated, truncated, info = env.step(action)\n    policy.update(action, reward)\n    metric.update(reward)\n    if terminated or truncated:\n        break\n\nmetric\n</code></pre> <pre><code>Sum: 755.\n</code></pre></p>"},{"location":"api/bandit/RandomPolicy/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p>"},{"location":"api/bandit/ThompsonSampling/","title":"ThompsonSampling","text":"<p>Thompson sampling.</p> <p>Thompson sampling is often used with a Beta distribution. However, any probability distribution can be used, as long it makes sense with the reward shape. For instance, a Beta distribution is meant to be used with binary rewards, while a Gaussian distribution is meant to be used with continuous rewards. </p> <p>The randomness of a distribution is controlled by its seed. The seed should not set within the distribution, but should rather be defined in the policy parametrization. In other words, you should do this: </p> <pre><code>policy = ThompsonSampling(dist=proba.Beta(1, 1), seed=42) \n</code></pre> <p>and not this: </p> <pre><code>policy = ThompsonSampling(dist=proba.Beta(1, 1, seed=42)) \n</code></pre>"},{"location":"api/bandit/ThompsonSampling/#parameters","title":"Parameters","text":"<ul> <li> <p>reward_obj</p> <p>Type \u2192 proba.base.Distribution | None</p> <p>Default \u2192 <code>None</code></p> <p>A distribution to sample from.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/ThompsonSampling/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/ThompsonSampling/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import bandit\nfrom river import proba\nfrom river import stats\n\nenv = gym.make(\n    'river_bandits/CandyCaneContest-v0'\n)\n_ = env.reset(seed=42)\n_ = env.action_space.seed(123)\n\npolicy = bandit.ThompsonSampling(reward_obj=proba.Beta(), seed=101)\n\nmetric = stats.Sum()\nwhile True:\n    arm = policy.pull(range(env.action_space.n))\n    observation, reward, terminated, truncated, info = env.step(arm)\n    policy.update(arm, reward)\n    metric.update(reward)\n    if terminated or truncated:\n        break\n\nmetric\n</code></pre> <pre><code>Sum: 820.\n</code></pre></p>"},{"location":"api/bandit/ThompsonSampling/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p> <ol> <li> <p>An Empirical Evaluation of Thompson Sampling \u21a9</p> </li> </ol>"},{"location":"api/bandit/UCB/","title":"UCB","text":"<p>Upper Confidence Bound (UCB) bandit policy.</p> <p>Due to the nature of this algorithm, it's recommended to scale the target so that it exhibits sub-gaussian properties. This can be done by passing a <code>preprocessing.TargetStandardScaler</code> instance to the <code>reward_scaler</code> argument.</p>"},{"location":"api/bandit/UCB/#parameters","title":"Parameters","text":"<ul> <li> <p>delta</p> <p>Type \u2192 float</p> <p>The confidence level. Setting this to 1 leads to what is called the UCB1 policy.</p> </li> <li> <p>reward_obj</p> <p>Default \u2192 <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>reward_scaler</p> <p>Default \u2192 <code>None</code></p> <p>A reward scaler used to scale the rewards before they are fed to the reward object. This can be useful to scale the rewards to a (0, 1) range for instance.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/bandit/UCB/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/UCB/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import bandit\nfrom river import preprocessing\nfrom river import stats\n\nenv = gym.make(\n    'river_bandits/CandyCaneContest-v0'\n)\n_ = env.reset(seed=42)\n_ = env.action_space.seed(123)\n\npolicy = bandit.UCB(\n    delta=100,\n    reward_scaler=preprocessing.TargetStandardScaler(None),\n    seed=42\n)\n\nmetric = stats.Sum()\nwhile True:\n    arm = policy.pull(range(env.action_space.n))\n    observation, reward, terminated, truncated, info = env.step(arm)\n    policy.update(arm, reward)\n    metric.update(reward)\n    if terminated or truncated:\n        break\n\nmetric\n</code></pre> <pre><code>Sum: 744.\n</code></pre></p>"},{"location":"api/bandit/UCB/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p> <ol> <li> <p>Lai, T. L., &amp; Robbins, H. (1985). Asymptotically efficient adaptive allocation rules. Advances in applied mathematics, 6(1), 4-22. \u21a9</p> </li> <li> <p>Upper Confidence Bounds - The Multi-Armed Bandit Problem and Its Solutions - Lilian Weng \u21a9</p> </li> <li> <p>The Upper Confidence Bound Algorithm - Bandit Algorithms \u21a9</p> </li> </ol>"},{"location":"api/bandit/evaluate-offline/","title":"evaluate_offline","text":"<p>Evaluate a policy on historical logs using replay.</p> <p>This is a high-level utility function for evaluating a policy using the replay methodology. This methodology is an off-policy evaluation method. It does not require an environment, and is instead data-driven. </p> <p>At each step, an arm is pulled from the provided policy. If the arm is the same as the arm that was pulled in the historical data, the reward is used to update the policy. If the arm is different, the reward is ignored. This is the off-policy aspect of the evaluation.</p>"},{"location":"api/bandit/evaluate-offline/#parameters","title":"Parameters","text":"<ul> <li> <p>policy</p> <p>Type \u2192 bandit.base.Policy</p> <p>The policy to evaluate.</p> </li> <li> <p>history</p> <p>Type \u2192 History | bandit.datasets.BanditDataset</p> <p>The history of the bandit problem. This is a generator that yields tuples of the form <code>(arms, context, arm, reward)</code>.</p> </li> <li> <p>reward_stat</p> <p>Type \u2192 stats.base.Univariate | None</p> <p>Default \u2192 <code>None</code></p> <p>The reward statistic to use. Defaults to <code>stats.Sum</code>.</p> </li> </ul>"},{"location":"api/bandit/evaluate-offline/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import bandit\n\nrng = random.Random(42)\narms = ['A', 'B', 'C']\nclicks = [\n    (\n        arms,\n        # no context\n        None,\n        # random arm\n        rng.choice(arms),\n        # reward\n        rng.random() &gt; 0.5\n    )\n    for _ in range(1000)\n]\n\ntotal_reward, n_samples_used = bandit.evaluate_offline(\n    policy=bandit.EpsilonGreedy(0.1, seed=42),\n    history=clicks,\n)\n\ntotal_reward\n</code></pre> <pre><code>Sum: 172.\n</code></pre></p> <p><pre><code>n_samples_used\n</code></pre> <pre><code>321\n</code></pre></p> <p>This also works out of the box with datasets that inherit from <code>river.bandit.BanditDataset</code>.</p> <p><pre><code>news = bandit.datasets.NewsArticles()\ntotal_reward, n_samples_used = bandit.evaluate_offline(\n    policy=bandit.RandomPolicy(seed=42),\n    history=news,\n)\n\ntotal_reward, n_samples_used\n</code></pre> <pre><code>(Sum: 105., 1027)\n</code></pre></p> <p>As expected, the policy succeeds in roughly 10% of cases. Indeed, there are 10 arms and 10000 samples, so the expected number of successes is 1000.</p> <ol> <li> <p>Offline Evaluation of Multi-Armed Bandit Algorithms in Python using Replay \u21a9</p> </li> <li> <p>Unbiased Offline Evaluation of Contextual-bandit-based News Article Recommendation Algorithms \u21a9</p> </li> <li> <p>Understanding Inverse Propensity Score for Contextual Bandits \u21a9</p> </li> </ol>"},{"location":"api/bandit/evaluate/","title":"evaluate","text":"<p>Benchmark a list of policies on a given Gym environment.</p> <p>This is a high-level utility function for benchmarking a list of policies on a given Gym environment. For example, it can be used to populate a <code>pandas.DataFrame</code> with the contents of each step of each episode.</p>"},{"location":"api/bandit/evaluate/#parameters","title":"Parameters","text":"<ul> <li> <p>policies</p> <p>Type \u2192 list[bandit.base.Policy]</p> <p>A list of policies to evaluate. The policy will be reset before each episode.</p> </li> <li> <p>env</p> <p>Type \u2192 gym.Env</p> <p>The Gym environment to use. One copy will be made for each policy at the beginning of each episode.</p> </li> <li> <p>reward_stat</p> <p>Type \u2192 stats.base.Univariate | None</p> <p>Default \u2192 <code>None</code></p> <p>A univariate statistic to keep track of the rewards. This statistic will be reset before each episode. Note that this is not the same as the reward object used by the policies. It's just a statistic to keep track of each policy's performance. If <code>None</code>, <code>stats.Sum</code> is used.</p> </li> <li> <p>n_episodes</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>20</code></p> <p>The number of episodes to run.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility. A random number generator will be used to seed differently the environment before each episode.</p> </li> </ul>"},{"location":"api/bandit/evaluate/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import bandit\n\ntrace = bandit.evaluate(\n    policies=[\n        bandit.UCB(delta=1, seed=42),\n        bandit.EpsilonGreedy(epsilon=0.1, seed=42),\n    ],\n    env=gym.make(\n        'river_bandits/CandyCaneContest-v0',\n        max_episode_steps=100\n    ),\n    n_episodes=5,\n    seed=42\n)\n\nfor step in trace:\n    print(step)\n    break\n</code></pre> <pre><code>{'episode': 0, 'step': 0, 'policy_idx': 0, 'arm': 81, 'reward': 0.0, 'reward_stat': 0.0}\n</code></pre></p> <p>The return type of this function is a generator. Each step of the generator is a dictionary. You can pass the generator to a <code>pandas.DataFrame</code> to get a nice representation of the results.</p> <p><pre><code>import pandas as pd\n\ntrace = bandit.evaluate(\n    policies=[\n        bandit.UCB(delta=1, seed=42),\n        bandit.EpsilonGreedy(epsilon=0.1, seed=42),\n    ],\n    env=gym.make(\n        'river_bandits/CandyCaneContest-v0',\n        max_episode_steps=100\n    ),\n    n_episodes=5,\n    seed=42\n)\n\ntrace_df = pd.DataFrame(trace)\ntrace_df.sample(5, random_state=42)\n</code></pre> <pre><code>     episode  step  policy_idx  arm  reward  reward_stat\n521        2    60           1   25     0.0         36.0\n737        3    68           1   40     1.0         20.0\n740        3    70           0   58     0.0         36.0\n660        3    30           0   31     1.0         16.0\n411        2     5           1   35     1.0          5.0\n</code></pre></p> <p>The length of the dataframe is the number of policies times the number of episodes times the maximum number of steps per episode.</p> <p><pre><code>len(trace_df)\n</code></pre> <pre><code>1000\n</code></pre></p> <p><pre><code>(\n    trace_df.policy_idx.nunique() *\n    trace_df.episode.nunique() *\n    trace_df.step.nunique()\n)\n</code></pre> <pre><code>1000\n</code></pre></p>"},{"location":"api/bandit/base/ContextualPolicy/","title":"ContextualPolicy","text":"<p>Contextual bandit policy base class.</p>"},{"location":"api/bandit/base/ContextualPolicy/#parameters","title":"Parameters","text":"<ul> <li> <p>reward_obj</p> <p>Type \u2192 RewardObj | None</p> <p>Default \u2192 <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>reward_scaler</p> <p>Type \u2192 compose.TargetTransformRegressor | None</p> <p>Default \u2192 <code>None</code></p> <p>A reward scaler used to scale the rewards before they are fed to the reward object. This can be useful to scale the rewards to a (0, 1) range for instance.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> </ul>"},{"location":"api/bandit/base/ContextualPolicy/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/base/ContextualPolicy/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> <li>context     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>context </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p>"},{"location":"api/bandit/base/Policy/","title":"Policy","text":"<p>Bandit policy base class.</p>"},{"location":"api/bandit/base/Policy/#parameters","title":"Parameters","text":"<ul> <li> <p>reward_obj</p> <p>Type \u2192 RewardObj | None</p> <p>Default \u2192 <code>None</code></p> <p>The reward object used to measure the performance of each arm. This can be a metric, a statistic, or a distribution.</p> </li> <li> <p>reward_scaler</p> <p>Type \u2192 compose.TargetTransformRegressor | None</p> <p>Default \u2192 <code>None</code></p> <p>A reward scaler used to scale the rewards before they are fed to the reward object. This can be useful to scale the rewards to a (0, 1) range for instance.</p> </li> <li> <p>burn_in</p> <p>Default \u2192 <code>0</code></p> <p>The number of steps to use for the burn-in phase. Each arm is given the chance to be pulled during the burn-in phase. This is useful to mitigate selection bias.</p> </li> </ul>"},{"location":"api/bandit/base/Policy/#attributes","title":"Attributes","text":"<ul> <li> <p>ranking</p> <p>Return the list of arms in descending order of performance.</p> </li> </ul>"},{"location":"api/bandit/base/Policy/#methods","title":"Methods","text":"pull <p>Pull arm(s).</p> <p>This method is a generator that yields the arm(s) that should be pulled. During the burn-in phase, all the arms that have not been pulled enough times are yielded. Once the burn-in phase is over, the policy is allowed to choose the arm(s) that should be pulled. If you only want to pull one arm at a time during the burn-in phase, simply call <code>next(policy.pull(arms))</code>.</p> <p>Parameters</p> <ul> <li>arm_ids     \u2014 'list[ArmID]' </li> </ul> <p>Returns</p> <p>ArmID:     A single arm.</p> <p></p> update <p>Update an arm's state.</p> <p>Parameters</p> <ul> <li>arm_id </li> <li>reward_args </li> <li>reward_kwargs </li> </ul> <p></p>"},{"location":"api/bandit/datasets/BanditDataset/","title":"BanditDataset","text":"<p>Base class for bandit datasets.</p>"},{"location":"api/bandit/datasets/BanditDataset/#parameters","title":"Parameters","text":"<ul> <li> <p>n_features</p> <p>Number of features in the dataset.</p> </li> <li> <p>n_samples</p> <p>Default \u2192 <code>None</code></p> <p>Number of samples in the dataset.</p> </li> <li> <p>n_classes</p> <p>Default \u2192 <code>None</code></p> <p>Number of classes in the dataset, only applies to classification datasets.</p> </li> <li> <p>n_outputs</p> <p>Default \u2192 <code>None</code></p> <p>Number of outputs the target is made of, only applies to multi-output datasets.</p> </li> <li> <p>sparse</p> <p>Default \u2192 <code>False</code></p> <p>Whether the dataset is sparse or not.</p> </li> </ul>"},{"location":"api/bandit/datasets/BanditDataset/#attributes","title":"Attributes","text":"<ul> <li> <p>arms</p> <p>The list of arms that can be pulled.</p> </li> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/bandit/datasets/BanditDataset/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/bandit/datasets/NewsArticles/","title":"NewsArticles","text":"<p>News articles bandit dataset.</p> <p>This is a personalization dataset. It contains 10000 observations. There are 10 arms, and the reward is binary. There are 100 features, which turns this into a contextual bandit problem.</p>"},{"location":"api/bandit/datasets/NewsArticles/#attributes","title":"Attributes","text":"<ul> <li> <p>arms</p> <p>The list of arms that can be pulled.</p> </li> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/bandit/datasets/NewsArticles/#examples","title":"Examples","text":"<p><pre><code>from river import bandit\n\ndataset = bandit.datasets.NewsArticles()\ncontext, arm, reward = next(iter(dataset))\n\nlen(context)\n</code></pre> <pre><code>100\n</code></pre></p> <p><pre><code>arm, reward\n</code></pre> <pre><code>(2, False)\n</code></pre></p>"},{"location":"api/bandit/datasets/NewsArticles/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Machine Learning for Personalization homework \u21a9</p> </li> <li> <p>Contextual Bandits Analysis of LinUCB Disjoint Algorithm with Dataset \u21a9</p> </li> </ol>"},{"location":"api/bandit/envs/CandyCaneContest/","title":"CandyCaneContest","text":"<p>Candy cane contest Kaggle competition.</p>"},{"location":"api/bandit/envs/CandyCaneContest/#parameters","title":"Parameters","text":"<ul> <li> <p>n_machines</p> <p>Default \u2192 <code>100</code></p> <p>Number of vending machines.</p> </li> <li> <p>reward_decay</p> <p>Default \u2192 <code>0.03</code></p> <p>The multiplicate rate at which the expected reward of each vending machine decays.</p> </li> </ul>"},{"location":"api/bandit/envs/CandyCaneContest/#attributes","title":"Attributes","text":"<ul> <li> <p>np_random</p> <p>Returns the environment's internal :attr:<code>_np_random</code> that if not set will initialise with a random seed.  Returns:     Instances of <code>np.random.Generator</code></p> </li> <li> <p>render_mode</p> </li> <li> <p>spec</p> </li> <li> <p>unwrapped</p> <p>Returns the base non-wrapped environment.  Returns:     Env: The base non-wrapped :class:<code>gymnasium.Env</code> instance</p> </li> </ul>"},{"location":"api/bandit/envs/CandyCaneContest/#examples","title":"Examples","text":"<p><pre><code>import gymnasium as gym\nfrom river import stats\n\nenv = gym.make('river_bandits/CandyCaneContest-v0')\n_ = env.reset(seed=42)\n_ = env.action_space.seed(123)\n\nmetric = stats.Sum()\nwhile True:\n    arm = env.action_space.sample()\n    observation, reward, terminated, truncated, info = env.step(arm)\n    metric.update(reward)\n    if terminated or truncated:\n        break\n\nmetric\n</code></pre> <pre><code>Sum: 734.\n</code></pre></p>"},{"location":"api/bandit/envs/CandyCaneContest/#methods","title":"Methods","text":"close <p>After the user has finished using the environment, close contains the code necessary to \"clean up\" the environment.</p> <p>This is critical for closing rendering windows, database or HTTP connections. Calling <code>close</code> on an already closed environment has no effect and won't raise an error.</p> <p></p> get_wrapper_attr <p>Gets the attribute <code>name</code> from the environment.</p> <p>Parameters</p> <ul> <li>name     \u2014 'str' </li> </ul> <p></p> render <p>Compute the render frames as specified by :attr:<code>render_mode</code> during the initialization of the environment.</p> <p>The environment's :attr:<code>metadata</code> render modes (<code>env.metadata[\"render_modes\"]</code>) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through <code>gymnasium.make</code> which automatically applies a wrapper to collect rendered frames.  Note:     As the :attr:<code>render_mode</code> is known during <code>__init__</code>, the objects used to render the environment state     should be initialised in <code>__init__</code>.  By convention, if the :attr:<code>render_mode</code> is:  - None (default): no render is computed. - \"human\": The environment is continuously rendered in the current display or terminal, usually for human consumption.   This rendering should occur during :meth:<code>step</code> and :meth:<code>render</code> doesn't need to be called. Returns <code>None</code>. - \"rgb_array\": Return a single frame representing the current state of the environment.   A frame is a <code>np.ndarray</code> with shape <code>(x, y, 3)</code> representing RGB values for an x-by-y pixel image. - \"ansi\": Return a strings (<code>str</code>) or <code>StringIO.StringIO</code> containing a terminal-style text representation   for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). - \"rgb_array_list\" and \"ansi_list\": List based version of render modes are possible (except Human) through the   wrapper, :py:class:<code>gymnasium.wrappers.RenderCollection</code> that is automatically applied during <code>gymnasium.make(..., render_mode=\"rgb_array_list\")</code>.   The frames collected are popped after :meth:<code>render</code> is called or :meth:<code>reset</code>.  Note:     Make sure that your class's :attr:<code>metadata</code> <code>\"render_modes\"</code> key includes the list of supported modes.  .. versionchanged:: 0.25.0      The render function was changed to no longer accept parameters, rather these parameters should be specified     in the environment initialised, i.e., <code>gymnasium.make(\"CartPole-v1\", render_mode=\"human\")</code></p> <p></p> reset <p>Resets the environment to an initial internal state, returning an initial observation and info.</p> <p>This method generates a new starting state often with some randomness to ensure that the agent explores the state space and learns a generalised policy about the environment. This randomness can be controlled with the <code>seed</code> parameter otherwise if the environment already has a random number generator and :meth:<code>reset</code> is called with <code>seed=None</code>, the RNG is not reset.  Therefore, :meth:<code>reset</code> should (in the typical use case) be called with a seed right after initialization and then never again.  For Custom environments, the first line of :meth:<code>reset</code> should be <code>super().reset(seed=seed)</code> which implements the seeding correctly.  .. versionchanged:: v0.25      The <code>return_info</code> parameter was removed and now info is expected to be returned.  Args:     seed (optional int): The seed that is used to initialize the environment's PRNG (<code>np_random</code>).         If the environment does not already have a PRNG and <code>seed=None</code> (the default option) is passed,         a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom).         However, if the environment already has a PRNG and <code>seed=None</code> is passed, the PRNG will not be reset.         If you pass an integer, the PRNG will be reset even if it already exists.         Usually, you want to pass an integer right after the environment has been initialized and then never again.         Please refer to the minimal example above to see this paradigm in action.     options (optional dict): Additional information to specify how the environment is reset (optional,         depending on the specific environment)  Returns:     observation (ObsType): Observation of the initial state. This will be an element of :attr:<code>observation_space</code>         (typically a numpy array) and is analogous to the observation returned by :meth:<code>step</code>.     info (dictionary):  This dictionary contains auxiliary information complementing <code>observation</code>. It should be analogous to         the <code>info</code> returned by :meth:<code>step</code>.</p> <p>Parameters</p> <ul> <li>seed     \u2014 'int | None'     \u2014 defaults to <code>None</code> </li> <li>options     \u2014 'dict[str, Any] | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> step <p>Run one timestep of the environment's dynamics using the agent actions.</p> <p>When the end of an episode is reached (<code>terminated or truncated</code>), it is necessary to call :meth:<code>reset</code> to reset this environment's state for the next episode.  .. versionchanged:: 0.26      The Step API was changed removing <code>done</code> in favor of <code>terminated</code> and <code>truncated</code> to make it clearer     to users when the environment had terminated or truncated which is critical for reinforcement learning     bootstrapping algorithms.  Args:     action (ActType): an action provided by the agent to update the environment state.  Returns:     observation (ObsType): An element of the environment's :attr:<code>observation_space</code> as the next observation due to the agent actions.         An example is a numpy array containing the positions and velocities of the pole in CartPole.     reward (SupportsFloat): The reward as a result of taking the action.     terminated (bool): Whether the agent reaches the terminal state (as defined under the MDP of the task)         which can be positive or negative. An example is reaching the goal state or moving into the lava from         the Sutton and Barton, Gridworld. If true, the user needs to call :meth:<code>reset</code>.     truncated (bool): Whether the truncation condition outside the scope of the MDP is satisfied.         Typically, this is a timelimit, but could also be used to indicate an agent physically going out of bounds.         Can be used to end the episode prematurely before a terminal state is reached.         If true, the user needs to call :meth:<code>reset</code>.     info (dict): Contains auxiliary diagnostic information (helpful for debugging, learning, and logging).         This might, for instance, contain: metrics that describe the agent's performance state, variables that are         hidden from observations, or individual reward terms that are combined to produce the total reward.         In OpenAI Gym &lt;v26, it contains \"TimeLimit.truncated\" to distinguish truncation and termination,         however this is deprecated in favour of returning terminated and truncated variables.     done (bool): (Deprecated) A boolean value for if the episode has ended, in which case further :meth:<code>step</code> calls will         return undefined results. This was removed in OpenAI Gym v26 in favor of terminated and truncated attributes.         A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully,         a certain timelimit was exceeded, or the physics simulation has entered an invalid state.</p> <p>Parameters</p> <ul> <li>machine_index </li> </ul> <p></p> <ol> <li> <p>Santa 2020 - The Candy Cane Contest \u21a9</p> </li> </ol>"},{"location":"api/bandit/envs/KArmedTestbed/","title":"KArmedTestbed","text":"<p>k-armed testbed.</p> <p>This is a simple environment that can be used to test bandit algorithms. It is based on the 10 armed testbed described in the book \"Reinforcement Learning: An Introduction\" by Sutton and Barto.</p>"},{"location":"api/bandit/envs/KArmedTestbed/#parameters","title":"Parameters","text":"<ul> <li> <p>k</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>Number of arms.</p> </li> </ul>"},{"location":"api/bandit/envs/KArmedTestbed/#attributes","title":"Attributes","text":"<ul> <li> <p>np_random</p> <p>Returns the environment's internal :attr:<code>_np_random</code> that if not set will initialise with a random seed.  Returns:     Instances of <code>np.random.Generator</code></p> </li> <li> <p>render_mode</p> </li> <li> <p>spec</p> </li> <li> <p>unwrapped</p> <p>Returns the base non-wrapped environment.  Returns:     Env: The base non-wrapped :class:<code>gymnasium.Env</code> instance</p> </li> </ul>"},{"location":"api/bandit/envs/KArmedTestbed/#methods","title":"Methods","text":"close <p>After the user has finished using the environment, close contains the code necessary to \"clean up\" the environment.</p> <p>This is critical for closing rendering windows, database or HTTP connections. Calling <code>close</code> on an already closed environment has no effect and won't raise an error.</p> <p></p> get_wrapper_attr <p>Gets the attribute <code>name</code> from the environment.</p> <p>Parameters</p> <ul> <li>name     \u2014 'str' </li> </ul> <p></p> render <p>Compute the render frames as specified by :attr:<code>render_mode</code> during the initialization of the environment.</p> <p>The environment's :attr:<code>metadata</code> render modes (<code>env.metadata[\"render_modes\"]</code>) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through <code>gymnasium.make</code> which automatically applies a wrapper to collect rendered frames.  Note:     As the :attr:<code>render_mode</code> is known during <code>__init__</code>, the objects used to render the environment state     should be initialised in <code>__init__</code>.  By convention, if the :attr:<code>render_mode</code> is:  - None (default): no render is computed. - \"human\": The environment is continuously rendered in the current display or terminal, usually for human consumption.   This rendering should occur during :meth:<code>step</code> and :meth:<code>render</code> doesn't need to be called. Returns <code>None</code>. - \"rgb_array\": Return a single frame representing the current state of the environment.   A frame is a <code>np.ndarray</code> with shape <code>(x, y, 3)</code> representing RGB values for an x-by-y pixel image. - \"ansi\": Return a strings (<code>str</code>) or <code>StringIO.StringIO</code> containing a terminal-style text representation   for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). - \"rgb_array_list\" and \"ansi_list\": List based version of render modes are possible (except Human) through the   wrapper, :py:class:<code>gymnasium.wrappers.RenderCollection</code> that is automatically applied during <code>gymnasium.make(..., render_mode=\"rgb_array_list\")</code>.   The frames collected are popped after :meth:<code>render</code> is called or :meth:<code>reset</code>.  Note:     Make sure that your class's :attr:<code>metadata</code> <code>\"render_modes\"</code> key includes the list of supported modes.  .. versionchanged:: 0.25.0      The render function was changed to no longer accept parameters, rather these parameters should be specified     in the environment initialised, i.e., <code>gymnasium.make(\"CartPole-v1\", render_mode=\"human\")</code></p> <p></p> reset <p>Resets the environment to an initial internal state, returning an initial observation and info.</p> <p>This method generates a new starting state often with some randomness to ensure that the agent explores the state space and learns a generalised policy about the environment. This randomness can be controlled with the <code>seed</code> parameter otherwise if the environment already has a random number generator and :meth:<code>reset</code> is called with <code>seed=None</code>, the RNG is not reset.  Therefore, :meth:<code>reset</code> should (in the typical use case) be called with a seed right after initialization and then never again.  For Custom environments, the first line of :meth:<code>reset</code> should be <code>super().reset(seed=seed)</code> which implements the seeding correctly.  .. versionchanged:: v0.25      The <code>return_info</code> parameter was removed and now info is expected to be returned.  Args:     seed (optional int): The seed that is used to initialize the environment's PRNG (<code>np_random</code>).         If the environment does not already have a PRNG and <code>seed=None</code> (the default option) is passed,         a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom).         However, if the environment already has a PRNG and <code>seed=None</code> is passed, the PRNG will not be reset.         If you pass an integer, the PRNG will be reset even if it already exists.         Usually, you want to pass an integer right after the environment has been initialized and then never again.         Please refer to the minimal example above to see this paradigm in action.     options (optional dict): Additional information to specify how the environment is reset (optional,         depending on the specific environment)  Returns:     observation (ObsType): Observation of the initial state. This will be an element of :attr:<code>observation_space</code>         (typically a numpy array) and is analogous to the observation returned by :meth:<code>step</code>.     info (dictionary):  This dictionary contains auxiliary information complementing <code>observation</code>. It should be analogous to         the <code>info</code> returned by :meth:<code>step</code>.</p> <p>Parameters</p> <ul> <li>seed     \u2014 'int | None'     \u2014 defaults to <code>None</code> </li> <li>options     \u2014 'dict[str, Any] | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> step <p>Run one timestep of the environment's dynamics using the agent actions.</p> <p>When the end of an episode is reached (<code>terminated or truncated</code>), it is necessary to call :meth:<code>reset</code> to reset this environment's state for the next episode.  .. versionchanged:: 0.26      The Step API was changed removing <code>done</code> in favor of <code>terminated</code> and <code>truncated</code> to make it clearer     to users when the environment had terminated or truncated which is critical for reinforcement learning     bootstrapping algorithms.  Args:     action (ActType): an action provided by the agent to update the environment state.  Returns:     observation (ObsType): An element of the environment's :attr:<code>observation_space</code> as the next observation due to the agent actions.         An example is a numpy array containing the positions and velocities of the pole in CartPole.     reward (SupportsFloat): The reward as a result of taking the action.     terminated (bool): Whether the agent reaches the terminal state (as defined under the MDP of the task)         which can be positive or negative. An example is reaching the goal state or moving into the lava from         the Sutton and Barton, Gridworld. If true, the user needs to call :meth:<code>reset</code>.     truncated (bool): Whether the truncation condition outside the scope of the MDP is satisfied.         Typically, this is a timelimit, but could also be used to indicate an agent physically going out of bounds.         Can be used to end the episode prematurely before a terminal state is reached.         If true, the user needs to call :meth:<code>reset</code>.     info (dict): Contains auxiliary diagnostic information (helpful for debugging, learning, and logging).         This might, for instance, contain: metrics that describe the agent's performance state, variables that are         hidden from observations, or individual reward terms that are combined to produce the total reward.         In OpenAI Gym &lt;v26, it contains \"TimeLimit.truncated\" to distinguish truncation and termination,         however this is deprecated in favour of returning terminated and truncated variables.     done (bool): (Deprecated) A boolean value for if the episode has ended, in which case further :meth:<code>step</code> calls will         return undefined results. This was removed in OpenAI Gym v26 in favor of terminated and truncated attributes.         A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully,         a certain timelimit was exceeded, or the physics simulation has entered an invalid state.</p> <p>Parameters</p> <ul> <li>arm </li> </ul> <p></p>"},{"location":"api/base/Base/","title":"Base","text":"<p>Base class that is inherited by the majority of classes in River.</p> <p>This base class allows us to handle the following tasks in a uniform manner: </p> <ul> <li> <p>Getting and setting parameters</p> </li> <li> <p>Displaying information</p> </li> <li> <p>Mutating/cloning</p> </li> </ul>"},{"location":"api/base/Base/#methods","title":"Methods","text":"clone <p>Return a fresh estimator with the same parameters.</p> <p>The clone has the same parameters but has not been updated with any data.  This works by looking at the parameters from the class signature. Each parameter is either  - recursively cloned if its a class. - deep-copied via <code>copy.deepcopy</code> if not.  If the calling object is stochastic (i.e. it accepts a seed parameter) and has not been seeded, then the clone will not be idempotent. Indeed, this method's purpose if simply to return a new instance with the same input parameters.</p> <p>Parameters</p> <ul> <li>new_params     \u2014 'dict[str, typing.Any] | None'     \u2014 defaults to <code>None</code> </li> <li>include_attributes     \u2014 'bool'     \u2014 defaults to <code>False</code> </li> </ul> <p></p> mutate <p>Modify attributes.</p> <p>This changes parameters inplace. Although you can change attributes yourself, this is the recommended way to proceed. By default, all attributes are immutable, meaning they shouldn't be mutated. Calling <code>mutate</code> on an immutable attribute raises a <code>ValueError</code>. Mutable attributes are specified via the <code>_mutable_attributes</code> property, and are thus specified on a per-estimator basis.</p> <p>Parameters</p> <ul> <li>new_attrs     \u2014 'dict[str, typing.Any]' </li> </ul> <p></p>"},{"location":"api/base/BaseTransformer/","title":"BaseTransformer","text":""},{"location":"api/base/BaseTransformer/#methods","title":"Methods","text":"transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/base/BinaryDriftAndWarningDetector/","title":"BinaryDriftAndWarningDetector","text":"<p>A binary drift detector that is also capable of issuing warnings.</p>"},{"location":"api/base/BinaryDriftAndWarningDetector/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/base/BinaryDriftAndWarningDetector/#methods","title":"Methods","text":"update <p>Update the detector with a single boolean input.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p></p>"},{"location":"api/base/BinaryDriftDetector/","title":"BinaryDriftDetector","text":"<p>A drift detector for binary data.</p>"},{"location":"api/base/BinaryDriftDetector/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/base/BinaryDriftDetector/#methods","title":"Methods","text":"update <p>Update the detector with a single boolean input.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p></p>"},{"location":"api/base/Classifier/","title":"Classifier","text":"<p>A classifier.</p>"},{"location":"api/base/Classifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/base/Clusterer/","title":"Clusterer","text":"<p>A clustering model.</p>"},{"location":"api/base/Clusterer/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> </ul> <p></p> predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p> <p></p>"},{"location":"api/base/DriftAndWarningDetector/","title":"DriftAndWarningDetector","text":"<p>A drift detector that is also capable of issuing warnings.</p>"},{"location":"api/base/DriftAndWarningDetector/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/base/DriftAndWarningDetector/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'int | float' </li> </ul> <p></p>"},{"location":"api/base/DriftDetector/","title":"DriftDetector","text":"<p>A drift detector.</p>"},{"location":"api/base/DriftDetector/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/base/DriftDetector/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'int | float' </li> </ul> <p></p>"},{"location":"api/base/Ensemble/","title":"Ensemble","text":"<p>An ensemble is a model which is composed of a list of models.</p>"},{"location":"api/base/Ensemble/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>Type \u2192 Iterator[T]</p> </li> </ul>"},{"location":"api/base/Ensemble/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/base/Ensemble/#methods","title":"Methods","text":"append <p>S.append(value) -- append value to the end of the sequence</p> <p>Parameters</p> <ul> <li>item </li> </ul> <p></p> clear <p>S.clear() -&gt; None -- remove all items from S</p> <p></p> copy count <p>S.count(value) -&gt; integer -- return number of occurrences of value</p> <p>Parameters</p> <ul> <li>item </li> </ul> <p></p> extend <p>S.extend(iterable) -- extend sequence by appending elements from the iterable</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> index <p>S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. Raises ValueError if the value is not present.</p> <p>Supporting start and stop arguments is optional, but recommended.</p> <p>Parameters</p> <ul> <li>item </li> <li>args </li> </ul> <p></p> insert <p>S.insert(index, value) -- insert value before index</p> <p>Parameters</p> <ul> <li>i </li> <li>item </li> </ul> <p></p> pop <p>S.pop([index]) -&gt; item -- remove and return item at index (default last). Raise IndexError if list is empty or index is out of range.</p> <p>Parameters</p> <ul> <li>i     \u2014 defaults to <code>-1</code> </li> </ul> <p></p> remove <p>S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present.</p> <p>Parameters</p> <ul> <li>item </li> </ul> <p></p> reverse <p>S.reverse() -- reverse IN PLACE</p> <p></p> sort"},{"location":"api/base/Estimator/","title":"Estimator","text":"<p>An estimator.</p>"},{"location":"api/base/Estimator/#methods","title":"Methods","text":""},{"location":"api/base/MiniBatchClassifier/","title":"MiniBatchClassifier","text":"<p>A classifier that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchClassifier/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and boolean targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> </ul> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_many <p>Predict the outcome probabilities for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A dataframe with probabilities of <code>True</code> and <code>False</code> for each sample.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/base/MiniBatchRegressor/","title":"MiniBatchRegressor","text":"<p>A regressor that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchRegressor/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and real-valued targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> </ul> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted outcomes.</p> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/base/MiniBatchSupervisedTransformer/","title":"MiniBatchSupervisedTransformer","text":"<p>A supervised transformer that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchSupervisedTransformer/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/base/MiniBatchTransformer/","title":"MiniBatchTransformer","text":"<p>A transform that can operate on mini-batches.</p>"},{"location":"api/base/MiniBatchTransformer/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/base/MultiLabelClassifier/","title":"MultiLabelClassifier","text":"<p>Multi-label classifier.</p>"},{"location":"api/base/MultiLabelClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and the labels <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>y     \u2014 'dict[FeatureName, bool]' </li> </ul> <p></p> predict_one <p>Predict the labels of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[FeatureName, bool]:     The predicted labels.</p> <p></p> predict_proba_one <p>Predict the probability of each label appearing given dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[FeatureName, dict[bool, float]]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/base/MultiTargetRegressor/","title":"MultiTargetRegressor","text":"<p>Multi-target regressor.</p>"},{"location":"api/base/MultiTargetRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>y     \u2014 'dict[FeatureName, RegTarget]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p></p> predict_one <p>Predict the outputs of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> </ul> <p>Returns</p> <p>dict[FeatureName, RegTarget]:     The predictions.</p> <p></p>"},{"location":"api/base/Regressor/","title":"Regressor","text":"<p>A regressor.</p>"},{"location":"api/base/Regressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/base/SupervisedTransformer/","title":"SupervisedTransformer","text":"<p>A supervised transformer.</p>"},{"location":"api/base/SupervisedTransformer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code> and a target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/base/Transformer/","title":"Transformer","text":"<p>A transformer.</p>"},{"location":"api/base/Transformer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/base/Wrapper/","title":"Wrapper","text":"<p>A wrapper model.</p>"},{"location":"api/base/WrapperEnsemble/","title":"WrapperEnsemble","text":"<p>A wrapper ensemble is an ensemble composed of multiple copies of the same model.</p>"},{"location":"api/base/WrapperEnsemble/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 T</p> <p>The model to copy.</p> </li> <li> <p>n_models</p> <p>Type \u2192 int</p> <p>The number of copies to make.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/base/WrapperEnsemble/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/base/WrapperEnsemble/#methods","title":"Methods","text":""},{"location":"api/cluster/CluStream/","title":"CluStream","text":"<p>CluStream</p> <p>The CluStream algorithm <sup>1</sup> maintains statistical information about the data using micro-clusters. These micro-clusters are temporal extensions of cluster feature vectors. The micro-clusters are stored at snapshots in time following a pyramidal pattern. This pattern allows to recall summary statistics from different time horizons. </p> <p>Training with a new point <code>p</code> is performed in two main tasks: </p> <ul> <li> <p>Determinate the closest micro-cluster to <code>p</code>. </p> </li> <li> <p>Check whether <code>p</code> fits (memory) into the closest micro-cluster: </p> <ul> <li> <p>if <code>p</code> fits, put into micro-cluster</p> </li> <li> <p>if <code>p</code> does not fit, free some space to insert a new micro-cluster.</p> </li> </ul> <p>This is done in two ways, delete an old micro-cluster or merge the       two micro-clusters closest to each other. </p> </li> </ul> <p>This implementation is an improved version from the original algorithm. Instead of calculating the traditional cluster feature vector of the number of observations, linear sum and sum of squares of data points and time stamps, this implementation adopts the use of Welford's algorithm <sup>2</sup> to calculate the incremental variance, facilitated through <code>stats.Var</code> available within River. </p> <p>Since River does not support an actual \"off-line\" phase of the clustering algorithm (as data points are assumed to arrive continuously, one at a time), a <code>time_gap</code> parameter is introduced. After each <code>time_gap</code>, an incremental K-Means clustering algorithm will be initialized and applied on currently available micro-clusters to form the final solution, i.e. macro-clusters.</p>"},{"location":"api/cluster/CluStream/#parameters","title":"Parameters","text":"<ul> <li> <p>n_macro_clusters</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The number of clusters (k) for the k-means algorithm.</p> </li> <li> <p>max_micro_clusters</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>100</code></p> <p>The maximum number of micro-clusters to use.</p> </li> <li> <p>micro_cluster_r_factor</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2</code></p> <p>Multiplier for the micro-cluster radius. When deciding to add a new data point to a micro-cluster, the maximum boundary is defined as a factor of the <code>micro_cluster_r_factor</code> of the RMS deviation of the data points in the micro-cluster from the centroid.</p> </li> <li> <p>time_window</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000</code></p> <p>If the current time is <code>T</code> and the time window is <code>h</code>, we only consider the data that arrived within the period <code>(T-h,T)</code>.</p> </li> <li> <p>time_gap</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>100</code></p> <p>An incremental k-means is applied on the current set of micro-clusters after each <code>time_gap</code> to form the final macro-cluster solution.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed used for generating initial centroid positions.</p> </li> <li> <p>kwargs</p> <p>Other parameters passed to the incremental kmeans at <code>cluster.KMeans</code>.</p> </li> </ul>"},{"location":"api/cluster/CluStream/#attributes","title":"Attributes","text":"<ul> <li> <p>centers (dict)</p> <p>Central positions of each cluster.</p> </li> </ul>"},{"location":"api/cluster/CluStream/#examples","title":"Examples","text":"<p>In the following example, <code>max_micro_clusters</code> is set relatively low due to the limited number of training points. Moreover, all points are learnt before any predictions are made. The <code>halflife</code> is set at 0.4, to show that you can pass <code>cluster.KMeans</code> parameters via keyword arguments.</p> <p><pre><code>from river import cluster\nfrom river import stream\n\nX = [\n    [1, 2],\n    [1, 4],\n    [1, 0],\n    [-4, 2],\n    [-4, 4],\n    [-4, 0],\n    [5, 0],\n    [5, 2],\n    [5, 4]\n]\n\nclustream = cluster.CluStream(\n    n_macro_clusters=3,\n    max_micro_clusters=5,\n    time_gap=3,\n    seed=0,\n    halflife=0.4\n)\n\nfor x, _ in stream.iter_array(X):\n    clustream.learn_one(x)\n\nclustream.predict_one({0: 1, 1: 1})\n</code></pre> <pre><code>1\n</code></pre></p> <p><pre><code>clustream.predict_one({0: -4, 1: 3})\n</code></pre> <pre><code>2\n</code></pre></p> <p><pre><code>clustream.predict_one({0: 4, 1: 3.5})\n</code></pre> <pre><code>0\n</code></pre></p>"},{"location":"api/cluster/CluStream/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p> <p></p> <ol> <li> <p>Aggarwal, C.C., Philip, S.Y., Han, J. and Wang, J., 2003, A framework for clustering evolving data streams. In Proceedings 2003 VLDB conference (pp. 81-92). Morgan Kaufmann.\u00a0\u21a9</p> </li> <li> <p>Chan, T.F., Golub, G.H. and LeVeque, R.J., 1982. Updating formulae and a pairwise algorithm for computing sample variances. In COMPSTAT 1982 5th Symposium held at Toulouse 1982 (pp. 30-41). Physica, Heidelberg. https://doi.org/10.1007/978-3-642-51461-6_3.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/DBSTREAM/","title":"DBSTREAM","text":"<p>DBSTREAM</p> <p>DBSTREAM <sup>1</sup> is a clustering algorithm for evolving data streams. It is the first micro-cluster-based online clustering component that explicitly captures the density between micro-clusters via a shared density graph. The density information in the graph is then exploited for reclustering based on actual density between adjacent micro clusters. </p> <p>The algorithm is divided into two parts: </p> <p>Online micro-cluster maintenance (learning) </p> <p>For a new point <code>p</code>: </p> <ul> <li> <p>Find all micro clusters for which <code>p</code> falls within the fixed radius (clustering threshold). If no neighbor is found, a new micro cluster with a weight of 1 is created for <code>p</code>. </p> </li> <li> <p>If no neighbor is found, a new micro cluster with a weight of 1 is created for <code>p</code>. If one or more neighbors of <code>p</code> are found, we update the micro clusters by applying the appropriate fading, increasing their weight and then we try to move them closer to <code>p</code> using the Gaussian neighborhood function. </p> </li> <li> <p>Next, the shared density graph is updated. To prevent collapsing micro clusters, we will restrict the movement for micro clusters in case they come closer than \\(r\\) (clustering threshold) to each other. Finishing this process, the time stamp is also increased by 1. </p> </li> <li> <p>Finally, the cleanup will be processed. It is executed every <code>t_gap</code> time steps, removing weak micro clusters and weak entries in the shared density graph to recover memory and improve the clustering algorithm's processing speed. </p> </li> </ul> <p>Offline generation of macro clusters (clustering) </p> <p>The offline generation of macro clusters is generated through the two following steps: </p> <ul> <li> <p>The connectivity graph <code>C</code> is constructed using shared density entries between strong micro clusters. The edges in this connectivity graph with a connectivity value greater than the intersection threshold (\\(\\alpha\\)) are used to find connected components representing the final cluster. </p> </li> <li> <p>After the connectivity graph is generated, a variant of the DBSCAN algorithm proposed by Ester et al. is applied to form all macro clusters from \\(\\alpha\\)-connected micro clusters.</p> </li> </ul>"},{"location":"api/cluster/DBSTREAM/#parameters","title":"Parameters","text":"<ul> <li> <p>clustering_threshold</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>DBStream represents each micro cluster by a leader (a data point defining the micro cluster's center) and the density in an area of a user-specified radius \\(r\\) (<code>clustering_threshold</code>) around the center.</p> </li> <li> <p>fading_factor</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>Parameter that controls the importance of historical data to current cluster. Note that <code>fading_factor</code> has to be different from <code>0</code>.</p> </li> <li> <p>cleanup_interval</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>2</code></p> <p>The time interval between two consecutive time points when the cleanup process is  conducted.</p> </li> <li> <p>intersection_factor</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.3</code></p> <p>The intersection factor related to the area of the overlap of the micro clusters relative to the area cover by micro clusters. This parameter is used to determine whether a micro cluster or a shared density is weak.</p> </li> <li> <p>minimum_weight</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>The minimum weight for a cluster to be not \"noisy\".</p> </li> </ul>"},{"location":"api/cluster/DBSTREAM/#attributes","title":"Attributes","text":"<ul> <li> <p>n_clusters</p> <p>Number of clusters generated by the algorithm.</p> </li> <li> <p>clusters</p> <p>A set of final clusters of type <code>DBStreamMicroCluster</code>. However, these are either micro clusters, or macro clusters that are generated by merging all \\(\\alpha\\)-connected micro clusters. This set is generated through the offline phase of the algorithm.</p> </li> <li> <p>centers</p> <p>Final clusters' centers.</p> </li> <li> <p>micro_clusters</p> <p>Micro clusters generated by the algorithm. Instead of updating directly the new instance points into a nearest micro cluster, through each iteration, the weight and center will be modified so that the clusters are closer to the new points, using the Gaussian neighborhood function.</p> </li> </ul>"},{"location":"api/cluster/DBSTREAM/#examples","title":"Examples","text":"<p><pre><code>from river import cluster\nfrom river import stream\n\nX = [\n    [1, 0.5], [1, 0.625], [1, 0.75], [1, 1.125], [1, 1.5], [1, 1.75],\n    [4, 1.5], [4, 2.25], [4, 2.5], [4, 3], [4, 3.25], [4, 3.5]\n]\n\ndbstream = cluster.DBSTREAM(\n    clustering_threshold=1.5,\n    fading_factor=0.05,\n    cleanup_interval=4,\n    intersection_factor=0.5,\n    minimum_weight=1\n)\n\nfor x, _ in stream.iter_array(X):\n    dbstream.learn_one(x)\n\ndbstream.predict_one({0: 1, 1: 2})\n</code></pre> <pre><code>0\n</code></pre></p> <p><pre><code>dbstream.predict_one({0: 5, 1: 2})\n</code></pre> <pre><code>1\n</code></pre></p> <p><pre><code>dbstream._n_clusters\n</code></pre> <pre><code>2\n</code></pre></p>"},{"location":"api/cluster/DBSTREAM/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p> <p></p> <ol> <li> <p>Michael Hahsler and Matthew Bolanos (2016, pp 1449-1461). Clustering Data Streams Based on   Shared Density between Micro-Clusters, IEEE Transactions on Knowledge and Data Engineering 28(6) .   In Proceedings of the Sixth SIAM International Conference on Data Mining,   April 20\u201322, 2006, Bethesda, MD, USA.\u00a0\u21a9</p> </li> <li> <p>Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases   with Noise. In KDD-96 Proceedings, AAAI.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/DenStream/","title":"DenStream","text":"<p>DenStream</p> <p>DenStream <sup>1</sup> is a clustering algorithm for evolving data streams. DenStream can discover clusters with arbitrary shape and is robust against noise (outliers). </p> <p>\"Dense\" micro-clusters (named core-micro-clusters) summarise the clusters of arbitrary shape. A pruning strategy based on the concepts of potential and outlier micro-clusters guarantees the precision of the weights of the micro-clusters with limited memory. </p> <p>The algorithm is divided into two parts: </p> <p>Online micro-cluster maintenance (learning) </p> <p>For a new point <code>p</code>: </p> <ul> <li> <p>Try to merge <code>p</code> into either the nearest <code>p-micro-cluster</code> (potential), <code>o-micro-cluster</code> (outlier), or create a new <code>o-micro-cluster</code> and insert it into the outlier buffer. </p> </li> <li> <p>For each <code>T_p</code> iterations, consider the weights of all potential and outlier micro-clusters. If their weights are smaller than a certain threshold (different for each type of micro-clusters), the micro-cluster is deleted. </p> </li> </ul> <p>Offline generation of clusters on-demand (clustering) </p> <p>A variant of the DBSCAN algorithm <sup>2</sup> is used, such that all density-connected p-micro-clusters determine the final clusters. Moreover, in order for the algorithm to always be able to generate clusters, a certain number of points must be passed through the algorithm with a suitable streaming speed (number of points passed through within a unit time), indicated by <code>n_samples_init</code> and <code>stream_speed</code>.</p>"},{"location":"api/cluster/DenStream/#parameters","title":"Parameters","text":"<ul> <li> <p>decaying_factor</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.25</code></p> <p>Parameter that controls the importance of historical data to current cluster. Note that <code>decaying_factor</code> has to be different from <code>0</code>.</p> </li> <li> <p>beta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.75</code></p> <p>Parameter to determine the threshold of outlier relative to core micro-clusters. The value of <code>beta</code> must be within the range <code>(0,1]</code>.</p> </li> <li> <p>mu</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>2</code></p> <p>Parameter to determine the threshold of outliers relative to core micro-cluster. As <code>beta * mu</code> must be greater than 1, <code>mu</code> must be within the range <code>(1/beta, inf)</code>.</p> </li> <li> <p>epsilon</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.02</code></p> <p>Defines the epsilon neighborhood</p> </li> <li> <p>n_samples_init</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000</code></p> <p>Number of points to to initiqalize the online process</p> </li> <li> <p>stream_speed</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>100</code></p> <p>Number of points arrived in unit time</p> </li> </ul>"},{"location":"api/cluster/DenStream/#attributes","title":"Attributes","text":"<ul> <li> <p>n_clusters</p> <p>Number of clusters generated by the algorithm.</p> </li> <li> <p>clusters</p> <p>A set of final clusters of type <code>MicroCluster</code>, which means that these cluster include all the required information, including number of points, creation time, weight, (weighted) linear sum, (weighted) square sum, center and radius.</p> </li> <li> <p>p_micro_clusters</p> <p>The potential core-icro-clusters that are generated by the algorithm. When a generate cluster request arrives, these p-micro-clusters will go through a variant of the DBSCAN algorithm to determine the final clusters.</p> </li> <li> <p>o_micro_clusters</p> <p>The outlier micro-clusters.</p> </li> </ul>"},{"location":"api/cluster/DenStream/#examples","title":"Examples","text":"<p>The following example uses the default parameters of the algorithm to test its functionality. The set of evolving points <code>X</code> are designed so that clusters are easily identifiable.</p> <p><pre><code>from river import cluster\nfrom river import stream\n\nX = [\n    [-1, -0.5], [-1, -0.625], [-1, -0.75], [-1, -1], [-1, -1.125],\n    [-1, -1.25], [-1.5, -0.5], [-1.5, -0.625], [-1.5, -0.75], [-1.5, -1],\n    [-1.5, -1.125], [-1.5, -1.25], [1, 1.5], [1, 1.75], [1, 2],\n    [4, 1.25], [4, 1.5], [4, 2.25], [4, 2.5], [4, 3],\n    [4, 3.25], [4, 3.5], [4, 3.75], [4, 4],\n]\n\ndenstream = cluster.DenStream(decaying_factor=0.01,\n                              beta=0.5,\n                              mu=2.5,\n                              epsilon=0.5,\n                              n_samples_init=10)\n\nfor x, _ in stream.iter_array(X):\n    denstream.learn_one(x)\n\ndenstream.predict_one({0: -1, 1: -2})\n</code></pre> <pre><code>1\n</code></pre></p> <p><pre><code>denstream.predict_one({0: 5, 1: 4})\n</code></pre> <pre><code>2\n</code></pre></p> <p><pre><code>denstream.predict_one({0: 1, 1: 1})\n</code></pre> <pre><code>0\n</code></pre></p> <p><pre><code>denstream.n_clusters\n</code></pre> <pre><code>3\n</code></pre></p>"},{"location":"api/cluster/DenStream/#methods","title":"Methods","text":"BufferItem learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p> <p></p> <ol> <li> <p>Feng et al (2006, pp 328-339). Density-Based Clustering over an Evolving Data Stream with   Noise. In Proceedings of the Sixth SIAM International Conference on Data Mining,   April 20\u201322, 2006, Bethesda, MD, USA.\u00a0\u21a9</p> </li> <li> <p>Ester et al (1996). A Density-Based Algorithm for Discovering Clusters in Large Spatial   Databases with Noise. In KDD-96 Proceedings, AAAI.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/KMeans/","title":"KMeans","text":"<p>Incremental k-means.</p> <p>The most common way to implement batch k-means is to use Lloyd's algorithm, which consists in assigning all the data points to a set of cluster centers and then moving the centers accordingly. This requires multiple passes over the data and thus isn't applicable in a streaming setting. </p> <p>In this implementation we start by finding the cluster that is closest to the current observation. We then move the cluster's central position towards the new observation. The <code>halflife</code> parameter determines by how much to move the cluster toward the new observation. You will get better results if you scale your data appropriately.</p>"},{"location":"api/cluster/KMeans/#parameters","title":"Parameters","text":"<ul> <li> <p>n_clusters</p> <p>Default \u2192 <code>5</code></p> <p>Maximum number of clusters to assign.</p> </li> <li> <p>halflife</p> <p>Default \u2192 <code>0.5</code></p> <p>Amount by which to move the cluster centers, a reasonable value is between 0 and 1.</p> </li> <li> <p>mu</p> <p>Default \u2192 <code>0</code></p> <p>Mean of the normal distribution used to instantiate cluster positions.</p> </li> <li> <p>sigma</p> <p>Default \u2192 <code>1</code></p> <p>Standard deviation of the normal distribution used to instantiate cluster positions.</p> </li> <li> <p>p</p> <p>Default \u2192 <code>2</code></p> <p>Power parameter for the Minkowski metric. When <code>p=1</code>, this corresponds to the Manhattan distance, while <code>p=2</code> corresponds to the Euclidean distance.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed used for generating initial centroid positions.</p> </li> </ul>"},{"location":"api/cluster/KMeans/#attributes","title":"Attributes","text":"<ul> <li> <p>centers (dict)</p> <p>Central positions of each cluster.</p> </li> </ul>"},{"location":"api/cluster/KMeans/#examples","title":"Examples","text":"<p>In the following example the cluster assignments are exactly the same as when using <code>sklearn</code>'s batch implementation. However, changing the <code>halflife</code> parameter will produce different outputs.</p> <p><pre><code>from river import cluster\nfrom river import stream\n\nX = [\n    [1, 2],\n    [1, 4],\n    [1, 0],\n    [-4, 2],\n    [-4, 4],\n    [-4, 0]\n]\n\nk_means = cluster.KMeans(n_clusters=2, halflife=0.1, sigma=3, seed=42)\n\nfor i, (x, _) in enumerate(stream.iter_array(X)):\n    k_means.learn_one(x)\n    print(f'{X[i]} is assigned to cluster {k_means.predict_one(x)}')\n</code></pre> <pre><code>[1, 2] is assigned to cluster 1\n[1, 4] is assigned to cluster 1\n[1, 0] is assigned to cluster 0\n[-4, 2] is assigned to cluster 1\n[-4, 4] is assigned to cluster 1\n[-4, 0] is assigned to cluster 0\n</code></pre></p> <p><pre><code>k_means.predict_one({0: 0, 1: 0})\n</code></pre> <pre><code>0\n</code></pre></p> <p><pre><code>k_means.predict_one({0: 4, 1: 4})\n</code></pre> <pre><code>1\n</code></pre></p>"},{"location":"api/cluster/KMeans/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> </ul> <p></p> learn_predict_one <p>Equivalent to <code>k_means.learn_one(x).predict_one(x)</code>, but faster.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p></p> predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p> <p></p> <ol> <li> <p>Sequential k-Means Clustering \u21a9</p> </li> <li> <p>Sculley, D., 2010, April. Web-scale k-means clustering. In Proceedings of the 19th international conference on World Wide Web (pp. 1177-1178) \u21a9</p> </li> </ol>"},{"location":"api/cluster/ODAC/","title":"ODAC","text":"<p>The Online Divisive-Agglomerative Clustering (ODAC)<sup>1</sup> aims at continuously maintaining a hierarchical cluster structure from evolving time series data streams.</p> <p>The distance between time-series a and b is given by <code>rnomc(a, b) = sqrt((1 - corr(a, b)) / 2)</code>, where <code>corr(a, b)</code> is the Pearson Correlation coefficient. If the cluster has only one time-series, the diameter is given by the time-series variance. The cluster's diameter is given by the largest distance between the cluster's time-series. </p> <p>ODAC continuously monitors the evolution of diameters, only of the leaves, and splits or merges them by gathering more data or reacting to concept drift - a confidence level from the Hoeffding bound supports such changes. </p> <p>So, the split operator, where the Hoeffding bound is applied, occurs when the difference between the largest distance (diameter) and the second largest difference is greater than a constant. Furthermore, the merge operator checks if one of the cluster's children has a diameter bigger than their parent - applying the Hoeffding bound again.</p>"},{"location":"api/cluster/ODAC/#parameters","title":"Parameters","text":"<ul> <li> <p>confidence_level</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.9</code></p> <p>The confidence level that user wants to work.</p> </li> <li> <p>n_min</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>100</code></p> <p>Number of minimum observations to gather before checking whether or not clusters must be split or merged.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.1</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> </ul>"},{"location":"api/cluster/ODAC/#attributes","title":"Attributes","text":"<ul> <li> <p>structure_changed (bool)</p> <p>This variable is true when the structure changed, produced by splitting or aggregation.</p> </li> </ul>"},{"location":"api/cluster/ODAC/#examples","title":"Examples","text":"<p><pre><code>from river import cluster\nfrom river.datasets import synth\n\nmodel = cluster.ODAC()\n\ndataset = synth.FriedmanDrift(drift_type='gra', position=(150, 200), seed=42)\n\nfor i, (x, _) in enumerate(dataset.take(500)):\n    model.learn_one(x)\n    if model.structure_changed:\n        print(f\"Structure changed at observation {i + 1}\")\n</code></pre> <pre><code>Structure changed at observation 1\nStructure changed at observation 100\nStructure changed at observation 200\nStructure changed at observation 300\n</code></pre></p> <p><pre><code>print(model.render_ascii())\n</code></pre> <pre><code>ROOT d1=0.79 d2=0.76 [NOT ACTIVE]\n\u251c\u2500\u2500 CH1_LVL_1 d1=0.74 d2=0.72 [NOT ACTIVE]\n\u2502   \u251c\u2500\u2500 CH1_LVL_2 d1=0.08 [3]\n\u2502   \u2514\u2500\u2500 CH2_LVL_2 d1=0.73 [2, 4]\n\u2514\u2500\u2500 CH2_LVL_1 d1=0.81 d2=0.78 [NOT ACTIVE]\n    \u251c\u2500\u2500 CH1_LVL_2 d1=0.73 d2=0.67 [NOT ACTIVE]\n    \u2502   \u251c\u2500\u2500 CH1_LVL_3 d1=0.72 [0, 9]\n    \u2502   \u2514\u2500\u2500 CH2_LVL_3 d1=0.08 [1]\n    \u2514\u2500\u2500 CH2_LVL_2 d1=0.74 d2=0.73 [NOT ACTIVE]\n        \u251c\u2500\u2500 CH1_LVL_3 d1=0.71 [5, 6]\n        \u2514\u2500\u2500 CH2_LVL_3 d1=0.71 [7, 8]\n</code></pre></p> <p>You can access some properties of the clustering model directly:</p> <p><pre><code>model.n_clusters\n</code></pre> <pre><code>11\n</code></pre></p> <p><pre><code>model.n_active_clusters\n</code></pre> <pre><code>6\n</code></pre></p> <p><pre><code>model.height\n</code></pre> <pre><code>3\n</code></pre></p> <p>These properties are also available in a summarized form:</p> <p><pre><code>model.summary\n</code></pre> <pre><code>{'n_clusters': 11, 'n_active_clusters': 6, 'height': 3}\n</code></pre></p>"},{"location":"api/cluster/ODAC/#methods","title":"Methods","text":"draw <p>Method to draw the hierarchical cluster's structure as a Graphviz graph.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code> </li> <li>show_clusters_info     \u2014 'list[typing.Hashable]'     \u2014 defaults to <code>['timeseries_names', 'd1', 'd2', 'e']</code> </li> <li>n_decimal_places     \u2014 'int'     \u2014 defaults to <code>2</code> </li> </ul> <p></p> learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> predict_one <p>This algorithm does not predict anything. It builds a hierarchical cluster's structure.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> render_ascii <p>Method to render the hierarchical cluster's structure in text format.</p> <p>Parameters</p> <ul> <li>n_decimal_places     \u2014 'int'     \u2014 defaults to <code>2</code> </li> </ul> <p></p> <ol> <li> <p>P. P. Rodrigues, J. Gama and J. Pedroso, \"Hierarchical Clustering of Time-Series Data Streams\" in IEEE Transactions on Knowledge and Data Engineering, vol. 20, no. 5, pp. 615-627, May 2008, doi: 10.1109/TKDE.2007.190727.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/STREAMKMeans/","title":"STREAMKMeans","text":"<p>STREAMKMeans</p> <p>STREAMKMeans is an alternative version of the original algorithm STREAMLSEARCH proposed by O'Callaghan et al. <sup>1</sup>, by replacing the k-medians using <code>LSEARCH</code> by the k-means algorithm. </p> <p>However, instead of using the traditional k-means, which requires a total reclustering each time the temporary chunk of data points is full, the implementation of this algorithm uses an incremental k-means. </p> <p>At first, the cluster centers are initialized with a <code>KMeans</code> instance. For a new point <code>p</code>: </p> <ul> <li> <p>If the size of chunk is less than the maximum size allowed, add the new point to the temporary chunk. </p> </li> <li> <p>When the size of chunk reaches the maximum value size allowed </p> <ul> <li>A new incremental <code>KMeans</code> instance is created. The latter will process all points in the</li> </ul> <p>temporary chunk. The centers of this new instance then become the new centers. </p> <ul> <li>All points are deleted from the temporary chunk so that new points can be added.</li> </ul> </li> <li> <p>When a prediction request arrives, the centers of the algorithm will be exactly the same as the centers of the original <code>KMeans</code> at the time of retrieval.</p> </li> </ul>"},{"location":"api/cluster/STREAMKMeans/#parameters","title":"Parameters","text":"<ul> <li> <p>chunk_size</p> <p>Default \u2192 <code>10</code></p> <p>Maximum size allowed for the temporary data chunk.</p> </li> <li> <p>n_clusters</p> <p>Default \u2192 <code>2</code></p> <p>Number of clusters generated by the algorithm.</p> </li> <li> <p>kwargs</p> <p>Other parameters passed to the incremental kmeans at <code>cluster.KMeans</code>.</p> </li> </ul>"},{"location":"api/cluster/STREAMKMeans/#attributes","title":"Attributes","text":"<ul> <li> <p>centers</p> <p>Cluster centers generated from running the incremental <code>KMeans</code> algorithm through centers of each chunk.</p> </li> </ul>"},{"location":"api/cluster/STREAMKMeans/#examples","title":"Examples","text":"<p><pre><code>from river import cluster\nfrom river import stream\n\nX = [\n    [1, 0.5], [1, 0.625], [1, 0.75], [1, 1.125], [1, 1.5], [1, 1.75],\n    [4, 1.5], [4, 2.25], [4, 2.5], [4, 3], [4, 3.25], [4, 3.5]\n]\n\nstreamkmeans = cluster.STREAMKMeans(chunk_size=3, n_clusters=2, halflife=0.5, sigma=1.5, seed=0)\n\nfor x, _ in stream.iter_array(X):\n    streamkmeans.learn_one(x)\n\nstreamkmeans.predict_one({0: 1, 1: 0})\n</code></pre> <pre><code>0\n</code></pre></p> <p><pre><code>streamkmeans.predict_one({0: 5, 1: 2})\n</code></pre> <pre><code>1\n</code></pre></p>"},{"location":"api/cluster/STREAMKMeans/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p> <p></p> <ol> <li> <p>O'Callaghan et al. (2002). Streaming-data algorithms for high-quality clustering.   In Proceedings 18th International Conference on Data Engineering, Feb 26 - March 1,   San Jose, CA, USA. DOI: 10.1109/ICDE.2002.994785.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/cluster/TextClust/","title":"TextClust","text":"<p>textClust, a clustering algorithm for text data.</p> <p>textClust <sup>1</sup><sup>2</sup> is a stream clustering algorithm for textual data that can identify and track topics over time in a stream of texts. The algorithm uses a widely popular two-phase clustering approach where the stream is first summarised in real-time. </p> <p>The result is many small preliminary clusters in the stream called <code>micro-clusters</code>. Micro-clusters maintain enough information to update and efficiently calculate the cosine similarity between them over time, based on the TF-IDF vector of their texts. Upon request, the miro-clusters can be reclustered to generate the final result using any distance-based clustering algorithm, such as hierarchical clustering. To keep the micro-clusters up-to-date, our algorithm applies a fading strategy where micro-clusters that are not updated regularly lose relevance and are eventually removed.</p>"},{"location":"api/cluster/TextClust/#parameters","title":"Parameters","text":"<ul> <li> <p>radius</p> <p>Default \u2192 <code>0.3</code></p> <p>Distance threshold to merge two micro-clusters. Must be within the range <code>(0, 1]</code></p> </li> <li> <p>fading_factor</p> <p>Default \u2192 <code>0.0005</code></p> <p>Fading factor of micro-clusters</p> </li> <li> <p>tgap</p> <p>Default \u2192 <code>100</code></p> <p>Time between outlier removal</p> </li> <li> <p>term_fading</p> <p>Default \u2192 <code>True</code></p> <p>Determines whether individual terms should also be faded</p> </li> <li> <p>real_time_fading</p> <p>Default \u2192 <code>True</code></p> <p>Parameter that specifies whether natural time or the number of observations should be used for fading</p> </li> <li> <p>micro_distance</p> <p>Default \u2192 <code>tfidf_cosine_distance</code></p> <p>Distance metric used for clustering macro-clusters</p> </li> <li> <p>macro_distance</p> <p>Default \u2192 <code>tfidf_cosine_distance</code></p> <p>Distance metric used for clustering macro-clusters</p> </li> <li> <p>num_macro</p> <p>Default \u2192 <code>3</code></p> <p>Number of macro clusters that should be identified during the reclustering phase</p> </li> <li> <p>min_weight</p> <p>Default \u2192 <code>0</code></p> <p>Minimum weight of micro clusters to be used for reclustering</p> </li> <li> <p>auto_r</p> <p>Default \u2192 <code>False</code></p> <p>Parameter that specifies if  <code>radius</code> should be automatically updated</p> </li> <li> <p>auto_merge</p> <p>Default \u2192 <code>True</code></p> <p>Determines, if close observations shall be merged together</p> </li> <li> <p>sigma</p> <p>Default \u2192 <code>1</code></p> <p>Parameter that influences the automated trheshold adaption technique</p> </li> </ul>"},{"location":"api/cluster/TextClust/#attributes","title":"Attributes","text":"<ul> <li> <p>micro_clusters</p> <p>Micro-clusters generated by the algorithm. Micro-clusters are of type <code>textclust.microcluster</code></p> </li> </ul>"},{"location":"api/cluster/TextClust/#examples","title":"Examples","text":"<p><pre><code>from river import compose\nfrom river import feature_extraction\nfrom river import metrics\nfrom river import cluster\n\ncorpus = [\n   {\"text\":'This is the first document.',\"idd\":1, \"cluster\": 1, \"cluster\":1},\n   {\"text\":'This document is the second document.',\"idd\":2,\"cluster\": 1},\n   {\"text\":'And this is super unrelated.',\"idd\":3,\"cluster\": 2},\n   {\"text\":'Is this the first document?',\"idd\":4,\"cluster\": 1},\n   {\"text\":'This is super unrelated as well',\"idd\":5,\"cluster\": 2},\n   {\"text\":'Test text',\"idd\":6,\"cluster\": 5}\n]\n\nstopwords = [ 'stop', 'the', 'to', 'and', 'a', 'in', 'it', 'is', 'I']\n\nmetric = metrics.AdjustedRand()\n\nmodel = compose.Pipeline(\n    feature_extraction.BagOfWords(lowercase=True, ngram_range=(1, 2), stop_words=stopwords),\n    cluster.TextClust(real_time_fading=False, fading_factor=0.001, tgap=100, auto_r=True,\n    radius=0.9)\n)\n\nfor x in corpus:\n    y_pred = model.predict_one(x[\"text\"])\n    y = x[\"cluster\"]\n    metric.update(y,y_pred)\n    model.learn_one(x[\"text\"])\n\nprint(metric)\n</code></pre> <pre><code>AdjustedRand: -0.17647058823529413\n</code></pre></p>"},{"location":"api/cluster/TextClust/#methods","title":"Methods","text":"distances get_assignment get_macroclusters learn_one <p>Update the model with a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>t     \u2014 defaults to <code>None</code> </li> <li>w     \u2014 defaults to <code>None</code> </li> </ul> <p></p> microcluster predict_one <p>Predicts the cluster number for a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[typing.FeatureName, Any]' </li> <li>w     \u2014 defaults to <code>None</code> </li> <li>type     \u2014 defaults to <code>micro</code> </li> </ul> <p>Returns</p> <p>int:     A cluster number.</p> <p></p> showclusters tfcontainer updateMacroClusters <ol> <li> <p>Assenmacher, D. und Trautmann, H. (2022). Textual One-Pass Stream Clustering with Automated Distance Threshold Adaption. In: Asian Conference on Intelligent Information and Database Systems (Accepted)\u00a0\u21a9</p> </li> <li> <p>Carnein, M., Assenmacher, D., Trautmann, H. (2017). Stream Clustering of Chat Messages with Applications to Twitch Streams. In: Advances in Conceptual Modeling. ER 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/compat/River2SKLClassifier/","title":"River2SKLClassifier","text":"<p>Compatibility layer from River to scikit-learn for classification.</p>"},{"location":"api/compat/River2SKLClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>river_estimator</p> <p>Type \u2192 base.Classifier</p> </li> </ul>"},{"location":"api/compat/River2SKLClassifier/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p> <p></p> get_metadata_routing <p>Get metadata routing of this object.</p> <p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing mechanism works.</p> <p>Returns</p> <p>MetadataRequest</p> <p></p> get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2014 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p> <p></p> partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> <li>classes     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p> <p></p> predict <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Predicted target values for each row of <code>X</code>.</p> <p></p> predict_proba <p>Predicts the target probability of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Predicted target values for each row of <code>X</code>.</p> <p></p> score <p>Return the mean accuracy on the given test data and labels.</p> <p>In multi-label classification, this is the subset accuracy which is a harsh metric since you require for each sample that each label set be correctly predicted.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> <li>sample_weight     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>float</p> <p></p> set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p> <p></p> set_partial_fit_request <p>Request metadata passed to the <code>partial_fit</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see :func:<code>sklearn.set_config</code>). Please see :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing mechanism works.  The options for each parameter are:  - <code>True</code>: metadata is requested, and passed to <code>partial_fit</code> if provided. The request is ignored if metadata is not provided.  - <code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>partial_fit</code>.  - <code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.  - <code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.  The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.  .. versionadded:: 1.3  .. note::     This method is only relevant if this estimator is used as a     sub-estimator of a meta-estimator, e.g. used inside a     :class:<code>~sklearn.pipeline.Pipeline</code>. Otherwise it has no effect.</p> <p>Parameters</p> <ul> <li>classes     \u2014 Union[bool, NoneType, str]     \u2014 defaults to <code>$UNCHANGED$</code> </li> </ul> <p>Returns</p> <p>River2SKLClassifier:     object</p> <p></p> set_score_request <p>Request metadata passed to the <code>score</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see :func:<code>sklearn.set_config</code>). Please see :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing mechanism works.  The options for each parameter are:  - <code>True</code>: metadata is requested, and passed to <code>score</code> if provided. The request is ignored if metadata is not provided.  - <code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>score</code>.  - <code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.  - <code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.  The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.  .. versionadded:: 1.3  .. note::     This method is only relevant if this estimator is used as a     sub-estimator of a meta-estimator, e.g. used inside a     :class:<code>~sklearn.pipeline.Pipeline</code>. Otherwise it has no effect.</p> <p>Parameters</p> <ul> <li>sample_weight     \u2014 Union[bool, NoneType, str]     \u2014 defaults to <code>$UNCHANGED$</code> </li> </ul> <p>Returns</p> <p>River2SKLClassifier:     object</p> <p></p>"},{"location":"api/compat/River2SKLClusterer/","title":"River2SKLClusterer","text":"<p>Compatibility layer from River to scikit-learn for clustering.</p>"},{"location":"api/compat/River2SKLClusterer/#parameters","title":"Parameters","text":"<ul> <li> <p>river_estimator</p> <p>Type \u2192 base.Clusterer</p> </li> </ul>"},{"location":"api/compat/River2SKLClusterer/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p> <p></p> fit_predict <p>Perform clustering on <code>X</code> and returns cluster labels.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2014 defaults to <code>None</code> </li> <li>kwargs </li> </ul> <p>Returns</p> <p>ndarray of shape (n_samples,), dtype=np.int64</p> <p></p> get_metadata_routing <p>Get metadata routing of this object.</p> <p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing mechanism works.</p> <p>Returns</p> <p>MetadataRequest</p> <p></p> get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2014 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p> <p></p> partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p> <p></p> predict <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Transformed output.</p> <p></p> set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p> <p></p>"},{"location":"api/compat/River2SKLRegressor/","title":"River2SKLRegressor","text":"<p>Compatibility layer from River to scikit-learn for regression.</p>"},{"location":"api/compat/River2SKLRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>river_estimator</p> <p>Type \u2192 base.Regressor</p> </li> </ul>"},{"location":"api/compat/River2SKLRegressor/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p> <p></p> get_metadata_routing <p>Get metadata routing of this object.</p> <p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing mechanism works.</p> <p>Returns</p> <p>MetadataRequest</p> <p></p> get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2014 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p> <p></p> partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> </ul> <p>Returns</p> <p>self</p> <p></p> predict <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>np.ndarray:     Predicted target values for each row of <code>X</code>.</p> <p></p> score <p>Return the coefficient of determination of the prediction.</p> <p>The coefficient of determination :math:<code>R^2</code> is defined as :math:<code>(1 - \\frac{u}{v})</code>, where :math:<code>u</code> is the residual sum of squares <code>((y_true - y_pred)** 2).sum()</code> and :math:<code>v</code> is the total sum of squares <code>((y_true - y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a :math:<code>R^2</code> score of 0.0.</p> <p>Parameters</p> <ul> <li>X </li> <li>y </li> <li>sample_weight     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>float</p> <p></p> set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p> <p></p> set_score_request <p>Request metadata passed to the <code>score</code> method.</p> <p>Note that this method is only relevant if <code>enable_metadata_routing=True</code> (see :func:<code>sklearn.set_config</code>). Please see :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing mechanism works.  The options for each parameter are:  - <code>True</code>: metadata is requested, and passed to <code>score</code> if provided. The request is ignored if metadata is not provided.  - <code>False</code>: metadata is not requested and the meta-estimator will not pass it to <code>score</code>.  - <code>None</code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.  - <code>str</code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.  The default (<code>sklearn.utils.metadata_routing.UNCHANGED</code>) retains the existing request. This allows you to change the request for some parameters and not others.  .. versionadded:: 1.3  .. note::     This method is only relevant if this estimator is used as a     sub-estimator of a meta-estimator, e.g. used inside a     :class:<code>~sklearn.pipeline.Pipeline</code>. Otherwise it has no effect.</p> <p>Parameters</p> <ul> <li>sample_weight     \u2014 Union[bool, NoneType, str]     \u2014 defaults to <code>$UNCHANGED$</code> </li> </ul> <p>Returns</p> <p>River2SKLRegressor:     object</p> <p></p>"},{"location":"api/compat/River2SKLTransformer/","title":"River2SKLTransformer","text":"<p>Compatibility layer from River to scikit-learn for transformation.</p>"},{"location":"api/compat/River2SKLTransformer/#parameters","title":"Parameters","text":"<ul> <li> <p>river_estimator</p> <p>Type \u2192 base.Transformer</p> </li> </ul>"},{"location":"api/compat/River2SKLTransformer/#methods","title":"Methods","text":"fit <p>Fits to an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p> <p></p> fit_transform <p>Fit to data, then transform it.</p> <p>Fits transformer to <code>X</code> and <code>y</code> with optional parameters <code>fit_params</code> and returns a transformed version of <code>X</code>.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2014 defaults to <code>None</code> </li> <li>fit_params </li> </ul> <p>Returns</p> <p>ndarray array of shape (n_samples, n_features_new)</p> <p></p> get_metadata_routing <p>Get metadata routing of this object.</p> <p>Please check :ref:<code>User Guide &lt;metadata_routing&gt;</code> on how the routing mechanism works.</p> <p>Returns</p> <p>MetadataRequest</p> <p></p> get_params <p>Get parameters for this estimator.</p> <p>Parameters</p> <ul> <li>deep     \u2014 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>dict</p> <p></p> partial_fit <p>Fits incrementally on a portion of a dataset.</p> <p>Parameters</p> <ul> <li>X </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>self</p> <p></p> set_output <p>Set output container.</p> <p>See :ref:<code>sphx_glr_auto_examples_miscellaneous_plot_set_output.py</code> for an example on how to use the API.</p> <p>Parameters</p> <ul> <li>transform     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>estimator instance</p> <p></p> set_params <p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as :class:<code>~sklearn.pipeline.Pipeline</code>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it's possible to update each component of a nested object.</p> <p>Parameters</p> <ul> <li>params </li> </ul> <p>Returns</p> <p>estimator instance</p> <p></p> transform <p>Predicts the target of an entire dataset contained in memory.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>Transformed output.</p> <p></p>"},{"location":"api/compat/SKL2RiverClassifier/","title":"SKL2RiverClassifier","text":"<p>Compatibility layer from scikit-learn to River for classification.</p>"},{"location":"api/compat/SKL2RiverClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>estimator</p> <p>Type \u2192 sklearn_base.ClassifierMixin</p> <p>A scikit-learn regressor which has a <code>partial_fit</code> method.</p> </li> <li> <p>classes</p> <p>Type \u2192 list</p> </li> </ul>"},{"location":"api/compat/SKL2RiverClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import compat\nfrom river import evaluate\nfrom river import metrics\nfrom river import preprocessing\nfrom river import stream\nfrom sklearn import linear_model\nfrom sklearn import datasets\n\ndataset = stream.iter_sklearn_dataset(\n    dataset=datasets.load_breast_cancer(),\n    shuffle=True,\n    seed=42\n)\n\nmodel = preprocessing.StandardScaler()\nmodel |= compat.convert_sklearn_to_river(\n    estimator=linear_model.SGDClassifier(\n        loss='log_loss',\n        eta0=0.01,\n        learning_rate='constant'\n    ),\n    classes=[False, True]\n)\n\nmetric = metrics.LogLoss()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>LogLoss: 0.198029\n</code></pre></p>"},{"location":"api/compat/SKL2RiverClassifier/#methods","title":"Methods","text":"learn_many learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_many predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_many predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/compat/SKL2RiverRegressor/","title":"SKL2RiverRegressor","text":"<p>Compatibility layer from scikit-learn to River for regression.</p>"},{"location":"api/compat/SKL2RiverRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>estimator</p> <p>Type \u2192 sklearn_base.BaseEstimator</p> <p>A scikit-learn transformer which has a <code>partial_fit</code> method.</p> </li> </ul>"},{"location":"api/compat/SKL2RiverRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import compat\nfrom river import evaluate\nfrom river import metrics\nfrom river import preprocessing\nfrom river import stream\nfrom sklearn import linear_model\nfrom sklearn import datasets\n\ndataset = stream.iter_sklearn_dataset(\n    dataset=datasets.load_diabetes(),\n    shuffle=True,\n    seed=42\n)\n\nscaler = preprocessing.StandardScaler()\nsgd_reg = compat.convert_sklearn_to_river(linear_model.SGDRegressor())\nmodel = scaler | sgd_reg\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 84.501421\n</code></pre></p>"},{"location":"api/compat/SKL2RiverRegressor/#methods","title":"Methods","text":"learn_many learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_many predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/compat/convert-river-to-sklearn/","title":"convert_river_to_sklearn","text":"<p>Wraps a river estimator to make it compatible with scikit-learn.</p>"},{"location":"api/compat/convert-river-to-sklearn/#parameters","title":"Parameters","text":"<ul> <li> <p>estimator</p> <p>Type \u2192 base.Estimator</p> </li> </ul>"},{"location":"api/compat/convert-sklearn-to-river/","title":"convert_sklearn_to_river","text":"<p>Wraps a scikit-learn estimator to make it compatible with river.</p>"},{"location":"api/compat/convert-sklearn-to-river/#parameters","title":"Parameters","text":"<ul> <li> <p>estimator</p> <p>Type \u2192 sklearn_base.BaseEstimator</p> </li> <li> <p>classes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>Class names necessary for classifiers.</p> </li> </ul>"},{"location":"api/compose/Discard/","title":"Discard","text":"<p>Removes features.</p> <p>This can be used in a pipeline when you want to remove certain features. The <code>transform_one</code> method is pure, and therefore returns a fresh new dictionary instead of removing the specified keys from the input.</p>"},{"location":"api/compose/Discard/#parameters","title":"Parameters","text":"<ul> <li> <p>keys</p> <p>Type \u2192 base.typing.FeatureName</p> <p>Key(s) to discard.</p> </li> </ul>"},{"location":"api/compose/Discard/#examples","title":"Examples","text":"<p><pre><code>from river import compose\n\nx = {'a': 42, 'b': 12, 'c': 13}\ncompose.Discard('a', 'b').transform_one(x)\n</code></pre> <pre><code>{'c': 13}\n</code></pre></p> <p>You can chain a discarder with any estimator in order to apply said estimator to the desired features.</p> <p><pre><code>from river import feature_extraction as fx\n\nx = {'sales': 10, 'shop': 'Ikea', 'country': 'Sweden'}\n\npipeline = (\n    compose.Discard('shop', 'country') |\n    fx.PolynomialExtender()\n)\npipeline.transform_one(x)\n</code></pre> <pre><code>{'sales': 10, 'sales*sales': 100}\n</code></pre></p>"},{"location":"api/compose/Discard/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>dict:     The transformed values.</p> <p></p>"},{"location":"api/compose/FuncTransformer/","title":"FuncTransformer","text":"<p>Wraps a function to make it usable in a pipeline.</p> <p>There is often a need to apply an arbitrary transformation to a set of features. For instance, this could involve parsing a date and then extracting the hour from said date. If you're processing a stream of data, then you can do this yourself by calling the necessary code at your leisure. On the other hand, if you want to do this as part of a pipeline, then you need to follow a simple convention. </p> <p>To use a function as part of a pipeline, take as input a <code>dict</code> of features and output a <code>dict</code>. Once you have initialized this class with your function, then you can use it like you would use any other (unsupervised) transformer. </p> <p>It is up to you if you want your function to be pure or not. By pure we refer to a function that doesn't modify its input. However, we recommend writing pure functions because this reduces the chances of inserting bugs into your pipeline.</p>"},{"location":"api/compose/FuncTransformer/#parameters","title":"Parameters","text":"<ul> <li> <p>func</p> <p>Type \u2192 typing.Callable[[dict], dict]</p> <p>A function that takes as input a <code>dict</code> and outputs a <code>dict</code>.</p> </li> </ul>"},{"location":"api/compose/FuncTransformer/#examples","title":"Examples","text":"<p><pre><code>from pprint import pprint\nimport datetime as dt\nfrom river import compose\n\nx = {'date': '2019-02-14'}\n\ndef parse_date(x):\n    date = dt.datetime.strptime(x['date'], '%Y-%m-%d')\n    x['is_weekend'] = date.day in (5, 6)\n    x['hour'] = date.hour\n    return x\n\nt = compose.FuncTransformer(parse_date)\npprint(t.transform_one(x))\n</code></pre> <pre><code>{'date': '2019-02-14', 'hour': 0, 'is_weekend': False}\n</code></pre></p> <p>The above example is not pure because it modifies the input. The following example is pure and produces the same output:</p> <p><pre><code>def parse_date(x):\n    date = dt.datetime.strptime(x['date'], '%Y-%m-%d')\n    return {'is_weekend': date.day in (5, 6), 'hour': date.hour}\n\nt = compose.FuncTransformer(parse_date)\npprint(t.transform_one(x))\n</code></pre> <pre><code>{'hour': 0, 'is_weekend': False}\n</code></pre></p> <p>The previous example doesn't include the <code>date</code> feature because it returns a new <code>dict</code>. However, a common usecase is to add a feature to an existing set of features. You can do this in a pure way by unpacking the input <code>dict</code> into the output <code>dict</code>:</p> <p><pre><code>def parse_date(x):\n    date = dt.datetime.strptime(x['date'], '%Y-%m-%d')\n    return {'is_weekend': date.day in (5, 6), 'hour': date.hour, **x}\n\nt = compose.FuncTransformer(parse_date)\npprint(t.transform_one(x))\n</code></pre> <pre><code>{'date': '2019-02-14', 'hour': 0, 'is_weekend': False}\n</code></pre></p> <p>You can add <code>FuncTransformer</code> to a pipeline just like you would with any other transformer.</p> <p><pre><code>from river import naive_bayes\n\npipeline = compose.FuncTransformer(parse_date) | naive_bayes.MultinomialNB()\npipeline\n</code></pre> <pre><code>Pipeline (\n  FuncTransformer (\n    func=\"parse_date\"\n  ),\n  MultinomialNB (\n    alpha=1.\n  )\n)\n</code></pre></p> <p>If you provide a function without wrapping it, then the pipeline will do it for you:</p> <pre><code>pipeline = parse_date | naive_bayes.MultinomialNB()\n</code></pre>"},{"location":"api/compose/FuncTransformer/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/compose/Grouper/","title":"Grouper","text":"<p>Applies a transformer within different groups.</p> <p>This transformer allows you to split your data into groups and apply a transformer within each group. This happens in a streaming manner, which means that the groups are discovered online. A separate copy of the provided transformer is made whenever a new group appears. The groups are defined according to one or more keys.</p>"},{"location":"api/compose/Grouper/#parameters","title":"Parameters","text":"<ul> <li> <p>transformer</p> <p>Type \u2192 base.BaseTransformer</p> </li> <li> <p>by</p> <p>Type \u2192 base.typing.FeatureName | list[base.typing.FeatureName]</p> <p>The field on which to group the data. This can either by a single value, or a list of values.</p> </li> </ul>"},{"location":"api/compose/Grouper/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/compose/Pipeline/","title":"Pipeline","text":"<p>A pipeline of estimators.</p> <p>Pipelines allow you to chain different steps into a sequence. Typically, when doing supervised learning, a pipeline contains one or more transformation steps, whilst it's a regressor or a classifier. It is highly recommended to use pipelines with River. Indeed, in an online learning setting, it is very practical to have a model defined as a single object. Take a look at the user guide for further information and practical examples. </p> <p>One special thing to take notice to is the way transformers are handled. It is usual to predict something for a sample and wait for the ground truth to arrive. In such a scenario, the features are seen before the ground truth arrives. Therefore, the unsupervised parts of the pipeline are updated when <code>predict_one</code> and <code>predict_proba_one</code> are called. Usually the unsupervised parts of the pipeline are all the steps that precede the final step, which is a supervised model. However, some transformers are supervised and are therefore also updated during calls to <code>learn_one</code>.</p>"},{"location":"api/compose/Pipeline/#parameters","title":"Parameters","text":"<ul> <li> <p>steps</p> <p>Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.</p> </li> </ul>"},{"location":"api/compose/Pipeline/#examples","title":"Examples","text":"<p>The recommended way to declare a pipeline is to use the <code>|</code> operator. The latter allows you to chain estimators in a very terse manner:</p> <pre><code>from river import linear_model\nfrom river import preprocessing\n\nscaler = preprocessing.StandardScaler()\nlog_reg = linear_model.LinearRegression()\nmodel = scaler | log_reg\n</code></pre> <p>This results in a pipeline that stores each step inside a dictionary.</p> <p><pre><code>model\n</code></pre> <pre><code>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</code></pre></p> <p>You can access parts of a pipeline in the same manner as a dictionary:</p> <p><pre><code>model['LinearRegression']\n</code></pre> <pre><code>LinearRegression (\n  optimizer=SGD (\n    lr=Constant (\n      learning_rate=0.01\n    )\n  )\n  loss=Squared ()\n  l2=0.\n  l1=0.\n  intercept_init=0.\n  intercept_lr=Constant (\n    learning_rate=0.01\n  )\n  clip_gradient=1e+12\n  initializer=Zeros ()\n)\n</code></pre></p> <p>Note that you can also declare a pipeline by using the <code>compose.Pipeline</code> constructor method, which is slightly more verbose:</p> <pre><code>from river import compose\n\nmodel = compose.Pipeline(scaler, log_reg)\n</code></pre> <p>By using a <code>compose.TransformerUnion</code>, you can define complex pipelines that apply different steps to different parts of the data. For instance, we can extract word counts from text data, and extract polynomial features from numeric data.</p> <pre><code>from river import feature_extraction as fx\n\ntfidf = fx.TFIDF('text')\ncounts = fx.BagOfWords('text')\ntext_part = compose.Select('text') | (tfidf + counts)\n\nnum_part = compose.Select('a', 'b') | fx.PolynomialExtender()\n\nmodel = text_part + num_part\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression()\n</code></pre> <p>The following shows an example of using <code>debug_one</code> to visualize how the information flows and changes throughout the pipeline.</p> <p><pre><code>from river import compose\nfrom river import naive_bayes\n\ndataset = [\n    ('A positive comment', True),\n    ('A negative comment', False),\n    ('A happy comment', True),\n    ('A lovely comment', True),\n    ('A harsh comment', False)\n]\n\ntfidf = fx.TFIDF() | compose.Prefixer('tfidf_')\ncounts = fx.BagOfWords() | compose.Prefixer('count_')\nmnb = naive_bayes.MultinomialNB()\nmodel = (tfidf + counts) | mnb\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nx = dataset[0][0]\nreport = model.debug_one(dataset[0][0])\nprint(report)\n</code></pre> <pre><code>0. Input\n--------\nA positive comment\n1. Transformer union\n--------------------\n    1.0 TFIDF | Prefixer\n    --------------------\n    tfidf_comment: 0.43017 (float)\n    tfidf_positive: 0.90275 (float)\n    1.1 BagOfWords | Prefixer\n    -------------------------\n    count_comment: 1 (int)\n    count_positive: 1 (int)\ncount_comment: 1 (int)\ncount_positive: 1 (int)\ntfidf_comment: 0.43017 (float)\ntfidf_positive: 0.90275 (float)\n2. MultinomialNB\n----------------\nFalse: 0.19221\nTrue: 0.80779\n</code></pre></p>"},{"location":"api/compose/Pipeline/#methods","title":"Methods","text":"debug_one <p>Displays the state of a set of features as it goes through the pipeline.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>show_types     \u2014 defaults to <code>True</code> </li> <li>n_decimals     \u2014 defaults to <code>5</code> </li> </ul> <p></p> forecast <p>Return a forecast.</p> <p>Only works if each estimator has a <code>transform_one</code> method and the final estimator has a <code>forecast</code> method. This is the case of time series models from the <code>time_series</code> module.</p> <p>Parameters</p> <ul> <li>horizon     \u2014 'int' </li> <li>xs     \u2014 'list[dict] | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> learn_many <p>Fit to a mini-batch.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series | None'     \u2014 defaults to <code>None</code> </li> <li>params </li> </ul> <p></p> learn_one <p>Fit to a single instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 defaults to <code>None</code> </li> <li>params </li> </ul> <p></p> predict_many <p>Call transform_many, and then predict_many on the final step.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> predict_one <p>Call <code>transform_one</code> on the first steps and <code>predict_one</code> on the last step.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>params </li> </ul> <p></p> predict_proba_many <p>Call transform_many, and then predict_proba_many on the final step.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> predict_proba_one <p>Call <code>transform_one</code> on the first steps and <code>predict_proba_one</code> on the last step.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>params </li> </ul> <p></p> score_one <p>Call <code>transform_one</code> on the first steps and <code>score_one</code> on the last step.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>params </li> </ul> <p></p> transform_many <p>Apply each transformer in the pipeline to some features.</p> <p>The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> transform_one <p>Apply each transformer in the pipeline to some features.</p> <p>The final step in the pipeline will be applied if it is a transformer. If not, then it will be ignored and the output from the penultimate step will be returned. Note that the steps that precede the final step are assumed to all be transformers.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>params </li> </ul> <p></p>"},{"location":"api/compose/Prefixer/","title":"Prefixer","text":"<p>Prepends a prefix on features names.</p>"},{"location":"api/compose/Prefixer/#parameters","title":"Parameters","text":"<ul> <li> <p>prefix</p> <p>Type \u2192 str</p> </li> </ul>"},{"location":"api/compose/Prefixer/#examples","title":"Examples","text":"<p><pre><code>from river import compose\n\nx = {'a': 42, 'b': 12}\ncompose.Prefixer('prefix_').transform_one(x)\n</code></pre> <pre><code>{'prefix_a': 42, 'prefix_b': 12}\n</code></pre></p>"},{"location":"api/compose/Prefixer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/compose/Renamer/","title":"Renamer","text":"<p>Renames features following substitution rules.</p>"},{"location":"api/compose/Renamer/#parameters","title":"Parameters","text":"<ul> <li> <p>mapping</p> <p>Type \u2192 dict[str, str]</p> <p>Dictionary describing substitution rules. Keys in <code>mapping</code> that are not a feature's name are silently ignored.</p> </li> </ul>"},{"location":"api/compose/Renamer/#examples","title":"Examples","text":"<p><pre><code>from river import compose\n\nmapping = {'a': 'v', 'c': 'o'}\nx = {'a': 42, 'b': 12}\ncompose.Renamer(mapping).transform_one(x)\n</code></pre> <pre><code>{'b': 12, 'v': 42}\n</code></pre></p>"},{"location":"api/compose/Renamer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/compose/Select/","title":"Select","text":"<p>Selects features.</p> <p>This can be used in a pipeline when you want to select certain features. The <code>transform_one</code> method is pure, and therefore returns a fresh new dictionary instead of filtering the specified keys from the input.</p>"},{"location":"api/compose/Select/#parameters","title":"Parameters","text":"<ul> <li> <p>keys</p> <p>Type \u2192 base.typing.FeatureName</p> <p>Key(s) to keep.</p> </li> </ul>"},{"location":"api/compose/Select/#examples","title":"Examples","text":"<p><pre><code>from river import compose\n\nx = {'a': 42, 'b': 12, 'c': 13}\ncompose.Select('c').transform_one(x)\n</code></pre> <pre><code>{'c': 13}\n</code></pre></p> <p>You can chain a selector with any estimator in order to apply said estimator to the desired features.</p> <p><pre><code>from river import feature_extraction as fx\n\nx = {'sales': 10, 'shop': 'Ikea', 'country': 'Sweden'}\n\npipeline = (\n    compose.Select('sales') |\n    fx.PolynomialExtender()\n)\npipeline.transform_one(x)\n</code></pre> <pre><code>{'sales': 10, 'sales*sales': 100}\n</code></pre></p> <p>This transformer also supports mini-batch processing:</p> <p><pre><code>import random\nfrom river import compose\n\nrandom.seed(42)\nX = [{\"x_1\": random.uniform(8, 12), \"x_2\": random.uniform(8, 12)} for _ in range(6)]\nfor x in X:\n    print(x)\n</code></pre> <pre><code>{'x_1': 10.557707193831535, 'x_2': 8.100043020890668}\n{'x_1': 9.100117273476478, 'x_2': 8.892842952595291}\n{'x_1': 10.94588485665605, 'x_2': 10.706797949691644}\n{'x_1': 11.568718270819382, 'x_2': 8.347755330517664}\n{'x_1': 9.687687278741082, 'x_2': 8.119188877752281}\n{'x_1': 8.874551899214413, 'x_2': 10.021421152413449}\n</code></pre></p> <pre><code>import pandas as pd\nX = pd.DataFrame.from_dict(X)\n</code></pre> <p>You can then call <code>transform_many</code> to transform a mini-batch of features:</p> <p><pre><code>compose.Select('x_2').transform_many(X)\n</code></pre> <pre><code>    x_2\n0   8.100043\n1   8.892843\n2  10.706798\n3   8.347755\n4   8.119189\n5  10.021421\n</code></pre></p>"},{"location":"api/compose/Select/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/compose/SelectType/","title":"SelectType","text":"<p>Selects features based on their type.</p> <p>This is practical when you want to apply different preprocessing steps to different kinds of features. For instance, a common usecase is to apply a <code>preprocessing.StandardScaler</code> to numeric features and a <code>preprocessing.OneHotEncoder</code> to categorical features.</p>"},{"location":"api/compose/SelectType/#parameters","title":"Parameters","text":"<ul> <li> <p>types</p> <p>Type \u2192 type</p> <p>Python types which you want to select. Under the hood, the <code>isinstance</code> method will be used to check if a value is of a given type.</p> </li> </ul>"},{"location":"api/compose/SelectType/#examples","title":"Examples","text":"<pre><code>import numbers\nfrom river import compose\nfrom river import linear_model\nfrom river import preprocessing\n\nnum = compose.SelectType(numbers.Number) | preprocessing.StandardScaler()\ncat = compose.SelectType(str) | preprocessing.OneHotEncoder()\nmodel = (num + cat) | linear_model.LogisticRegression()\n</code></pre>"},{"location":"api/compose/SelectType/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/compose/Suffixer/","title":"Suffixer","text":"<p>Appends a suffix on features names.</p>"},{"location":"api/compose/Suffixer/#parameters","title":"Parameters","text":"<ul> <li> <p>suffix</p> <p>Type \u2192 str</p> </li> </ul>"},{"location":"api/compose/Suffixer/#examples","title":"Examples","text":"<p><pre><code>from river import compose\n\nx = {'a': 42, 'b': 12}\ncompose.Suffixer('_suffix').transform_one(x)\n</code></pre> <pre><code>{'a_suffix': 42, 'b_suffix': 12}\n</code></pre></p>"},{"location":"api/compose/Suffixer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/compose/TargetTransformRegressor/","title":"TargetTransformRegressor","text":"<p>Modifies the target before training.</p> <p>The user is expected to check that <code>func</code> and <code>inverse_func</code> are coherent with each other.</p>"},{"location":"api/compose/TargetTransformRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 base.Regressor</p> <p>Regression model to wrap.</p> </li> <li> <p>func</p> <p>Type \u2192 typing.Callable</p> <p>A function modifying the target before training.</p> </li> <li> <p>inverse_func</p> <p>Type \u2192 typing.Callable</p> <p>A function to return to the target's original space.</p> </li> </ul>"},{"location":"api/compose/TargetTransformRegressor/#examples","title":"Examples","text":"<p><pre><code>import math\nfrom river import compose\nfrom river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\nmodel = (\n    preprocessing.StandardScaler() |\n    compose.TargetTransformRegressor(\n        regressor=linear_model.LinearRegression(intercept_lr=0.15),\n        func=math.log,\n        inverse_func=math.exp\n    )\n)\nmetric = metrics.MSE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MSE: 10.999752\n</code></pre></p>"},{"location":"api/compose/TargetTransformRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/compose/TransformerProduct/","title":"TransformerProduct","text":"<p>Computes interactions between the outputs of a set transformers.</p> <p>This is for when you want to add interaction terms between groups of features. It may also be used an alternative to <code>feature_extraction.PolynomialExtender</code> when the latter is overkill.</p>"},{"location":"api/compose/TransformerProduct/#parameters","title":"Parameters","text":"<ul> <li> <p>transformers</p> <p>Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.</p> </li> </ul>"},{"location":"api/compose/TransformerProduct/#examples","title":"Examples","text":"<p>Let's say we have a certain set of features with two groups. In practice these may be different namespaces, such one for items and the other for users.</p> <pre><code>x = dict(\n    a=0, b=1,  # group 1\n    x=2, y=3   # group 2\n)\n</code></pre> <p>We might want to add interaction terms between groups <code>('a', 'b')</code> and <code>('x', 'y')</code>, as so:</p> <p><pre><code>from pprint import pprint\nfrom river.compose import Select, TransformerProduct\n\nproduct = TransformerProduct(\n    Select('a', 'b'),\n    Select('x', 'y')\n)\npprint(product.transform_one(x))\n</code></pre> <pre><code>{'a*x': 0, 'a*y': 0, 'b*x': 2, 'b*y': 3}\n</code></pre></p> <p>This can also be done with the following shorthand:</p> <p><pre><code>product = Select('a', 'b') * Select('x', 'y')\npprint(product.transform_one(x))\n</code></pre> <pre><code>{'a*x': 0, 'a*y': 0, 'b*x': 2, 'b*y': 3}\n</code></pre></p> <p>If you want to include the original terms, you can do something like this:</p> <p><pre><code>group_1 = Select('a', 'b')\ngroup_2 = Select('x', 'y')\nproduct = group_1 + group_2 + group_1 * group_2\npprint(product.transform_one(x))\n</code></pre> <pre><code>{'a': 0, 'a*x': 0, 'a*y': 0, 'b': 1, 'b*x': 2, 'b*y': 3, 'x': 2, 'y': 3}\n</code></pre></p>"},{"location":"api/compose/TransformerProduct/#methods","title":"Methods","text":"learn_many <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> learn_one <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p></p> transform_many <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> transform_one <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p>"},{"location":"api/compose/TransformerUnion/","title":"TransformerUnion","text":"<p>Packs multiple transformers into a single one.</p> <p>Pipelines allow you to apply steps sequentially. Therefore, the output of a step becomes the input of the next one. In many cases, you may want to pass the output of a step to multiple steps. This simple transformer allows you to do so. In other words, it enables you to apply particular steps to different parts of an input. A typical example is when you want to scale numeric features and one-hot encode categorical features. </p> <p>This transformer is essentially a list of transformers. Whenever it is updated, it loops through each transformer and updates them. Meanwhile, calling <code>transform_one</code> collects the output of each transformer and merges them into a single dictionary.</p>"},{"location":"api/compose/TransformerUnion/#parameters","title":"Parameters","text":"<ul> <li> <p>transformers</p> <p>Ideally, a list of (name, estimator) tuples. A name is automatically inferred if none is provided.</p> </li> </ul>"},{"location":"api/compose/TransformerUnion/#examples","title":"Examples","text":"<p>Take the following dataset:</p> <pre><code>X = [\n    {'place': 'Taco Bell', 'revenue': 42},\n    {'place': 'Burger King', 'revenue': 16},\n    {'place': 'Burger King', 'revenue': 24},\n    {'place': 'Taco Bell', 'revenue': 58},\n    {'place': 'Burger King', 'revenue': 20},\n    {'place': 'Taco Bell', 'revenue': 50}\n]\n</code></pre> <p>As an example, let's assume we want to compute two aggregates of a dataset. We therefore define two <code>feature_extraction.Agg</code>s and initialize a <code>TransformerUnion</code> with them:</p> <pre><code>from river import compose\nfrom river import feature_extraction\nfrom river import stats\n\nmean = feature_extraction.Agg(\n    on='revenue', by='place',\n    how=stats.Mean()\n)\ncount = feature_extraction.Agg(\n    on='revenue', by='place',\n    how=stats.Count()\n)\nagg = compose.TransformerUnion(mean, count)\n</code></pre> <p>We can now update each transformer and obtain their output with a single function call:</p> <p><pre><code>from pprint import pprint\nfor x in X:\n    agg.learn_one(x)\n    pprint(agg.transform_one(x))\n</code></pre> <pre><code>{'revenue_count_by_place': 1, 'revenue_mean_by_place': 42.0}\n{'revenue_count_by_place': 1, 'revenue_mean_by_place': 16.0}\n{'revenue_count_by_place': 2, 'revenue_mean_by_place': 20.0}\n{'revenue_count_by_place': 2, 'revenue_mean_by_place': 50.0}\n{'revenue_count_by_place': 3, 'revenue_mean_by_place': 20.0}\n{'revenue_count_by_place': 3, 'revenue_mean_by_place': 50.0}\n</code></pre></p> <p>Note that you can use the <code>+</code> operator as a shorthand notation:</p> <p>agg = mean + count</p> <p>This allows you to build complex pipelines in a very terse manner. For instance, we can create a pipeline that scales each feature and fits a logistic regression as so:</p> <pre><code>from river import linear_model as lm\nfrom river import preprocessing as pp\n\nmodel = (\n    (mean + count) |\n    pp.StandardScaler() |\n    lm.LogisticRegression()\n)\n</code></pre> <p>Whice is equivalent to the following code:</p> <pre><code>model = compose.Pipeline(\n    compose.TransformerUnion(mean, count),\n    pp.StandardScaler(),\n    lm.LogisticRegression()\n)\n</code></pre> <p>Note that you access any part of a <code>TransformerUnion</code> by name:</p> <p><pre><code>model['TransformerUnion']['Agg']\n</code></pre> <pre><code>Agg (\n    on=\"revenue\"\n    by=['place']\n    how=Mean ()\n)\n</code></pre></p> <p><pre><code>model['TransformerUnion']['Agg1']\n</code></pre> <pre><code>Agg (\n    on=\"revenue\"\n    by=['place']\n    how=Count ()\n)\n</code></pre></p> <p>You can also manually provide a name for each step:</p> <pre><code>agg = compose.TransformerUnion(\n    ('Mean revenue by place', mean),\n    ('# by place', count)\n)\n</code></pre> <p>Mini-batch example:</p> <pre><code>X = pd.DataFrame([\n    {\"place\": 2, \"revenue\": 42},\n    {\"place\": 3, \"revenue\": 16},\n    {\"place\": 3, \"revenue\": 24},\n    {\"place\": 2, \"revenue\": 58},\n    {\"place\": 3, \"revenue\": 20},\n    {\"place\": 2, \"revenue\": 50},\n])\n</code></pre> <p>Since we need a transformer with mini-batch support to demonstrate, we shall use a <code>StandardScaler</code>.</p> <p><pre><code>from river import compose\nfrom river import preprocessing\n\nagg = (\n    compose.Select(\"place\") +\n    (compose.Select(\"revenue\") | preprocessing.StandardScaler())\n)\n\nagg.learn_many(X)\nagg.transform_many(X)\n</code></pre> <pre><code>   place   revenue\n0      2  0.441250\n1      3 -1.197680\n2      3 -0.693394\n3      2  1.449823\n4      3 -0.945537\n5      2  0.945537\n</code></pre></p>"},{"location":"api/compose/TransformerUnion/#methods","title":"Methods","text":"learn_many <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> learn_one <p>Update each transformer.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p></p> transform_many <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> transform_one <p>Passes the data through each transformer and packs the results together.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p>"},{"location":"api/compose/learn-during-predict/","title":"learn_during_predict","text":"<p>A context manager for fitting unsupervised steps during prediction.</p> <p>Usually, unsupervised parts of a pipeline are updated during <code>learn_one</code>. However, in the case of online learning, it is possible to update them before, during the prediction step. This context manager allows you to do so. </p> <p>This usually brings a slight performance improvement. But it is not done by default because it is not intuitive and is more difficult to test. It also means that you have to call <code>predict_one</code> before <code>learn_one</code> in order for the whole pipeline to be updated.</p>"},{"location":"api/compose/learn-during-predict/#examples","title":"Examples","text":"<p>Let's first see what methods are called if we just call <code>predict_one</code>.</p> <p><pre><code>import io\nimport logging\nfrom river import compose\nfrom river import datasets\nfrom river import linear_model\nfrom river import preprocessing\nfrom river import utils\n\nmodel = compose.Pipeline(\n    preprocessing.StandardScaler(),\n    linear_model.LinearRegression()\n)\n\nclass_condition = lambda x: x.__class__.__name__ in ('StandardScaler', 'LinearRegression')\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nlogs = io.StringIO()\nsh = logging.StreamHandler(logs)\nsh.setLevel(logging.DEBUG)\nlogger.addHandler(sh)\n\nwith utils.log_method_calls(class_condition):\n    for x, y in datasets.TrumpApproval().take(1):\n        _ = model.predict_one(x)\n\nprint(logs.getvalue())\n</code></pre> <pre><code>StandardScaler.transform_one\nLinearRegression.predict_one\n</code></pre></p> <p>Now let's use the context manager and see what methods get called.</p> <p><pre><code>logs = io.StringIO()\nsh = logging.StreamHandler(logs)\nsh.setLevel(logging.DEBUG)\nlogger.addHandler(sh)\n\nwith utils.log_method_calls(class_condition), compose.learn_during_predict():\n    for x, y in datasets.TrumpApproval().take(1):\n        _ = model.predict_one(x)\n\nprint(logs.getvalue())\n</code></pre> <pre><code>StandardScaler.learn_one\nStandardScaler.transform_one\nLinearRegression.predict_one\n</code></pre></p> <p>We can see that the scaler did not get updated before transforming the data.</p> <p>This also works when working with mini-batches.</p> <p><pre><code>logs = io.StringIO()\nsh = logging.StreamHandler(logs)\nsh.setLevel(logging.DEBUG)\nlogger.addHandler(sh)\n\nwith utils.log_method_calls(class_condition):\n    for x, y in datasets.TrumpApproval().take(1):\n        _ = model.predict_many(pd.DataFrame([x]))\nprint(logs.getvalue())\n</code></pre> <pre><code>StandardScaler.transform_many\nLinearRegression.predict_many\n</code></pre></p> <p><pre><code>logs = io.StringIO()\nsh = logging.StreamHandler(logs)\nsh.setLevel(logging.DEBUG)\nlogger.addHandler(sh)\n\nwith utils.log_method_calls(class_condition), compose.learn_during_predict():\n    for x, y in datasets.TrumpApproval().take(1):\n        _ = model.predict_many(pd.DataFrame([x]))\nprint(logs.getvalue())\n</code></pre> <pre><code>StandardScaler.learn_many\nStandardScaler.transform_many\nLinearRegression.predict_many\n</code></pre></p>"},{"location":"api/conf/Interval/","title":"Interval","text":"<p>An object to represent a (prediction) interval.</p> <p>Users are not expected to use this class as-is. Instead, they should use the <code>with_interval</code> parameter of the <code>predict_one</code> method of any regressor or classifier wrapped with a conformal prediction method.</p>"},{"location":"api/conf/Interval/#parameters","title":"Parameters","text":"<ul> <li> <p>lower</p> <p>Type \u2192 float</p> <p>The lower bound of the interval.</p> </li> <li> <p>upper</p> <p>Type \u2192 float</p> <p>The upper bound of the interval.</p> </li> </ul>"},{"location":"api/conf/Interval/#attributes","title":"Attributes","text":"<ul> <li> <p>center</p> <p>The center of the interval.</p> </li> <li> <p>width</p> <p>The width of the interval.</p> </li> </ul>"},{"location":"api/conf/RegressionJackknife/","title":"RegressionJackknife","text":"<p>Jackknife method for regression.</p> <p>This is a conformal prediction method for regression. It is based on the jackknife method. The idea is to compute the quantiles of the residuals of the regressor. The prediction interval is then computed as the prediction of the regressor plus the quantiles of the residuals. </p> <p>This works naturally online, as the quantiles of the residuals are updated at each iteration. Each residual is produced before the regressor is updated, which ensures the predicted intervals are not optimistic. </p> <p>Note that the produced intervals are marginal and not conditional. This means that the intervals are not adjusted for the features <code>x</code>. This is a limitation of the jackknife method. However, the jackknife method is very simple and efficient. It is also very robust to outliers.</p>"},{"location":"api/conf/RegressionJackknife/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 T</p> <p>The regressor to be wrapped.</p> </li> <li> <p>confidence_level</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.95</code></p> <p>The confidence level of the prediction intervals.</p> </li> <li> <p>window_size</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The size of the window used to compute the quantiles of the residuals. If <code>None</code>, the quantiles are computed over the whole history. It is advised to set this if you expect the model's performance to change over time.</p> </li> </ul>"},{"location":"api/conf/RegressionJackknife/#examples","title":"Examples","text":"<pre><code>from river import conf\nfrom river import datasets\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\nfrom river import stats\n\ndataset = datasets.TrumpApproval()\n\nmodel = conf.RegressionJackknife(\n    (\n        preprocessing.StandardScaler() |\n        linear_model.LinearRegression(intercept_lr=.1)\n    ),\n    confidence_level=0.9\n)\n\nvalidity = stats.Mean()\nefficiency = stats.Mean()\n\nfor x, y in dataset:\n    interval = model.predict_one(x, with_interval=True)\n    validity.update(y in interval)\n    efficiency.update(interval.width)\n    model.learn_one(x, y)\n</code></pre> <p>The interval's validity is the proportion of times the true value is within the interval. We specified a confidence level of 90%, so we expect the validity to be around 90%.</p> <p><pre><code>validity\n</code></pre> <pre><code>Mean: 0.939061\n</code></pre></p> <p>The interval's efficiency is the average width of the intervals.</p> <p><pre><code>efficiency\n</code></pre> <pre><code>Mean: 4.078361\n</code></pre></p> <p>Lowering the confidence lowering will mechanically improve the efficiency.</p>"},{"location":"api/conf/RegressionJackknife/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, object]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>kwargs     \u2014 'object' </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, object]' </li> <li>with_interval     \u2014 'bool'     \u2014 defaults to <code>False</code> </li> <li>kwargs     \u2014 'object' </li> </ul> <p>Returns</p> <p>float | interval.Interval:     The prediction.</p> <p></p> <ol> <li> <p>Barber, Rina Foygel, Emmanuel J. Candes, Aaditya Ramdas, and Ryan J. Tibshirani. \"Predictive inference with the jackknife+.\" The Annals of Statistics 49, no. 1 (2021): 486-507. \u21a9</p> </li> </ol>"},{"location":"api/covariance/EmpiricalCovariance/","title":"EmpiricalCovariance","text":"<p>Empirical covariance matrix.</p>"},{"location":"api/covariance/EmpiricalCovariance/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof</p> <p>Default \u2192 <code>1</code></p> <p>Delta Degrees of Freedom.</p> </li> </ul>"},{"location":"api/covariance/EmpiricalCovariance/#attributes","title":"Attributes","text":"<ul> <li>matrix</li> </ul>"},{"location":"api/covariance/EmpiricalCovariance/#examples","title":"Examples","text":"<p><pre><code>import numpy as np\nimport pandas as pd\nfrom river import covariance\n\nnp.random.seed(42)\nX = pd.DataFrame(np.random.random((8, 3)), columns=[\"red\", \"green\", \"blue\"])\nX\n</code></pre> <pre><code>        red     green      blue\n0  0.374540  0.950714  0.731994\n1  0.598658  0.156019  0.155995\n2  0.058084  0.866176  0.601115\n3  0.708073  0.020584  0.969910\n4  0.832443  0.212339  0.181825\n5  0.183405  0.304242  0.524756\n6  0.431945  0.291229  0.611853\n7  0.139494  0.292145  0.366362\n</code></pre></p> <p><pre><code>cov = covariance.EmpiricalCovariance()\nfor x in X.to_dict(orient=\"records\"):\n    cov.update(x)\ncov\n</code></pre> <pre><code>        blue     green    red\n blue    0.076    0.020   -0.010\ngreen    0.020    0.113   -0.053\n  red   -0.010   -0.053    0.079\n</code></pre></p> <p>There is also an <code>update_many</code> method to process mini-batches. The results are identical.</p> <p><pre><code>cov = covariance.EmpiricalCovariance()\ncov.update_many(X)\ncov\n</code></pre> <pre><code>        blue     green    red\n blue    0.076    0.020   -0.010\ngreen    0.020    0.113   -0.053\n  red   -0.010   -0.053    0.079\n</code></pre></p> <p>The covariances are stored in a dictionary, meaning any one of them can be accessed as such:</p> <p><pre><code>cov[\"blue\", \"green\"]\n</code></pre> <pre><code>Cov: 0.020292\n</code></pre></p> <p>Diagonal entries are variances:</p> <p><pre><code>cov[\"blue\", \"blue\"]\n</code></pre> <pre><code>Var: 0.076119\n</code></pre></p>"},{"location":"api/covariance/EmpiricalCovariance/#methods","title":"Methods","text":"revert <p>Downdate with a single sample.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> update <p>Update with a single sample.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p></p> update_many <p>Update with a dataframe of samples.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p>"},{"location":"api/covariance/EmpiricalPrecision/","title":"EmpiricalPrecision","text":"<p>Empirical precision matrix.</p> <p>The precision matrix is the inverse of the covariance matrix. </p> <p>This implementation leverages the Sherman-Morrison formula. The resulting inverse covariance matrix is not guaranteed to be identical to a batch computation. However, the difference shrinks with the number of observations.</p>"},{"location":"api/covariance/EmpiricalPrecision/#attributes","title":"Attributes","text":"<ul> <li>matrix</li> </ul>"},{"location":"api/covariance/EmpiricalPrecision/#examples","title":"Examples","text":"<p><pre><code>import numpy as np\nimport pandas as pd\nfrom river import covariance\n\nnp.random.seed(42)\nX = pd.DataFrame(np.random.random((1000, 3)))\nX.head()\n</code></pre> <pre><code>          0         1         2\n0  0.374540  0.950714  0.731994\n1  0.598658  0.156019  0.155995\n2  0.058084  0.866176  0.601115\n3  0.708073  0.020584  0.969910\n4  0.832443  0.212339  0.181825\n</code></pre></p> <p><pre><code>prec = covariance.EmpiricalPrecision()\nfor x in X.to_dict(orient=\"records\"):\n    prec.update(x)\n\nprec\n</code></pre> <pre><code>    0        1        2\n0   12.026   -0.122   -0.214\n1   -0.122   11.276   -0.026\n2   -0.214   -0.026   11.632\n</code></pre></p> <p><pre><code>pd.DataFrame(np.linalg.inv(np.cov(X.T, ddof=1)))\n</code></pre> <pre><code>           0          1          2\n0  12.159791  -0.124966  -0.218671\n1  -0.124966  11.393394  -0.026662\n2  -0.218671  -0.026662  11.756907\n</code></pre></p>"},{"location":"api/covariance/EmpiricalPrecision/#methods","title":"Methods","text":"update <p>Update with a single sample.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p></p> update_many <p>Update with a dataframe of samples.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> <ol> <li> <p>Online Estimation of the Inverse Covariance Matrix - Markus Thill \u21a9</p> </li> <li> <p>Fast rank-one updates to matrix inverse? - Tim Vieira \u21a9</p> </li> <li> <p>Woodbury matrix identity \u21a9</p> </li> </ol>"},{"location":"api/datasets/AirlinePassengers/","title":"AirlinePassengers","text":"<p>Monthly number of international airline passengers.</p> <p>The stream contains 144 items and only one single feature, which is the month. The goal is to predict the number of passengers each month by capturing the trend and the seasonality of the data.</p>"},{"location":"api/datasets/AirlinePassengers/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/AirlinePassengers/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>International airline passengers: monthly totals in thousands. Jan 49 \u2013 Dec 60 \u21a9</p> </li> </ol>"},{"location":"api/datasets/Bananas/","title":"Bananas","text":"<p>Bananas dataset.</p> <p>An artificial dataset where instances belongs to several clusters with a banana shape. There are two attributes that correspond to the x and y axis, respectively.</p>"},{"location":"api/datasets/Bananas/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Bananas/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>OpenML page \u21a9</p> </li> </ol>"},{"location":"api/datasets/Bikes/","title":"Bikes","text":"<p>Bike sharing station information from the city of Toulouse.</p> <p>The goal is to predict the number of bikes in 5 different bike stations from the city of Toulouse.</p>"},{"location":"api/datasets/Bikes/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Bikes/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>A short introduction and conclusion to the OpenBikes 2016 Challenge \u21a9</p> </li> </ol>"},{"location":"api/datasets/ChickWeights/","title":"ChickWeights","text":"<p>Chick weights along time.</p> <p>The stream contains 578 items and 3 features. The goal is to predict the weight of each chick along time, according to the diet the chick is on. The data is ordered by time and then by chick.</p>"},{"location":"api/datasets/ChickWeights/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/ChickWeights/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Chick weight dataset overview \u21a9</p> </li> </ol>"},{"location":"api/datasets/CreditCard/","title":"CreditCard","text":"<p>Credit card frauds.</p> <p>The datasets contains transactions made by credit cards in September 2013 by european cardholders. This dataset presents transactions that occurred in two days, where we have 492 frauds out of 284,807 transactions. The dataset is highly unbalanced, the positive class (frauds) account for 0.172% of all transactions. </p> <p>It contains only numerical input variables which are the result of a PCA transformation. Unfortunately, due to confidentiality issues, we cannot provide the original features and more background information about the data. Features V1, V2, ... V28 are the principal components obtained with PCA, the only features which have not been transformed with PCA are 'Time' and 'Amount'. Feature 'Time' contains the seconds elapsed between each transaction and the first transaction in the dataset. The feature 'Amount' is the transaction Amount, this feature can be used for example-dependant cost-senstive learning. Feature 'Class' is the response variable and it takes value 1 in case of fraud and 0 otherwise.</p>"},{"location":"api/datasets/CreditCard/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/CreditCard/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson and Gianluca Bontempi. Calibrating Probability with Undersampling for Unbalanced Classification. In Symposium on Computational Intelligence and Data Mining (CIDM), IEEE, 2015\u00a0\u21a9</p> </li> <li> <p>Dal Pozzolo, Andrea; Caelen, Olivier; Le Borgne, Yann-Ael; Waterschoot, Serge; Bontempi, Gianluca. Learned lessons in credit card fraud detection from a practitioner perspective, Expert systems with applications,41,10,4915-4928,2014, Pergamon\u00a0\u21a9</p> </li> <li> <p>Dal Pozzolo, Andrea; Boracchi, Giacomo; Caelen, Olivier; Alippi, Cesare; Bontempi, Gianluca. Credit card fraud detection: a realistic modeling and a novel learning strategy, IEEE transactions on neural networks and learning systems,29,8,3784-3797,2018,IEEE\u00a0\u21a9</p> </li> <li> <p>Dal Pozzolo, Andrea Adaptive Machine learning for credit card fraud detection ULB MLG PhD thesis (supervised by G. Bontempi)\u00a0\u21a9</p> </li> <li> <p>Carcillo, Fabrizio; Dal Pozzolo, Andrea; Le Borgne, Yann-Ael; Caelen, Olivier; Mazzer, Yannis; Bontempi, Gianluca. Scarff: a scalable framework for streaming credit card fraud detection with Spark, Information fusion,41, 182-194,2018,Elsevier\u00a0\u21a9</p> </li> <li> <p>Carcillo, Fabrizio; Le Borgne, Yann-Ael; Caelen, Olivier; Bontempi, Gianluca. Streaming active learning strategies for real-life credit card fraud detection: assessment and visualization, International Journal of Data Science and Analytics, 5,4,285-300,2018,Springer International Publishing\u00a0\u21a9</p> </li> <li> <p>Bertrand Lebichot, Yann-Ael Le Borgne, Liyun He, Frederic Oble, Gianluca Bontempi Deep-Learning Domain Adaptation Techniques for Credit Cards Fraud Detection, INNSBDDL 2019: Recent Advances in Big Data and Deep Learning, pp 78-88, 2019\u00a0\u21a9</p> </li> <li> <p>Fabrizio Carcillo, Yann-Ael Le Borgne, Olivier Caelen, Frederic Oble, Gianluca Bontempi Combining Unsupervised and Supervised Learning in Credit Card Fraud Detection Information Sciences, 2019\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/Elec2/","title":"Elec2","text":"<p>Electricity prices in New South Wales.</p> <p>This is a binary classification task, where the goal is to predict if the price of electricity will go up or down. </p> <p>This data was collected from the Australian New South Wales Electricity Market. In this market, prices are not fixed and are affected by demand and supply of the market. They are set every five minutes. Electricity transfers to/from the neighboring state of Victoria were done to alleviate fluctuations.</p>"},{"location":"api/datasets/Elec2/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Elec2/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>SPLICE-2 Comparative Evaluation: Electricity Pricing \u21a9</p> </li> <li> <p>DataHub description \u21a9</p> </li> </ol>"},{"location":"api/datasets/HTTP/","title":"HTTP","text":"<p>HTTP dataset of the KDD 1999 cup.</p> <p>The goal is to predict whether or not an HTTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.</p>"},{"location":"api/datasets/HTTP/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/HTTP/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>HTTP (KDDCUP99) dataset \u21a9</p> </li> </ol>"},{"location":"api/datasets/Higgs/","title":"Higgs","text":"<p>Higgs dataset.</p> <p>The data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22) are kinematic properties measured by the particle detectors in the accelerator. The last seven features are functions of the first 21 features; these are high-level features derived by physicists to help discriminate between the two classes.</p>"},{"location":"api/datasets/Higgs/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Higgs/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/ImageSegments/","title":"ImageSegments","text":"<p>Image segments classification.</p> <p>This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass.</p>"},{"location":"api/datasets/ImageSegments/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/ImageSegments/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/Insects/","title":"Insects","text":"<p>Insects dataset.</p> <p>This dataset has different variants for concept drift evaluation: </p> <ul> <li> <p>abrupt_balanced</p> </li> <li> <p>abrupt_imbalanced</p> </li> <li> <p>gradual_balanced</p> </li> <li> <p>gradual_imbalanced</p> </li> <li> <p>incremental_abrupt_balanced</p> </li> <li> <p>incremental_reoccurring_balanced</p> </li> <li> <p>incremental_balanced</p> </li> </ul> <p>The number of samples and the difficulty change from one variant to another. The number of classes is always the same (6), except for the last variant (24).</p>"},{"location":"api/datasets/Insects/#parameters","title":"Parameters","text":"<ul> <li> <p>variant</p> <p>Default \u2192 <code>abrupt_balanced</code></p> <p>Indicates which variant of the dataset to load. Defaults to \"abrupt_balanced\".</p> </li> </ul>"},{"location":"api/datasets/Insects/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Insects/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>USP DS repository \u21a9</p> </li> <li> <p>Souza, V., Reis, D.M.D., Maletzke, A.G. and Batista, G.E., 2020. Challenges in Benchmarking Stream Learning Algorithms with Real-world Data. arXiv preprint arXiv:2005.00113. \u21a9</p> </li> </ol>"},{"location":"api/datasets/Keystroke/","title":"Keystroke","text":"<p>CMU keystroke dataset.</p> <p>Users are tasked to type in a password. The task is to determine which user is typing in the password. </p> <p>The only difference with the original dataset is that the \"sessionIndex\" and \"rep\" attributes have been dropped.</p>"},{"location":"api/datasets/Keystroke/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Keystroke/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Keystroke Dynamics - Benchmark Data Set \u21a9</p> </li> </ol>"},{"location":"api/datasets/MaliciousURL/","title":"MaliciousURL","text":"<p>Malicious URLs dataset.</p> <p>This dataset contains features about URLs that are classified as malicious or not.</p>"},{"location":"api/datasets/MaliciousURL/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/MaliciousURL/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Detecting Malicious URLs \u21a9</p> </li> <li> <p>Identifying Suspicious URLs: An Application of Large-Scale Online Learning \u21a9</p> </li> </ol>"},{"location":"api/datasets/MovieLens100K/","title":"MovieLens100K","text":"<p>MovieLens 100K dataset.</p> <p>MovieLens datasets were collected by the GroupLens Research Project at the University of Minnesota. This dataset consists of 100,000 ratings (1-5) from 943 users on 1682 movies. Each user has rated at least 20 movies. User and movie information are provided. The data was collected through the MovieLens web site (movielens.umn.edu) during the seven-month period from September 19th, 1997 through April 22nd, 1998.</p>"},{"location":"api/datasets/MovieLens100K/#parameters","title":"Parameters","text":"<ul> <li> <p>unpack_user_and_item</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not the user and item should be extracted from the context and included as extra keyword arguments.</p> </li> </ul>"},{"location":"api/datasets/MovieLens100K/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/MovieLens100K/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>The MovieLens Datasets: History and Context \u21a9</p> </li> </ol>"},{"location":"api/datasets/Music/","title":"Music","text":"<p>Multi-label music mood prediction.</p> <p>The goal is to predict to which kinds of moods a song pertains to.</p>"},{"location":"api/datasets/Music/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Music/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Read, J., Reutemann, P., Pfahringer, B. and Holmes, G., 2016. MEKA: a multi-label/multi-target extension to WEKA. The Journal of Machine Learning Research, 17(1), pp.667-671. \u21a9</p> </li> </ol>"},{"location":"api/datasets/Phishing/","title":"Phishing","text":"<p>Phishing websites.</p> <p>This dataset contains features from web pages that are classified as phishing or not.</p>"},{"location":"api/datasets/Phishing/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Phishing/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/Restaurants/","title":"Restaurants","text":"<p>Data from the Kaggle Recruit Restaurants challenge.</p> <p>The goal is to predict the number of visitors in each of 829 Japanese restaurants over a period of roughly 16 weeks. The data is ordered by date and then by restaurant ID.</p>"},{"location":"api/datasets/Restaurants/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Restaurants/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Recruit Restaurant Visitor Forecasting \u21a9</p> </li> </ol>"},{"location":"api/datasets/SMSSpam/","title":"SMSSpam","text":"<p>SMS Spam Collection dataset.</p> <p>The data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent 13.4% of the dataset. The goal is to predict whether an SMS is a spam or not.</p>"},{"location":"api/datasets/SMSSpam/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/SMSSpam/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Almeida, T.A., Hidalgo, J.M.G. and Yamakami, A., 2011, September. Contributions to the study of SMS spam filtering: new collection and results. In Proceedings of the 11th ACM symposium on Document engineering (pp. 259-262). \u21a9</p> </li> </ol>"},{"location":"api/datasets/SMTP/","title":"SMTP","text":"<p>SMTP dataset from the KDD 1999 cup.</p> <p>The goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.</p>"},{"location":"api/datasets/SMTP/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/SMTP/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>SMTP (KDDCUP99) dataset \u21a9</p> </li> </ol>"},{"location":"api/datasets/SolarFlare/","title":"SolarFlare","text":"<p>Solar flare multi-output regression.</p>"},{"location":"api/datasets/SolarFlare/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/SolarFlare/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>UCI page \u21a9</p> </li> </ol>"},{"location":"api/datasets/TREC07/","title":"TREC07","text":"<p>TREC's 2007 Spam Track dataset.</p> <p>The data contains 75,419 chronologically ordered items, i.e. 3 months of emails delivered to a particular server in 2007. Spam messages represent 66.6% of the dataset. The goal is to predict whether an email is a spam or not. </p> <p>The available raw features are: sender, recipients, date, subject, body.</p>"},{"location":"api/datasets/TREC07/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/TREC07/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>TREC 2007 Spam Track Overview \u21a9</p> </li> <li> <p>Code ran to parse the dataset \u21a9</p> </li> </ol>"},{"location":"api/datasets/Taxis/","title":"Taxis","text":"<p>Taxi ride durations in New York City.</p> <p>The goal is to predict the duration of taxi rides in New York City.</p>"},{"location":"api/datasets/Taxis/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/Taxis/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>New York City Taxi Trip Duration competition on Kaggle \u21a9</p> </li> </ol>"},{"location":"api/datasets/TrumpApproval/","title":"TrumpApproval","text":"<p>Donald Trump approval ratings.</p> <p>This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model.</p>"},{"location":"api/datasets/TrumpApproval/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/TrumpApproval/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Trump Approval Ratings \u21a9</p> </li> </ol>"},{"location":"api/datasets/WaterFlow/","title":"WaterFlow","text":"<p>Water flow through a pipeline branch.</p> <p>The series includes hourly values for about 2 months, March 2022 to May 2022. The values are expressed in liters per second. There are four anomalous segments in the series: </p> <ul> <li>3 \"low value moments\": this is due to water losses or human intervention for maintenance * A small peak in the water inflow after the first 2 segments: this is due to a pumping     operation into the main pipeline, when more water pressure is needed </li> </ul> <p>This dataset is well suited for time series forecasting models, as well as anomaly detection methods. Ideally, the goal is to build a time series forecasting model that is robust to the anomalous segments. </p> <p>This data has been kindly donated by the Tecnojest s.r.l. company (www.invidea.it) from Italy.</p>"},{"location":"api/datasets/WaterFlow/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/WaterFlow/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/WebTraffic/","title":"WebTraffic","text":"<p>Web sessions information from an events company based in South Africa.</p> <p>The goal is to predict the number of web sessions in 4 different regions in South Africa. </p> <p>The data consists of 15 minute interval traffic values between '2023-06-16 00:00:00' and '2023-09-15 23:45:00' for each region. Two types of sessions are captured <code>sessionsA</code> and <code>sessionsB</code>. The <code>isMissing</code> flag is equal to 1 if any of the servers failed to capture sessions, otherwise if all servers functioned properly this flag is equal to 0. </p> <p>Things to consider: </p> <ul> <li>region <code>R5</code> captures sessions in backup mode. Strictly speaking, <code>R5</code> is not necessary to predict. * Can <code>sessionsA</code> and <code>sessionsB</code> events be predicted accurately for each region over the next day (next 96 intervals)? * What is the best way to deal with the missing values? * How can model selection be used (a multi-model approach)? * Can dependence (correlation) between regions be utilised for more accurate predictions? * Can both <code>sessionA</code> and <code>sessionB</code> be predicted simultaneously with one model? </li> </ul> <p>This dataset is well suited for time series forecasting models, as well as anomaly detection methods. Ideally, the goal is to build a time series forecasting model that is robust to the anomalous events and generalise well on normal operating conditions.</p>"},{"location":"api/datasets/WebTraffic/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/WebTraffic/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/base/Dataset/","title":"Dataset","text":"<p>Base class for all datasets.</p> <p>All datasets inherit from this class, be they stored in a file or generated on the fly.</p>"},{"location":"api/datasets/base/Dataset/#parameters","title":"Parameters","text":"<ul> <li> <p>task</p> <p>Type of task the dataset is meant for. Should be one of the following:      - \"Regression\"     - \"Binary classification\"     - \"Multi-class classification\"     - \"Multi-output binary classification\"     - \"Multi-output regression\"</p> </li> <li> <p>n_features</p> <p>Number of features in the dataset.</p> </li> <li> <p>n_samples</p> <p>Default \u2192 <code>None</code></p> <p>Number of samples in the dataset.</p> </li> <li> <p>n_classes</p> <p>Default \u2192 <code>None</code></p> <p>Number of classes in the dataset, only applies to classification datasets.</p> </li> <li> <p>n_outputs</p> <p>Default \u2192 <code>None</code></p> <p>Number of outputs the target is made of, only applies to multi-output datasets.</p> </li> <li> <p>sparse</p> <p>Default \u2192 <code>False</code></p> <p>Whether the dataset is sparse or not.</p> </li> </ul>"},{"location":"api/datasets/base/Dataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/base/Dataset/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/base/FileDataset/","title":"FileDataset","text":"<p>Base class for datasets that are stored in a local file.</p> <p>Small datasets that are part of the river package inherit from this class.</p>"},{"location":"api/datasets/base/FileDataset/#parameters","title":"Parameters","text":"<ul> <li> <p>filename</p> <p>The file's name.</p> </li> <li> <p>directory</p> <p>Default \u2192 <code>None</code></p> <p>The directory where the file is contained. Defaults to the location of the <code>datasets</code> module.</p> </li> <li> <p>desc</p> <p>Extra dataset parameters to pass as keyword arguments.</p> </li> </ul>"},{"location":"api/datasets/base/FileDataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/base/FileDataset/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/base/RemoteDataset/","title":"RemoteDataset","text":"<p>Base class for datasets that are stored in a remote file.</p> <p>Medium and large datasets that are not part of the river package inherit from this class. </p> <p>The filename doesn't have to be provided if unpack is False. Indeed in the latter case the filename will be inferred from the URL.</p>"},{"location":"api/datasets/base/RemoteDataset/#parameters","title":"Parameters","text":"<ul> <li> <p>url</p> <p>The URL the dataset is located at.</p> </li> <li> <p>size</p> <p>The expected download size.</p> </li> <li> <p>unpack</p> <p>Default \u2192 <code>True</code></p> <p>Whether to unpack the download or not.</p> </li> <li> <p>filename</p> <p>Default \u2192 <code>None</code></p> <p>An optional name to given to the file if the file is unpacked.</p> </li> <li> <p>desc</p> <p>Extra dataset parameters to pass as keyword arguments.</p> </li> </ul>"},{"location":"api/datasets/base/RemoteDataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>is_downloaded</p> <p>Indicate whether or the data has been correctly downloaded.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/datasets/base/RemoteDataset/#methods","title":"Methods","text":"download take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/base/SyntheticDataset/","title":"SyntheticDataset","text":"<p>A synthetic dataset.</p>"},{"location":"api/datasets/base/SyntheticDataset/#parameters","title":"Parameters","text":"<ul> <li> <p>task</p> <p>Type of task the dataset is meant for. Should be one of: - \"Regression\" - \"Binary classification\" - \"Multi-class classification\" - \"Multi-output binary classification\" - \"Multi-output regression\"</p> </li> <li> <p>n_features</p> <p>Number of features in the dataset.</p> </li> <li> <p>n_samples</p> <p>Default \u2192 <code>None</code></p> <p>Number of samples in the dataset.</p> </li> <li> <p>n_classes</p> <p>Default \u2192 <code>None</code></p> <p>Number of classes in the dataset, only applies to classification datasets.</p> </li> <li> <p>n_outputs</p> <p>Default \u2192 <code>None</code></p> <p>Number of outputs the target is made of, only applies to multi-output datasets.</p> </li> <li> <p>sparse</p> <p>Default \u2192 <code>False</code></p> <p>Whether the dataset is sparse or not.</p> </li> </ul>"},{"location":"api/datasets/base/SyntheticDataset/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/base/SyntheticDataset/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/Agrawal/","title":"Agrawal","text":"<p>Agrawal stream generator.</p> <p>The generator was introduced by Agrawal et al. <sup>1</sup>, and was a common source of data for early work on scaling up decision tree learners. The generator produces a stream containing nine features, six numeric and three categorical. There are 10 functions defined for generating binary class labels from the features. Presumably these determine whether the loan should be approved. Classification functions are listed in the original paper <sup>1</sup>. </p> <p>Feature | Description | Values </p> <ul> <li> <p><code>salary</code> | salary | uniformly distributed from 20k to 150k </p> </li> <li> <p><code>commission</code> | commission | 0 if <code>salary</code> &lt; 75k else uniformly distributed from 10k to 75k </p> </li> <li> <p><code>age</code> | age | uniformly distributed from 20 to 80 </p> </li> <li> <p><code>elevel</code> | education level | uniformly chosen from 0 to 4 </p> </li> <li> <p><code>car</code> | car maker | uniformly chosen from 1 to 20 </p> </li> <li> <p><code>zipcode</code> | zip code of the town | uniformly chosen from 0 to 8 </p> </li> <li> <p><code>hvalue</code> | house value | uniformly distributed from 50k x zipcode to 100k x zipcode </p> </li> <li> <p><code>hyears</code> | years house owned | uniformly distributed from 1 to 30 </p> </li> <li> <p><code>loan</code> | total loan amount | uniformly distributed from 0 to 500k</p> </li> </ul>"},{"location":"api/datasets/synth/Agrawal/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>The classification function to use for the generation. Valid values are from 0 to 9.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, the class distribution will converge to a uniform distribution.</p> </li> <li> <p>perturbation</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>The probability that noise will happen in the generation. Each new sample will be perturbed by the magnitude of <code>perturbation</code>. Valid values are in the range [0.0 to 1.0].</p> </li> </ul>"},{"location":"api/datasets/synth/Agrawal/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Agrawal/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Agrawal(\n    classification_function=0,\n    seed=42\n)\n\ndataset\n</code></pre> <pre><code>Synthetic data generator\n&lt;BLANKLINE&gt;\n    Name  Agrawal\n    Task  Binary classification\n Samples  \u221e\nFeatures  9\n Outputs  1\n Classes  2\n  Sparse  False\n&lt;BLANKLINE&gt;\nConfiguration\n-------------\nclassification_function  0\n                   seed  42\n        balance_classes  False\n           perturbation  0.0\n</code></pre></p> <p><pre><code>for x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[103125.4837, 0, 21, 2, 8, 3, 319768.9642, 4, 338349.7437] 1\n[135983.3438, 0, 25, 4, 14, 0, 423837.7755, 7, 116330.4466] 1\n[98262.4347, 0, 55, 1, 18, 6, 144088.1244, 19, 139095.3541] 0\n[133009.0417, 0, 68, 1, 14, 5, 233361.4025, 7, 478606.5361] 1\n[63757.2908, 16955.9382, 26, 2, 12, 4, 522851.3093, 24, 229712.4398] 1\n</code></pre></p>"},{"location":"api/datasets/synth/Agrawal/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function randomly.</p> <p></p> take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/Agrawal/#notes","title":"Notes","text":"<p>The sample generation works as follows: The 9 features are generated with the random generator, initialized with the seed passed by the user. Then, the classification function decides, as a function of all the attributes, whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes. Finally, add noise if <code>perturbation</code> &gt; 0.0.</p> <ol> <li> <p>Rakesh Agrawal, Tomasz Imielinksi, and Arun Swami. \"Database Mining:   A Performance Perspective\", IEEE Transactions on Knowledge and   Data Engineering, 5(6), December 1993.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/AnomalySine/","title":"AnomalySine","text":"<p>Simulate a stream with anomalies in sine waves.</p> <p>The amount of data generated by this generator is finite. </p> <p>The data generated corresponds to sine and cosine functions. Anomalies are induced by replacing the cosine values with values from a different a sine function. The <code>contextual</code> flag can be used to introduce contextual anomalies which are values in the normal global range, but abnormal compared to the seasonal pattern. Contextual attributes are introduced by replacing cosine entries with sine values. </p> <p>The target indicates whether or not the instances are anomalous.</p>"},{"location":"api/datasets/synth/AnomalySine/#parameters","title":"Parameters","text":"<ul> <li> <p>n_samples</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10000</code></p> <p>The number of samples to generate. This generator creates a batch of data affected by contextual anomalies and noise.</p> </li> <li> <p>n_anomalies</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2500</code></p> <p>Number of anomalies. Can't be larger than <code>n_samples</code>.</p> </li> <li> <p>contextual</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, will add contextual anomalies.</p> </li> <li> <p>n_contextual</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2500</code></p> <p>Number of contextual anomalies. Can't be larger than <code>n_samples</code>.</p> </li> <li> <p>shift</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>4</code></p> <p>Shift in number of samples applied when retrieving contextual anomalies.</p> </li> <li> <p>noise</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.5</code></p> <p>Amount of noise.</p> </li> <li> <p>replace</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, anomalies are randomly sampled with replacement.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/AnomalySine/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/AnomalySine/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.AnomalySine(\n    seed=12345,\n    n_samples=100,\n    n_anomalies=25,\n    contextual=True,\n    n_contextual=10\n)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{'sine': -0.7119, 'cosine': 0.8777} False\n{'sine': 0.8792, 'cosine': -0.0290} False\n{'sine': 0.0440, 'cosine': 3.0852} True\n{'sine': 0.5520, 'cosine': 3.4515} True\n{'sine': 0.8037, 'cosine': 0.4027} False\n</code></pre></p>"},{"location":"api/datasets/synth/AnomalySine/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/ConceptDriftStream/","title":"ConceptDriftStream","text":"<p>Generates a stream with concept drift.</p> <p>A stream generator that adds concept drift or change by joining two streams. This is done by building a weighted combination of two pure distributions that characterizes the target concepts before and after the change. </p> <p>The sigmoid function is an elegant and practical solution to define the probability that each new instance of the stream belongs to the new concept after the drift. The sigmoid function introduces a gradual, smooth transition whose duration is controlled with two parameters: </p> <ul> <li> <p>\\(p\\), the position of the change.</p> </li> <li> <p>\\(w\\), the width of the transition.</p> </li> </ul> <p>The sigmoid function at sample \\(t\\) is </p> \\[f(t) = 1/(1+e^{-4(t-p)/w})\\]"},{"location":"api/datasets/synth/ConceptDriftStream/#parameters","title":"Parameters","text":"<ul> <li> <p>stream</p> <p>Type \u2192 datasets.base.SyntheticDataset | None</p> <p>Default \u2192 <code>None</code></p> <p>Original stream</p> </li> <li> <p>drift_stream</p> <p>Type \u2192 datasets.base.SyntheticDataset | None</p> <p>Default \u2192 <code>None</code></p> <p>Drift stream</p> </li> <li> <p>position</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5000</code></p> <p>Central position of the concept drift change.</p> </li> <li> <p>width</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000</code></p> <p>Width of concept drift change.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>alpha</p> <p>Type \u2192 float | None</p> <p>Default \u2192 <code>None</code></p> <p>Angle of change used to estimate the width of concept drift change. If set, it will override the width parameter. Valid values are in the range (0.0, 90.0].</p> </li> </ul>"},{"location":"api/datasets/synth/ConceptDriftStream/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/ConceptDriftStream/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.ConceptDriftStream(\n    stream=synth.SEA(seed=42, variant=0),\n    drift_stream=synth.SEA(seed=42, variant=1),\n    seed=1, position=5, width=2\n)\n\nfor x, y in dataset.take(10):\n    print(x, y)\n</code></pre> <pre><code>{0: 6.3942, 1: 0.2501, 2: 2.7502} False\n{0: 2.2321, 1: 7.3647, 2: 6.7669} True\n{0: 8.9217, 1: 0.8693, 2: 4.2192} True\n{0: 0.2979, 1: 2.1863, 2: 5.0535} False\n{0: 6.3942, 1: 0.2501, 2: 2.7502} False\n{0: 2.2321, 1: 7.3647, 2: 6.7669} True\n{0: 8.9217, 1: 0.8693, 2: 4.2192} True\n{0: 0.2979, 1: 2.1863, 2: 5.0535} False\n{0: 0.2653, 1: 1.9883, 2: 6.4988} False\n{0: 5.4494, 1: 2.2044, 2: 5.8926} False\n</code></pre></p>"},{"location":"api/datasets/synth/ConceptDriftStream/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/ConceptDriftStream/#notes","title":"Notes","text":"<p>An optional way to estimate the width of the transition \\(w\\) is based on the angle \\(\\alpha\\), \\(w = 1/ tan(\\alpha)\\). Since width corresponds to the number of samples for the transition, the width is rounded to the nearest smaller integer. Notice that larger values of \\(\\alpha\\) result in smaller widths. For \\(\\alpha &gt; 45.0\\), the width is smaller than 1 so values are rounded to 1 to avoid division by zero errors.</p>"},{"location":"api/datasets/synth/Friedman/","title":"Friedman","text":"<p>Friedman synthetic dataset.</p> <p>Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. The target is defined by the following function: </p> \\[y = 10 sin(\\pi x_0 x_1) + 20 (x_2 - 0.5)^2 + 10 x_3 + 5 x_4 + \\epsilon\\] <p>In the last expression, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\), is the noise. Therefore, only the first 5 features are relevant.</p>"},{"location":"api/datasets/synth/Friedman/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Friedman/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Friedman/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Friedman(seed=42)\n\nfor x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 7.04\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 18.16\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] 8.90\n</code></pre></p>"},{"location":"api/datasets/synth/Friedman/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Friedman, J.H., 1991. Multivariate adaptive regression splines. The annals of statistics, pp.1-67. \u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/FriedmanDrift/","title":"FriedmanDrift","text":"<p>Friedman synthetic dataset with concept drifts.</p> <p>Each observation is composed of 10 features. Each feature value is sampled uniformly in [0, 1]. Only the first 5 features are relevant. The target is defined by different functions depending on the type of the drift. </p> <p>The three available modes of operation of the data generator are described in <sup>1</sup>.</p>"},{"location":"api/datasets/synth/FriedmanDrift/#parameters","title":"Parameters","text":"<ul> <li> <p>drift_type</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>lea</code></p> <p>The variant of concept drift. - <code>'lea'</code>: Local Expanding Abrupt drift. The concept drift appears in two distinct regions of the instance space, while the remaining regions are left unaltered. There are three points of abrupt change in the training dataset. At every consecutive change the regions of drift are expanded. - <code>'gra'</code>: Global Recurring Abrupt drift. The concept drift appears over the whole instance space. There are two points of concept drift. At the second point of drift the old concept reoccurs. - <code>'gsg'</code>: Global and Slow Gradual drift. The concept drift affects all the instance space. However, the change is gradual and not abrupt. After each one of the two change points covered by this variant, and during a window of length <code>transition_window</code>, examples from both old and the new concepts are generated with equal probability. After the transition period, only the examples from the new concept are generated.</p> </li> <li> <p>position</p> <p>Type \u2192 tuple[int, ...]</p> <p>Default \u2192 <code>(50000, 100000, 150000)</code></p> <p>The amount of monitored instances after which each concept drift occurs. A tuple with at least two element must be passed, where each number is greater than the preceding one. If <code>drift_type='lea'</code>, then the tuple must have three elements.</p> </li> <li> <p>transition_window</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10000</code></p> <p>The length of the transition window between two concepts. Only applicable when  <code>drift_type='gsg'</code>. If set to zero, the drifts will be abrupt. Anytime  <code>transition_window &gt; 0</code>, it defines a window in which instances of the new  concept are gradually introduced among the examples from the old concept.  During this transition phase, both old and new concepts appear with equal probability.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/FriedmanDrift/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/FriedmanDrift/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.FriedmanDrift(\n    drift_type='lea',\n    position=(1, 2, 3),\n    seed=42\n)\n\nfor x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 7.04\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 18.16\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] -2.65\n</code></pre></p> <p><pre><code>dataset = synth.FriedmanDrift(\n    drift_type='gra',\n    position=(2, 3),\n    seed=42\n)\n\nfor x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 8.96\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 18.16\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] 8.90\n</code></pre></p> <p><pre><code>dataset = synth.FriedmanDrift(\n    drift_type='gsg',\n    position=(1, 4),\n    transition_window=2,\n    seed=42\n)\n\nfor x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[0.63, 0.02, 0.27, 0.22, 0.73, 0.67, 0.89, 0.08, 0.42, 0.02] 7.66\n[0.02, 0.19, 0.64, 0.54, 0.22, 0.58, 0.80, 0.00, 0.80, 0.69] 8.33\n[0.34, 0.15, 0.95, 0.33, 0.09, 0.09, 0.84, 0.60, 0.80, 0.72] 8.92\n[0.37, 0.55, 0.82, 0.61, 0.86, 0.57, 0.70, 0.04, 0.22, 0.28] 17.32\n[0.07, 0.23, 0.10, 0.27, 0.63, 0.36, 0.37, 0.20, 0.26, 0.93] 6.05\n</code></pre></p>"},{"location":"api/datasets/synth/FriedmanDrift/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Ikonomovska, E., Gama, J. and D\u017eeroski, S., 2011. Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), pp.128-168.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Hyperplane/","title":"Hyperplane","text":"<p>Hyperplane stream generator.</p> <p>Generates a problem of prediction class of a rotation hyperplane. It was used as testbed for CVFDT and VFDT in <sup>1</sup>. </p> <p>A hyperplane in d-dimensional space is the set of points \\(x\\) that satisfy </p> \\[\\sum^{d}_{i=1} w_i x_i = w_0 = \\sum^{d}_{i=1} w_i\\] <p>where \\(x_i\\) is the i-th coordinate of \\(x\\). </p> <ul> <li> <p>Examples for which \\(\\sum^{d}_{i=1} w_i x_i &gt; w_0\\), are labeled positive.</p> </li> <li> <p>Examples for which \\(\\sum^{d}_{i=1} w_i x_i \\leq w_0\\), are labeled negative.</p> </li> </ul> <p>Hyperplanes are useful for simulating time-changing concepts because we can change the orientation and position of the hyperplane in a smooth manner by changing the relative size of the weights. We introduce change to this dataset by adding drift to each weighted feature \\(w_i = w_i + d \\sigma\\), where \\(\\sigma\\) is the probability that the direction of change is reversed and \\(d\\) is the change applied to each example.</p>"},{"location":"api/datasets/synth/Hyperplane/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>n_features</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of attributes to generate. Higher than 2.</p> </li> <li> <p>n_drift_features</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2</code></p> <p>The number of attributes with drift. Higher than 2.</p> </li> <li> <p>mag_change</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>Magnitude of the change for every example. From 0.0 to 1.0.</p> </li> <li> <p>noise_percentage</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>Percentage of noise to add to the data. From 0.0 to 1.0.</p> </li> <li> <p>sigma</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.1</code></p> <p>Probability that the direction of change is reversed. From 0.0 to 1.0.</p> </li> </ul>"},{"location":"api/datasets/synth/Hyperplane/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Hyperplane/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Hyperplane(seed=42, n_features=2)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{0: 0.2750, 1: 0.2232} 0\n{0: 0.0869, 1: 0.4219} 1\n{0: 0.0265, 1: 0.1988} 0\n{0: 0.5892, 1: 0.8094} 0\n{0: 0.3402, 1: 0.1554} 0\n</code></pre></p>"},{"location":"api/datasets/synth/Hyperplane/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/Hyperplane/#notes","title":"Notes","text":"<p>The sample generation works as follows: The features are generated with the random number generator, initialized with the seed passed by the user. Then the classification function decides, as a function of the sum of the weighted features and the sum of the weights, whether the instance belongs to class 0 or class 1. The last step is to add noise and generate drift.</p> <ol> <li> <p>G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams.   In KDD'01, pages 97-106, San Francisco, CA, 2001. ACM Press.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/LED/","title":"LED","text":"<p>LED stream generator.</p> <p>This data source originates from the CART book <sup>1</sup>. An implementation in C was donated to the UCI <sup>2</sup> machine learning repository by David Aha. The goal is to predict the digit displayed on a seven-segment LED display, where each attribute has a 10% chance of being inverted. It has an optimal Bayes classification rate of 74%. The particular configuration of the generator used for experiments (LED) produces 24 binary attributes, 17 of which are irrelevant.</p>"},{"location":"api/datasets/synth/LED/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>noise_percentage</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value  will be switched</p> </li> <li> <p>irrelevant_features</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Adds 17 non-relevant attributes to the stream.</p> </li> </ul>"},{"location":"api/datasets/synth/LED/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/LED/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.LED(seed = 112, noise_percentage = 0.28, irrelevant_features= False)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{0: 1, 1: 0, 2: 1, 3: 0, 4: 0, 5: 1, 6: 0} 7\n{0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 0} 8\n{0: 1, 1: 1, 2: 1, 3: 1, 4: 0, 5: 1, 6: 0} 9\n{0: 0, 1: 0, 2: 1, 3: 0, 4: 0, 5: 1, 6: 0} 1\n{0: 0, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0} 1\n</code></pre></p>"},{"location":"api/datasets/synth/LED/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/LED/#notes","title":"Notes","text":"<p>An instance is generated based on the parameters passed. If <code>has_noise</code> is set then the total number of attributes will be 24, otherwise there will be 7 attributes.</p> <ol> <li> <p>Leo Breiman, Jerome Friedman, R. Olshen, and Charles J. Stone.   Classification and Regression Trees. Wadsworth and Brooks,   Monterey, CA,1984.\u00a0\u21a9</p> </li> <li> <p>A. Asuncion and D. J. Newman. UCI Machine Learning Repository   [http://www.ics.uci.edu/~mlearn/mlrepository.html].   University of California, Irvine, School of Information and   Computer Sciences,2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/LEDDrift/","title":"LEDDrift","text":"<p>LED stream generator with concept drift.</p> <p>This class is an extension of the <code>LED</code> generator whose purpose is to add concept drift to the stream.</p>"},{"location":"api/datasets/synth/LEDDrift/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>noise_percentage</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>The probability that noise will happen in the generation. At each new sample generated, a random number is generated, and if it is equal or less than the noise_percentage, the led value  will be switched</p> </li> <li> <p>irrelevant_features</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Adds 17 non-relevant attributes to the stream.</p> </li> <li> <p>n_drift_features</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>The number of attributes that have drift.</p> </li> </ul>"},{"location":"api/datasets/synth/LEDDrift/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/LEDDrift/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.LEDDrift(seed = 112, noise_percentage = 0.28,\n                         irrelevant_features= True, n_drift_features=4)\n\nfor x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1] 7\n[1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0] 6\n[0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1] 1\n[1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1] 6\n[1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0] 7\n</code></pre></p>"},{"location":"api/datasets/synth/LEDDrift/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/LEDDrift/#notes","title":"Notes","text":"<p>An instance is generated based on the parameters passed. If <code>has_noise</code> is set then the total number of attributes will be 24, otherwise there will be 7 attributes.</p>"},{"location":"api/datasets/synth/Logical/","title":"Logical","text":"<p>Logical functions stream generator.</p> <p>Make a toy dataset with three labels that represent the logical functions: <code>OR</code>, <code>XOR</code>, <code>AND</code> (functions of the 2D input). </p> <p>Data is generated in 'tiles' which contain the complete set of logical operations results. The tiles are repeated <code>n_tiles</code> times. Optionally, the generated data can be shuffled.</p>"},{"location":"api/datasets/synth/Logical/#parameters","title":"Parameters","text":"<ul> <li> <p>n_tiles</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1</code></p> <p>Number of tiles to generate.</p> </li> <li> <p>shuffle</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If set, generated data will be shuffled.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Logical/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Logical/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Logical(n_tiles=2, shuffle=True, seed=42)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{'A': 1, 'B': 1} {'OR': 1, 'XOR': 0, 'AND': 1}\n{'A': 0, 'B': 0} {'OR': 0, 'XOR': 0, 'AND': 0}\n{'A': 1, 'B': 0} {'OR': 1, 'XOR': 1, 'AND': 0}\n{'A': 1, 'B': 1} {'OR': 1, 'XOR': 0, 'AND': 1}\n{'A': 1, 'B': 0} {'OR': 1, 'XOR': 1, 'AND': 0}\n</code></pre></p>"},{"location":"api/datasets/synth/Logical/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/Mixed/","title":"Mixed","text":"<p>Mixed data stream generator.</p> <p>This generator is an implementation of a data stream with abrupt concept drift and boolean noise-free examples as described in <sup>1</sup>. </p> <p>It has four relevant attributes, two boolean attributes \\(v, w\\) and two numeric attributes \\(x, y\\) uniformly distributed from 0 to 1. The examples are labeled depending on the classification function chosen from below. </p> <ul> <li> <p><code>function 0</code>:   if \\(v\\) and \\(w\\) are true or \\(v\\) and \\(z\\) are true or \\(w\\) and \\(z\\) are true   then 0 else 1, where \\(z\\) is \\(y &lt; 0.5 + 0.3 sin(3 \\pi  x)\\) </p> </li> <li> <p><code>function 1</code>:    The opposite of <code>function 0</code>. </p> </li> </ul> <p>Concept drift can be introduced by changing the classification function. This can be done manually or using <code>ConceptDriftStream</code>.</p>"},{"location":"api/datasets/synth/Mixed/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Which of the two classification functions to use for the generation. Valid options are 0 or 1.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Whether to balance classes or not. If balanced, the class distribution will converge to a uniform distribution.</p> </li> </ul>"},{"location":"api/datasets/synth/Mixed/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Mixed/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\ndataset = synth.Mixed(seed = 42, classification_function=1, balance_classes = True)\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{0: True, 1: False, 2: 0.2750, 3: 0.2232} 1\n{0: False, 1: False, 2: 0.2186, 3: 0.5053} 0\n{0: False, 1: True, 2: 0.8094, 3: 0.0064} 1\n{0: False, 1: False, 2: 0.1010, 3: 0.2779} 0\n{0: True, 1: False, 2: 0.37018, 3: 0.2095} 1\n</code></pre></p>"},{"location":"api/datasets/synth/Mixed/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function.</p> <p></p> take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/Mixed/#notes","title":"Notes","text":"<p>The sample generation works as follows: The two numeric attributes are generated with the random  generator initialized with the seed passed by the user (optional). The boolean attributes are either 0 or 1 based on the comparison of the random number generator and 0.5, the classification function decides whether to classify the instance as class 0 or class 1. The next step is to verify if the classes should be balanced, and if so, balance the classes.</p> <p>The generated sample will have 4 relevant features and 1 label (it is a binary-classification task).</p> <ol> <li> <p>Gama, Joao, et al. \"Learning with drift detection.\" Advances in   artificial intelligence-SBIA 2004. Springer Berlin Heidelberg,   2004. 286-295\"\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Mv/","title":"Mv","text":"<p>Mv artificial dataset.</p> <p>Artificial dataset composed of both nominal and numeric features, whose features present co-dependencies. Originally described in <sup>1</sup>. </p> <p>The features are generated using the following expressions: </p> <ul> <li> <p>\\(x_1\\): uniformly distributed over <code>[-5, 5]</code>.</p> </li> <li> <p>\\(x_2\\): uniformly distributed over <code>[-15, -10]</code>.</p> </li> <li> <p>\\(x_3\\):</p> <ul> <li> <p>if \\(x_1 &gt; 0\\), \\(x_3 \\leftarrow\\) <code>'green'</code> </p> </li> <li> <p>else \\(x_3 \\leftarrow\\) <code>'red'</code> with probability \\(0.4\\) and \\(x_3 \\leftarrow\\) <code>'brown'</code>     with probability \\(0.6\\). </p> </li> </ul> </li> <li> <p>\\(x_4\\):</p> <ul> <li> <p>if \\(x_3 =\\) <code>'green'</code>, \\(x_4 \\leftarrow x_1 + 2 x_2\\) </p> </li> <li> <p>else \\(x_4 = \\frac{x_1}{2}\\) with probability \\(0.3\\) and \\(x_4 = \\frac{x_2}{2}\\)     with probability \\(0.7\\). </p> </li> </ul> </li> <li> <p>\\(x_5\\): uniformly distributed over <code>[-1, 1]</code>.</p> </li> <li> <p>\\(x_6 \\leftarrow x_4 \\times \\epsilon\\), where \\(\\epsilon\\) is uniformly distributed</p> </li> </ul> <p>over <code>[0, 5]</code>. </p> <ul> <li> <p>\\(x_7\\): <code>'yes'</code> with probability \\(0.3\\), and <code>'no'</code> with probability \\(0.7\\).</p> </li> <li> <p>\\(x_8\\): <code>'normal'</code> if \\(x_5 &lt; 0.5\\) else <code>'large'</code>.</p> </li> <li> <p>\\(x_9\\): uniformly distributed over <code>[100, 500]</code>.</p> </li> <li> <p>\\(x_{10}\\): uniformly distributed integer over the interval <code>[1000, 1200]</code>.</p> </li> </ul> <p>The target value is generated using the following rules: </p> <ul> <li> <p>if \\(x_2 &gt; 2\\), \\(y \\leftarrow 35 - 0.5 x_4\\)</p> </li> <li> <p>else if \\(-2 \\le x_4 \\le 2\\), \\(y \\leftarrow 10 - 2 x_1\\)</p> </li> <li> <p>else if \\(x_7 =\\) <code>'yes'</code>, \\(y \\leftarrow 3 - \\frac{x_1}{x_4}\\)</p> </li> <li> <p>else if \\(x_8 =\\) <code>'normal'</code>, \\(y \\leftarrow x_6 + x_1\\)</p> </li> <li> <p>else \\(y \\leftarrow \\frac{x_1}{2}\\).</p> </li> </ul>"},{"location":"api/datasets/synth/Mv/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Mv/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Mv/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Mv(seed=42)\n\nfor x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[1.39, -14.87, 'green', -28.35, -0.44, -31.64, 'no', 'normal', 370.67, 1178.43] -30.25\n[-4.13, -12.89, 'red', -2.06, 0.01, -0.27, 'yes', 'normal', 359.95, 1108.98] 1.00\n[-2.79, -12.05, 'brown', -1.39, 0.61, -4.87, 'no', 'large', 162.19, 1191.44] 15.59\n[-1.63, -14.53, 'red', -7.26, 0.20, -29.33, 'no', 'normal', 314.49, 1194.62] -30.96\n[-1.21, -12.23, 'brown', -6.11, 0.72, -17.66, 'no', 'large', 118.32, 1045.57] -0.60\n</code></pre></p>"},{"location":"api/datasets/synth/Mv/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Mv in Lu\u00eds Torgo regression datasets \u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Planes2D/","title":"Planes2D","text":"<p>2D Planes synthetic dataset.</p> <p>This dataset is described in <sup>1</sup> and was adapted from <sup>2</sup>. The features are generated using the following probabilities: </p> \\[P(x_1 = -1) = P(x_1 = 1) = \\frac{1}{2}\\] \\[P(x_m = -1) = P(x_m = 0) = P(x_m = 1) = \\frac{1}{3}, m=2,\\ldots, 10\\] <p>The target value is defined by the following rule: </p> \\[\\text{if}~x_1 = 1, y \\leftarrow 3 + 3x_2 + 2x_3 + x_4 + \\epsilon\\] \\[\\text{if}~x_1 = -1, y \\leftarrow -3 + 3x_5 + 2x_6 + x_7 + \\epsilon\\] <p>In the expressions, \\(\\epsilon \\sim \\mathcal{N}(0, 1)\\), is the noise.</p>"},{"location":"api/datasets/synth/Planes2D/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/Planes2D/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Planes2D/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Planes2D(seed=42)\n\nfor x, y in dataset.take(5):\n    print(list(x.values()), y)\n</code></pre> <pre><code>[-1, -1, 1, 0, -1, -1, -1, 1, -1, 1] -9.07\n[1, -1, -1, -1, -1, -1, 1, 1, -1, 1] -4.25\n[-1, 1, 1, 1, 1, 0, -1, 0, 1, 0] -0.95\n[-1, 1, 0, 0, 0, -1, -1, 0, -1, -1] -6.10\n[1, -1, 0, 0, 1, 0, -1, 1, 0, 1] 1.60\n</code></pre></p>"},{"location":"api/datasets/synth/Planes2D/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>2DPlanes in Lu\u00eds Torgo regression datasets \u21a9</p> </li> <li> <p>Breiman, L., Friedman, J., Stone, C.J. and Olshen, R.A., 1984. Classification and regression trees. CRC press.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/RandomRBF/","title":"RandomRBF","text":"<p>Random Radial Basis Function generator.</p> <p>Produces a radial basis function stream. A number of centroids, having a random central position, a standard deviation, a class label and weight are generated. A new sample is created by choosing one of the centroids at random, taking into account their weights, and offsetting the attributes in a random direction from the centroid's center. The offset length is drawn from a Gaussian distribution. </p> <p>This process will create a normally distributed hypersphere of samples on the surrounds of each centroid.</p>"},{"location":"api/datasets/synth/RandomRBF/#parameters","title":"Parameters","text":"<ul> <li> <p>seed_model</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Model's random seed to generate centroids.</p> </li> <li> <p>seed_sample</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Sample's random seed.</p> </li> <li> <p>n_classes</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2</code></p> <p>The number of class labels to generate.</p> </li> <li> <p>n_features</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of numerical features to generate.</p> </li> <li> <p>n_centroids</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>50</code></p> <p>The number of centroids to generate.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBF/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBF/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\ndataset = synth.RandomRBF(seed_model=42, seed_sample=42,\n                          n_classes=4, n_features=4, n_centroids=20)\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{0: 1.0989, 1: 0.3840, 2: 0.7759, 3: 0.6592} 2\n{0: 0.2366, 1: 1.3233, 2: 0.5691, 3: 0.2083} 0\n{0: 1.3540, 1: -0.3306, 2: 0.1683, 3: 0.8865} 0\n{0: 0.2585, 1: -0.2217, 2: 0.4739, 3: 0.6522} 0\n{0: 0.1295, 1: 0.5953, 2: 0.1774, 3: 0.6673} 1\n</code></pre></p>"},{"location":"api/datasets/synth/RandomRBF/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/RandomRBFDrift/","title":"RandomRBFDrift","text":"<p>Random Radial Basis Function generator with concept drift.</p> <p>This class is an extension from the <code>RandomRBF</code> generator. Concept drift can be introduced in instances of this class. </p> <p>The drift is created by adding a \"speed\" to certain centroids. As the samples are generated each of the moving centroids' centers is changed by an amount determined by its speed.</p>"},{"location":"api/datasets/synth/RandomRBFDrift/#parameters","title":"Parameters","text":"<ul> <li> <p>seed_model</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Model's random seed to generate centroids.</p> </li> <li> <p>seed_sample</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Sample's random seed.</p> </li> <li> <p>n_classes</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2</code></p> <p>The number of class labels to generate.</p> </li> <li> <p>n_features</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of numerical features to generate.</p> </li> <li> <p>n_centroids</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>50</code></p> <p>The number of centroids to generate.</p> </li> <li> <p>change_speed</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>The concept drift speed.</p> </li> <li> <p>n_drift_centroids</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>50</code></p> <p>The number of centroids that will drift.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBFDrift/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomRBFDrift/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\ndataset = synth.RandomRBFDrift(seed_model=42, seed_sample=42,\n                               n_classes=4, n_features=4, n_centroids=20,\n                               change_speed=0.87, n_drift_centroids=10)\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{0: 1.0989, 1: 0.3840, 2: 0.7759, 3: 0.6592} 2\n{0: 1.1496, 1: 1.9014, 2: 1.5393, 3: 0.3210} 0\n{0: 0.7146, 1: -0.2414, 2: 0.8933, 3: 1.6633} 0\n{0: 0.3797, 1: -0.1027, 2: 0.8717, 3: 1.1635} 0\n{0: 0.1295, 1: 0.5953, 2: 0.1774, 3: 0.6673} 1\n</code></pre></p>"},{"location":"api/datasets/synth/RandomRBFDrift/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/RandomTree/","title":"RandomTree","text":"<p>Random Tree generator.</p> <p>This generator is based on <sup>1</sup>. The generator creates a random tree by splitting features at random and setting labels at its leaves. </p> <p>The tree structure is composed of node objects, which can be either inner nodes or leaf nodes. The choice comes as a function of the parameters passed to its initializer. </p> <p>Since the concepts are generated and classified according to a tree structure, in theory, it should favor decision tree learners.</p>"},{"location":"api/datasets/synth/RandomTree/#parameters","title":"Parameters","text":"<ul> <li> <p>seed_tree</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Seed for random generation of tree.</p> </li> <li> <p>seed_sample</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Seed for random generation of instances.</p> </li> <li> <p>n_classes</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2</code></p> <p>The number of classes to generate.</p> </li> <li> <p>n_num_features</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The number of numerical features to generate.</p> </li> <li> <p>n_cat_features</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The number of categorical features to generate.</p> </li> <li> <p>n_categories_per_feature</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The number of values to generate per categorical feature.</p> </li> <li> <p>max_tree_depth</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The maximum depth of the tree concept.</p> </li> <li> <p>first_leaf_level</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>3</code></p> <p>The first level of the tree above <code>max_tree_depth</code> that can have leaves.</p> </li> <li> <p>fraction_leaves_per_level</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.15</code></p> <p>The fraction of leaves per level from <code>first_leaf_level</code> onwards.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomTree/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/RandomTree/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.RandomTree(seed_tree=42, seed_sample=42, n_classes=2,\n                           n_num_features=2, n_cat_features=2,\n                           n_categories_per_feature=2, max_tree_depth=6,\n                           first_leaf_level=3, fraction_leaves_per_level=0.15)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{'x_num_0': 0.6394, 'x_num_1': 0.0250, 'x_cat_0': 1, 'x_cat_1': 0} 0\n{'x_num_0': 0.2232, 'x_num_1': 0.7364, 'x_cat_0': 0, 'x_cat_1': 1} 1\n{'x_num_0': 0.0317, 'x_num_1': 0.0936, 'x_cat_0': 0, 'x_cat_1': 0} 0\n{'x_num_0': 0.5612, 'x_num_1': 0.7160, 'x_cat_0': 1, 'x_cat_1': 0} 0\n{'x_num_0': 0.4492, 'x_num_1': 0.2781, 'x_cat_0': 0, 'x_cat_1': 0} 0\n</code></pre></p>"},{"location":"api/datasets/synth/RandomTree/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Domingos, Pedro, and Geoff Hulten. \"Mining high-speed data streams.\"   In Proceedings of the sixth ACM SIGKDD international conference on   Knowledge discovery and data mining, pp. 71-80. 2000.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/SEA/","title":"SEA","text":"<p>SEA synthetic dataset.</p> <p>Implementation of the data stream with abrupt drift described in <sup>1</sup>. Each observation is composed of 3 features. Only the first two features are relevant. The target is binary, and is positive if the sum of the features exceeds a certain threshold. There are 4 thresholds to choose from. Concept drift can be introduced by switching the threshold anytime during the stream. </p> <ul> <li> <p>Variant 0: <code>True</code> if \\(att1 + att2 &gt; 8\\) </p> </li> <li> <p>Variant 1: <code>True</code> if \\(att1 + att2 &gt; 9\\) </p> </li> <li> <p>Variant 2: <code>True</code> if \\(att1 + att2 &gt; 7\\) </p> </li> <li> <p>Variant 3: <code>True</code> if \\(att1 + att2 &gt; 9.5\\)</p> </li> </ul>"},{"location":"api/datasets/synth/SEA/#parameters","title":"Parameters","text":"<ul> <li> <p>variant</p> <p>Default \u2192 <code>0</code></p> <p>Determines the classification function to use. Possible choices are 0, 1, 2, 3.</p> </li> <li> <p>noise</p> <p>Default \u2192 <code>0.0</code></p> <p>Determines the amount of observations for which the target sign will be flipped.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed number used for reproducibility.</p> </li> </ul>"},{"location":"api/datasets/synth/SEA/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/SEA/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.SEA(variant=0, seed=42)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{0: 6.39426, 1: 0.25010, 2: 2.75029} False\n{0: 2.23210, 1: 7.36471, 2: 6.76699} True\n{0: 8.92179, 1: 0.86938, 2: 4.21921} True\n{0: 0.29797, 1: 2.18637, 2: 5.05355} False\n{0: 0.26535, 1: 1.98837, 2: 6.49884} False\n</code></pre></p>"},{"location":"api/datasets/synth/SEA/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>A Streaming Ensemble Algorithm (SEA) for Large-Scale Classification \u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/STAGGER/","title":"STAGGER","text":"<p>STAGGER concepts stream generator.</p> <p>This generator is an implementation of the dara stream with abrupt concept drift, as described in <sup>1</sup>. </p> <p>The STAGGER concepts are boolean functions <code>f</code> with three features describing objects: size (small, medium and large), shape (circle, square and triangle) and colour (red, blue and green). </p> <p><code>f</code> options: </p> <ol> <li> <p><code>True</code> if the size is small and the color is red. </p> </li> <li> <p><code>True</code> if the color is green or the shape is a circle. </p> </li> <li> <p><code>True</code> if the size is medium or large </p> </li> </ol> <p>Concept drift can be introduced by changing the classification function. This can be done manually or using <code>datasets.synth.ConceptDriftStream</code>. </p> <p>One important feature is the possibility to balance classes, which means the class distribution will tend to a uniform one.</p>"},{"location":"api/datasets/synth/STAGGER/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Classification functions to use. From 0 to 2.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution.</p> </li> </ul>"},{"location":"api/datasets/synth/STAGGER/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/STAGGER/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.STAGGER(classification_function = 2, seed = 112,\n                     balance_classes = False)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{'size': 1, 'color': 2, 'shape': 2} 1\n{'size': 2, 'color': 1, 'shape': 2} 1\n{'size': 1, 'color': 1, 'shape': 2} 1\n{'size': 0, 'color': 1, 'shape': 0} 0\n{'size': 2, 'color': 1, 'shape': 0} 1\n</code></pre></p>"},{"location":"api/datasets/synth/STAGGER/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function at random.</p> <p></p> take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/STAGGER/#notes","title":"Notes","text":"<p>The sample generation works as follows: The 3 attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced, if this option is set by the user.</p> <ol> <li> <p>Schlimmer, J. C., &amp; Granger, R. H. (1986). Incremental learning   from noisy data. Machine learning, 1(3), 317-354.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Sine/","title":"Sine","text":"<p>Sine generator.</p> <p>This generator is an implementation of the dara stream with abrupt concept drift, as described in Gama, Joao, et al. <sup>1</sup>. </p> <p>It generates up to 4 relevant numerical features, that vary from 0 to 1, where only 2 of them are relevant to the classification task and the other 2 are optionally added by as noise. A classification function is chosen among four options: </p> <ol> <li> <p><code>SINE1</code>. Abrupt concept drift, noise-free examples. It has two relevant    attributes. Each attributes has values uniformly distributed in [0, 1].    In the first context all points below the curve \\(y = sin(x)\\) are    classified as positive. </p> </li> <li> <p><code>Reversed SINE1</code>. The reversed classification of <code>SINE1</code>. </p> </li> <li> <p><code>SINE2</code>. The same two relevant attributes. The classification function    is \\(y &lt; 0.5 + 0.3 sin(3 \\pi  x)\\). </p> </li> <li> <p><code>Reversed SINE2</code>. The reversed classification of <code>SINE2</code>. </p> </li> </ol> <p>Concept drift can be introduced by changing the classification function. This can be done manually or using <code>ConceptDriftStream</code>. </p> <p>Two important features are the possibility to balance classes, which means the class distribution will tend to a uniform one, and the possibility to add noise, which will, add two non relevant attributes.</p>"},{"location":"api/datasets/synth/Sine/#parameters","title":"Parameters","text":"<ul> <li> <p>classification_function</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Classification functions to use. From 0 to 3.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>balance_classes</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Whether to balance classes or not. If balanced, the class distribution will converge to an uniform distribution.</p> </li> <li> <p>has_noise</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Adds 2 non relevant features to the stream.</p> </li> </ul>"},{"location":"api/datasets/synth/Sine/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Sine/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Sine(classification_function = 2, seed = 112,\n                     balance_classes = False, has_noise = True)\n\nfor x, y in dataset.take(5):\n    print(x, y)\n</code></pre> <pre><code>{0: 0.4812, 1: 0.6660, 2: 0.6198, 3: 0.6994} 1\n{0: 0.9022, 1: 0.7518, 2: 0.1625, 3: 0.2209} 0\n{0: 0.4547, 1: 0.3901, 2: 0.9629, 3: 0.7287} 0\n{0: 0.4683, 1: 0.3515, 2: 0.2273, 3: 0.6027} 0\n{0: 0.9238, 1: 0.1673, 2: 0.4522, 3: 0.3447} 0\n</code></pre></p>"},{"location":"api/datasets/synth/Sine/#methods","title":"Methods","text":"generate_drift <p>Generate drift by switching the classification function at random.</p> <p></p> take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/Sine/#notes","title":"Notes","text":"<p>The sample generation works as follows: The two attributes are generated with the random number generator. The classification function defines whether to classify the instance as class 0 or class 1. Finally, data is balanced and noise is added, if these options are set by the user.</p> <p>The generated sample will have 2 relevant features, and an additional two noise features if <code>has_noise</code> is set.</p> <ol> <li> <p>Gama, Joao, et al.'s 'Learning with drift detection.'   Advances in artificial intelligence-SBIA 2004.   Springer Berlin Heidelberg, 2004. 286-295.\"\u00a0\u21a9</p> </li> </ol>"},{"location":"api/datasets/synth/Waveform/","title":"Waveform","text":"<p>Waveform stream generator.</p> <p>Generates samples with 21 numeric features and 3 classes, based on a random differentiation of some base waveforms. Supports noise addition, in this case the samples will have 40 features.</p>"},{"location":"api/datasets/synth/Waveform/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>has_noise</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Adds 19 unrelated features to the stream.</p> </li> </ul>"},{"location":"api/datasets/synth/Waveform/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> </ul>"},{"location":"api/datasets/synth/Waveform/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\n\ndataset = synth.Waveform(seed=42, has_noise=True)\n\nfor x, y in dataset:\n    break\n\nx\n</code></pre> <pre><code>{0: -0.0397, 1: -0.7484, 2: 0.2974, 3: 0.3574, 4: -0.0735, 5: -0.3647, 6: 1.5631,     7: 2.5291, 8: 4.1599, 9: 4.9587, 10: 4.52587, 11: 4.0097, 12: 3.6705, 13: 1.7033,     14: 1.4898, 15: 1.9743, 16: 0.0898, 17: 2.319, 18: 0.2552, 19: -0.4775, 20: -0.71339,     21: 0.3770, 22: 0.3671, 23: 1.6579, 24: 0.7828, 25: 0.5855, 26: -0.5807, 27: 0.7112,     28: -0.0271, 29: 0.2968, 30: -0.4997, 31: 0.1302, 32: 0.3578, 33: -0.1900, 34: -0.3771,     35: 1.3560, 36: 0.7124, 37: -0.6245, 38: 0.1346, 39: 0.3550}\n</code></pre></p> <p><pre><code>y\n</code></pre> <pre><code>2\n</code></pre></p>"},{"location":"api/datasets/synth/Waveform/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/datasets/synth/Waveform/#notes","title":"Notes","text":"<p>An instance is generated based on the parameters passed. The generator will randomly choose one of the hard coded waveforms, as well as random multipliers. For each feature, the actual value generated will be a a combination of the hard coded functions, with the multipliers and a random value.</p> <p>If noise is added then the features 21 to 40 will be replaced with a random normal value.</p>"},{"location":"api/drift/ADWIN/","title":"ADWIN","text":"<p>Adaptive Windowing method for concept drift detection<sup>1</sup>.</p> <p>ADWIN (ADaptive WINdowing) is a popular drift detection method with mathematical guarantees. ADWIN efficiently keeps a variable-length window of recent items; such that it holds that there has no been change in the data distribution. This window is further divided into two sub-windows \\((W_0, W_1)\\) used to determine if a change has happened. ADWIN compares the average of \\(W_0\\) and \\(W_1\\) to confirm that they correspond to the same distribution. Concept drift is detected if the distribution equality no longer holds. Upon detecting a drift, \\(W_0\\) is replaced by \\(W_1\\) and a new \\(W_1\\) is initialized. ADWIN uses a significance value \\(\\delta=\\in(0,1)\\) to determine if the two sub-windows correspond to the same distribution.</p>"},{"location":"api/drift/ADWIN/#parameters","title":"Parameters","text":"<ul> <li> <p>delta</p> <p>Default \u2192 <code>0.002</code></p> <p>Significance value.</p> </li> <li> <p>clock</p> <p>Default \u2192 <code>32</code></p> <p>How often ADWIN should check for changes. 1 means every new data point, default is 32. Higher values speed up processing, but may also lead to increased delay in change detection.</p> </li> <li> <p>max_buckets</p> <p>Default \u2192 <code>5</code></p> <p>The maximum number of buckets of each size that ADWIN should keep before merging buckets. The idea of data buckets comes from the compression algorithm introduced in the ADWIN2, the second iteration of the ADWIN algorithm presented in the original research paper. This is the ADWIN version available in River.</p> </li> <li> <p>min_window_length</p> <p>Default \u2192 <code>5</code></p> <p>The minimum length allowed for a subwindow when checking for concept drift. Subwindows whose size is smaller than this value will be ignored during concept drift evaluation. Lower values may decrease delay in change detection but may also lead to more false positives.</p> </li> <li> <p>grace_period</p> <p>Default \u2192 <code>10</code></p> <p>ADWIN does not perform any change detection until at least this many data points have arrived.</p> </li> </ul>"},{"location":"api/drift/ADWIN/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>estimation</p> <p>Estimate of mean value in the window.</p> </li> <li> <p>n_detections</p> <p>The total number of detected changes.</p> </li> <li> <p>total</p> <p>The sum of the stored elements.</p> </li> <li> <p>variance</p> <p>The sample variance within the stored (adaptive) window.</p> </li> <li> <p>width</p> <p>Window size</p> </li> </ul>"},{"location":"api/drift/ADWIN/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(12345)\nadwin = drift.ADWIN()\n\ndata_stream = rng.choices([0, 1], k=1000) + rng.choices(range(4, 8), k=1000)\n\nfor i, val in enumerate(data_stream):\n    adwin.update(val)\n    if adwin.drift_detected:\n        print(f\"Change detected at index {i}, input value: {val}\")\n</code></pre> <pre><code>Change detected at index 1023, input value: 4\n</code></pre></p>"},{"location":"api/drift/ADWIN/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Apart from adding the element value to the window, by inserting it in the correct bucket, it will also update the relevant statistics, in this case the total sum of all values, the window width and the total variance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'int | float' </li> </ul> <p>Returns</p> <p>None:     self</p> <p></p> <ol> <li> <p>Albert Bifet and Ricard Gavalda. \"Learning from time-changing data with adaptive windowing.\" In Proceedings of the 2007 SIAM international conference on data mining, pp. 443-448. Society for Industrial and Applied Mathematics, 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/DriftRetrainingClassifier/","title":"DriftRetrainingClassifier","text":"<p>Drift retraining classifier.</p> <p>This classifier is a wrapper for any classifier. It monitors the incoming data for concept drifts and warnings in the model's accuracy. In case a warning is detected, a background model starts to train. If a drift is detected, the model will be replaced by the background model, and the background model will be reset.</p>"},{"location":"api/drift/DriftRetrainingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier and background classifier class.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftAndWarningDetector | base.BinaryDriftAndWarningDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Algorithm to track warnings and concept drifts. Attention! If the parameter train_in_background is True, the drift_detector must have a warning tracker.</p> </li> <li> <p>train_in_background</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>Parameter to determine if a background model will be used.</p> </li> </ul>"},{"location":"api/drift/DriftRetrainingClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import drift\nfrom river import metrics\nfrom river import tree\n\ndataset = datasets.Elec2().take(3000)\n\nmodel = drift.DriftRetrainingClassifier(\n    model=tree.HoeffdingTreeClassifier(),\n    drift_detector=drift.binary.DDM()\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 86.46%\n</code></pre></p>"},{"location":"api/drift/DriftRetrainingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/drift/DummyDriftDetector/","title":"DummyDriftDetector","text":"<p>Baseline drift detector that generates pseudo drift detection signals.</p> <p>There are two approaches<sup>1</sup>: </p> <ul> <li> <p><code>fixed</code> where the drift signal is generated every <code>t_0</code> samples.</p> </li> <li> <p><code>random</code> corresponds to a pseudo-random drift detection strategy.</p> </li> </ul>"},{"location":"api/drift/DummyDriftDetector/#parameters","title":"Parameters","text":"<ul> <li> <p>trigger_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>fixed</code></p> <p>The trigger method to use. * <code>fixed</code> * <code>random</code></p> </li> <li> <p>t_0</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>300</code></p> <p>Reference point to define triggers.</p> </li> <li> <p>w</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Auxiliary parameter whose purpose is twofold: - if <code>trigger_method=\"fixed\"</code>, the periodic drift signals will only start after an initial warm-up period randomly defined between <code>[0, w]</code>. Useful to avoid that all ensemble members are reset at the same time when periodic triggers are used as the adaptation strategy. - if <code>trigger_method=\"random\"</code>, <code>w</code> defines the probability bounds of triggering a drift. The chance of triggering a drift is \\(0.5\\) after observing <code>t_0</code> instances and becomes \\(1\\) after monitoring <code>t_0 + w / 2</code> instances. A sigmoid function is used to produce values between <code>[0, 1]</code> that are used as the reset probabilities.</p> </li> <li> <p>dynamic_cloning</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Whether to change the <code>seed</code> and <code>w</code> values each time <code>clone()</code> is called.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/drift/DummyDriftDetector/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/DummyDriftDetector/#examples","title":"Examples","text":"<pre><code>import random\nfrom river import drift\n\nrng = random.Random(42)\n</code></pre> <p>The observed values will not affect the periodic triggers.</p> <pre><code>data = [rng.gauss(0, 1) for _ in range(1000)]\n</code></pre> <p>Let's start with the fixed drift signals:</p> <p><pre><code>ptrigger = DummyDriftDetector(t_0=500, seed=42)\nfor i, v in enumerate(data):\n    ptrigger.update(v)\n    if ptrigger.drift_detected:\n        print(f\"Drift detected at instance {i}.\")\n</code></pre> <pre><code>Drift detected at instance 499.\nDrift detected at instance 999.\n</code></pre></p> <p>Now, the random drift signals:</p> <p><pre><code>rtrigger = DummyDriftDetector(\n    trigger_method=\"random\",\n    t_0=500,\n    w=100,\n    dynamic_cloning=True,\n    seed=42\n)\nfor i, v in enumerate(data):\n    rtrigger.update(v)\n    if rtrigger.drift_detected:\n        print(f\"Drift detected at instance {i}.\")\n</code></pre> <pre><code>Drift detected at instance 368.\nDrift detected at instance 817.\n</code></pre></p> <p>Remember to set a w &gt; 0 value if random triggers are used:</p> <p><pre><code>try:\n    DummyDriftDetector(trigger_method=\"random\")\nexcept ValueError as ve:\n    print(ve)\n</code></pre> <pre><code>The 'w' value must be greater than zero when 'trigger_method' is 'random'.\n</code></pre></p> <p>Since we set <code>dynamic_cloning</code> to <code>True</code>, a clone of the periodic trigger will have its internal parameters changed:</p> <p><pre><code>rtrigger = rtrigger.clone()\nfor i, v in enumerate(data):\n    rtrigger.update(v)\n    if rtrigger.drift_detected:\n        print(f\"Drift detected at instance {i}.\")\n</code></pre> <pre><code>Drift detected at instance 429.\nDrift detected at instance 728.\n</code></pre></p>"},{"location":"api/drift/DummyDriftDetector/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'int | float' </li> </ul> <p></p>"},{"location":"api/drift/DummyDriftDetector/#notes","title":"Notes","text":"<p>When used in ensembles, a naive implementation of periodic drift signals would make all ensemble members reset at the same time. To avoid that, the <code>dynamic_cloning</code> parameter can be set to <code>True</code>. In this case, every time the <code>clone</code> method of this detector is called in an ensemble a new <code>seed</code> is defined. If <code>dynamic_cloning=True</code> and <code>trigger_method=\"fixed\"</code>, a new <code>w</code> between <code>[0, t_0]</code> will also be created for the new cloned instance.</p> <ol> <li> <p>Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini, Bernhard Pfahringer, and Albert Bifet. On Ensemble Techniques for Data Stream Regression. IJCNN'20. International Joint Conference on Neural Networks. 2020.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/KSWIN/","title":"KSWIN","text":"<p>Kolmogorov-Smirnov Windowing method for concept drift detection.</p>"},{"location":"api/drift/KSWIN/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.005</code></p> <p>Probability for the test statistic of the Kolmogorov-Smirnov-Test. The alpha parameter is very sensitive, therefore should be set below 0.01.</p> </li> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>100</code></p> <p>Size of the sliding window.</p> </li> <li> <p>stat_size</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>30</code></p> <p>Size of the statistic window.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> <li> <p>window</p> <p>Type \u2192 typing.Iterable | None</p> <p>Default \u2192 <code>None</code></p> <p>Already collected data to avoid cold start.</p> </li> </ul>"},{"location":"api/drift/KSWIN/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/KSWIN/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(12345)\nkswin = drift.KSWIN(alpha=0.0001, seed=42)\n\ndata_stream = rng.choices([0, 1], k=1000) + rng.choices(range(4, 8), k=1000)\n\nfor i, val in enumerate(data_stream):\n    kswin.update(val)\n    if kswin.drift_detected:\n        print(f\"Change detected at index {i}, input value: {val}\")\n</code></pre> <pre><code>Change detected at index 1016, input value: 6\n</code></pre></p>"},{"location":"api/drift/KSWIN/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Adds an element on top of the sliding window and removes the oldest one from the window. Afterwards, the KS-test is performed.</p> <p>Parameters</p> <ul> <li>x     \u2014 'int | float' </li> </ul> <p>Returns</p> <p>None:     self</p> <p></p>"},{"location":"api/drift/KSWIN/#notes","title":"Notes","text":"<p>KSWIN (Kolmogorov-Smirnov Windowing) is a concept change detection method based on the Kolmogorov-Smirnov (KS) statistical test. KS-test is a statistical test with no assumption of underlying data distribution. KSWIN can monitor data or performance distributions. Note that the detector accepts one dimensional input as array.</p> <p>KSWIN maintains a sliding window \\(\\Psi\\) of fixed size \\(n\\) (window_size). The last \\(r\\) (stat_size) samples of \\(\\Psi\\) are assumed to represent the last concept considered as \\(R\\). From the first \\(n-r\\) samples of \\(\\Psi\\), \\(r\\) samples are uniformly drawn, representing an approximated last concept \\(W\\).</p> <p>The KS-test is performed on the windows \\(R\\) and \\(W\\) of the same size. KS -test compares the distance of the empirical cumulative data distribution \\(dist(R,W)\\).</p> <p>A concept drift is detected by KSWIN if:</p> \\[ dist(R,W) &gt; \\sqrt{-\\frac{ln\\alpha}{r}} \\] <p>The difference in empirical data distributions between the windows \\(R\\) and \\(W\\) is too large since \\(R\\) and \\(W\\) come from the same distribution.</p> <ol> <li> <p>Christoph Raab, Moritz Heusinger, Frank-Michael Schleif, Reactive Soft Prototype Computing for Concept Drift Streams, Neurocomputing, 2020,\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/NoDrift/","title":"NoDrift","text":"<p>Dummy class used to turn off concept drift detection capabilities of adaptive models. It always signals that no concept drift was detected. Examples --------</p> <p>from river import drift &gt;&gt;&gt; from river import evaluate &gt;&gt;&gt; from river import forest &gt;&gt;&gt; from river import metrics &gt;&gt;&gt; from river.datasets import synth </p> <p>dataset = datasets.synth.ConceptDriftStream( ...     seed=8, ...     position=500, ...     width=40, ... ).take(700) </p> <p>We can turn off the warning detection capabilities of Adaptive Random Forest (ARF) or other similar models. Thus, the base models will reset immediately after identifying a drift, bypassing the background model building phase: </p> <p>adaptive_model = forest.ARFClassifier( ...     leaf_prediction=\"mc\", ...     warning_detector=drift.NoDrift(), ...     seed=8 ... ) </p> <p>We can also turn off the concept drift handling capabilities completely: </p> <p>stationary_model = forest.ARFClassifier( ...     leaf_prediction=\"mc\", ...     warning_detector=drift.NoDrift(), ...     drift_detector=drift.NoDrift(), ...     seed=8 ... ) </p> <p>Let's put that to test: </p> <p>for x, y in dataset: ...     adaptive_model.learn_one(x, y) ...     stationary_model.learn_one(x, y) </p> <p>The adaptive model: </p> <p>adaptive_model.n_drifts_detected() 2 </p> <p>adaptive_model.n_warnings_detected() 0 </p> <p>The stationary one: </p> <p>stationary_model.n_drifts_detected() 0 </p> <p>stationary_model.n_warnings_detected() 0</p>"},{"location":"api/drift/NoDrift/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/NoDrift/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'int | float' </li> </ul> <p></p>"},{"location":"api/drift/PageHinkley/","title":"PageHinkley","text":"<p>Page-Hinkley method for concept drift detection.</p> <p>This change detection method works by computing the observed values and their mean up to the current moment. Page-Hinkley does not signal warning zones, only change detections. </p> <p>This detector implements the CUSUM control chart for detecting changes. This implementation also supports the two-sided Page-Hinkley test to detect increasing and decreasing changes in the mean of the input values.</p>"},{"location":"api/drift/PageHinkley/#parameters","title":"Parameters","text":"<ul> <li> <p>min_instances</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>30</code></p> <p>The minimum number of instances before detecting change.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.005</code></p> <p>The delta factor for the Page-Hinkley test.</p> </li> <li> <p>threshold</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>50.0</code></p> <p>The change detection threshold (lambda).</p> </li> <li> <p>alpha</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.9999</code></p> <p>The forgetting factor, used to weight the observed value and the mean.</p> </li> <li> <p>mode</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>both</code></p> <p>Whether to consider increases (\"up\"), decreases (\"down\") or both (\"both\") when monitoring the fading mean.</p> </li> </ul>"},{"location":"api/drift/PageHinkley/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/PageHinkley/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(12345)\nph = drift.PageHinkley()\n\ndata_stream = rng.choices([0, 1], k=1000) + rng.choices(range(4, 8), k=1000)\n\nfor i, val in enumerate(data_stream):\n    ph.update(val)\n    if ph.drift_detected:\n        print(f\"Change detected at index {i}, input value: {val}\")\n</code></pre> <pre><code>Change detected at index 1006, input value: 5\n</code></pre></p>"},{"location":"api/drift/PageHinkley/#methods","title":"Methods","text":"update <p>Update the detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'int | float' </li> </ul> <p></p> <ol> <li> <p>E. S. Page. 1954. Continuous Inspection Schemes. Biometrika 41, 1/2 (1954), 100-115.\u00a0\u21a9</p> </li> <li> <p>Sebasti\u00e3o, R., &amp; Fernandes, J. M. (2017, June). Supporting the Page-Hinkley test with empirical mode decomposition for change detection. In International Symposium on Methodologies for Intelligent Systems (pp. 492-498). Springer, Cham.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/binary/DDM/","title":"DDM","text":"<p>Drift Detection Method.</p> <p>DDM (Drift Detection Method) is a concept change detection method based on the PAC learning model premise, that the learner's error rate will decrease as the number of analysed samples increase, as long as the data distribution is stationary. </p> <p>If the algorithm detects an increase in the error rate, that surpasses a calculated threshold, either change is detected or the algorithm will warn the user that change may occur in the near future, which is called the warning zone. </p> <p>The detection threshold is calculated in function of two statistics, obtained when \\((p_i + s_i)\\) is minimum: </p> <ul> <li> <p>\\(p_{min}\\): The minimum recorded error rate. </p> </li> <li> <p>\\(s_{min}\\): The minimum recorded standard deviation. </p> </li> </ul> <p>At instant \\(i\\), the detection algorithm uses: </p> <ul> <li> <p>\\(p_i\\): The error rate at instant \\(i\\). </p> </li> <li> <p>\\(s_i\\): The standard deviation at instant \\(i\\). </p> </li> </ul> <p>The conditions for entering the warning zone and detecting change are as follows [see implementation note below]: </p> <ul> <li> <p>if \\(p_i + s_i \\geq p_{min} + w_l * s_{min}\\) -&gt; Warning zone </p> </li> <li> <p>if \\(p_i + s_i \\geq p_{min} + d_l * s_{min}\\) -&gt; Change detected </p> </li> </ul> <p>In the above expressions, \\(w_l\\) and \\(d_l\\) represent, respectively, the warning and drift thresholds. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\)</p> </li> <li> <p>1: Error, \\(y \\neq y'\\)</p> </li> </ul>"},{"location":"api/drift/binary/DDM/#parameters","title":"Parameters","text":"<ul> <li> <p>warm_start</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>30</code></p> <p>The minimum required number of analyzed samples so change can be detected. Warm start parameter for the drift detector.</p> </li> <li> <p>warning_threshold</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>2.0</code></p> <p>Threshold to decide if the detector is in a warning zone. The default value gives 95\\% of confidence level to the warning assessment.</p> </li> <li> <p>drift_threshold</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>3.0</code></p> <p>Threshold to decide if a drift was detected. The default value gives a 99\\% of confidence level to the drift assessment.</p> </li> </ul>"},{"location":"api/drift/binary/DDM/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/binary/DDM/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(42)\nddm = drift.binary.DDM()\n\ndata_stream = rng.choices([0, 1], k=1000)\ndata_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\nprint_warning = True\nfor i, x in enumerate(data_stream):\n    ddm.update(x)\n    if ddm.warning_detected and print_warning:\n        print(f\"Warning detected at index {i}\")\n        print_warning = False\n    if ddm.drift_detected:\n        print(f\"Change detected at index {i}\")\n        print_warning = True\n</code></pre> <pre><code>Warning detected at index 1084\nChange detected at index 1334\nWarning detected at index 1492\n</code></pre></p>"},{"location":"api/drift/binary/DDM/#methods","title":"Methods","text":"update <p>Update the detector with a single boolean input.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p></p> <ol> <li> <p>Jo\u00e3o Gama, Pedro Medas, Gladys Castillo, Pedro Pereira Rodrigues: Learning with Drift Detection. SBIA 2004: 286-295\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/binary/EDDM/","title":"EDDM","text":"<p>Early Drift Detection Method.</p> <p>EDDM (Early Drift Detection Method) aims to improve the detection rate of gradual concept drift in DDM, while keeping a good performance against abrupt concept drift. </p> <p>This method works by keeping track of the average distance between two errors instead of only the error rate. For this, it is necessary to keep track of the running average distance and the running standard deviation, as well as the maximum distance and the maximum standard deviation. </p> <p>The algorithm works similarly to the DDM algorithm, by keeping track of statistics only. It works with the running average distance (\\(p_i'\\)) and the running standard deviation (\\(s_i'\\)), as well as \\(p'_{max}\\) and \\(s'_{max}\\), which are the values of \\(p_i'\\) and \\(s_i'\\) when \\((p_i' + 2 * s_i')\\) reaches its maximum. </p> <p>Like DDM, there are two threshold values that define the borderline between no change, warning zone, and drift detected. These are as follows: </p> <ul> <li> <p>if \\((p_i' + 2 * s_i') / (p'_{max} + 2 * s'_{max}) &lt; \\alpha\\) -&gt; Warning zone </p> </li> <li> <p>if \\((p_i' + 2 * s_i') / (p'_{max} + 2 * s'_{max}) &lt; \\beta\\) -&gt; Change detected </p> </li> </ul> <p>\\(\\alpha\\) and \\(\\beta\\) are set to 0.95 and 0.9, respectively. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\)</p> </li> <li> <p>1: Error, \\(y \\\\neq y'\\)</p> </li> </ul>"},{"location":"api/drift/binary/EDDM/#parameters","title":"Parameters","text":"<ul> <li> <p>warm_start</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>30</code></p> <p>The minimum required number of monitored errors/failures so change can be detected. Warm start parameter for the drift detector.</p> </li> <li> <p>alpha</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.95</code></p> <p>Threshold for triggering a warning. Must be between 0 and 1. The smaller the value, the more conservative the detector becomes.</p> </li> <li> <p>beta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.9</code></p> <p>Threshold for triggering a drift. Must be between 0 and 1. The smaller the value, the more conservative the detector becomes.</p> </li> </ul>"},{"location":"api/drift/binary/EDDM/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/binary/EDDM/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(42)\neddm = drift.binary.EDDM(alpha=0.8, beta=0.75)\n\ndata_stream = rng.choices([0, 1], k=1000)\ndata_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\nprint_warning = True\nfor i, x in enumerate(data_stream):\n    eddm.update(x)\n    if eddm.warning_detected and print_warning:\n        print(f\"Warning detected at index {i}\")\n        print_warning = False\n    if eddm.drift_detected:\n        print(f\"Change detected at index {i}\")\n        print_warning = True\n</code></pre> <pre><code>Warning detected at index 1059\nChange detected at index 1278\n</code></pre></p>"},{"location":"api/drift/binary/EDDM/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p>Returns</p> <p>None:     self</p> <p></p> <ol> <li> <p>Early Drift Detection Method. Manuel Baena-Garcia, Jose Del Campo-Avila, Ra\u00fal Fidalgo, Albert Bifet, Ricard Gavalda, Rafael Morales-Bueno. In Fourth International Workshop on Knowledge Discovery from Data Streams, 2006.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/binary/FHDDM/","title":"FHDDM","text":"<p>Fast Hoeffding Drift Detection Method.</p> <p>FHDDM is a drift detection method based on the Hoeffding's inequality which uses the input average as estimator. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\)</p> </li> <li> <p>1: Error, \\(y \\neq y'\\)</p> </li> </ul> <p>Implementation based on MOA.</p>"},{"location":"api/drift/binary/FHDDM/#parameters","title":"Parameters","text":"<ul> <li> <p>sliding_window_size</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>100</code></p> <p>The minimum required number of analyzed samples so change can be detected.</p> </li> <li> <p>confidence_level</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-06</code></p> <p>Confidence level used to determine the epsilon coefficient in Hoeffding\u2019s inequality. The default value gives a 99\\% of confidence level to the drift assessment.</p> </li> <li> <p>short_window_size</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The size of the short window size that it is used in a Stacking version of FHDDM <sup>2</sup>.</p> </li> </ul>"},{"location":"api/drift/binary/FHDDM/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/binary/FHDDM/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(42)\nfhddm = drift.binary.FHDDM()\nfhddm_s = drift.binary.FHDDM(short_window_size = 20)\ndata_stream = rng.choices([0, 1], k=250)\ndata_stream = data_stream + rng.choices([0, 1], k=250, weights=[0.9, 0.1])\nfor i, x in enumerate(data_stream):\n    fhddm.update(x)\n    fhddm_s.update(x)\n    if fhddm.drift_detected or fhddm_s.drift_detected:\n        print(f\"Change detected at index {i}\")\n</code></pre> <pre><code>Change detected at index 279\nChange detected at index 315\n</code></pre></p>"},{"location":"api/drift/binary/FHDDM/#methods","title":"Methods","text":"update <p>Update the detector with a single boolean input.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p></p> <ol> <li> <p>A. Pesaranghader, H.L. Viktor, Fast Hoeffding Drift Detection Method for Evolving Data Streams. In the Proceedings of ECML-PKDD 2016.\u00a0\u21a9</p> </li> <li> <p>Reservoir of Diverse Adaptive Learners and Stacking Fast Hoeffding Drift Detection Methods for Evolving Data Streams.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/binary/HDDM-A/","title":"HDDM_A","text":"<p>Drift Detection Method based on Hoeffding's bounds with moving average-test.</p> <p>HDDM_A is a drift detection method based on the Hoeffding's inequality which uses the input average as estimator. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\)</p> </li> <li> <p>1: Error, \\(y \\neq y'\\)</p> </li> </ul> <p>Implementation based on MOA.</p>"},{"location":"api/drift/binary/HDDM-A/#parameters","title":"Parameters","text":"<ul> <li> <p>drift_confidence</p> <p>Default \u2192 <code>0.001</code></p> <p>Confidence to the drift</p> </li> <li> <p>warning_confidence</p> <p>Default \u2192 <code>0.005</code></p> <p>Confidence to the warning</p> </li> <li> <p>two_sided_test</p> <p>Default \u2192 <code>False</code></p> <p>If <code>True</code>, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).</p> </li> </ul>"},{"location":"api/drift/binary/HDDM-A/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/binary/HDDM-A/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(42)\nhddm_a = drift.binary.HDDM_A()\n\ndata_stream = rng.choices([0, 1], k=1000)\ndata_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\nprint_warning = True\nfor i, x in enumerate(data_stream):\n    hddm_a.update(x)\n    if hddm_a.warning_detected and print_warning:\n        print(f\"Warning detected at index {i}\")\n        print_warning = False\n    if hddm_a.drift_detected:\n        print(f\"Change detected at index {i}\")\n        print_warning = True\n</code></pre> <pre><code>Warning detected at index 451\nChange detected at index 1206\n</code></pre></p>"},{"location":"api/drift/binary/HDDM-A/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p>Returns</p> <p>None:     self</p> <p></p> <ol> <li> <p>Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift detection methods based on Hoeffding's bounds. IEEE Transactions on Knowledge and Data Engineering, 2014, 27(3): 810-823.\u00a0\u21a9</p> </li> <li> <p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/binary/HDDM-W/","title":"HDDM_W","text":"<p>Drift Detection Method based on Hoeffding's bounds with moving weighted average-test.</p> <p>HDDM_W is an online drift detection method based on McDiarmid's bounds. HDDM_W uses the Exponentially Weighted Moving Average (EWMA) statistic as estimator. </p> <p>Input: <code>x</code> is an entry in a stream of bits, where 1 indicates error/failure and 0 represents correct/normal values. </p> <p>For example, if a classifier's prediction \\(y'\\) is right or wrong w.r.t. the true target label \\(y\\): </p> <ul> <li> <p>0: Correct, \\(y=y'\\)</p> </li> <li> <p>1: Error, \\(y \\neq y'\\)</p> </li> </ul> <p>Implementation based on MOA.</p>"},{"location":"api/drift/binary/HDDM-W/#parameters","title":"Parameters","text":"<ul> <li> <p>drift_confidence</p> <p>Default \u2192 <code>0.001</code></p> <p>Confidence to the drift</p> </li> <li> <p>warning_confidence</p> <p>Default \u2192 <code>0.005</code></p> <p>Confidence to the warning</p> </li> <li> <p>lambda_val</p> <p>Default \u2192 <code>0.05</code></p> <p>The weight given to recent data. Smaller values mean less weight given to recent data.</p> </li> <li> <p>two_sided_test</p> <p>Default \u2192 <code>False</code></p> <p>If True, will monitor error increments and decrements (two-sided). By default will only monitor increments (one-sided).</p> </li> </ul>"},{"location":"api/drift/binary/HDDM-W/#attributes","title":"Attributes","text":"<ul> <li> <p>drift_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> <li> <p>warning_detected</p> <p>Whether or not a drift is detected following the last update.</p> </li> </ul>"},{"location":"api/drift/binary/HDDM-W/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import drift\n\nrng = random.Random(42)\nhddm_w = drift.binary.HDDM_W()\n\ndata_stream = rng.choices([0, 1], k=1000)\ndata_stream = data_stream + rng.choices([0, 1], k=1000, weights=[0.3, 0.7])\n\nprint_warning = True\nfor i, x in enumerate(data_stream):\n    hddm_w.update(x)\n    if hddm_w.warning_detected and print_warning:\n        print(f\"Warning detected at index {i}\")\n        print_warning = False\n    if hddm_w.drift_detected:\n        print(f\"Change detected at index {i}\")\n        print_warning = True\n</code></pre> <pre><code>Warning detected at index 451\nChange detected at index 1077\n</code></pre></p>"},{"location":"api/drift/binary/HDDM-W/#methods","title":"Methods","text":"update <p>Update the change detector with a single data point.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p>Returns</p> <p>None:     self</p> <p></p> <ol> <li> <p>Fr\u00edas-Blanco I, del Campo-\u00c1vila J, Ramos-Jimenez G, et al. Online and non-parametric drift  detection methods based on Hoeffding\u2019s bounds. IEEE Transactions on Knowledge and Data  Engineering, 2014, 27(3): 810-823.\u00a0\u21a9</p> </li> <li> <p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer. MOA: Massive Online Analysis;  Journal of Machine Learning Research 11: 1601-1604, 2010.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/datasets/AirlinePassengers/","title":"AirlinePassengers","text":"<p>JFK Airline Passengers</p> <p>This dataset gives the number of passengers arriving and departing at JFK. The data is obtained from New York State's official Kaggle page for this dataset.</p>"},{"location":"api/drift/datasets/AirlinePassengers/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/drift/datasets/AirlinePassengers/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>https://www.kaggle.com/new-york-state/nys-air-passenger-traffic,-port-authority-of-ny-nj#air-passenger-traffic-per-month-port-authority-of-ny-nj-beginning-1977.csv\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/datasets/Apple/","title":"Apple","text":"<p>Apple Stock</p> <p>This dataset concerns the daily close price and volume of Apple stock around the year 2000. The dataset is sampled every 3 observations to reduce the length of the time series. This dataset is retrieved from Yahoo Finance.</p>"},{"location":"api/drift/datasets/Apple/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/drift/datasets/Apple/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>https://finance.yahoo.com/quote/AAPL/history?period1=850348800&amp;period2=1084579200&amp;interval=1d&amp;filter=history&amp;frequency=1d\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/datasets/Bitcoin/","title":"Bitcoin","text":"<p>Bitcoin Market Price</p> <p>This is a regression task, where the goal is to predict the average USD market price across major bitcoin exchanges. This data was collected from the official Blockchain website. There is only one feature given, the day of exchange, which is in increments of three. The first 500 lines have been removed because they are not interesting.</p>"},{"location":"api/drift/datasets/Bitcoin/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/drift/datasets/Bitcoin/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>https://www.blockchain.com/fr/explorer/charts/market-price?timespan=all\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/datasets/BrentSpotPrice/","title":"BrentSpotPrice","text":"<p>Brent Spot Price</p> <p>This is the USD price for Brent Crude oil, measured daily. We include the time series     from 2000 onwards. The data is sampled at every 10 original observations to reduce the length of the series. </p> <p>The data is obtained from the U.S. Energy Information Administration. Since the data is in the public domain,     we distribute it as part of this repository. </p> <p>Since the original data has observations only on trading days, there are arguably gaps in this time     series (on non-trading days). However we consider these to be consecutive, and thus also consider     the sampled time series to have consecutive observations.</p>"},{"location":"api/drift/datasets/BrentSpotPrice/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/drift/datasets/BrentSpotPrice/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>U.S. Energy Information Administration (Sep. 2019)\u00a0\u21a9</p> </li> <li> <p>https://www.eia.gov/opendata/v1/qb.php?sdid=PET.RBRTE.D\u00a0\u21a9</p> </li> </ol>"},{"location":"api/drift/datasets/Occupancy/","title":"Occupancy","text":"<p>Room occupancy data.</p> <p>Dataset on detecting room occupancy based on several variables. The dataset contains temperature, humidity, light, and CO2 variables. </p> <p>The data is sampled at every 16 observations to reduce the length of the series.</p>"},{"location":"api/drift/datasets/Occupancy/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/drift/datasets/Occupancy/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p> Candanedo, Luis M., and V\u00e9ronique Feldheim. \"Accurate occupancy detection of an office room from light, temperature, humidity and CO2 measurements using statistical learning models.\" Energy and Buildings 112 (2016): 28-39.</p>"},{"location":"api/drift/datasets/RunLog/","title":"RunLog","text":"<p>Interval Training Running Pace.</p> <p>This dataset shows the pace of a runner during an interval training session, where a mobile application provides instructions on when to run and when to walk.</p>"},{"location":"api/drift/datasets/RunLog/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/drift/datasets/RunLog/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/drift/datasets/UKCoalEmploy/","title":"UKCoalEmploy","text":"<p>Historic Employment in UK Coal Mines</p> <p>This is historic data obtained from the UK government.     We use the employment column for the number of workers employed in the British coal mines     Missing values in the data are replaced with the value of the preceding year.</p>"},{"location":"api/drift/datasets/UKCoalEmploy/#attributes","title":"Attributes","text":"<ul> <li> <p>desc</p> <p>Return the description from the docstring.</p> </li> <li> <p>path</p> </li> </ul>"},{"location":"api/drift/datasets/UKCoalEmploy/#methods","title":"Methods","text":"take <p>Iterate over the k samples.</p> <p>Parameters</p> <ul> <li>k     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>https://www.gov.uk/government/statistical-data-sets/historical-coal-data-coal-production-availability-and-consumption\u00a0\u21a9</p> </li> </ol>"},{"location":"api/dummy/NoChangeClassifier/","title":"NoChangeClassifier","text":"<p>Dummy classifier which returns the last class seen.</p> <p>The predict_one method will output the last class seen whilst predict_proba_one will return 1 for the last class seen and 0 for the others.</p>"},{"location":"api/dummy/NoChangeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>last_class</p> <p>The last class seen.</p> </li> <li> <p>classes</p> <p>The set of classes seen.</p> </li> </ul>"},{"location":"api/dummy/NoChangeClassifier/#examples","title":"Examples","text":"<p>Taken from example 2.1 from this page.</p> <p><pre><code>import pprint\nfrom river import dummy\n\nsentences = [\n    ('glad happy glad', '+'),\n    ('glad glad joyful', '+'),\n    ('glad pleasant', '+'),\n    ('miserable sad glad', '\u2212')\n]\n\nmodel = dummy.NoChangeClassifier()\n\nfor sentence, label in sentences:\n    model.learn_one(sentence, label)\n\nnew_sentence = 'glad sad miserable pleasant glad'\nmodel.predict_one(new_sentence)\n</code></pre> <pre><code>'\u2212'\n</code></pre></p> <p><pre><code>pprint.pprint(model.predict_proba_one(new_sentence))\n</code></pre> <pre><code>{'+': 0, '\u2212': 1}\n</code></pre></p>"},{"location":"api/dummy/NoChangeClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/dummy/PriorClassifier/","title":"PriorClassifier","text":"<p>Dummy classifier which uses the prior distribution.</p> <p>The <code>predict_one</code> method will output the most common class whilst <code>predict_proba_one</code> will return the normalized class counts.</p>"},{"location":"api/dummy/PriorClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>counts (collections.Counter)</p> <p>Class counts.</p> </li> <li> <p>n (int)</p> <p>Total number of seen instances.</p> </li> </ul>"},{"location":"api/dummy/PriorClassifier/#examples","title":"Examples","text":"<p>Taken from example 2.1 from this page</p> <p><pre><code>from river import dummy\n\nsentences = [\n    ('glad happy glad', '+'),\n    ('glad glad joyful', '+'),\n    ('glad pleasant', '+'),\n    ('miserable sad glad', '\u2212')\n]\n\nmodel = dummy.PriorClassifier()\n\nfor sentence, label in sentences:\n    model.learn_one(sentence, label)\n\nnew_sentence = 'glad sad miserable pleasant glad'\nmodel.predict_one(new_sentence)\n</code></pre> <pre><code>'+'\n</code></pre> <pre><code>model.predict_proba_one(new_sentence)\n</code></pre> <pre><code>{'+': 0.75, '\u2212': 0.25}\n</code></pre></p>"},{"location":"api/dummy/PriorClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Krichevsky\u2013Trofimov estimator \u21a9</p> </li> </ol>"},{"location":"api/dummy/StatisticRegressor/","title":"StatisticRegressor","text":"<p>Dummy regressor that uses a univariate statistic to make predictions.</p>"},{"location":"api/dummy/StatisticRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>statistic</p> <p>Type \u2192 stats.base.Univariate</p> </li> </ul>"},{"location":"api/dummy/StatisticRegressor/#examples","title":"Examples","text":"<p><pre><code>from pprint import pprint\nfrom river import dummy\nfrom river import stats\n\nsentences = [\n    ('glad happy glad', 3),\n    ('glad glad joyful', 3),\n    ('glad pleasant', 2),\n    ('miserable sad glad', -3)\n]\n\nmodel = dummy.StatisticRegressor(stats.Mean())\n\nfor sentence, score in sentences:\n    model.learn_one(sentence, score)\n\nnew_sentence = 'glad sad miserable pleasant glad'\nmodel.predict_one(new_sentence)\n</code></pre> <pre><code>1.25\n</code></pre></p>"},{"location":"api/dummy/StatisticRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/ensemble/ADWINBaggingClassifier/","title":"ADWINBaggingClassifier","text":"<p>ADWIN Bagging classifier.</p> <p>ADWIN Bagging <sup>1</sup> is the online bagging method of Oza and Russell <sup>2</sup> with the addition of the <code>ADWIN</code> algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.</p>"},{"location":"api/ensemble/ADWINBaggingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to bag.</p> </li> <li> <p>n_models</p> <p>Default \u2192 <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/ADWINBaggingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/ADWINBaggingClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\n\nmodel = ensemble.ADWINBaggingClassifier(\n    model=(\n        preprocessing.StandardScaler() |\n        linear_model.LogisticRegression()\n    ),\n    n_models=3,\n    seed=42\n)\n\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.65%\n</code></pre></p>"},{"location":"api/ensemble/ADWINBaggingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Averages the predictions of each classifier.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p></p> <ol> <li> <p>Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009.\u00a0\u21a9</p> </li> <li> <p>Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/ADWINBoostingClassifier/","title":"ADWINBoostingClassifier","text":"<p>ADWIN Boosting classifier.</p> <p>ADWIN Boosting <sup>1</sup> is the online boosting method of Oza and Russell <sup>2</sup> with the addition of the <code>ADWIN</code> algorithm as a change detector. If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.</p>"},{"location":"api/ensemble/ADWINBoostingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to boost.</p> </li> <li> <p>n_models</p> <p>Default \u2192 <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/ADWINBoostingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/ADWINBoostingClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\nmodel = ensemble.ADWINBoostingClassifier(\n    model=(\n        preprocessing.StandardScaler() |\n        linear_model.LogisticRegression()\n    ),\n    n_models=3,\n    seed=42\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.61%\n</code></pre></p>"},{"location":"api/ensemble/ADWINBoostingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Albert Bifet, Geoff Holmes, Bernhard Pfahringer, Richard Kirkby, and Ricard Gavald\u00e0. \"New ensemble methods for evolving data streams.\" In 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 2009.\u00a0\u21a9</p> </li> <li> <p>Oza, N., Russell, S. \"Online bagging and boosting.\" In: Artificial Intelligence and Statistics 2001, pp. 105\u2013112. Morgan Kaufmann, 2001.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/AdaBoostClassifier/","title":"AdaBoostClassifier","text":"<p>Boosting for classification.</p> <p>For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter lambda. The lambda parameter is updated when the weaks learners fit successively the same observation.</p>"},{"location":"api/ensemble/AdaBoostClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to boost.</p> </li> <li> <p>n_models</p> <p>Default \u2192 <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/AdaBoostClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/AdaBoostClassifier/#examples","title":"Examples","text":"<p>In the following example three tree classifiers are boosted together. The performance is slightly better than when using a single tree.</p> <p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\n\ndataset = datasets.Phishing()\n\nmetric = metrics.LogLoss()\n\nmodel = ensemble.AdaBoostClassifier(\n    model=(\n        tree.HoeffdingTreeClassifier(\n            split_criterion='gini',\n            delta=1e-5,\n            grace_period=2000\n        )\n    ),\n    n_models=5,\n    seed=42\n)\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>LogLoss: 0.370805\n</code></pre></p> <p><pre><code>print(model)\n</code></pre> <pre><code>AdaBoostClassifier(HoeffdingTreeClassifier)\n</code></pre></p>"},{"location":"api/ensemble/AdaBoostClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/BOLEClassifier/","title":"BOLEClassifier","text":"<p>Boosting Online Learning Ensemble (BOLE).</p> <p>A modified version of Oza Online Boosting Algorithm <sup>1</sup>. For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter lambda. The first model to be trained will be the one with worst <code>correct_weight / (correct_weight + wrong_weight)</code>. The worst model not yet trained will receive lambda values for training from the models that incorrectly classified an instance, and the best model's not yet trained will receive lambda values for training from the models that correctly classified an instance. For more details, see <sup>2</sup>.</p>"},{"location":"api/ensemble/BOLEClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to boost.</p> </li> <li> <p>n_models</p> <p>Default \u2192 <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> <li> <p>error_bound</p> <p>Default \u2192 <code>0.5</code></p> <p>Error bound percentage for allowing models to vote.</p> </li> </ul>"},{"location":"api/ensemble/BOLEClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/BOLEClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import drift\nfrom river import metrics\nfrom river import tree\n\ndataset = datasets.Elec2().take(3000)\n\nmodel = ensemble.BOLEClassifier(\n    model=drift.DriftRetrainingClassifier(\n        model=tree.HoeffdingTreeClassifier(),\n        drift_detector=drift.binary.DDM()\n    ),\n    n_models=10,\n    seed=42\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 93.63%\n</code></pre></p>"},{"location":"api/ensemble/BOLEClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> <li> <p>R. S. M. d. Barros, S. Garrido T. de Carvalho Santos and P. M. Gon\u00e7alves J\u00fanior, \"A Boosting-like Online Learning Ensemble,\" 2016 International Joint Conference on Neural Networks (IJCNN), 2016, pp. 1871-1878, doi: 10.1109/IJCNN.2016.7727427.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/BaggingClassifier/","title":"BaggingClassifier","text":"<p>Online bootstrap aggregation for classification.</p> <p>For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter 1. <code>k</code> thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do <code>scipy.stats.utils.random.poisson(1).pmf(k)</code> to obtain more detailed values.</p>"},{"location":"api/ensemble/BaggingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to bag.</p> </li> <li> <p>n_models</p> <p>Default \u2192 <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/BaggingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/BaggingClassifier/#examples","title":"Examples","text":"<p>In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression.</p> <p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\n\nmodel = ensemble.BaggingClassifier(\n    model=(\n        preprocessing.StandardScaler() |\n        linear_model.LogisticRegression()\n    ),\n    n_models=3,\n    seed=42\n)\n\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.65%\n</code></pre></p> <p><pre><code>print(model)\n</code></pre> <pre><code>BaggingClassifier(StandardScaler | LogisticRegression)\n</code></pre></p>"},{"location":"api/ensemble/BaggingClassifier/#methods","title":"Methods","text":"learn_one predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Averages the predictions of each classifier.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p></p> <ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/BaggingRegressor/","title":"BaggingRegressor","text":"<p>Online bootstrap aggregation for regression.</p> <p>For each incoming observation, each model's <code>learn_one</code> method is called <code>k</code> times where <code>k</code> is sampled from a Poisson distribution of parameter 1. <code>k</code> thus has a 36% chance of being equal to 0, a 36% chance of being equal to 1, an 18% chance of being equal to 2, a 6% chance of being equal to 3, a 1% chance of being equal to 4, etc. You can do <code>scipy.stats.utils.random.poisson(1).pmf(k)</code> for more detailed values.</p>"},{"location":"api/ensemble/BaggingRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Regressor</p> <p>The regressor to bag.</p> </li> <li> <p>n_models</p> <p>Default \u2192 <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/BaggingRegressor/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/BaggingRegressor/#examples","title":"Examples","text":"<p>In the following example three logistic regressions are bagged together. The performance is slightly better than when using a single logistic regression.</p> <p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\n\nmodel = preprocessing.StandardScaler()\nmodel |= ensemble.BaggingRegressor(\n    model=linear_model.LinearRegression(intercept_lr=0.1),\n    n_models=3,\n    seed=42\n)\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.677586\n</code></pre></p>"},{"location":"api/ensemble/BaggingRegressor/#methods","title":"Methods","text":"learn_one predict_one <p>Averages the predictions of each regressor.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p></p> <ol> <li> <p>Oza, N.C., 2005, October. Online bagging and boosting. In 2005 IEEE international conference on systems, man and cybernetics (Vol. 3, pp. 2340-2345). Ieee. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/EWARegressor/","title":"EWARegressor","text":"<p>Exponentially Weighted Average regressor.</p>"},{"location":"api/ensemble/EWARegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>Type \u2192 list[base.Regressor]</p> <p>The regressors to hedge.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.RegressionLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function that has to be minimized. Defaults to <code>optim.losses.Squared</code>.</p> </li> <li> <p>learning_rate</p> <p>Default \u2192 <code>0.5</code></p> <p>The learning rate by which the model weights are multiplied at each iteration.</p> </li> </ul>"},{"location":"api/ensemble/EWARegressor/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/EWARegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\nfrom river import stream\n\noptimizers = [\n    optim.SGD(0.01),\n    optim.RMSProp(),\n    optim.AdaGrad()\n]\n\nfor optimizer in optimizers:\n\n    dataset = datasets.TrumpApproval()\n    metric = metrics.MAE()\n    model = (\n        preprocessing.StandardScaler() |\n        linear_model.LinearRegression(\n            optimizer=optimizer,\n            intercept_lr=.1\n        )\n    )\n\n    print(optimizer, evaluate.progressive_val_score(dataset, model, metric))\n</code></pre> <pre><code>SGD MAE: 0.558735\nRMSProp MAE: 0.522449\nAdaGrad MAE: 0.477289\n</code></pre></p> <p><pre><code>dataset = datasets.TrumpApproval()\nmetric = metrics.MAE()\nhedge = (\n    preprocessing.StandardScaler() |\n    ensemble.EWARegressor(\n        [\n            linear_model.LinearRegression(optimizer=o, intercept_lr=.1)\n            for o in optimizers\n        ],\n        learning_rate=0.005\n    )\n)\n\nevaluate.progressive_val_score(dataset, hedge, metric)\n</code></pre> <pre><code>MAE: 0.496298\n</code></pre></p>"},{"location":"api/ensemble/EWARegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> learn_predict_one predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Online Learning from Experts: Weighed Majority and Hedge \u21a9</p> </li> <li> <p>Wikipedia page on the multiplicative weight update method \u21a9</p> </li> <li> <p>Kivinen, J. and Warmuth, M.K., 1997. Exponentiated gradient versus gradient descent for linear predictors. information and computation, 132(1), pp.1-63. \u21a9</p> </li> </ol>"},{"location":"api/ensemble/LeveragingBaggingClassifier/","title":"LeveragingBaggingClassifier","text":"<p>Leveraging Bagging ensemble classifier.</p> <p>Leveraging Bagging [^1] is an improvement over the Oza Bagging algorithm. The bagging performance is leveraged by increasing the re-sampling. It uses a poisson distribution to simulate the re-sampling process. To increase re-sampling it uses a higher <code>w</code> value of the Poisson distribution (agerage number of events), 6 by default, increasing the input space diversity, by attributing a different range of weights to the data samples. </p> <p>To deal with concept drift, Leveraging Bagging uses the ADWIN algorithm to monitor the performance of each member of the enemble If concept drift is detected, the worst member of the ensemble (based on the error estimation by ADWIN) is replaced by a new (empty) classifier.</p>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier to bag.</p> </li> <li> <p>n_models</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of models in the ensemble.</p> </li> <li> <p>w</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>6</code></p> <p>Indicates the average number of events. This is the lambda parameter of the Poisson distribution used to compute the re-sampling weight.</p> </li> <li> <p>adwin_delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.002</code></p> <p>The delta parameter for the ADWIN change detector.</p> </li> <li> <p>bagging_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>bag</code></p> <p>The bagging method to use. Can be one of the following: * 'bag' - Leveraging Bagging using ADWIN. * 'me' - Assigns \\(weight=1\\) if sample is misclassified,   otherwise \\(weight=error/(1-error)\\). * 'half' - Use resampling without replacement for half of the instances. * 'wt' - Resample without taking out all instances. * 'subag' - Resampling without replacement.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>bagging_methods</p> <p>Valid bagging_method options.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\n\nmodel = ensemble.LeveragingBaggingClassifier(\n    model=(\n        preprocessing.StandardScaler() |\n        linear_model.LogisticRegression()\n    ),\n    n_models=3,\n    seed=42\n)\n\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 88.55%\n</code></pre></p>"},{"location":"api/ensemble/LeveragingBaggingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Averages the predictions of each classifier.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p></p>"},{"location":"api/ensemble/SRPClassifier/","title":"SRPClassifier","text":"<p>Streaming Random Patches ensemble classifier.</p> <p>The Streaming Random Patches (SRP) <sup>1</sup> is an ensemble method that simulates bagging or random subspaces. The default algorithm uses both bagging and random subspaces, namely Random Patches. The default base estimator is a Hoeffding Tree, but other base estimators can be used (differently from random forest variations).</p>"},{"location":"api/ensemble/SRPClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Estimator | None</p> <p>Default \u2192 <code>None</code></p> <p>The base estimator.</p> </li> <li> <p>n_models</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>Number of members in the ensemble.</p> </li> <li> <p>subspace_size</p> <p>Type \u2192 int | float | str</p> <p>Default \u2192 <code>0.6</code></p> <p>Number of features per subset for each classifier where <code>M</code> is the total number of features. A negative value means <code>M - subspace_size</code>. Only applies when using random subspaces or random patches. * If <code>int</code> indicates the number of features to use. Valid range [2, M].  * If <code>float</code> indicates the percentage of features to use, Valid range (0., 1.].  * 'sqrt' - <code>sqrt(M)+1</code> * 'rmsqrt' - Residual from <code>M-(sqrt(M)+1)</code></p> </li> <li> <p>training_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>patches</code></p> <p>The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches.</p> </li> <li> <p>lam</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>6</code></p> <p>Lambda value for resampling.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Drift detector.</p> </li> <li> <p>warning_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Warning detector.</p> </li> <li> <p>disable_detector</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>off</code></p> <p>Option to disable drift detectors: * If <code>'off'</code>, detectors are enabled. * If <code>'drift'</code>, disables concept drift detection and the background learner. * If <code>'warning'</code>, disables the background learner and ensemble members are  reset if drift is detected.</p> </li> <li> <p>disable_weighted_vote</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disables weighted voting.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> <li> <p>metric</p> <p>Type \u2192 ClassificationMetric | None</p> <p>Default \u2192 <code>None</code></p> <p>The metric to track members performance within the ensemble. This implementation assumes that larger values are better when using weighted votes.</p> </li> </ul>"},{"location":"api/ensemble/SRPClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/SRPClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import ensemble\nfrom river import evaluate\nfrom river import metrics\nfrom river.datasets import synth\nfrom river import tree\n\ndataset = synth.ConceptDriftStream(\n    seed=42,\n    position=500,\n    width=50\n).take(1000)\n\nbase_model = tree.HoeffdingTreeClassifier(\n    grace_period=50, delta=0.01,\n    nominal_attributes=['age', 'car', 'zipcode']\n)\nmodel = ensemble.SRPClassifier(\n    model=base_model, n_models=3, seed=42,\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 72.17%\n</code></pre></p>"},{"location":"api/ensemble/SRPClassifier/#methods","title":"Methods","text":"learn_one predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> reset"},{"location":"api/ensemble/SRPClassifier/#notes","title":"Notes","text":"<p>This implementation uses <code>n_models=10</code> as default given the impact on processing time. The optimal number of models depends on the data and resources available.</p> <ol> <li> <p>Heitor Murilo Gomes, Jesse Read, Albert Bifet.   Streaming Random Patches for Evolving Data Stream Classification.   IEEE International Conference on Data Mining (ICDM), 2019.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/SRPRegressor/","title":"SRPRegressor","text":"<p>Streaming Random Patches ensemble regressor.</p> <p>The Streaming Random Patches <sup>1</sup> ensemble method for regression trains each base learner on a subset of features and instances from the original data, namely a random patch. This strategy to enforce diverse base models is similar to the one in the random forest, yet it is not restricted to using decision trees as base learner. </p> <p>This method is an adaptation of <sup>2</sup> for regression.</p>"},{"location":"api/ensemble/SRPRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Regressor | None</p> <p>Default \u2192 <code>None</code></p> <p>The base estimator.</p> </li> <li> <p>n_models</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>Number of members in the ensemble.</p> </li> <li> <p>subspace_size</p> <p>Type \u2192 int | float | str</p> <p>Default \u2192 <code>0.6</code></p> <p>Number of features per subset for each classifier where <code>M</code> is the total number of features. A negative value means <code>M - subspace_size</code>. Only applies when using random subspaces or random patches. * If <code>int</code> indicates the number of features to use. Valid range [2, M].  * If <code>float</code> indicates the percentage of features to use, Valid range (0., 1.].  * 'sqrt' - <code>sqrt(M)+1</code> * 'rmsqrt' - Residual from <code>M-(sqrt(M)+1)</code></p> </li> <li> <p>training_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>patches</code></p> <p>The training method to use. * 'subspaces' - Random subspaces. * 'resampling' - Resampling. * 'patches' - Random patches.</p> </li> <li> <p>lam</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>6</code></p> <p>Lambda value for bagging.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Drift detector.</p> </li> <li> <p>warning_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Warning detector.</p> </li> <li> <p>disable_detector</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>off</code></p> <p>Option to disable drift detectors: * If <code>'off'</code>, detectors are enabled. * If <code>'drift'</code>, disables concept drift detection and the background learner. * If <code>'warning'</code>, disables the background learner and ensemble members are  reset if drift is detected.</p> </li> <li> <p>disable_weighted_vote</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, disables weighted voting.</p> </li> <li> <p>drift_detection_criteria</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>error</code></p> <p>The criteria used to track drifts. * 'error' - absolute error. * 'prediction' - predicted target values.</p> </li> <li> <p>aggregation_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>mean</code></p> <p>The method to use to aggregate predictions in the ensemble. * 'mean' * 'median'</p> </li> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> <li> <p>metric</p> <p>Type \u2192 RegressionMetric | None</p> <p>Default \u2192 <code>None</code></p> <p>The metric to track members performance within the ensemble.</p> </li> </ul>"},{"location":"api/ensemble/SRPRegressor/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/SRPRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import ensemble\nfrom river import evaluate\nfrom river import metrics\nfrom river.datasets import synth\nfrom river import tree\n\ndataset = synth.FriedmanDrift(\n    drift_type='gsg',\n    position=(350, 750),\n    transition_window=200,\n    seed=42\n).take(1000)\n\nbase_model = tree.HoeffdingTreeRegressor(grace_period=50)\nmodel = ensemble.SRPRegressor(\n    model=base_model,\n    training_method=\"patches\",\n    n_models=3,\n    seed=42\n)\n\nmetric = metrics.R2()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>R2: 0.571117\n</code></pre></p>"},{"location":"api/ensemble/SRPRegressor/#methods","title":"Methods","text":"learn_one predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> reset"},{"location":"api/ensemble/SRPRegressor/#notes","title":"Notes","text":"<p>This implementation uses <code>n_models=10</code> as default given the impact on processing time. The optimal number of models depends on the data and resources available.</p> <ol> <li> <p>Heitor Gomes, Jacob Montiel, Saulo Martiello Mastelini,   Bernhard Pfahringer, and Albert Bifet.   On Ensemble Techniques for Data Stream Regression.   IJCNN'20. International Joint Conference on Neural Networks. 2020.\u00a0\u21a9</p> </li> <li> <p>Heitor Murilo Gomes, Jesse Read, Albert Bifet.   Streaming Random Patches for Evolving Data Stream Classification.   IEEE International Conference on Data Mining (ICDM), 2019.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/ensemble/StackingClassifier/","title":"StackingClassifier","text":"<p>Stacking for binary classification.</p>"},{"location":"api/ensemble/StackingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>Type \u2192 list[base.Classifier]</p> </li> <li> <p>meta_classifier</p> <p>Type \u2192 base.Classifier</p> </li> <li> <p>include_features</p> <p>Default \u2192 <code>True</code></p> <p>Indicates whether or not the original features should be provided to the meta-model along with the predictions from each model.</p> </li> </ul>"},{"location":"api/ensemble/StackingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/StackingClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import compose\nfrom river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model as lm\nfrom river import metrics\nfrom river import preprocessing as pp\n\ndataset = datasets.Phishing()\n\nmodel = compose.Pipeline(\n    ('scale', pp.StandardScaler()),\n    ('stack', ensemble.StackingClassifier(\n        [\n            lm.LogisticRegression(),\n            lm.PAClassifier(mode=1, C=0.01),\n            lm.PAClassifier(mode=2, C=0.01),\n        ],\n        meta_classifier=lm.LogisticRegression()\n    ))\n)\n\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 88.14%\n</code></pre></p>"},{"location":"api/ensemble/StackingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>A Kaggler's Guide to Model Stacking in Practice \u21a9</p> </li> </ol>"},{"location":"api/ensemble/VotingClassifier/","title":"VotingClassifier","text":"<p>Voting classifier.</p> <p>A classification is made by aggregating the predictions of each model in the ensemble. The probabilities for each class are summed up if <code>use_probabilities</code> is set to <code>True</code>. If not, the probabilities are ignored and each prediction is weighted the same. In this case, it's important that you use an odd number of classifiers. A random class will be picked if the number of classifiers is even.</p>"},{"location":"api/ensemble/VotingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>Type \u2192 list[base.Classifier]</p> <p>The classifiers.</p> </li> <li> <p>use_probabilities</p> <p>Default \u2192 <code>True</code></p> <p>Whether or to weight each prediction with its associated probability.</p> </li> </ul>"},{"location":"api/ensemble/VotingClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/ensemble/VotingClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import ensemble\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import naive_bayes\nfrom river import preprocessing\nfrom river import tree\n\ndataset = datasets.Phishing()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    ensemble.VotingClassifier([\n        linear_model.LogisticRegression(),\n        tree.HoeffdingTreeClassifier(),\n        naive_bayes.GaussianNB()\n    ])\n)\n\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 86.94%\n</code></pre></p>"},{"location":"api/ensemble/VotingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/evaluate/BinaryClassificationTrack/","title":"BinaryClassificationTrack","text":"<p>This track evaluates a model's performance on binary classification tasks. These do not include synthetic datasets.</p>"},{"location":"api/evaluate/BinaryClassificationTrack/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/MultiClassClassificationTrack/","title":"MultiClassClassificationTrack","text":"<p>This track evaluates a model's performance on multi-class classification tasks. These do not include synthetic datasets.</p>"},{"location":"api/evaluate/MultiClassClassificationTrack/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/RegressionTrack/","title":"RegressionTrack","text":"<p>This track evaluates a model's performance on regression tasks. These do not include synthetic datasets.</p>"},{"location":"api/evaluate/RegressionTrack/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/Track/","title":"Track","text":"<p>A track evaluate a model's performance.</p> <p>The following metrics are recorded: </p> <ul> <li> <p>Time, which should be interpreted with wisdom. Indeed time can depend on the architecture</p> <p>and local resource situations. Comparison via FLOPS should be preferred. - The model's memory footprint.</p> </li> <li> <p>The model's predictive performance on the track's dataset.</p> </li> </ul>"},{"location":"api/evaluate/Track/#parameters","title":"Parameters","text":"<ul> <li> <p>name</p> <p>Type \u2192 str</p> <p>The name of the track.</p> </li> <li> <p>datasets</p> <p>The datasets that compose the track.</p> </li> <li> <p>metric</p> <p>The metric(s) used to track performance.</p> </li> </ul>"},{"location":"api/evaluate/Track/#methods","title":"Methods","text":"run"},{"location":"api/evaluate/iter-progressive-val-score/","title":"iter_progressive_val_score","text":"<p>Evaluates the performance of a model on a streaming dataset and yields results.</p> <p>This does exactly the same as <code>evaluate.progressive_val_score</code>. The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results.</p>"},{"location":"api/evaluate/iter-progressive-val-score/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset</p> <p>Type \u2192 base.typing.Dataset</p> <p>The stream of observations against which the model will be evaluated.</p> </li> <li> <p>model</p> <p>The model to evaluate.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.Metric</p> <p>The metric used to evaluate the model's predictions.</p> </li> <li> <p>moment</p> <p>Type \u2192 str | typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>The attribute used for measuring time. If a callable is passed, then it is expected to take as input a <code>dict</code> of features. If <code>None</code>, then the observations are implicitly timestamped in the order in which they arrive.</p> </li> <li> <p>delay</p> <p>Type \u2192 str | int | dt.timedelta | typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the <code>moment</code> value. For instance, if <code>moment</code> is a <code>datetime.date</code>, then <code>delay</code> is expected to be a <code>datetime.timedelta</code>. If a callable is passed, then it is expected to take as input a <code>dict</code> of features and the target. If a <code>str</code> is passed, then it will be used to access the relevant field from the features. If <code>None</code> is passed, then no delay will be used, which leads to doing standard online validation.</p> </li> <li> <p>step</p> <p>Default \u2192 <code>1</code></p> <p>Iteration number at which to yield results. This only takes into account the predictions, and not the training steps.</p> </li> <li> <p>measure_time</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to measure the elapsed time.</p> </li> <li> <p>measure_memory</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to measure the memory usage of the model.</p> </li> <li> <p>yield_predictions</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to include predictions. If step is 1, then this is equivalent to yielding the predictions at every iterations. Otherwise, not all predictions will be yielded.</p> </li> </ul>"},{"location":"api/evaluate/iter-progressive-val-score/#examples","title":"Examples","text":"<p>Take the following model:</p> <pre><code>from river import linear_model\nfrom river import preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression()\n)\n</code></pre> <p>We can evaluate it on the <code>Phishing</code> dataset as so:</p> <p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\n\nsteps = evaluate.iter_progressive_val_score(\n    model=model,\n    dataset=datasets.Phishing(),\n    metric=metrics.ROCAUC(),\n    step=200\n)\n\nfor step in steps:\n    print(step)\n</code></pre> <pre><code>{'ROCAUC': ROCAUC: 90.20%, 'Step': 200}\n{'ROCAUC': ROCAUC: 92.25%, 'Step': 400}\n{'ROCAUC': ROCAUC: 93.23%, 'Step': 600}\n{'ROCAUC': ROCAUC: 94.05%, 'Step': 800}\n{'ROCAUC': ROCAUC: 94.79%, 'Step': 1000}\n{'ROCAUC': ROCAUC: 95.07%, 'Step': 1200}\n{'ROCAUC': ROCAUC: 95.07%, 'Step': 1250}\n</code></pre></p> <p>The <code>yield_predictions</code> parameter can be used to include the predictions in the results:</p> <p><pre><code>import itertools\n\nsteps = evaluate.iter_progressive_val_score(\n    model=model,\n    dataset=datasets.Phishing(),\n    metric=metrics.ROCAUC(),\n    step=1,\n    yield_predictions=True\n)\n\nfor step in itertools.islice(steps, 100, 105):\n   print(step)\n</code></pre> <pre><code>{'ROCAUC': ROCAUC: 94.68%, 'Step': 101, 'Prediction': {False: 0.966..., True: 0.033...}}\n{'ROCAUC': ROCAUC: 94.75%, 'Step': 102, 'Prediction': {False: 0.035..., True: 0.964...}}\n{'ROCAUC': ROCAUC: 94.82%, 'Step': 103, 'Prediction': {False: 0.043..., True: 0.956...}}\n{'ROCAUC': ROCAUC: 94.89%, 'Step': 104, 'Prediction': {False: 0.816..., True: 0.183...}}\n{'ROCAUC': ROCAUC: 94.96%, 'Step': 105, 'Prediction': {False: 0.041..., True: 0.958...}}\n</code></pre></p> <ol> <li> <p>Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9</p> </li> <li> <p>Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9</p> </li> </ol>"},{"location":"api/evaluate/progressive-val-score/","title":"progressive_val_score","text":"<p>Evaluates the performance of a model on a streaming dataset.</p> <p>This method is the canonical way to evaluate a model's performance. When used correctly, it allows you to exactly assess how a model would have performed in a production scenario. </p> <p><code>dataset</code> is converted into a stream of questions and answers. At each step the model is either asked to predict an observation, or is either updated. The target is only revealed to the model after a certain amount of time, which is determined by the <code>delay</code> parameter. Note that under the hood this uses the <code>stream.simulate_qa</code> function to go through the data in arrival order. </p> <p>By default, there is no delay, which means that the samples are processed one after the other. When there is no delay, this function essentially performs progressive validation. When there is a delay, then we refer to it as delayed progressive validation. </p> <p>It is recommended to use this method when you want to determine a model's performance on a dataset. In particular, it is advised to use the <code>delay</code> parameter in order to get a reliable assessment. Indeed, in a production scenario, it is often the case that ground truths are made available after a certain amount of time. By using this method, you can reproduce this scenario and therefore truthfully assess what would have been the performance of a model on a given dataset.</p>"},{"location":"api/evaluate/progressive-val-score/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset</p> <p>Type \u2192 base.typing.Dataset</p> <p>The stream of observations against which the model will be evaluated.</p> </li> <li> <p>model</p> <p>The model to evaluate.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.Metric</p> <p>The metric used to evaluate the model's predictions.</p> </li> <li> <p>moment</p> <p>Type \u2192 str | typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>The attribute used for measuring time. If a callable is passed, then it is expected to take as input a <code>dict</code> of features. If <code>None</code>, then the observations are implicitly timestamped in the order in which they arrive.</p> </li> <li> <p>delay</p> <p>Type \u2192 str | int | dt.timedelta | typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>The amount to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the <code>moment</code> value. For instance, if <code>moment</code> is a <code>datetime.date</code>, then <code>delay</code> is expected to be a <code>datetime.timedelta</code>. If a callable is passed, then it is expected to take as input a <code>dict</code> of features and the target. If a <code>str</code> is passed, then it will be used to access the relevant field from the features. If <code>None</code> is passed, then no delay will be used, which leads to doing standard online validation.</p> </li> <li> <p>print_every</p> <p>Default \u2192 <code>0</code></p> <p>Iteration number at which to print the current metric. This only takes into account the predictions, and not the training steps.</p> </li> <li> <p>show_time</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to display the elapsed time.</p> </li> <li> <p>show_memory</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to display the memory usage of the model.</p> </li> <li> <p>print_kwargs</p> <p>Extra keyword arguments are passed to the <code>print</code> function. For instance, this allows providing a <code>file</code> argument, which indicates where to output progress.</p> </li> </ul>"},{"location":"api/evaluate/progressive-val-score/#examples","title":"Examples","text":"<p>Take the following model:</p> <pre><code>from river import linear_model\nfrom river import preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression()\n)\n</code></pre> <p>We can evaluate it on the <code>Phishing</code> dataset as so:</p> <p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\n\nevaluate.progressive_val_score(\n    model=model,\n    dataset=datasets.Phishing(),\n    metric=metrics.ROCAUC(),\n    print_every=200\n)\n</code></pre> <pre><code>[200] ROCAUC: 90.20%\n[400] ROCAUC: 92.25%\n[600] ROCAUC: 93.23%\n[800] ROCAUC: 94.05%\n[1,000] ROCAUC: 94.79%\n[1,200] ROCAUC: 95.07%\n[1,250] ROCAUC: 95.07%\nROCAUC: 95.07%\n</code></pre></p> <p>We haven't specified a delay, therefore this is strictly equivalent to the following piece of code:</p> <p><pre><code>model = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression()\n)\n\nmetric = metrics.ROCAUC()\n\nfor x, y in datasets.Phishing():\n    y_pred = model.predict_proba_one(x)\n    metric.update(y, y_pred)\n    model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 95.07%\n</code></pre></p> <p>When <code>print_every</code> is specified, the current state is printed at regular intervals. Under the hood, Python's <code>print</code> method is being used. You can pass extra keyword arguments to modify its behavior. For instance, you may use the <code>file</code> argument if you want to log the progress to a file of your choice.</p> <p><pre><code>with open('progress.log', 'w') as f:\n    metric = evaluate.progressive_val_score(\n        model=model,\n        dataset=datasets.Phishing(),\n        metric=metrics.ROCAUC(),\n        print_every=200,\n        file=f\n    )\n\nwith open('progress.log') as f:\n    for line in f.read().splitlines():\n        print(line)\n</code></pre> <pre><code>[200] ROCAUC: 94.00%\n[400] ROCAUC: 94.70%\n[600] ROCAUC: 95.17%\n[800] ROCAUC: 95.42%\n[1,000] ROCAUC: 95.82%\n[1,200] ROCAUC: 96.00%\n[1,250] ROCAUC: 96.04%\n</code></pre></p> <p>Note that the performance is slightly better than above because we haven't used a fresh copy of the model. Instead, we've reused the existing model which has already done a full pass on the data.</p> <pre><code>import os; os.remove('progress.log')\n</code></pre> <ol> <li> <p>Beating the Hold-Out: Bounds for K-fold and Progressive Cross-Validation \u21a9</p> </li> <li> <p>Grzenda, M., Gomes, H.M. and Bifet, A., 2019. Delayed labelling evaluation for data streams. Data Mining and Knowledge Discovery, pp.1-30 \u21a9</p> </li> </ol>"},{"location":"api/facto/FFMClassifier/","title":"FFMClassifier","text":"<p>Field-aware Factorization Machine for binary classification.</p> <p>The model equation is defined by: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_{j, f_{j'}}\\) is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\(\\mathbf{v}_{j', f_j}\\) is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FFMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.BinaryLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FFMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FFMClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman', 'time': .12}, True),\n    ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, True),\n    ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, True),\n    ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, False),\n    ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, True),\n    ({'user': 'Bob', 'item': 'Superman', 'time': .13}, True),\n    ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, True),\n    ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, True),\n    ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, False)\n)\n\nmodel = facto.FFMClassifier(\n    n_factors=10,\n    intercept=.5,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n</code></pre> <pre><code>True\n</code></pre></p>"},{"location":"api/facto/FFMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50). \u21a9</p> </li> </ol>"},{"location":"api/facto/FFMRegressor/","title":"FFMRegressor","text":"<p>Field-aware Factorization Machine for regression.</p> <p>The model equation is defined by: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_j} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_{j, f_{j'}}\\) is the latent vector corresponding to \\(j\\) feature for \\(f_{j'}\\) field, and \\(\\mathbf{v}_{j', f_j}\\) is the latent vector corresponding to \\(j'\\) feature for \\(f_j\\) field. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FFMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.RegressionLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FFMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FFMRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman', 'time': .12}, 8),\n    ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, 5),\n    ({'user': 'Bob', 'item': 'Superman', 'time': .13}, 8),\n    ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, 2)\n)\n\nmodel = facto.FFMRegressor(\n    n_factors=10,\n    intercept=5,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n</code></pre> <pre><code>5.319945\n</code></pre></p> <p><pre><code>report = model.debug_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n\nprint(report)\n</code></pre> <pre><code>Name                                       Value      Weight     Contribution\n                               Intercept    1.00000    5.23501        5.23501\n                                user_Bob    1.00000    0.11438        0.11438\n                                    time    0.14000    0.03186        0.00446\n    item_Harry Potter(time) - time(item)    0.14000    0.03153        0.00441\n             user_Bob(time) - time(user)    0.14000    0.02864        0.00401\n                       item_Harry Potter    1.00000    0.00000        0.00000\nuser_Bob(item) - item_Harry Potter(user)    1.00000   -0.04232       -0.04232\n</code></pre></p>"},{"location":"api/facto/FFMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Juan, Y., Zhuang, Y., Chin, W.S. and Lin, C.J., 2016, September. Field-aware factorization machines for CTR prediction. In Proceedings of the 10th ACM Conference on Recommender Systems (pp. 43-50). \u21a9</p> </li> </ol>"},{"location":"api/facto/FMClassifier/","title":"FMClassifier","text":"<p>Factorization Machine for binary classification.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/FMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.BinaryLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FMClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, True),\n    ({'user': 'Alice', 'item': 'Terminator'}, True),\n    ({'user': 'Alice', 'item': 'Star Wars'}, True),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, False),\n    ({'user': 'Alice', 'item': 'Harry Potter '}, True),\n    ({'user': 'Bob', 'item': 'Superman'}, True),\n    ({'user': 'Bob', 'item': 'Terminator'}, True),\n    ({'user': 'Bob', 'item': 'Star Wars'}, True),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, False)\n)\n\nmodel = facto.FMClassifier(\n    n_factors=10,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'Bob': 1, 'Harry Potter': 1})\n</code></pre> <pre><code>True\n</code></pre></p>"},{"location":"api/facto/FMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> <li> <p>Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9</p> </li> </ol>"},{"location":"api/facto/FMRegressor/","title":"FMRegressor","text":"<p>Factorization Machine for regression.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/FMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.RegressionLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/FMRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, 8),\n    ({'user': 'Alice', 'item': 'Terminator'}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter '}, 5),\n    ({'user': 'Bob', 'item': 'Superman'}, 8),\n    ({'user': 'Bob', 'item': 'Terminator'}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n)\n\nmodel = facto.FMRegressor(\n    n_factors=10,\n    intercept=5,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'Bob': 1, 'Harry Potter': 1})\n</code></pre> <pre><code>5.236504\n</code></pre></p> <p><pre><code>report = model.debug_one({'Bob': 1, 'Harry Potter': 1})\n\nprint(report)\n</code></pre> <pre><code>Name                 Value      Weight     Contribution\n         Intercept    1.00000    5.23426        5.23426\nBob - Harry Potter    1.00000    0.00224        0.00224\n      Harry Potter    1.00000    0.00000        0.00000\n               Bob    1.00000    0.00000        0.00000\n</code></pre></p>"},{"location":"api/facto/FMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> <li> <p>Rendle, S., 2012, May. Factorization Machines with libFM. In ACM Transactions on Intelligent Systems and Technology 3, 3, Article 57, 22 pages. \u21a9</p> </li> </ol>"},{"location":"api/facto/FwFMClassifier/","title":"FwFMClassifier","text":"<p>Field-weighted Factorization Machine for binary classification.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FwFMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>int_weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the field pairs interaction weights.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.BinaryLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FwFMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> <li> <p>interaction_weights</p> <p>The current interaction strengths of field pairs.</p> </li> </ul>"},{"location":"api/facto/FwFMClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, True),\n    ({'user': 'Alice', 'item': 'Terminator'}, True),\n    ({'user': 'Alice', 'item': 'Star Wars'}, True),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, False),\n    ({'user': 'Alice', 'item': 'Harry Potter '}, True),\n    ({'user': 'Bob', 'item': 'Superman'}, True),\n    ({'user': 'Bob', 'item': 'Terminator'}, True),\n    ({'user': 'Bob', 'item': 'Star Wars'}, True),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, False)\n)\n\nmodel = facto.FwFMClassifier(\n    n_factors=10,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'Bob': 1, 'Harry Potter': 1})\n</code></pre> <pre><code>True\n</code></pre></p>"},{"location":"api/facto/FwFMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9</p> </li> </ol>"},{"location":"api/facto/FwFMRegressor/","title":"FwFMRegressor","text":"<p>Field-weighted Factorization Machine for regression.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'}\\] <p>Where \\(f_j\\) and \\(f_{j'}\\) are \\(j\\) and \\(j'\\) fields, respectively, and \\(\\mathbf{v}_j\\) and \\(\\mathbf{v}_{j'}\\) are \\(j\\) and \\(j'\\) latent vectors, respectively. </p> <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables. Field names are inferred from feature names by taking everything before the first underscore: <code>feature_name.split('_')[0]</code>.</p>"},{"location":"api/facto/FwFMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>int_weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the field pairs interaction weights.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.RegressionLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/FwFMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> <li> <p>interaction_weights</p> <p>The current interaction strengths of field pairs.</p> </li> </ul>"},{"location":"api/facto/FwFMRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, 8),\n    ({'user': 'Alice', 'item': 'Terminator'}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter '}, 5),\n    ({'user': 'Bob', 'item': 'Superman'}, 8),\n    ({'user': 'Bob', 'item': 'Terminator'}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n)\n\nmodel = facto.FwFMRegressor(\n    n_factors=10,\n    intercept=5,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'Bob': 1, 'Harry Potter': 1})\n</code></pre> <pre><code>5.236501\n</code></pre></p> <p><pre><code>report = model.debug_one({'Bob': 1, 'Harry Potter': 1})\n\nprint(report)\n</code></pre> <pre><code>Name                                    Value      Weight     Contribution\n                            Intercept    1.00000    5.23426        5.23426\nBob(Harry Potter) - Harry Potter(Bob)    1.00000    0.00224        0.00224\n                         Harry Potter    1.00000    0.00000        0.00000\n                                  Bob    1.00000    0.00000        0.00000\n</code></pre></p>"},{"location":"api/facto/FwFMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Junwei Pan, Jian Xu, Alfonso Lobos Ruiz, Wenliang Zhao, Shengjun Pan, Yu Sun, and Quan Lu, 2018, April. Field-weighted Factorization Machines for Click-Through Rate Prediction in Display Advertising. In Proceedings of the 2018 World Wide Web Conference on World Wide Web. International World Wide Web Conferences Steering Committee, (pp. 1349\u20131357). \u21a9</p> </li> </ol>"},{"location":"api/facto/HOFMClassifier/","title":"HOFMClassifier","text":"<p>Higher-Order Factorization Machine for binary classification.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/HOFMClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>degree</p> <p>Default \u2192 <code>3</code></p> <p>Polynomial degree or model order.</p> </li> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note that the intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.BinaryLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/HOFMClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/HOFMClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman', 'time': .12}, True),\n    ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, True),\n    ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, True),\n    ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, False),\n    ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, True),\n    ({'user': 'Bob', 'item': 'Superman', 'time': .13}, True),\n    ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, True),\n    ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, True),\n    ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, False)\n)\n\nmodel = facto.HOFMClassifier(\n    degree=3,\n    n_factors=10,\n    intercept=.5,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n</code></pre> <pre><code>True\n</code></pre></p>"},{"location":"api/facto/HOFMClassifier/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> </ol>"},{"location":"api/facto/HOFMRegressor/","title":"HOFMRegressor","text":"<p>Higher-Order Factorization Machine for regression.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right)\\] <p>For more efficiency, this model automatically one-hot encodes strings features considering them as categorical variables.</p>"},{"location":"api/facto/HOFMRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>degree</p> <p>Default \u2192 <code>3</code></p> <p>Polynomial degree or model order.</p> </li> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>weight_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the feature weights. Note thatthe intercept is handled separately.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.RegressionLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>sample_normalization</p> <p>Default \u2192 <code>False</code></p> <p>Whether to divide each element of <code>x</code> by <code>x</code>'s L2-norm.</p> </li> <li> <p>l1_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0.</p> </li> <li> <p>l2_weight</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>l1_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push latent weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>intercept</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. An instance of <code>optim.schedulers.Constant</code> is used if a <code>float</code> is passed. No intercept will be used if this is set to 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme. Defaults to <code>optim.initializers.Zeros</code>()`.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme. Defaults to <code>optim.initializers.Normal</code>(mu=.0, sigma=.1, random_state=self.random_state)`.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Randomization seed used for reproducibility.</p> </li> </ul>"},{"location":"api/facto/HOFMRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights assigned to the features.</p> </li> <li> <p>latents</p> <p>The current latent weights assigned to the features.</p> </li> </ul>"},{"location":"api/facto/HOFMRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import facto\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman', 'time': .12}, 8),\n    ({'user': 'Alice', 'item': 'Terminator', 'time': .13}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars', 'time': .14}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill', 'time': .15}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter ', 'time': .16}, 5),\n    ({'user': 'Bob', 'item': 'Superman', 'time': .13}, 8),\n    ({'user': 'Bob', 'item': 'Terminator', 'time': .12}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars', 'time': .16}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill', 'time': .10}, 2)\n)\n\nmodel = facto.HOFMRegressor(\n    degree=3,\n    n_factors=10,\n    intercept=5,\n    seed=42,\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n</code></pre> <pre><code>5.311745\n</code></pre></p> <p><pre><code>report = model.debug_one({'user': 'Bob', 'item': 'Harry Potter', 'time': .14})\n\nprint(report)\n</code></pre> <pre><code>Name                                  Value      Weight     Contribution\n                          Intercept    1.00000    5.23495        5.23495\n                           user_Bob    1.00000    0.11436        0.11436\n                               time    0.14000    0.03185        0.00446\n                    user_Bob - time    0.14000    0.00884        0.00124\nuser_Bob - item_Harry Potter - time    0.14000    0.00117        0.00016\n                  item_Harry Potter    1.00000    0.00000        0.00000\n           item_Harry Potter - time    0.14000   -0.00695       -0.00097\n       user_Bob - item_Harry Potter    1.00000   -0.04246       -0.04246\n</code></pre></p>"},{"location":"api/facto/HOFMRegressor/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the FM regressor.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Rendle, S., 2010, December. Factorization machines. In 2010 IEEE International Conference on Data Mining (pp. 995-1000). IEEE. \u21a9</p> </li> </ol>"},{"location":"api/feature-extraction/Agg/","title":"Agg","text":"<p>Computes a streaming aggregate.</p> <p>This transformer allows to compute an aggregate statistic, very much like the groupby method from <code>pandas</code>, but on a streaming dataset. This makes use of the streaming statistics from the <code>stats</code> module. </p> <p>When <code>learn_one</code> is called, the running statistic <code>how</code> of group <code>by</code> is updated with the value of <code>on</code>. Meanwhile, the output of <code>transform_one</code> is a single-element dictionary, where the key is the name of the aggregate and the value is the current value of the statistic for the relevant group. The key is automatically inferred from the parameters. </p> <p>Note that you can use a <code>compose.TransformerUnion</code> to extract many aggregate statistics in a concise manner.</p>"},{"location":"api/feature-extraction/Agg/#parameters","title":"Parameters","text":"<ul> <li> <p>on</p> <p>Type \u2192 str</p> <p>The feature on which to compute the aggregate statistic.</p> </li> <li> <p>by</p> <p>Type \u2192 str | list[str] | None</p> <p>The feature by which to group the data. All the data is included in the aggregate if this is <code>None</code>.</p> </li> <li> <p>how</p> <p>Type \u2192 stats.base.Univariate | utils.Rolling | utils.TimeRolling</p> <p>The statistic to compute.</p> </li> </ul>"},{"location":"api/feature-extraction/Agg/#attributes","title":"Attributes","text":"<ul> <li> <p>state</p> <p>Return the current values for each group as a series.</p> </li> </ul>"},{"location":"api/feature-extraction/Agg/#examples","title":"Examples","text":"<p>Consider the following dataset:</p> <pre><code>X = [\n    {'country': 'France', 'place': 'Taco Bell', 'revenue': 42},\n    {'country': 'Sweden', 'place': 'Burger King', 'revenue': 16},\n    {'country': 'France', 'place': 'Burger King', 'revenue': 24},\n    {'country': 'Sweden', 'place': 'Taco Bell', 'revenue': 58},\n    {'country': 'Sweden', 'place': 'Burger King', 'revenue': 20},\n    {'country': 'France', 'place': 'Taco Bell', 'revenue': 50},\n    {'country': 'France', 'place': 'Burger King', 'revenue': 10},\n    {'country': 'Sweden', 'place': 'Taco Bell', 'revenue': 80}\n]\n</code></pre> <p>As an example, we can calculate the average (how) revenue (on) for each place (by):</p> <p><pre><code>from river import feature_extraction as fx\nfrom river import stats\n\nagg = fx.Agg(\n    on='revenue',\n    by='place',\n    how=stats.Mean()\n)\n\nfor x in X:\n    agg.learn_one(x)\n    print(agg.transform_one(x))\n</code></pre> <pre><code>{'revenue_mean_by_place': 42.0}\n{'revenue_mean_by_place': 16.0}\n{'revenue_mean_by_place': 20.0}\n{'revenue_mean_by_place': 50.0}\n{'revenue_mean_by_place': 20.0}\n{'revenue_mean_by_place': 50.0}\n{'revenue_mean_by_place': 17.5}\n{'revenue_mean_by_place': 57.5}\n</code></pre></p> <p>You can compute an aggregate over multiple keys by passing a tuple to the <code>by</code> argument. For instance, we can compute the maximum (how) revenue (on) per place as well as per day (by):</p> <p><pre><code>agg = fx.Agg(\n    on='revenue',\n    by=['place', 'country'],\n    how=stats.Max()\n)\n\nfor x in X:\n    agg.learn_one(x)\n    print(agg.transform_one(x))\n</code></pre> <pre><code>{'revenue_max_by_place_and_country': 42}\n{'revenue_max_by_place_and_country': 16}\n{'revenue_max_by_place_and_country': 24}\n{'revenue_max_by_place_and_country': 58}\n{'revenue_max_by_place_and_country': 20}\n{'revenue_max_by_place_and_country': 50}\n{'revenue_max_by_place_and_country': 24}\n{'revenue_max_by_place_and_country': 80}\n</code></pre></p> <p>You can use a <code>compose.TransformerUnion</code> in order to calculate multiple aggregates in one go. The latter can be constructed by using the <code>+</code> operator:</p> <p><pre><code>agg = (\n    fx.Agg(on='revenue', by='place', how=stats.Mean()) +\n    fx.Agg(on='revenue', by=['place', 'country'], how=stats.Max())\n)\n\nimport pprint\nfor x in X:\n    agg.learn_one(x)\n    pprint.pprint(agg.transform_one(x))\n</code></pre> <pre><code>{'revenue_max_by_place_and_country': 42, 'revenue_mean_by_place': 42.0}\n{'revenue_max_by_place_and_country': 16, 'revenue_mean_by_place': 16.0}\n{'revenue_max_by_place_and_country': 24, 'revenue_mean_by_place': 20.0}\n{'revenue_max_by_place_and_country': 58, 'revenue_mean_by_place': 50.0}\n{'revenue_max_by_place_and_country': 20, 'revenue_mean_by_place': 20.0}\n{'revenue_max_by_place_and_country': 50, 'revenue_mean_by_place': 50.0}\n{'revenue_max_by_place_and_country': 24, 'revenue_mean_by_place': 17.5}\n{'revenue_max_by_place_and_country': 80, 'revenue_mean_by_place': 57.5}\n</code></pre></p> <p>The <code>state</code> property returns a <code>pandas.Series</code>, which can be useful for visualizing the current state.</p> <p><pre><code>agg[0].state\n</code></pre> <pre><code>Taco Bell      57.5\nBurger King    17.5\nName: revenue_mean_by_place, dtype: float64\n</code></pre></p> <p><pre><code>agg[1].state\n</code></pre> <pre><code>place        country\nTaco Bell    France     50\nBurger King  Sweden     20\n             France     24\nTaco Bell    Sweden     80\nName: revenue_max_by_place_and_country, dtype: int64\n</code></pre></p> <p>This transformer can also be used in conjunction with <code>utils.TimeRolling</code>. The latter requires a <code>t</code> argument, which is a timestamp that indicates when the current row was observed. For instance, we can calculate the average (how) revenue (on) for each place (by) over the last 7 days (t):</p> <p><pre><code>import datetime as dt\nimport random\nimport string\nfrom river import utils\n\nagg = fx.Agg(\n    on=\"value\",\n    by=\"group\",\n    how=utils.TimeRolling(stats.Mean(), dt.timedelta(days=7))\n)\n\nfor day in range(366):\n    g = random.choice(string.ascii_lowercase)\n    x = {\n        \"group\": g,\n        \"value\": string.ascii_lowercase.index(g) + random.random(),\n    }\n    t = dt.datetime(2023, 1, 1) + dt.timedelta(days=day)\n    agg.learn_one(x, t=t)\n\nlen(agg.state)\n</code></pre> <pre><code>26\n</code></pre></p>"},{"location":"api/feature-extraction/Agg/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>t     \u2014 defaults to <code>None</code> </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>Streaming groupbys in pandas for big datasets \u21a9</p> </li> </ol>"},{"location":"api/feature-extraction/BagOfWords/","title":"BagOfWords","text":"<p>Counts tokens in sentences.</p> <p>This transformer can be used to counts tokens in a given piece of text. It takes care of normalizing the text before tokenizing it. In mini-batch settings, this transformers allows to convert a series of pandas of text into sparse dataframe. </p> <p>Note that the parameters are identical to those of <code>feature_extraction.TFIDF</code>.</p>"},{"location":"api/feature-extraction/BagOfWords/#parameters","title":"Parameters","text":"<ul> <li> <p>on</p> <p>Type \u2192 str | None</p> <p>Default \u2192 <code>None</code></p> <p>The name of the feature that contains the text to vectorize. If <code>None</code>, then each <code>learn_one</code> and <code>transform_one</code> will assume that each <code>x</code> that is provided is a <code>str</code>, andnot a <code>dict</code>.</p> </li> <li> <p>strip_accents</p> <p>Default \u2192 <code>True</code></p> <p>Whether or not to strip accent characters.</p> </li> <li> <p>lowercase</p> <p>Default \u2192 <code>True</code></p> <p>Whether or not to convert all characters to lowercase.</p> </li> <li> <p>preprocessor</p> <p>Type \u2192 typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional preprocessing function which overrides the <code>strip_accents</code> and <code>lowercase</code> steps, while preserving the tokenizing and n-grams generation steps.</p> </li> <li> <p>stop_words</p> <p>Type \u2192 set[str] | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional set of tokens to remove.</p> </li> <li> <p>tokenizer_pattern</p> <p>Default \u2192 <code>(?u)\\b\\w[\\w\\-]+\\b</code></p> <p>The tokenization pattern which is used when no <code>tokenizer</code> function is passed. A single capture group may optionally be specified.</p> </li> <li> <p>tokenizer</p> <p>Type \u2192 typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>A function used to convert preprocessed text into a <code>dict</code> of tokens. By default, a regex formula that works well in most cases is used.</p> </li> <li> <p>ngram_range</p> <p>Default \u2192 <code>(1, 1)</code></p> <p>The lower and upper boundary of the range n-grams to be extracted. All values of n such that <code>min_n &lt;= n &lt;= max_n</code> will be used. For example an <code>ngram_range</code> of <code>(1, 1)</code> means only unigrams, <code>(1, 2)</code> means unigrams and bigrams, and <code>(2, 2)</code> means only bigrams.</p> </li> </ul>"},{"location":"api/feature-extraction/BagOfWords/#examples","title":"Examples","text":"<p>By default, <code>BagOfWords</code> will take as input a sentence, preprocess it, tokenize the preprocessed text, and then return a <code>collections.Counter</code> containing the number of occurrences of each token.</p> <p><pre><code>from river import feature_extraction as fx\n\ncorpus = [\n    'This is the first document.',\n    'This document is the second document.',\n    'And this is the third one.',\n    'Is this the first document?',\n]\n\nbow = fx.BagOfWords()\n\nfor sentence in corpus:\n    print(bow.transform_one(sentence))\n</code></pre> <pre><code>{'this': 1, 'is': 1, 'the': 1, 'first': 1, 'document': 1}\n{'this': 1, 'document': 2, 'is': 1, 'the': 1, 'second': 1}\n{'and': 1, 'this': 1, 'is': 1, 'the': 1, 'third': 1, 'one': 1}\n{'is': 1, 'this': 1, 'the': 1, 'first': 1, 'document': 1}\n</code></pre></p> <p>Note that <code>learn_one</code> does not have to be called because <code>BagOfWords</code> is stateless. You can call it but it won't do anything.</p> <p>In the above example, a string is passed to <code>transform_one</code>. You can also indicate which field to access if the string is stored in a dictionary:</p> <p><pre><code>bow = fx.BagOfWords(on='sentence')\n\nfor sentence in corpus:\n    x = {'sentence': sentence}\n    print(bow.transform_one(x))\n</code></pre> <pre><code>{'this': 1, 'is': 1, 'the': 1, 'first': 1, 'document': 1}\n{'this': 1, 'document': 2, 'is': 1, 'the': 1, 'second': 1}\n{'and': 1, 'this': 1, 'is': 1, 'the': 1, 'third': 1, 'one': 1}\n{'is': 1, 'this': 1, 'the': 1, 'first': 1, 'document': 1}\n</code></pre></p> <p>The <code>ngram_range</code> parameter can be used to extract n-grams (including unigrams):</p> <p><pre><code>ngrammer = fx.BagOfWords(ngram_range=(1, 2))\n\nngrams = ngrammer.transform_one('I love the smell of napalm in the morning')\nfor ngram, count in ngrams.items():\n    print(ngram, count)\n</code></pre> <pre><code>love 1\nthe 2\nsmell 1\nof 1\nnapalm 1\nin 1\nmorning 1\n('love', 'the') 1\n('the', 'smell') 1\n('smell', 'of') 1\n('of', 'napalm') 1\n('napalm', 'in') 1\n('in', 'the') 1\n('the', 'morning') 1\n</code></pre></p> <p><code>BagOfWord</code> allows to build a term-frequency pandas sparse dataframe with the <code>transform_many</code> method.</p> <p><pre><code>import pandas as pd\nX = pd.Series(['Hello world', 'Hello River'], index = ['river', 'rocks'])\nbow = fx.BagOfWords()\nbow.transform_many(X=X)\n</code></pre> <pre><code>       hello  world  river\nriver      1      1      0\nrocks      1      0      1\n</code></pre></p>"},{"location":"api/feature-extraction/BagOfWords/#methods","title":"Methods","text":"learn_many learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> process_text transform_many <p>Transform pandas series of string into term-frequency pandas sparse dataframe.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.Series' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/feature-extraction/PolynomialExtender/","title":"PolynomialExtender","text":"<p>Polynomial feature extender.</p> <p>Generate features consisting of all polynomial combinations of the features with degree less than or equal to the specified degree. </p> <p>Be aware that the number of outputted features scales polynomially in the number of input features and exponentially in the degree. High degrees can cause overfitting.</p>"},{"location":"api/feature-extraction/PolynomialExtender/#parameters","title":"Parameters","text":"<ul> <li> <p>degree</p> <p>Default \u2192 <code>2</code></p> <p>The maximum degree of the polynomial features.</p> </li> <li> <p>interaction_only</p> <p>Default \u2192 <code>False</code></p> <p>If <code>True</code> then only combinations that include an element at most once will be computed.</p> </li> <li> <p>include_bias</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to include a dummy feature which is always equal to 1.</p> </li> <li> <p>bias_name</p> <p>Default \u2192 <code>bias</code></p> <p>Name to give to the bias feature.</p> </li> </ul>"},{"location":"api/feature-extraction/PolynomialExtender/#examples","title":"Examples","text":"<p><pre><code>from river import feature_extraction as fx\n\nX = [\n    {'x': 0, 'y': 1},\n    {'x': 2, 'y': 3},\n    {'x': 4, 'y': 5}\n]\n\npoly = fx.PolynomialExtender(degree=2, include_bias=True)\nfor x in X:\n    print(poly.transform_one(x))\n</code></pre> <pre><code>{'x': 0, 'y': 1, 'x*x': 0, 'x*y': 0, 'y*y': 1, 'bias': 1}\n{'x': 2, 'y': 3, 'x*x': 4, 'x*y': 6, 'y*y': 9, 'bias': 1}\n{'x': 4, 'y': 5, 'x*x': 16, 'x*y': 20, 'y*y': 25, 'bias': 1}\n</code></pre></p> <p><pre><code>X = [\n    {'x': 0, 'y': 1, 'z': 2},\n    {'x': 2, 'y': 3, 'z': 2},\n    {'x': 4, 'y': 5, 'z': 2}\n]\n\npoly = fx.PolynomialExtender(degree=3, interaction_only=True)\nfor x in X:\n    print(poly.transform_one(x))\n</code></pre> <pre><code>{'x': 0, 'y': 1, 'z': 2, 'x*y': 0, 'x*z': 0, 'y*z': 2, 'x*y*z': 0}\n{'x': 2, 'y': 3, 'z': 2, 'x*y': 6, 'x*z': 4, 'y*z': 6, 'x*y*z': 12}\n{'x': 4, 'y': 5, 'z': 2, 'x*y': 20, 'x*z': 8, 'y*z': 10, 'x*y*z': 40}\n</code></pre></p> <p>Polynomial features are typically used for a linear model to capture interactions between features. This may done by setting up a pipeline, as so:</p> <p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model as lm\nfrom river import metrics\nfrom river import preprocessing as pp\n\ndataset = datasets.Phishing()\n\nmodel = (\n    fx.PolynomialExtender() |\n    pp.StandardScaler() |\n    lm.LogisticRegression()\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 88.88%\n</code></pre></p>"},{"location":"api/feature-extraction/PolynomialExtender/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/feature-extraction/RBFSampler/","title":"RBFSampler","text":"<p>Extracts random features which approximate an RBF kernel.</p> <p>This is a powerful way to give non-linear capacity to linear classifiers. This method is also called \"random Fourier features\" in the literature.</p>"},{"location":"api/feature-extraction/RBFSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>gamma</p> <p>Default \u2192 <code>1.0</code></p> <p>RBF kernel parameter in <code>(-gamma * x^2)</code>.</p> </li> <li> <p>n_components</p> <p>Default \u2192 <code>100</code></p> <p>Number of samples per original feature. Equals the dimensionality of the computed feature space.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number seed.</p> </li> </ul>"},{"location":"api/feature-extraction/RBFSampler/#examples","title":"Examples","text":"<p><pre><code>from river import feature_extraction as fx\nfrom river import linear_model as lm\nfrom river import optim\nfrom river import stream\n\nX = [[0, 0], [1, 1], [1, 0], [0, 1]]\nY = [0, 0, 1, 1]\n\nmodel = lm.LogisticRegression(optimizer=optim.SGD(.1))\n\nfor x, y in stream.iter_array(X, Y):\n    model.learn_one(x, y)\n    y_pred = model.predict_one(x)\n    print(y, int(y_pred))\n</code></pre> <pre><code>0 0\n0 0\n1 0\n1 1\n</code></pre></p> <p><pre><code>model = (\n    fx.RBFSampler(seed=3) |\n    lm.LogisticRegression(optimizer=optim.SGD(.1))\n)\n\nfor x, y in stream.iter_array(X, Y):\n    model.learn_one(x, y)\n    y_pred = model.predict_one(x)\n    print(y, int(y_pred))\n</code></pre> <pre><code>0 0\n0 0\n1 1\n1 1\n</code></pre></p>"},{"location":"api/feature-extraction/RBFSampler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>Rahimi, A. and Recht, B., 2008. Random features for large-scale kernel machines. In Advances in neural information processing systems (pp. 1177-1184 \u21a9</p> </li> </ol>"},{"location":"api/feature-extraction/TFIDF/","title":"TFIDF","text":"<p>Computes TF-IDF values from sentences.</p> <p>The TF-IDF formula is the same one as scikit-learn. The only difference is the fact that the document frequencies are determined online, whereas in a batch setting they can be determined by performing an initial pass through the data. </p> <p>Note that the parameters are identical to those of <code>feature_extraction.BagOfWords</code>.</p>"},{"location":"api/feature-extraction/TFIDF/#parameters","title":"Parameters","text":"<ul> <li> <p>normalize</p> <p>Default \u2192 <code>True</code></p> <p>Whether or not the TF-IDF values by their L2 norm.</p> </li> <li> <p>on</p> <p>Type \u2192 str | None</p> <p>Default \u2192 <code>None</code></p> <p>The name of the feature that contains the text to vectorize. If <code>None</code>, then the input is treated as a document instead of a set of features.</p> </li> <li> <p>strip_accents</p> <p>Default \u2192 <code>True</code></p> <p>Whether or not to strip accent characters.</p> </li> <li> <p>lowercase</p> <p>Default \u2192 <code>True</code></p> <p>Whether or not to convert all characters to lowercase.</p> </li> <li> <p>preprocessor</p> <p>Type \u2192 typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional preprocessing function which overrides the <code>strip_accents</code> and <code>lowercase</code> steps, while preserving the tokenizing and n-grams generation steps.</p> </li> <li> <p>stop_words</p> <p>Type \u2192 set[str] | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional set of tokens to remove.</p> </li> <li> <p>tokenizer_pattern</p> <p>Default \u2192 <code>(?u)\\b\\w[\\w\\-]+\\b</code></p> <p>The tokenization pattern which is used when no <code>tokenizer</code> function is passed. A single capture group may optionally be specified.</p> </li> <li> <p>tokenizer</p> <p>Type \u2192 typing.Callable | None</p> <p>Default \u2192 <code>None</code></p> <p>A function used to convert preprocessed text into a <code>dict</code> of tokens. By default, a regex formula that works well in most cases is used.</p> </li> <li> <p>ngram_range</p> <p>Default \u2192 <code>(1, 1)</code></p> <p>The lower and upper boundary of the range n-grams to be extracted. All values of n such that <code>min_n &lt;= n &lt;= max_n</code> will be used. For example an <code>ngram_range</code> of <code>(1, 1)</code> means only unigrams, <code>(1, 2)</code> means unigrams and bigrams, and <code>(2, 2)</code> means only bigrams. Only works if <code>tokenizer</code> is not set to <code>False</code>.</p> </li> </ul>"},{"location":"api/feature-extraction/TFIDF/#attributes","title":"Attributes","text":"<ul> <li> <p>dfs (collections.defaultdict))</p> <p>Document counts.</p> </li> <li> <p>n (int)</p> <p>Number of scanned documents.</p> </li> </ul>"},{"location":"api/feature-extraction/TFIDF/#examples","title":"Examples","text":"<p><pre><code>from river import feature_extraction\n\ntfidf = feature_extraction.TFIDF()\n\ncorpus = [\n    'This is the first document.',\n    'This document is the second document.',\n    'And this is the third one.',\n    'Is this the first document?',\n]\n\nfor sentence in corpus:\n    tfidf.learn_one(sentence)\n    print(tfidf.transform_one(sentence))\n</code></pre> <pre><code>{'this': 0.447, 'is': 0.447, 'the': 0.447, 'first': 0.447, 'document': 0.447}\n{'this': 0.333, 'document': 0.667, 'is': 0.333, 'the': 0.333, 'second': 0.469}\n{'and': 0.497, 'this': 0.293, 'is': 0.293, 'the': 0.293, 'third': 0.497, 'one': 0.497}\n{'is': 0.384, 'this': 0.384, 'the': 0.384, 'first': 0.580, 'document': 0.469}\n</code></pre></p> <p>In the above example, a string is passed to <code>transform_one</code>. You can also indicate which field to access if the string is stored in a dictionary:</p> <p><pre><code>tfidf = feature_extraction.TFIDF(on='sentence')\n\nfor sentence in corpus:\n    x = {'sentence': sentence}\n    tfidf.learn_one(x)\n    print(tfidf.transform_one(x))\n</code></pre> <pre><code>{'this': 0.447, 'is': 0.447, 'the': 0.447, 'first': 0.447, 'document': 0.447}\n{'this': 0.333, 'document': 0.667, 'is': 0.333, 'the': 0.333, 'second': 0.469}\n{'and': 0.497, 'this': 0.293, 'is': 0.293, 'the': 0.293, 'third': 0.497, 'one': 0.497}\n{'is': 0.384, 'this': 0.384, 'the': 0.384, 'first': 0.580, 'document': 0.469}\n</code></pre></p>"},{"location":"api/feature-extraction/TFIDF/#methods","title":"Methods","text":"learn_many <p>Not available, will raise an exception.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> process_text transform_many <p>Not available, will raise an exception.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.Series' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/feature-extraction/TargetAgg/","title":"TargetAgg","text":"<p>Computes a streaming aggregate of the target values.</p> <p>This transformer is identical to <code>feature_extraction.Agg</code>, the only difference is that it operates on the target rather than on a feature. At each step, the running statistic <code>how</code> of target values in group <code>by</code> is updated with the target. It is therefore a supervised transformer.</p>"},{"location":"api/feature-extraction/TargetAgg/#parameters","title":"Parameters","text":"<ul> <li> <p>by</p> <p>Type \u2192 str | list[str] | None</p> <p>The feature by which to group the target values. All the data is included in the aggregate if this is <code>None</code>.</p> </li> <li> <p>how</p> <p>Type \u2192 stats.base.Univariate | utils.Rolling | utils.TimeRolling</p> <p>The statistic to compute.</p> </li> <li> <p>target_name</p> <p>Default \u2192 <code>y</code></p> <p>The target name which is used in the result.</p> </li> </ul>"},{"location":"api/feature-extraction/TargetAgg/#attributes","title":"Attributes","text":"<ul> <li> <p>state</p> <p>Return the current values for each group as a series.</p> </li> <li> <p>target_name</p> </li> </ul>"},{"location":"api/feature-extraction/TargetAgg/#examples","title":"Examples","text":"<p>Consider the following dataset, where the second value of each value is the target:</p> <pre><code>dataset = [\n    ({'country': 'France', 'place': 'Taco Bell'}, 42),\n    ({'country': 'Sweden', 'place': 'Burger King'}, 16),\n    ({'country': 'France', 'place': 'Burger King'}, 24),\n    ({'country': 'Sweden', 'place': 'Taco Bell'}, 58),\n    ({'country': 'Sweden', 'place': 'Burger King'}, 20),\n    ({'country': 'France', 'place': 'Taco Bell'}, 50),\n    ({'country': 'France', 'place': 'Burger King'}, 10),\n    ({'country': 'Sweden', 'place': 'Taco Bell'}, 80)\n]\n</code></pre> <p>As an example, let's perform a target encoding of the <code>place</code> feature. Instead of simply updating a running average, we use a <code>stats.BayesianMean</code> which allows us to incorporate some prior knowledge. This makes subsequent models less prone to overfitting. Indeed, it dampens the fact that too few samples might have been seen within a group.</p> <p><pre><code>from river import feature_extraction\nfrom river import stats\n\nagg = feature_extraction.TargetAgg(\n    by='place',\n    how=stats.BayesianMean(\n        prior=3,\n        prior_weight=1\n    )\n)\n\nfor x, y in dataset:\n    print(agg.transform_one(x))\n    agg.learn_one(x, y)\n</code></pre> <pre><code>{'y_bayes_mean_by_place': 3.0}\n{'y_bayes_mean_by_place': 3.0}\n{'y_bayes_mean_by_place': 9.5}\n{'y_bayes_mean_by_place': 22.5}\n{'y_bayes_mean_by_place': 14.333}\n{'y_bayes_mean_by_place': 34.333}\n{'y_bayes_mean_by_place': 15.75}\n{'y_bayes_mean_by_place': 38.25}\n</code></pre></p> <p>Just like with <code>feature_extraction.Agg</code>, we can specify multiple features on which to group the data:</p> <p><pre><code>agg = feature_extraction.TargetAgg(\n    by=['place', 'country'],\n    how=stats.BayesianMean(\n        prior=3,\n        prior_weight=1\n    )\n)\n\nfor x, y in dataset:\n    print(agg.transform_one(x))\n    agg.learn_one(x, y)\n</code></pre> <pre><code>{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 3.0}\n{'y_bayes_mean_by_place_and_country': 9.5}\n{'y_bayes_mean_by_place_and_country': 22.5}\n{'y_bayes_mean_by_place_and_country': 13.5}\n{'y_bayes_mean_by_place_and_country': 30.5}\n</code></pre></p> <p><pre><code>agg.state\n</code></pre> <pre><code>place        country\nTaco Bell    France     31.666667\nBurger King  Sweden     13.000000\n             France     12.333333\nTaco Bell    Sweden     47.000000\nName: y_bayes_mean_by_place_and_country, dtype: float64\n</code></pre></p> <p>This transformer can also be used in conjunction with <code>utils.TimeRolling</code>. The latter requires a <code>t</code> argument, which is a timestamp that indicates when the current row was observed. For instance, we can calculate the average (how) revenue (on) for each place (by) over the last 7 days (t):</p> <pre><code>import datetime as dt\nimport random\nimport string\nfrom river import utils\n\nagg = feature_extraction.TargetAgg(\n    by=\"group\",\n    how=utils.TimeRolling(stats.Mean(), dt.timedelta(days=7))\n)\n\nfor day in range(366):\n    g = random.choice(string.ascii_lowercase)\n    x = {\"group\": g}\n    y = string.ascii_lowercase.index(g) + random.random()\n    t = dt.datetime(2023, 1, 1) + dt.timedelta(days=day)\n    agg.learn_one(x, y, t=t)\n</code></pre>"},{"location":"api/feature-extraction/TargetAgg/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code> and a target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.Target' </li> <li>t     \u2014 defaults to <code>None</code> </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p> 1. Streaming groupbys in pandas for big datasets</p>"},{"location":"api/feature-selection/PoissonInclusion/","title":"PoissonInclusion","text":"<p>Randomly selects features with an inclusion trial.</p> <p>When a new feature is encountered, it is selected with probability <code>p</code>. The number of times a feature needs to beseen before it is added to the model follows a geometric distribution with expected value <code>1 / p</code>. This feature selection method is meant to be used when you have a very large amount of sparse features.</p>"},{"location":"api/feature-selection/PoissonInclusion/#parameters","title":"Parameters","text":"<ul> <li> <p>p</p> <p>Type \u2192 float</p> <p>Probability of including a feature the first time it is encountered.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed value used for reproducibility.</p> </li> </ul>"},{"location":"api/feature-selection/PoissonInclusion/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import feature_selection\nfrom river import stream\n\nselector = feature_selection.PoissonInclusion(p=0.1, seed=42)\n\ndataset = iter(datasets.TrumpApproval())\n\nfeature_names = next(dataset)[0].keys()\nn = 0\n\nwhile True:\n    x, y = next(dataset)\n    xt = selector.transform_one(x)\n    if xt.keys() == feature_names:\n        break\n    n += 1\n\nn\n</code></pre> <pre><code>12\n</code></pre></p>"},{"location":"api/feature-selection/PoissonInclusion/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9</p> </li> </ol>"},{"location":"api/feature-selection/SelectKBest/","title":"SelectKBest","text":"<p>Removes all but the \\(k\\) highest scoring features.</p>"},{"location":"api/feature-selection/SelectKBest/#parameters","title":"Parameters","text":"<ul> <li> <p>similarity</p> <p>Type \u2192 stats.base.Bivariate</p> </li> <li> <p>k</p> <p>Default \u2192 <code>10</code></p> <p>The number of features to keep.</p> </li> <li> <p>use_abs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>A boolean indicating whether to rank features based on the absolute value of their scores. This is particularly useful when the similarity metric can produce negative values, such as Pearson correlation. Defaults to <code>False</code>.</p> </li> </ul>"},{"location":"api/feature-selection/SelectKBest/#attributes","title":"Attributes","text":"<ul> <li> <p>similarities (dict)</p> <p>The similarity instances used for each feature.</p> </li> <li> <p>leaderboard (dict)</p> <p>The actual similarity measures.</p> </li> </ul>"},{"location":"api/feature-selection/SelectKBest/#examples","title":"Examples","text":"<p><pre><code>from pprint import pprint\nfrom river import feature_selection\nfrom river import stats\nfrom river import stream\nfrom sklearn import datasets\n\nX, y = datasets.make_regression(\n    n_samples=100,\n    n_features=10,\n    n_informative=2,\n    random_state=42\n)\n\nselector = feature_selection.SelectKBest(\n    similarity=stats.PearsonCorr(),\n    k=2\n)\n\nfor xi, yi, in stream.iter_array(X, y):\n    selector.learn_one(xi, yi)\n\npprint(selector.leaderboard)\n</code></pre> <pre><code>Counter({9: 0.7898,\n        7: 0.5444,\n        8: 0.1062,\n        2: 0.0638,\n        4: 0.0538,\n        5: 0.0271,\n        1: -0.0312,\n        6: -0.0657,\n        3: -0.1501,\n        0: -0.1895})\n</code></pre></p> <p><pre><code>selector.transform_one(xi)\n</code></pre> <pre><code>{7: -1.2795, 9: -1.8408}\n</code></pre></p> <p><pre><code>import random\n\nrandom.seed(42)\nX_abs = [[random.random() for _ in range(3)] for _ in range(100)]\ny_abs = [\n    0.6 * x[0]\n    - 0.9 * x[1]\n    + 0.1 * x[2]\n    + random.gauss(0, 0.1)\n    for x in X_abs\n]\n\nselector_no_abs = feature_selection.SelectKBest(\n    stats.PearsonCorr(),\n    k=1,\n    use_abs=False\n)\nfor xi, yi in stream.iter_array(X_abs, y_abs):\n    selector_no_abs.learn_one(xi, yi)\npprint(selector_no_abs.leaderboard)\n</code></pre> <pre><code>Counter({0: 0.5683236302249015,\n         2: -0.09937590098236333,\n         1: -0.7655616041162767})\n</code></pre> <pre><code>selector_no_abs.transform_one({i: v for i, v in enumerate(X_abs[-1])})\n</code></pre> <pre><code>{0: 0.009669699608339966}\n</code></pre></p> <p><pre><code>selector_with_abs = feature_selection.SelectKBest(\n    stats.PearsonCorr(),\n    k=1,\n    use_abs=True\n)\nfor xi, yi in stream.iter_array(X_abs, y_abs):\n    selector_with_abs.learn_one(xi, yi)\nselector_with_abs.transform_one({i: v for i, v in enumerate(X_abs[-1])})\n</code></pre> <pre><code>{1: 0.07524386007376704}\n</code></pre></p>"},{"location":"api/feature-selection/SelectKBest/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code> and a target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.Target' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/feature-selection/VarianceThreshold/","title":"VarianceThreshold","text":"<p>Removes low-variance features.</p>"},{"location":"api/feature-selection/VarianceThreshold/#parameters","title":"Parameters","text":"<ul> <li> <p>threshold</p> <p>Default \u2192 <code>0</code></p> <p>Only features with a variance above the threshold will be kept.</p> </li> <li> <p>min_samples</p> <p>Default \u2192 <code>2</code></p> <p>The minimum number of samples required to perform selection.</p> </li> </ul>"},{"location":"api/feature-selection/VarianceThreshold/#attributes","title":"Attributes","text":"<ul> <li> <p>variances (dict)</p> <p>The variance of each feature.</p> </li> </ul>"},{"location":"api/feature-selection/VarianceThreshold/#examples","title":"Examples","text":"<p><pre><code>from river import feature_selection\nfrom river import stream\n\nX = [\n    [0, 2, 0, 3],\n    [0, 1, 4, 3],\n    [0, 1, 1, 3]\n]\n\nselector = feature_selection.VarianceThreshold()\n\nfor x, _ in stream.iter_array(X):\n    selector.learn_one(x)\n    print(selector.transform_one(x))\n</code></pre> <pre><code>{0: 0, 1: 2, 2: 0, 3: 3}\n{1: 1, 2: 4}\n{1: 1, 2: 1}\n</code></pre></p>"},{"location":"api/feature-selection/VarianceThreshold/#methods","title":"Methods","text":"check_feature learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/forest/AMFClassifier/","title":"AMFClassifier","text":"<p>Aggregated Mondrian Forest classifier for online learning.</p> <p>This implementation is truly online<sup>1</sup>, in the sense that a single pass is performed, and that predictions can be produced anytime. </p> <p>Each node in a tree predicts according to the distribution of the labels it contains. This distribution is regularized using a \"Jeffreys\" prior with parameter <code>dirichlet</code>. For each class with <code>count</code> labels in the node and <code>n_samples</code> samples in it, the prediction of a node is given by </p> <p>\\(\\frac{count + dirichlet}{n_{samples} + dirichlet \\times n_{classes}}\\). </p> <p>The prediction for a sample is computed as the aggregated predictions of all the subtrees along the path leading to the leaf node containing the sample. The aggregation weights are exponential weights with learning rate <code>step</code> and log-loss when <code>use_aggregation</code> is <code>True</code>. </p> <p>This computation is performed exactly thanks to a context tree weighting algorithm. More details can be found in the paper cited in the references below. </p> <p>The final predictions are the average class probabilities predicted by each of the <code>n_estimators</code> trees in the forest.</p>"},{"location":"api/forest/AMFClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_estimators</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of trees in the forest.</p> </li> <li> <p>step</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>Step-size for the aggregation weights. Default is 1 for classification with the log-loss, which is usually the best choice.</p> </li> <li> <p>use_aggregation</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>Controls if aggregation is used in the trees. It is highly recommended to leave it as <code>True</code>.</p> </li> <li> <p>dirichlet</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.5</code></p> <p>Regularization level of the class frequencies used for predictions in each node. A rule of thumb is to set this to <code>1 / n_classes</code>, where <code>n_classes</code> is the expected number of classes which might appear. Default is <code>dirichlet = 0.5</code>, which works well for binary classification problems.</p> </li> <li> <p>split_pure</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Controls if nodes that contains only sample of the same class should be split (\"pure\" nodes). Default is <code>False</code>, namely pure nodes are not split, but <code>True</code> can be sometimes better.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/forest/AMFClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/forest/AMFClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import forest\nfrom river import metrics\n\ndataset = datasets.Bananas().take(500)\n\nmodel = forest.AMFClassifier(\n    n_estimators=10,\n    use_aggregation=True,\n    dirichlet=0.5,\n    seed=1\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 85.37%\n</code></pre></p>"},{"location":"api/forest/AMFClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/forest/AMFClassifier/#notes","title":"Notes","text":"<p>Only log_loss used for the computation of the aggregation weights is supported for now, namely the log-loss for multi-class classification.</p> <ol> <li> <p>Mourtada, J., Ga\u00efffas, S., &amp; Scornet, E. (2021). AMF: Aggregated Mondrian forests for online learning. Journal of the Royal Statistical Society Series B: Statistical Methodology, 83(3), 505-533.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/forest/AMFRegressor/","title":"AMFRegressor","text":"<p>Aggregated Mondrian Forest regressor for online learning.</p> <p>This algorithm is truly online, in the sense that a single pass is performed, and that predictions can be produced anytime. </p> <p>Each node in a tree predicts according to the average of the labels it contains. The prediction for a sample is computed as the aggregated predictions of all the subtrees along the path leading to the leaf node containing the sample. The aggregation weights are exponential weights with learning rate <code>step</code> using a squared loss when <code>use_aggregation</code> is <code>True</code>. </p> <p>This computation is performed exactly thanks to a context tree weighting algorithm. More details can be found in the original paper<sup>1</sup>. </p> <p>The final predictions are the average of the predictions of each of the <code>n_estimators</code> trees in the forest.</p>"},{"location":"api/forest/AMFRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_estimators</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of trees in the forest.</p> </li> <li> <p>step</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>Step-size for the aggregation weights.</p> </li> <li> <p>use_aggregation</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>Controls if aggregation is used in the trees. It is highly recommended to leave it as <code>True</code>.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/forest/AMFRegressor/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/forest/AMFRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import forest\nfrom river import metrics\n\ndataset = datasets.TrumpApproval()\nmodel = forest.AMFRegressor(seed=42)\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.268533\n</code></pre></p>"},{"location":"api/forest/AMFRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Mourtada, J., Ga\u00efffas, S., &amp; Scornet, E. (2021). AMF: Aggregated Mondrian forests for online learning. Journal of the Royal Statistical Society Series B: Statistical Methodology, 83(3), 505-533.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/forest/ARFClassifier/","title":"ARFClassifier","text":"<p>Adaptive Random Forest classifier.</p> <p>The 3 most important aspects of Adaptive Random Forest <sup>1</sup> are: </p> <ol> <li> <p>inducing diversity through re-sampling </p> </li> <li> <p>inducing diversity through randomly selecting subsets of features for    node splits </p> </li> <li> <p>drift detectors per base tree, which cause selective resets in response    to drifts </p> </li> </ol> <p>It also allows training background trees, which start training if a warning is detected and replace the active tree if the warning escalates to a drift.</p>"},{"location":"api/forest/ARFClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_models</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>Number of trees in the ensemble.</p> </li> <li> <p>max_features</p> <p>Type \u2192 bool | str | int</p> <p>Default \u2192 <code>sqrt</code></p> <p>Max number of attributes for each node split. - If <code>int</code>, then consider <code>max_features</code> at each split. - If <code>float</code>, then <code>max_features</code> is a percentage and   <code>int(max_features * n_features)</code> features are considered per split. - If \"sqrt\", then <code>max_features=sqrt(n_features)</code>. - If \"log2\", then <code>max_features=log2(n_features)</code>. - If None, then <code>max_features=n_features</code>.</p> </li> <li> <p>lambda_value</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>6</code></p> <p>The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging).</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.MultiClassMetric | None</p> <p>Default \u2192 <code>None</code></p> <p>Metric used to track trees performance within the ensemble. Defaults to <code>metrics.Accuracy</code>()`.</p> </li> <li> <p>disable_weighted_vote</p> <p>Default \u2192 <code>False</code></p> <p>If <code>True</code>, disables the weighted vote prediction.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Drift Detection method. Set to None to disable Drift detection. Defaults to <code>drift.ADWIN</code>(delta=0.001)`.</p> </li> <li> <p>warning_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Warning Detection method. Set to None to disable warning detection. Defaults to <code>drift.ADWIN</code>(delta=0.01)`.</p> </li> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>50</code></p> <p>[Tree parameter] Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] The maximum depth a tree can reach. If <code>None</code>, the tree will grow until the system recursion limit.</p> </li> <li> <p>split_criterion</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>info_gain</code></p> <p>[Tree parameter] Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Hellinger Distance</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>[Tree parameter] Allowed error in split decision, a value closer to 0 takes longer to decide.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>[Tree parameter] Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>nba</code></p> <p>[Tree parameter] Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>[Tree parameter] Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] List of Nominal attributes. If empty, then assume that all attributes are numerical.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, only allow binary splits.</p> </li> <li> <p>min_branch_fraction</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>[Tree parameter] The minimum percentage of observed data required for branches resulting from split candidates. To validate a split candidate, at least two resulting branches must have a percentage of samples greater than <code>min_branch_fraction</code>. This criterion prevents unnecessary splits when the majority of instances are concentrated in a single branch.</p> </li> <li> <p>max_share_to_split</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.99</code></p> <p>[Tree parameter] Only perform a split in a leaf if the proportion of elements in the majority class is smaller than this parameter value. This parameter avoids performing splits when most of the data belongs to a single class.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>100.0</code></p> <p>[Tree parameter] Maximum memory (MiB) consumed by the tree.</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2000000</code></p> <p>[Tree parameter] Number of instances between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>[Tree parameter] If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/forest/ARFClassifier/#attributes","title":"Attributes","text":"<ul> <li>models</li> </ul>"},{"location":"api/forest/ARFClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import evaluate\nfrom river import forest\nfrom river import metrics\nfrom river.datasets import synth\n\ndataset = synth.ConceptDriftStream(\n    seed=42,\n    position=500,\n    width=40\n).take(1000)\n\nmodel = forest.ARFClassifier(seed=8, leaf_prediction=\"mc\")\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 67.97%\n</code></pre></p> <p>The total number of warnings and drifts detected, respectively <pre><code>model.n_warnings_detected(), model.n_drifts_detected()\n</code></pre> <pre><code>(2, 1)\n</code></pre></p> <p>The number of warnings detected by tree number 2 <pre><code>model.n_warnings_detected(2)\n</code></pre> <pre><code>1\n</code></pre></p> <p>And the corresponding number of actual concept drift detected <pre><code>model.n_drifts_detected(2)\n</code></pre> <pre><code>1\n</code></pre></p>"},{"location":"api/forest/ARFClassifier/#methods","title":"Methods","text":"learn_one n_drifts_detected <p>Get the total number of concept drifts detected, or such number on an individual tree basis (optionally).</p> <p>Parameters</p> <ul> <li>tree_id     \u2014 'int | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     The number of concept drifts detected.</p> <p></p> n_warnings_detected <p>Get the total number of concept drift warnings detected, or the number on an individual tree basis (optionally).</p> <p>Parameters</p> <ul> <li>tree_id     \u2014 'int | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     The number of concept drift warnings detected.</p> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Heitor Murilo Gomes, Albert Bifet, Jesse Read, Jean Paul Barddal,  Fabricio Enembreck, Bernhard Pfharinger, Geoff Holmes, Talel Abdessalem.  Adaptive random forests for evolving data stream classification.  In Machine Learning, DOI: 10.1007/s10994-017-5642-8, Springer, 2017.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/forest/ARFRegressor/","title":"ARFRegressor","text":"<p>Adaptive Random Forest regressor.</p> <p>The 3 most important aspects of Adaptive Random Forest <sup>1</sup> are: </p> <ol> <li> <p>inducing diversity through re-sampling </p> </li> <li> <p>inducing diversity through randomly selecting subsets of features for    node splits </p> </li> <li> <p>drift detectors per base tree, which cause selective resets in response    to drifts </p> </li> </ol> <p>Notice that this implementation is slightly different from the original algorithm proposed in <sup>2</sup>. The <code>HoeffdingTreeRegressor</code> is used as base learner, instead of <code>FIMT-DD</code>. It also adds a new strategy to monitor the predictions and check for concept drifts. The deviations of the predictions to the target are monitored and normalized in the [0, 1] range to fulfill ADWIN's requirements. We assume that the data subjected to the normalization follows a normal distribution, and thus, lies within the interval of the mean \\(\\pm3\\sigma\\).</p>"},{"location":"api/forest/ARFRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_models</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>Number of trees in the ensemble.</p> </li> <li> <p>max_features</p> <p>Default \u2192 <code>sqrt</code></p> <p>Max number of attributes for each node split. - If <code>int</code>, then consider <code>max_features</code> at each split. - If <code>float</code>, then <code>max_features</code> is a percentage and   <code>int(max_features * n_features)</code> features are considered per split. - If \"sqrt\", then <code>max_features=sqrt(n_features)</code>. - If \"log2\", then <code>max_features=log2(n_features)</code>. - If None, then <code>max_features=n_features</code>.</p> </li> <li> <p>aggregation_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>median</code></p> <p>The method to use to aggregate predictions in the ensemble. - 'mean' - 'median' - If selected will disable the weighted vote.</p> </li> <li> <p>lambda_value</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>6</code></p> <p>The lambda value for bagging (lambda=6 corresponds to Leveraging Bagging).</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.RegressionMetric | None</p> <p>Default \u2192 <code>None</code></p> <p>Metric used to track trees performance within the ensemble. Depending, on the configuration, this metric is also used to weight predictions from the members of the ensemble. Defaults to <code>metrics.MSE</code>()`.</p> </li> <li> <p>disable_weighted_vote</p> <p>Default \u2192 <code>True</code></p> <p>If <code>True</code>, disables the weighted vote prediction, i.e. does not assign weights to individual tree's predictions and uses the arithmetic mean instead. Otherwise will use the <code>metric</code> value to weight predictions.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Drift Detection method. Set to None to disable Drift detection. Defaults to <code>drift.ADWIN</code>(0.001)`.</p> </li> <li> <p>warning_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Warning Detection method. Set to None to disable warning detection. Defaults to <code>drift.ADWIN</code>(0.01)`.</p> </li> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>50</code></p> <p>[Tree parameter] Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] The maximum depth a tree can reach. If <code>None</code>, the tree will grow until the system recursion limit.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>[Tree parameter] Allowed error in split decision, a value closer to 0 takes longer to decide.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>[Tree parameter] Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>adaptive</code></p> <p>[Tree parameter] Prediction mechanism used at leaves. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model</p> <p>Type \u2192 base.Regressor | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] The regression model used to provide responses if <code>leaf_prediction='model'</code>. If not provided, an instance of <code>linear_model.LinearRegression</code> with the default hyperparameters  is used.</p> </li> <li> <p>model_selector_decay</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.95</code></p> <p>[Tree parameter] The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] List of Nominal attributes. If empty, then assume that all attributes are numerical.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters.By default, <code>tree.splitter.EBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>[Tree parameter] The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, only allow binary splits.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>500.0</code></p> <p>[Tree parameter] Maximum memory (MiB) consumed by the tree.</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2000000</code></p> <p>[Tree parameter] Number of instances between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>[Tree parameter] If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/forest/ARFRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>models</p> </li> <li> <p>valid_aggregation_method</p> <p>Valid aggregation_method values.</p> </li> </ul>"},{"location":"api/forest/ARFRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import forest\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    forest.ARFRegressor(seed=42)\n)\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.772113\n</code></pre></p>"},{"location":"api/forest/ARFRegressor/#methods","title":"Methods","text":"learn_one n_drifts_detected <p>Get the total number of concept drifts detected, or such number on an individual tree basis (optionally).</p> <p>Parameters</p> <ul> <li>tree_id     \u2014 'int | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     The number of concept drifts detected.</p> <p></p> n_warnings_detected <p>Get the total number of concept drift warnings detected, or the number on an individual tree basis (optionally).</p> <p>Parameters</p> <ul> <li>tree_id     \u2014 'int | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>int:     The number of concept drift warnings detected.</p> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p> <ol> <li> <p>Gomes, H.M., Bifet, A., Read, J., Barddal, J.P., Enembreck, F.,   Pfharinger, B., Holmes, G. and Abdessalem, T., 2017. Adaptive random   forests for evolving data stream classification. Machine Learning,   106(9-10), pp.1469-1495.\u00a0\u21a9</p> </li> <li> <p>Gomes, H.M., Barddal, J.P., Boiko, L.E., Bifet, A., 2018.   Adaptive random forests for data stream regression. ESANN 2018.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/forest/OXTRegressor/","title":"OXTRegressor","text":"<p>Online Extra Trees regressor.</p> <p>The online Extra Trees<sup>1</sup> ensemble takes some steps further into randomization when compared to Adaptive Random Forests (ARF). A subspace of the feature space is considered at each split attempt, as ARF does, and online bagging or subbagging can also be (optionally) used. Nonetheless, Extra Trees randomizes the split candidates evaluated by each leaf node (just a single split is tested by numerical feature, which brings significant speedups to the ensemble), and might also randomize the maximum depth of the forest members, as well as the size of the feature subspace processed by each of its trees' leaves. </p> <p>On the other hand, OXT suffers from a cold-start problem. As the splits are random, the predictive performance in small samples is usually worse than using a deterministic split approach, such as the one used by ARF.</p>"},{"location":"api/forest/OXTRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_models</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of trees in the ensemble.</p> </li> <li> <p>max_features</p> <p>Type \u2192 bool | str | int</p> <p>Default \u2192 <code>sqrt</code></p> <p>Max number of attributes for each node split. - If int, then consider <code>max_features</code> at each split. - If float, then <code>max_features</code> is a percentage and <code>int(max_features * n_features)</code> features are considered per split. - If \"sqrt\", then <code>max_features=sqrt(n_features)</code>. - If \"log2\", then <code>max_features=log2(n_features)</code>. - If \"random\", then <code>max_features</code> will assume a different random number in the interval <code>[2, n_features]</code> for each tree leaf. - If None, then <code>max_features=n_features</code>.</p> </li> <li> <p>resampling_strategy</p> <p>Type \u2192 str | None</p> <p>Default \u2192 <code>subbagging</code></p> <p>The chosen instance resampling strategy: - If <code>None</code>, no resampling will be done and the trees will process all instances. - If <code>'baggging'</code>, online bagging will be performed (sampling with replacement). - If <code>'subbagging'</code>, online subbagging will be performed (sampling without replacement).</p> </li> <li> <p>resampling_rate</p> <p>Type \u2192 int | float</p> <p>Default \u2192 <code>0.5</code></p> <p>Only valid if <code>resampling_strategy</code> is not None. Controls the parameters of the resampling strategy.. - If <code>resampling_strategy='bagging'</code>, must be an integer greater than or equal to 1 that parameterizes the poisson distribution used to simulate bagging in online learning settings. It acts as the lambda parameter of Oza Bagging and Leveraging Bagging. - If <code>resampling_strategy='subbagging'</code>, must be a float in the interval \\((0, 1]\\) that controls the chance of each instance being used by a tree for learning.</p> </li> <li> <p>detection_mode</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>all</code></p> <p>The concept drift detection mode in which the forest operates. Valid values are: - \"all\": creates both warning and concept drift detectors. If a warning is detected, an alternate tree starts being trained in the background. If the warning trigger escalates to a concept drift, the affected tree is replaced by the alternate tree. - \"drop\": only the concept drift detectors are created. If a drift is detected, the affected tree is dropped and replaced by a new tree. - \"off\": disables the concept drift adaptation capabilities. The forest will act as if the processed stream is stationary.</p> </li> <li> <p>warning_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>The detector that will be used to trigger concept drift warnings. Defaults to <code>drift.ADWIN</code>(0.01)`.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>The detector used to detect concept drifts. Defaults to <code>drift.ADWIN</code>(0.001)`.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth the ensemble members might reach. If <code>None</code>, the trees will grow indefinitely.</p> </li> <li> <p>randomize_tree_depth</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not randomize the maximum depth of each tree in the ensemble. If <code>max_depth</code> is provided, it is going to act as an upper bound to generate the maximum depth for each tree.</p> </li> <li> <p>track_metric</p> <p>Type \u2192 metrics.base.RegressionMetric | None</p> <p>Default \u2192 <code>None</code></p> <p>The performance metric used to weight predictions. Defaults to <code>metrics.MAE</code>()`.</p> </li> <li> <p>disable_weighted_vote</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>Defines whether or not to use predictions weighted by each trees' prediction performance.</p> </li> <li> <p>split_buffer_size</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>Defines the size of the buffer used by the tree splitters when determining the feature range and a random split point in this interval.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed to support reproducibility.</p> </li> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>50</code></p> <p>[Tree parameter] Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>[Tree parameter] Allowed error in split decision, a value closer to 0 takes longer to decide.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>[Tree parameter] Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>adaptive</code></p> <p>[Tree parameter] Prediction mechanism used at leaves. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model</p> <p>Type \u2192 base.Regressor | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] The regression model used to provide responses if <code>leaf_prediction='model'</code>. If not provided, an instance of <code>linear_model.LinearRegression</code> with the default hyperparameters  is used.</p> </li> <li> <p>model_selector_decay</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.95</code></p> <p>[Tree parameter] The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>[Tree parameter] List of Nominal attributes. If empty, then assume that all attributes are numerical.</p> </li> <li> <p>min_samples_split</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>[Tree parameter] The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, only allow binary splits.</p> </li> <li> <p>max_size</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>500</code></p> <p>[Tree parameter] Maximum memory (MiB) consumed by the tree.</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2000000</code></p> <p>[Tree parameter] Number of instances between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>[Tree parameter] If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>[Tree parameter] If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/forest/OXTRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>instances_per_tree</p> <p>The number of instances processed by each one of the current forest members.  Each time a concept drift is detected, the count corresponding to the affected tree is reset.</p> </li> <li> <p>models</p> </li> <li> <p>n_drifts</p> <p>The number of concept drifts detected per ensemble member.</p> </li> <li> <p>n_tree_swaps</p> <p>The number of performed alternate tree swaps.  Not applicable if the warning detectors are disabled.</p> </li> <li> <p>n_warnings</p> <p>The number of warnings detected per ensemble member.</p> </li> <li> <p>total_instances</p> <p>The total number of instances processed by the ensemble.</p> </li> </ul>"},{"location":"api/forest/OXTRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import forest\n\ndataset = datasets.synth.Friedman(seed=42).take(5000)\n\nmodel = forest.OXTRegressor(n_models=3, seed=42)\n\nmetric = metrics.RMSE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>RMSE: 3.16212\n</code></pre></p>"},{"location":"api/forest/OXTRegressor/#methods","title":"Methods","text":"learn_one predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/forest/OXTRegressor/#notes","title":"Notes","text":"<p>As the Online Extra Trees change the way in which Hoeffding Trees perform split attempts and monitor numerical input features, some of the parameters of the vanilla Hoeffding Tree algorithms are not available.</p> <ol> <li> <p>Mastelini, S. M., Nakano, F. K., Vens, C., &amp; de Leon Ferreira, A. C. P. (2022). Online Extra Trees Regressor. IEEE Transactions on Neural Networks and Learning Systems.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/imblearn/ChebyshevOverSampler/","title":"ChebyshevOverSampler","text":"<p>Over-sampling for imbalanced regression using Chebyshev's inequality.</p> <p>Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). </p> <p>Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\). For any real number \\(t &gt; 0\\), the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\). </p> <p>Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\), and assuming \\(t &gt; 1\\), the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\). </p> <p>Alternatively, one can use \\(t\\) directly to estimate a frequency weight \\(\\kappa = \\lceil t\\rceil\\) and define an over-sampling strategy for extreme and rare target values<sup>1</sup>. Each incoming instance is used \\(\\kappa\\) times to update the underlying regressor. Frequent target values contribute only once to the underlying regressor, whereas rares cases are used multiple times for training.</p>"},{"location":"api/imblearn/ChebyshevOverSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 base.Regressor</p> <p>The regression model that will receive the biased sample.</p> </li> </ul>"},{"location":"api/imblearn/ChebyshevOverSampler/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import imblearn\nfrom river import metrics\nfrom river import preprocessing\nfrom river import rules\n\nmodel = (\n    preprocessing.StandardScaler() |\n    imblearn.ChebyshevOverSampler(\n        regressor=rules.AMRules(\n            n_min=50, delta=0.01\n        )\n    )\n)\n\nevaluate.progressive_val_score(\n    datasets.TrumpApproval(),\n    model,\n    metrics.MAE(),\n    print_every=500\n)\n</code></pre> <pre><code>[500] MAE: 1.629786\n[1,000] MAE: 1.663799\n[1,001] MAE: 1.66253\nMAE: 1.66253\n</code></pre></p>"},{"location":"api/imblearn/ChebyshevOverSampler/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/imblearn/ChebyshevUnderSampler/","title":"ChebyshevUnderSampler","text":"<p>Under-sampling for imbalanced regression using Chebyshev's inequality.</p> <p>Chebyshev's inequality can be used to define the probability of target observations being frequent values (w.r.t. the distribution mean). </p> <p>Let \\(Y\\) be a random variable with finite expected value \\(\\overline{y}\\) and non-zero variance \\(\\sigma^2\\). For any real number \\(t &gt; 0\\), the Chebyshev's inequality states that, for a wide class of unimodal probability distributions: \\(Pr(|y-\\overline{y}| \\ge t\\sigma) \\le \\dfrac{1}{t^2}\\). </p> <p>Taking \\(t=\\dfrac{|y-\\overline{y}|}{\\sigma}\\), and assuming \\(t &gt; 1\\), the Chebyshev\u2019s inequality for an observation \\(y\\) becomes: \\(P(|y - \\overline{y}|=t) = \\dfrac{\\sigma^2}{|y-\\overline{y}|}\\). The reciprocal of this probability is used for under-sampling<sup>1</sup> the most frequent cases. Extreme valued or rare cases have higher probabilities of selection, whereas the most frequent cases are likely to be discarded. Still, frequent cases have a small chance of being selected (controlled via the <code>sp</code> parameter) in case few rare instances were observed.</p>"},{"location":"api/imblearn/ChebyshevUnderSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 base.Regressor</p> <p>The regression model that will receive the biased sample.</p> </li> <li> <p>sp</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.15</code></p> <p>Second chance probability. Even if an example is not initially selected for training, it still has a small chance of being selected in case the number of rare case observed so far is small.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed to support reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/ChebyshevUnderSampler/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import imblearn\nfrom river import metrics\nfrom river import preprocessing\nfrom river import rules\n\nmodel = (\n    preprocessing.StandardScaler() |\n    imblearn.ChebyshevUnderSampler(\n        regressor=rules.AMRules(\n            n_min=50, delta=0.01,\n        ),\n        seed=42\n    )\n)\n\nevaluate.progressive_val_score(\n    datasets.TrumpApproval(),\n    model,\n    metrics.MAE(),\n    print_every=500\n)\n</code></pre> <pre><code>[500] MAE: 1.787162\n[1,000] MAE: 1.515711\n[1,001] MAE: 1.515236\nMAE: 1.515236\n</code></pre></p>"},{"location":"api/imblearn/ChebyshevUnderSampler/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Aminian, Ehsan, Rita P. Ribeiro, and Jo\u00e3o Gama. \"Chebyshev approaches for imbalanced data streams regression models.\" Data Mining and Knowledge Discovery 35.6 (2021): 2389-2466.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/imblearn/HardSamplingClassifier/","title":"HardSamplingClassifier","text":"<p>Hard sampling classifier.</p> <p>This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). </p> <p>The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes its place.</p>"},{"location":"api/imblearn/HardSamplingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> </li> <li> <p>size</p> <p>Type \u2192 int</p> <p>Size of the buffer.</p> </li> <li> <p>p</p> <p>Type \u2192 float</p> <p>Probability of updating the model with a sample from the buffer instead of a new incoming sample.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.BinaryLoss | optim.losses.MultiClassLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>Criterion used to evaluate the hardness of a sample.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed.</p> </li> </ul>"},{"location":"api/imblearn/HardSamplingClassifier/#attributes","title":"Attributes","text":"<ul> <li>classifier</li> </ul>"},{"location":"api/imblearn/HardSamplingClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import imblearn\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    imblearn.HardSamplingClassifier(\n        classifier=linear_model.LogisticRegression(),\n        p=0.1,\n        size=40,\n        seed=42,\n    )\n)\n\nevaluate.progressive_val_score(\n    dataset=datasets.Phishing(),\n    model=model,\n    metric=metrics.ROCAUC(),\n    print_every=500,\n)\n</code></pre> <pre><code>[500] ROCAUC: 92.78%\n[1,000] ROCAUC: 94.76%\n[1,250] ROCAUC: 95.06%\nROCAUC: 95.06%\n</code></pre></p>"},{"location":"api/imblearn/HardSamplingClassifier/#methods","title":"Methods","text":"learn_one predict_one predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/imblearn/HardSamplingRegressor/","title":"HardSamplingRegressor","text":"<p>Hard sampling regressor.</p> <p>This wrapper enables a model to retrain on past samples who's output was hard to predict. This works by storing the hardest samples in a buffer of a fixed size. When a new sample arrives, the wrapped model is either trained on one of the buffered samples with a probability p or on the new sample with a probability (1 - p). </p> <p>The hardness of an observation is evaluated with a loss function that compares the sample's ground truth with the wrapped model's prediction. If the buffer is not full, then the sample is added to the buffer. If the buffer is full and the new sample has a bigger loss than the lowest loss in the buffer, then the sample takes its place.</p>"},{"location":"api/imblearn/HardSamplingRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 base.Regressor</p> </li> <li> <p>size</p> <p>Type \u2192 int</p> <p>Size of the buffer.</p> </li> <li> <p>p</p> <p>Type \u2192 float</p> <p>Probability of updating the model with a sample from the buffer instead of a new incoming sample.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.RegressionLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>Criterion used to evaluate the hardness of a sample.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed.</p> </li> </ul>"},{"location":"api/imblearn/HardSamplingRegressor/#attributes","title":"Attributes","text":"<ul> <li>regressor</li> </ul>"},{"location":"api/imblearn/HardSamplingRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import imblearn\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    imblearn.HardSamplingRegressor(\n        regressor=linear_model.LinearRegression(),\n        p=.2,\n        size=30,\n        seed=42,\n    )\n)\n\nevaluate.progressive_val_score(\n    datasets.TrumpApproval(),\n    model,\n    metrics.MAE(),\n    print_every=500\n)\n</code></pre> <pre><code>[500] MAE: 2.274021\n[1,000] MAE: 1.392399\n[1,001] MAE: 1.391246\nMAE: 1.391246\n</code></pre></p>"},{"location":"api/imblearn/HardSamplingRegressor/#methods","title":"Methods","text":"learn_one predict_one"},{"location":"api/imblearn/RandomOverSampler/","title":"RandomOverSampler","text":"<p>Random over-sampling.</p> <p>This is a wrapper for classifiers. It will train the provided classifier by over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of reverse rejection sampling. </p> <p>See Working with imbalanced data for example usage.</p>"},{"location":"api/imblearn/RandomOverSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> </li> <li> <p>desired_dist</p> <p>Type \u2192 dict</p> <p>The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/RandomOverSampler/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import imblearn\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\nmodel = imblearn.RandomOverSampler(\n    (\n        preprocessing.StandardScaler() |\n        linear_model.LogisticRegression()\n    ),\n    desired_dist={False: 0.4, True: 0.6},\n    seed=42\n)\n\ndataset = datasets.CreditCard().take(3000)\n\nmetric = metrics.LogLoss()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>LogLoss: 0.0457...\n</code></pre></p>"},{"location":"api/imblearn/RandomOverSampler/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/imblearn/RandomSampler/","title":"RandomSampler","text":"<p>Random sampling by mixing under-sampling and over-sampling.</p> <p>This is a wrapper for classifiers. It will train the provided classifier by both under-sampling and over-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. </p> <p>See Working with imbalanced data for example usage.</p>"},{"location":"api/imblearn/RandomSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> </li> <li> <p>desired_dist</p> <p>Type \u2192 dict</p> <p>The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1. If set to <code>None</code>, then the observations will be sampled uniformly at random, which is strictly equivalent to using <code>ensemble.BaggingClassifier</code>.</p> </li> <li> <p>sampling_rate</p> <p>Default \u2192 <code>1.0</code></p> <p>The desired ratio of data to sample.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/RandomSampler/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import imblearn\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\nmodel = imblearn.RandomSampler(\n    (\n        preprocessing.StandardScaler() |\n        linear_model.LogisticRegression()\n    ),\n    desired_dist={False: 0.4, True: 0.6},\n    sampling_rate=0.8,\n    seed=42\n)\n\ndataset = datasets.CreditCard().take(3000)\n\nmetric = metrics.LogLoss()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>LogLoss: 0.09...\n</code></pre></p>"},{"location":"api/imblearn/RandomSampler/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/imblearn/RandomUnderSampler/","title":"RandomUnderSampler","text":"<p>Random under-sampling.</p> <p>This is a wrapper for classifiers. It will train the provided classifier by under-sampling the stream of given observations so that the class distribution seen by the classifier follows a given desired distribution. The implementation is a discrete version of rejection sampling. </p> <p>See Working with imbalanced data for example usage.</p>"},{"location":"api/imblearn/RandomUnderSampler/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> </li> <li> <p>desired_dist</p> <p>Type \u2192 dict</p> <p>The desired class distribution. The keys are the classes whilst the values are the desired class percentages. The values must sum up to 1.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/imblearn/RandomUnderSampler/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import imblearn\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\nmodel = imblearn.RandomUnderSampler(\n    (\n        preprocessing.StandardScaler() |\n        linear_model.LogisticRegression()\n    ),\n    desired_dist={False: 0.4, True: 0.6},\n    seed=42\n)\n\ndataset = datasets.CreditCard().take(3000)\n\nmetric = metrics.LogLoss()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>LogLoss: 0.0336...\n</code></pre></p>"},{"location":"api/imblearn/RandomUnderSampler/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Under-sampling a dataset with desired ratios \u21a9</p> </li> <li> <p>Wikipedia article on rejection sampling \u21a9</p> </li> </ol>"},{"location":"api/linear-model/ALMAClassifier/","title":"ALMAClassifier","text":"<p>Approximate Large Margin Algorithm (ALMA).</p>"},{"location":"api/linear-model/ALMAClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>p</p> <p>Default \u2192 <code>2</code></p> </li> <li> <p>alpha</p> <p>Default \u2192 <code>0.9</code></p> </li> <li> <p>B</p> <p>Default \u2192 <code>1.1111111111111112</code></p> </li> <li> <p>C</p> <p>Default \u2192 <code>1.4142135623730951</code></p> </li> </ul>"},{"location":"api/linear-model/ALMAClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>w (collections.defaultdict)</p> <p>The current weights.</p> </li> <li> <p>k (int)</p> <p>The number of instances seen during training.</p> </li> </ul>"},{"location":"api/linear-model/ALMAClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.ALMAClassifier()\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 82.56%\n</code></pre></p>"},{"location":"api/linear-model/ALMAClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Gentile, Claudio. \"A new approximate maximal margin classification algorithm.\" Journal of Machine Learning Research 2.Dec (2001): 213-242 \u21a9</p> </li> </ol>"},{"location":"api/linear-model/BayesianLinearRegression/","title":"BayesianLinearRegression","text":"<p>Bayesian linear regression.</p> <p>An advantage of Bayesian linear regression over standard linear regression is that features do not have to scaled beforehand. Another attractive property is that this flavor of linear regression is somewhat insensitive to its hyperparameters. Finally, this model can output instead a predictive distribution rather than just a point estimate. </p> <p>The downside is that the learning step runs in <code>O(n^2)</code> time, whereas the learning step of standard linear regression takes <code>O(n)</code> time.</p>"},{"location":"api/linear-model/BayesianLinearRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Default \u2192 <code>1</code></p> <p>Prior parameter.</p> </li> <li> <p>beta</p> <p>Default \u2192 <code>1</code></p> <p>Noise parameter.</p> </li> <li> <p>smoothing</p> <p>Type \u2192 float | None</p> <p>Default \u2192 <code>None</code></p> <p>Smoothing allows the model to gradually \"forget\" the past, and focus on the more recent data. It thus enables the model to deal with concept drift. Due to the current implementation, activating smoothing may slow down the model.</p> </li> </ul>"},{"location":"api/linear-model/BayesianLinearRegression/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\n\ndataset = datasets.TrumpApproval()\nmodel = linear_model.BayesianLinearRegression()\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.586...\n</code></pre></p> <p><pre><code>x, _ = next(iter(dataset))\nmodel.predict_one(x)\n</code></pre> <pre><code>43.852...\n</code></pre></p> <p><pre><code>model.predict_one(x, with_dist=True)\n</code></pre> <pre><code>\ud835\udca9(\u03bc=43.85..., \u03c3=1.00...)\n</code></pre></p> <p>The <code>smoothing</code> parameter can be set to make the model robust to drift. The parameter is expected to be between 0 and 1. To exemplify, let's generate some simulation data with an abrupt concept drift right in the middle.</p> <pre><code>import itertools\nimport random\n\ndef random_data(coefs, n, seed=42):\n    rng = random.Random(seed)\n    for _ in range(n):\n        x = {i: rng.random() for i, c in enumerate(coefs)}\n        y = sum(c * xi for c, xi in zip(coefs, x.values()))\n        yield x, y\n</code></pre> <p>Here's how the model performs without any smoothing:</p> <p><pre><code>model = linear_model.BayesianLinearRegression()\ndataset = itertools.chain(\n    random_data([0.1, 3], 100),\n    random_data([10, -2], 100)\n)\nmetric = metrics.MAE()\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 1.284...\n</code></pre></p> <p>And here's how it performs with some smoothing:</p> <p><pre><code>model = linear_model.BayesianLinearRegression(smoothing=0.8)\ndataset = itertools.chain(\n    random_data([0.1, 3], 100),\n    random_data([10, -2], 100)\n)\nmetric = metrics.MAE()\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.159...\n</code></pre></p> <p>Smoothing allows the model to gradually \"forget\" the past, and focus on the more recent data.</p> <p>Note how this works better than standard linear regression, even when using an aggressive learning rate.</p> <p><pre><code>from river import optim\nmodel = linear_model.LinearRegression(optimizer=optim.SGD(0.5))\ndataset = itertools.chain(\n    random_data([0.1, 3], 100),\n    random_data([10, -2], 100)\n)\nmetric = metrics.MAE()\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.242...\n</code></pre></p>"},{"location":"api/linear-model/BayesianLinearRegression/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_many predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>with_dist     \u2014 defaults to <code>False</code> </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p> <ol> <li> <p>Pattern Recognition and Machine Learning, page 52 \u2014 Christopher M. Bishop \u21a9</p> </li> <li> <p>Bayesian/Streaming Algorithms \u2014 Vincent Warmerdam \u21a9</p> </li> <li> <p>Bayesian linear regression for practitioners \u2014 Max Halford \u21a9</p> </li> </ol>"},{"location":"api/linear-model/LinearRegression/","title":"LinearRegression","text":"<p>Linear regression.</p> <p>This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: <code>learn_many</code>, <code>predict_many</code>, <code>predict_proba_many</code>. Each method takes as input a <code>pandas.DataFrame</code> where each column represents a feature. </p> <p>It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a <code>preprocessing.StandardScaler</code>.</p>"},{"location":"api/linear-model/LinearRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.RegressionLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>l1</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>intercept_init</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 optim.base.Scheduler | float</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer</p> <p>Type \u2192 optim.base.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/LinearRegression/#attributes","title":"Attributes","text":"<ul> <li> <p>weights (dict)</p> <p>The current weights.</p> </li> </ul>"},{"location":"api/linear-model/LinearRegression/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LinearRegression(intercept_lr=.1)\n)\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.558735\n</code></pre></p> <p><pre><code>model['LinearRegression'].intercept\n</code></pre> <pre><code>35.617670\n</code></pre></p> <p>You can call the <code>debug_one</code> method to break down a prediction. This works even if the linear regression is part of a pipeline.</p> <p><pre><code>x, y = next(iter(dataset))\nreport = model.debug_one(x)\nprint(report)\n</code></pre> <pre><code>0. Input\n--------\ngallup: 43.84321 (float)\nipsos: 46.19925 (float)\nmorning_consult: 48.31875 (float)\nordinal_date: 736389 (int)\nrasmussen: 44.10469 (float)\nyou_gov: 43.63691 (float)\n&lt;BLANKLINE&gt;\n1. StandardScaler\n-----------------\ngallup: 1.18810 (float)\nipsos: 2.10348 (float)\nmorning_consult: 2.73545 (float)\nordinal_date: -1.73032 (float)\nrasmussen: 1.26872 (float)\nyou_gov: 1.48391 (float)\n&lt;BLANKLINE&gt;\n2. LinearRegression\n-------------------\nName              Value      Weight      Contribution\n      Intercept    1.00000    35.61767       35.61767\n          ipsos    2.10348     0.62689        1.31866\nmorning_consult    2.73545     0.24180        0.66144\n         gallup    1.18810     0.43568        0.51764\n      rasmussen    1.26872     0.28118        0.35674\n        you_gov    1.48391     0.03123        0.04634\n   ordinal_date   -1.73032     3.45162       -5.97242\n&lt;BLANKLINE&gt;\nPrediction: 32.54607\n</code></pre></p>"},{"location":"api/linear-model/LinearRegression/#methods","title":"Methods","text":"debug_one <p>Debugs the output of the linear regression.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>decimals     \u2014 'int'     \u2014 defaults to <code>5</code> </li> </ul> <p>Returns</p> <p>str:     A table which explains the output.</p> <p></p> learn_many <p>Update the model with a mini-batch of features <code>X</code> and real-valued targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> <li>w     \u2014 'float | pd.Series'     \u2014 defaults to <code>1</code> </li> </ul> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X </li> </ul> <p>Returns</p> <p>The predicted outcomes.</p> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/linear-model/LogisticRegression/","title":"LogisticRegression","text":"<p>Logistic regression.</p> <p>This estimator supports learning with mini-batches. On top of the single instance methods, it provides the following methods: <code>learn_many</code>, <code>predict_many</code>, <code>predict_proba_many</code>. Each method takes as input a <code>pandas.DataFrame</code> where each column represents a feature. </p> <p>It is generally a good idea to scale the data beforehand in order for the optimizer to converge. You can do this online with a <code>preprocessing.StandardScaler</code>.</p>"},{"location":"api/linear-model/LogisticRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the weights. Note that the intercept is handled separately.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.BinaryLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for. Defaults to <code>optim.losses.Log</code>.</p> </li> <li> <p>l2</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>l1</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>intercept_init</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Type \u2192 float | optim.base.Scheduler</p> <p>Default \u2192 <code>0.01</code></p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer</p> <p>Type \u2192 optim.base.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/LogisticRegression/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights.</p> </li> </ul>"},{"location":"api/linear-model/LogisticRegression/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer=optim.SGD(.1))\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 88.96%\n</code></pre></p>"},{"location":"api/linear-model/LogisticRegression/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and boolean targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> <li>w     \u2014 'float | pd.Series'     \u2014 defaults to <code>1</code> </li> </ul> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_many <p>Predict the outcome probabilities for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A dataframe with probabilities of <code>True</code> and <code>False</code> for each sample.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/linear-model/PAClassifier/","title":"PAClassifier","text":"<p>Passive-aggressive learning for classification.</p>"},{"location":"api/linear-model/PAClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>C</p> <p>Default \u2192 <code>1.0</code></p> </li> <li> <p>mode</p> <p>Default \u2192 <code>1</code></p> </li> <li> <p>learn_intercept</p> <p>Default \u2192 <code>True</code></p> </li> </ul>"},{"location":"api/linear-model/PAClassifier/#examples","title":"Examples","text":"<p>The following example is taken from this blog post.</p> <p><pre><code>from river import linear_model\nfrom river import metrics\nfrom river import stream\nimport numpy as np\nfrom sklearn import datasets\nfrom sklearn import model_selection\n\nnp.random.seed(1000)\nX, y = datasets.make_classification(\n    n_samples=5000,\n    n_features=4,\n    n_informative=2,\n    n_redundant=0,\n    n_repeated=0,\n    n_classes=2,\n    n_clusters_per_class=2\n)\n\nX_train, X_test, y_train, y_test = model_selection.train_test_split(\n    X,\n    y,\n    test_size=0.35,\n    random_state=1000\n)\n\nmodel = linear_model.PAClassifier(\n    C=0.01,\n    mode=1\n)\n\nfor xi, yi in stream.iter_array(X_train, y_train):\n    model.learn_one(xi, yi)\n\nmetric = metrics.Accuracy() + metrics.LogLoss()\n\nfor xi, yi in stream.iter_array(X_test, y_test):\n    metric.update(yi, model.predict_proba_one(xi))\n\nprint(metric)\n</code></pre> <pre><code>Accuracy: 88.46%\nLogLoss: 0.325727...\n</code></pre></p>"},{"location":"api/linear-model/PAClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585 \u21a9</p> </li> </ol>"},{"location":"api/linear-model/PARegressor/","title":"PARegressor","text":"<p>Passive-aggressive learning for regression.</p>"},{"location":"api/linear-model/PARegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>C</p> <p>Default \u2192 <code>1.0</code></p> </li> <li> <p>mode</p> <p>Default \u2192 <code>1</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>learn_intercept</p> <p>Default \u2192 <code>True</code></p> </li> </ul>"},{"location":"api/linear-model/PARegressor/#examples","title":"Examples","text":"<p>The following example is taken from this blog post.</p> <p><pre><code>from river import linear_model\nfrom river import metrics\nfrom river import stream\nimport numpy as np\nfrom sklearn import datasets\n\nnp.random.seed(1000)\nX, y = datasets.make_regression(n_samples=500, n_features=4)\n\nmodel = linear_model.PARegressor(\n    C=0.01,\n    mode=2,\n    eps=0.1,\n    learn_intercept=False\n)\nmetric = metrics.MAE() + metrics.MSE()\n\nfor xi, yi in stream.iter_array(X, y):\n    y_pred = model.predict_one(xi)\n    model.learn_one(xi, yi)\n    metric.update(yi, y_pred)\n\nprint(metric)\n</code></pre> <pre><code>MAE: 9.809402\nMSE: 472.393532\n</code></pre></p>"},{"location":"api/linear-model/PARegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Crammer, K., Dekel, O., Keshet, J., Shalev-Shwartz, S. and Singer, Y., 2006. Online passive-aggressive algorithms. Journal of Machine Learning Research, 7(Mar), pp.551-585. \u21a9</p> </li> </ol>"},{"location":"api/linear-model/Perceptron/","title":"Perceptron","text":"<p>Perceptron classifier.</p> <p>In this implementation, the Perceptron is viewed as a special case of the logistic regression. The loss function that is used is the Hinge loss with a threshold set to 0, whilst the learning rate of the stochastic gradient descent procedure is set to 1 for both the weights and the intercept.</p>"},{"location":"api/linear-model/Perceptron/#parameters","title":"Parameters","text":"<ul> <li> <p>l2</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/Perceptron/#attributes","title":"Attributes","text":"<ul> <li> <p>weights</p> <p>The current weights.</p> </li> </ul>"},{"location":"api/linear-model/Perceptron/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model as lm\nfrom river import metrics\nfrom river import preprocessing as pp\n\ndataset = datasets.Phishing()\n\nmodel = pp.StandardScaler() | lm.Perceptron()\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 85.84%\n</code></pre></p>"},{"location":"api/linear-model/Perceptron/#methods","title":"Methods","text":"learn_many <p>Update the model with a mini-batch of features <code>X</code> and boolean targets <code>y</code>.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> <li>w     \u2014 'float | pd.Series'     \u2014 defaults to <code>1</code> </li> </ul> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_many <p>Predict the outcome probabilities for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A dataframe with probabilities of <code>True</code> and <code>False</code> for each sample.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/linear-model/SoftmaxRegression/","title":"SoftmaxRegression","text":"<p>Softmax regression is a generalization of logistic regression to multiple classes.</p> <p>Softmax regression is also known as \"multinomial logistic regression\". There are a set weights for each class, hence the <code>weights</code> attribute is a nested <code>collections.defaultdict</code>. The main advantage of using this instead of a one-vs-all logistic regression is that the probabilities will be calibrated. Moreover softmax regression is more robust to outliers.</p>"},{"location":"api/linear-model/SoftmaxRegression/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used to tune the weights.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.MultiClassLoss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2</p> <p>Default \u2192 <code>0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> </ul>"},{"location":"api/linear-model/SoftmaxRegression/#attributes","title":"Attributes","text":"<ul> <li>weights (collections.defaultdict)</li> </ul>"},{"location":"api/linear-model/SoftmaxRegression/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.ImageSegments()\n\nmodel = preprocessing.StandardScaler()\nmodel |= linear_model.SoftmaxRegression()\n\nmetric = metrics.MacroF1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MacroF1: 81.88%\n</code></pre></p>"},{"location":"api/linear-model/SoftmaxRegression/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Course on classification stochastic gradient descent \u21a9</p> </li> <li> <p>Binary vs. Multi-Class Logistic Regression \u21a9</p> </li> </ol>"},{"location":"api/linear-model/base/GLM/","title":"GLM","text":"<p>Generalized Linear Model.</p> <p>This serves as a base class for linear and logistic regression.</p>"},{"location":"api/linear-model/base/GLM/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer</p> <p>The sequential optimizer used for updating the weights. Note that the intercept updates are handled separately.</p> </li> <li> <p>loss</p> <p>The loss function to optimize for.</p> </li> <li> <p>l2</p> <p>Amount of L2 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>l1</p> <p>Amount of L1 regularization used to push weights towards 0. For now, only one type of penalty can be used. The joint use of L1 and L2 is not explicitly supported.</p> </li> <li> <p>intercept_init</p> <p>Initial intercept value.</p> </li> <li> <p>intercept_lr</p> <p>Learning rate scheduler used for updating the intercept. A <code>optim.schedulers.Constant</code> is used if a <code>float</code> is provided. The intercept is not updated when this is set to 0.</p> </li> <li> <p>clip_gradient</p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>initializer</p> <p>Weights initialization scheme.</p> </li> </ul>"},{"location":"api/linear-model/base/GLM/#attributes","title":"Attributes","text":"<ul> <li>weights</li> </ul>"},{"location":"api/linear-model/base/GLM/#methods","title":"Methods","text":"learn_many learn_one"},{"location":"api/metrics/Accuracy/","title":"Accuracy","text":"<p>Accuracy score, which is the percentage of exact matches.</p>"},{"location":"api/metrics/Accuracy/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Accuracy/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Accuracy/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [True, False, True, True, True]\ny_pred = [True, True, False, True, True]\n\nmetric = metrics.Accuracy()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>Accuracy: 60.00%\n</code></pre></p>"},{"location":"api/metrics/Accuracy/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/AdjustedMutualInfo/","title":"AdjustedMutualInfo","text":"<p>Adjusted Mutual Information between two clusterings.</p> <p>Adjusted Mutual Information (AMI) is an adjustment of the Mutual Information score that accounts for chance. It corrects the effect of agreement solely due to chance between clusterings, similar to the way the Adjusted Rand Index corrects the Rand Index. It is closely related to variation of information. The adjusted measure, however, is no longer metrical. </p> <p>For two clusterings \\(U\\) and \\(V\\), the Adjusted Mutual Information is calculated as: </p> \\[ AMI(U, V) = \\frac{MI(U, V) - E(MI(U, V))}{avg(H(U), H(V)) - E(MI(U, V))} \\] <p>This metric is independent of the permutation of the class or cluster label values; furthermore, it is also symmetric. This can be useful to measure the agreement of two label assignments strategies on the same dataset, regardless of the ground truth. </p> <p>However, due to the complexity of the Expected Mutual Info Score, the computation of this metric is an order of magnitude slower than most other metrics, in general.</p>"},{"location":"api/metrics/AdjustedMutualInfo/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>average_method</p> <p>Default \u2192 <code>arithmetic</code></p> <p>This parameter defines how to compute the normalizer in the denominator. Possible options include <code>min</code>, <code>max</code>, <code>arithmetic</code> and <code>geometric</code>.</p> </li> </ul>"},{"location":"api/metrics/AdjustedMutualInfo/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/AdjustedMutualInfo/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [1, 1, 2, 2, 3, 3]\ny_pred = [1, 1, 1, 2, 2, 2]\n\nmetric = metrics.AdjustedMutualInfo()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>1.0\n1.0\n0.0\n0.0\n0.105891\n0.298792\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>AdjustedMutualInfo: 0.298792\n</code></pre></p>"},{"location":"api/metrics/AdjustedMutualInfo/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Wikipedia contributors. (2021, March 17). Mutual information.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Mutual_information&amp;oldid=1012714929\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/AdjustedRand/","title":"AdjustedRand","text":"<p>Adjusted Rand Index.</p> <p>The Adjusted Rand Index is the corrected-for-chance version of the Rand Index <sup>1</sup> <sup>2</sup>. Such a correction for chance establishes a baseline by using the expected similarity of all pair-wise comparisons between clusterings specified by a random model. </p> <p>Traditionally, the Rand Index was corrected using the Permutation Model for Clustering. However, the premises of the permutation model are frequently violated; in many clustering scenarios, either the number of clusters or the size distribution of those clusters vary drastically. Variations of the adjusted Rand Index account for different models of random clusterings. </p> <p>Though the Rand Index may only yield a value between 0 and 1, the Adjusted Rand index can yield negative values if the index is less than the expected index.</p>"},{"location":"api/metrics/AdjustedRand/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/AdjustedRand/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/AdjustedRand/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 0, 0, 1, 1, 1]\ny_pred = [0, 0, 1, 1, 2, 2]\n\nmetric = metrics.AdjustedRand()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>1.0\n1.0\n0.0\n0.0\n0.09090909090909091\n0.24242424242424243\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>AdjustedRand: 0.242424\n</code></pre></p>"},{"location":"api/metrics/AdjustedRand/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Wikipedia contributors. (2021, January 13). Rand index.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Rand_index&amp;oldid=1000098911\u00a0\u21a9</p> </li> <li> <p>W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\".   Journal of the American Statistical Association. American Statistical Association.   66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/BalancedAccuracy/","title":"BalancedAccuracy","text":"<p>Balanced accuracy.</p> <p>Balanced accuracy is the average of recall obtained on each class. It is used to deal with imbalanced datasets in binary and multi-class classification problems.</p>"},{"location":"api/metrics/BalancedAccuracy/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/BalancedAccuracy/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/BalancedAccuracy/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\ny_true = [True, False, True, True, False, True]\ny_pred = [True, False, True, True, True, False]\n\nmetric = metrics.BalancedAccuracy()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>BalancedAccuracy: 62.50%\n</code></pre></p> <p><pre><code>y_true = [0, 1, 0, 0, 1, 0]\ny_pred = [0, 1, 0, 0, 0, 1]\nmetric = metrics.BalancedAccuracy()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>BalancedAccuracy: 62.50%\n</code></pre></p>"},{"location":"api/metrics/BalancedAccuracy/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/ClassificationReport/","title":"ClassificationReport","text":"<p>A report for monitoring a classifier.</p> <p>This class maintains a set of metrics and updates each of them every time <code>update</code> is called. You can print this class at any time during a model's lifetime to get a tabular visualization of various metrics. </p> <p>You can wrap a <code>metrics.ClassificationReport</code> with <code>utils.Rolling</code> in order to obtain a classification report over a window of observations. You can also wrap it with <code>utils.TimeRolling</code> to obtain a report over a period of time.</p>"},{"location":"api/metrics/ClassificationReport/#parameters","title":"Parameters","text":"<ul> <li> <p>decimals</p> <p>Default \u2192 <code>2</code></p> <p>The number of decimals to display in each cell.</p> </li> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/ClassificationReport/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/ClassificationReport/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = ['pear', 'apple', 'banana', 'banana', 'banana']\ny_pred = ['apple', 'pear', 'banana', 'banana', 'apple']\n\nreport = metrics.ClassificationReport()\n\nfor yt, yp in zip(y_true, y_pred):\n    report.update(yt, yp)\n\nprint(report)\n</code></pre> <pre><code>               Precision   Recall   F1       Support\n&lt;BLANKLINE&gt;\n   apple       0.00%    0.00%    0.00%         1\n  banana     100.00%   66.67%   80.00%         3\n    pear       0.00%    0.00%    0.00%         1\n&lt;BLANKLINE&gt;\n   Macro      33.33%   22.22%   26.67%\n   Micro      40.00%   40.00%   40.00%\nWeighted      60.00%   40.00%   48.00%\n&lt;BLANKLINE&gt;\n                 40.00% accuracy\n</code></pre></p>"},{"location":"api/metrics/ClassificationReport/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/CohenKappa/","title":"CohenKappa","text":"<p>Cohen's Kappa score.</p> <p>Cohen's Kappa expresses the level of agreement between two annotators on a classification problem. It is defined as </p> \\[ \\kappa = (p_o - p_e) / (1 - p_e) \\] <p>where \\(p_o\\) is the empirical probability of agreement on the label assigned to any sample (prequential accuracy), and \\(p_e\\) is the expected agreement when both annotators assign labels randomly.</p>"},{"location":"api/metrics/CohenKappa/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/CohenKappa/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/CohenKappa/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = ['cat', 'ant', 'cat', 'cat', 'ant', 'bird']\ny_pred = ['ant', 'ant', 'cat', 'cat', 'ant', 'cat']\n\nmetric = metrics.CohenKappa()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>CohenKappa: 42.86%\n</code></pre></p>"},{"location":"api/metrics/CohenKappa/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>J. Cohen (1960). \"A coefficient of agreement for nominal scales\". Educational and Psychological Measurement 20(1):37-46. doi:10.1177/001316446002000104.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Completeness/","title":"Completeness","text":"<p>Completeness Score.</p> <p>Completeness <sup>1</sup> is symmetrical to homogeneity. In order to satisfy the completeness criteria, a clustering must assign all of those datapoints that are members of a single class to a single cluster. To evaluate completeness, we examine the distribution cluster assignments within each class. In a perfectly complete clustering solution, each of these distributions will be completely skewed to a single cluster. </p> <p>We can evaluate this degree of skew by calculating the conditional entropy of the proposed cluster distribution given the class of the component data points. However, in the worst case scenario, each class is represented by every cluster with a distribution equal to the distribution of cluster sizes. Therefore, symmetric to the calculation above, we define completeness as: </p> \\[ c = \\begin{cases} 1 if H(K) = 0, \\\\ 1 - \\frac{H(K|C)}{H(K)} otherwise. \\end{cases}. \\]"},{"location":"api/metrics/Completeness/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Completeness/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Completeness/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [1, 1, 2, 2, 3, 3]\ny_pred = [1, 1, 1, 2, 2, 2]\n\nmetric = metrics.Completeness()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>1.0\n1.0\n1.0\n0.3836885465963443\n0.5880325916843805\n0.6666666666666667\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>Completeness: 66.67%\n</code></pre></p>"},{"location":"api/metrics/Completeness/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Andrew Rosenberg and Julia Hirschberg (2007).   V-Measure: A conditional entropy-based external cluster evaluation measure.   Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language   Processing and Computational Natural Language Learning, pp. 410 - 420,   Prague, June 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/ConfusionMatrix/","title":"ConfusionMatrix","text":"<p>Confusion Matrix for binary and multi-class classification.</p>"},{"location":"api/metrics/ConfusionMatrix/#parameters","title":"Parameters","text":"<ul> <li> <p>classes</p> <p>Default \u2192 <code>None</code></p> <p>The initial set of classes. This is optional and serves only for displaying purposes.</p> </li> </ul>"},{"location":"api/metrics/ConfusionMatrix/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>classes</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>total_false_negatives</p> </li> <li> <p>total_false_positives</p> </li> <li> <p>total_true_negatives</p> </li> <li> <p>total_true_positives</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/ConfusionMatrix/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = ['cat', 'ant', 'cat', 'cat', 'ant', 'bird']\ny_pred = ['ant', 'ant', 'cat', 'cat', 'ant', 'cat']\n\ncm = metrics.ConfusionMatrix()\n\nfor yt, yp in zip(y_true, y_pred):\n    cm.update(yt, yp)\n\ncm\n</code></pre> <pre><code>       ant  bird   cat\n ant     2     0     0\nbird     0     0     1\n cat     1     0     2\n</code></pre></p> <p><pre><code>cm['bird']['cat']\n</code></pre> <pre><code>1.0\n</code></pre></p>"},{"location":"api/metrics/ConfusionMatrix/#methods","title":"Methods","text":"false_negatives false_positives get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> support true_negatives true_positives update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/ConfusionMatrix/#notes","title":"Notes","text":"<p>This confusion matrix is a 2D matrix of shape <code>(n_classes, n_classes)</code>, corresponding to a single-target (binary and multi-class) classification task.</p> <p>Each row represents <code>true</code> (actual) class-labels, while each column corresponds to the <code>predicted</code> class-labels. For example, an entry in position <code>[1, 2]</code> means that the true class-label is 1, and the predicted class-label is 2 (incorrect prediction).</p> <p>This structure is used to keep updated statistics about a single-output classifier's performance and to compute multiple evaluation metrics.</p>"},{"location":"api/metrics/CrossEntropy/","title":"CrossEntropy","text":"<p>Multiclass generalization of the logarithmic loss.</p>"},{"location":"api/metrics/CrossEntropy/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/CrossEntropy/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2]\ny_pred = [\n    {0: 0.29450637, 1: 0.34216758, 2: 0.36332605},\n    {0: 0.21290077, 1: 0.32728332, 2: 0.45981591},\n    {0: 0.42860913, 1: 0.33380113, 2: 0.23758974},\n    {0: 0.44941979, 1: 0.32962558, 2: 0.22095463}\n]\n\nmetric = metrics.CrossEntropy()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>1.222454\n1.169691\n1.258864\n1.321597\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>CrossEntropy: 1.321598\n</code></pre></p>"},{"location":"api/metrics/CrossEntropy/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/F1/","title":"F1","text":"<p>Binary F1 score.</p>"},{"location":"api/metrics/F1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/F1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/F1/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [False, False, False, True, True, True]\ny_pred = [False, False, True, True, False, False]\n\nmetric = metrics.F1()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>F1: 40.00%\n</code></pre></p>"},{"location":"api/metrics/F1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/FBeta/","title":"FBeta","text":"<p>Binary F-Beta score.</p> <p>The FBeta score is a weighted harmonic mean between precision and recall. The higher the <code>beta</code> value, the higher the recall will be taken into account. When <code>beta</code> equals 1, precision and recall and equivalently weighted, which results in the F1 score (see <code>metrics.F1</code>).</p>"},{"location":"api/metrics/FBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta</p> <p>Type \u2192 float</p> <p>Weight of precision in the harmonic mean.</p> </li> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/FBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>precision (metrics.Precision)</p> </li> <li> <p>recall (metrics.Recall)</p> </li> </ul>"},{"location":"api/metrics/FBeta/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [False, False, False, True, True, True]\ny_pred = [False, False, True, True, False, False]\n\nmetric = metrics.FBeta(beta=2)\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>FBeta: 35.71%\n</code></pre></p>"},{"location":"api/metrics/FBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/FowlkesMallows/","title":"FowlkesMallows","text":"<p>Fowlkes-Mallows Index.</p> <p>The Fowlkes-Mallows Index <sup>1</sup> <sup>2</sup> is an external evaluation method that is used to determine the similarity between two clusterings, and also a metric to measure confusion matrices. The measure of similarity could be either between two hierarchical clusterings or a clustering and a benchmark classification. A higher value for the Fowlkes-Mallows index indicates a greater similarity between the clusters and the benchmark classifications. </p> <p>The Fowlkes-Mallows Index, for two cluster algorithms, is defined as: </p> \\[ FM = \\sqrt{PPV \\times TPR} = \\sqrt{\\frac{TP}{TP+FP} \\times \\frac{TP}{TP+FN}} \\] <p>where </p> <ul> <li> <p>TP, FP, FN are respectively the number of true positives, false positives and false negatives; </p> </li> <li> <p>TPR is the True Positive Rate (or Sensitivity/Recall), PPV is the Positive Predictive Rate (or Precision).</p> </li> </ul>"},{"location":"api/metrics/FowlkesMallows/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/FowlkesMallows/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/FowlkesMallows/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 0, 0, 1, 1, 1]\ny_pred = [0, 0, 1, 1, 2, 2]\n\nmetric = metrics.FowlkesMallows()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>FowlkesMallows: 0.00%\nFowlkesMallows: 100.00%\nFowlkesMallows: 57.74%\nFowlkesMallows: 40.82%\nFowlkesMallows: 35.36%\nFowlkesMallows: 47.14%\n</code></pre></p>"},{"location":"api/metrics/FowlkesMallows/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Wikipedia contributors. (2020, December 22).   Fowlkes\u2013Mallows index. In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Fowlkes%E2%80%93Mallows_index&amp;oldid=995714222\u00a0\u21a9</p> </li> <li> <p>E. B. Fowkles and C. L. Mallows (1983).   \u201cA method for comparing two hierarchical clusterings\u201d.   Journal of the American Statistical Association\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/GeometricMean/","title":"GeometricMean","text":"<p>Geometric mean score.</p> <p>The geometric mean is a good indicator of a classifier's performance in the presence of class imbalance because it is independent of the distribution of examples between classes. This implementation computes the geometric mean of class-wise sensitivity (recall). </p> \\[ gm = \\sqrt[n]{s_1\\cdot s_2\\cdot s_3\\cdot \\ldots\\cdot s_n} \\] <p>where \\(s_i\\) is the sensitivity (recall) of class \\(i\\) and \\(n\\) is the number of classes.</p>"},{"location":"api/metrics/GeometricMean/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/GeometricMean/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/GeometricMean/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = ['cat', 'ant', 'cat', 'cat', 'ant', 'bird', 'bird']\ny_pred = ['ant', 'ant', 'cat', 'cat', 'ant', 'cat', 'bird']\n\nmetric = metrics.GeometricMean()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>GeometricMean: 69.34%\n</code></pre></p>"},{"location":"api/metrics/GeometricMean/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Barandela, R. et al. \u201cStrategies for learning in class imbalance problems\u201d, Pattern Recognition, 36(3), (2003), pp 849-851.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Homogeneity/","title":"Homogeneity","text":"<p>Homogeneity Score.</p> <p>Homogeneity metric <sup>1</sup> of a cluster labeling given a ground truth. </p> <p>In order to satisfy the homogeneity criteria, a clustering must assign only those data points that are members of a single class to a single cluster. That is, the class distribution within each cluster should be skewed to a single class, that is, zero entropy. We determine how close a given clustering is to this ideal by examining the conditional entropy of the class distribution given the proposed clustering. </p> <p>However, in an imperfect situation, the size of this value is dependent on the size of the dataset and the distribution of class sizes. Therefore, instead of taking the raw conditional entropy, we normalize by the maximum reduction in entropy the clustering information could provide. </p> <p>As such, we define homogeneity as: </p> \\[ h = \\begin{cases} 1 if H(C) = 0, \\\\ 1 - \\frac{H(C|K)}{H(C)} otherwise. \\end{cases}. \\]"},{"location":"api/metrics/Homogeneity/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Homogeneity/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Homogeneity/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [1, 1, 2, 2, 3, 3]\ny_pred = [1, 1, 1, 2, 2, 2]\n\nmetric = metrics.Homogeneity()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>1.0\n1.0\n0.0\n0.311278\n0.37515\n0.42062\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>Homogeneity: 42.06%\n</code></pre></p>"},{"location":"api/metrics/Homogeneity/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Andrew Rosenberg and Julia Hirschberg (2007).   V-Measure: A conditional entropy-based external cluster evaluation measure.   Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language   Processing and Computational Natural Language Learning, pp. 410 - 420,   Prague, June 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Jaccard/","title":"Jaccard","text":"<p>Jaccard score.</p>"},{"location":"api/metrics/Jaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/Jaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Jaccard/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [False, True, True]\ny_pred = [True, True, True]\n\nmetric = metrics.Jaccard()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>Jaccard: 0.00%\nJaccard: 50.00%\nJaccard: 66.67%\n</code></pre></p>"},{"location":"api/metrics/Jaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Jaccard index \u21a9</p> </li> </ol>"},{"location":"api/metrics/LogLoss/","title":"LogLoss","text":"<p>Binary logarithmic loss.</p>"},{"location":"api/metrics/LogLoss/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/LogLoss/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [True, False, False, True]\ny_pred = [0.9,  0.1,   0.2,   0.65]\n\nmetric = metrics.LogLoss()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>0.105360\n0.105360\n0.144621\n0.216161\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>LogLoss: 0.216162\n</code></pre></p>"},{"location":"api/metrics/LogLoss/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/MAE/","title":"MAE","text":"<p>Mean absolute error.</p>"},{"location":"api/metrics/MAE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MAE/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmetric = metrics.MAE()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>0.5\n0.5\n0.333\n0.5\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>MAE: 0.5\n</code></pre></p>"},{"location":"api/metrics/MAE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/MAPE/","title":"MAPE","text":"<p>Mean absolute percentage error.</p>"},{"location":"api/metrics/MAPE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MAPE/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmetric = metrics.MAPE()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>MAPE: 32.738095\n</code></pre></p>"},{"location":"api/metrics/MAPE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/MCC/","title":"MCC","text":"<p>Matthews correlation coefficient.</p>"},{"location":"api/metrics/MCC/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/MCC/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MCC/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [True, True, True, False]\ny_pred = [True, False, True, True]\n\nmcc = metrics.MCC()\n\nfor yt, yp in zip(y_true, y_pred):\n    mcc.update(yt, yp)\n\nmcc\n</code></pre> <pre><code>MCC: -0.333333\n</code></pre></p>"},{"location":"api/metrics/MCC/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Wikipedia article \u21a9</p> </li> </ol>"},{"location":"api/metrics/MSE/","title":"MSE","text":"<p>Mean squared error.</p>"},{"location":"api/metrics/MSE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MSE/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmetric = metrics.MSE()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>0.25\n0.25\n0.1666\n0.375\n</code></pre></p>"},{"location":"api/metrics/MSE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/MacroF1/","title":"MacroF1","text":"<p>Macro-average F1 score.</p> <p>This works by computing the F1 score per class, and then performs a global average.</p>"},{"location":"api/metrics/MacroF1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroF1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroF1/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MacroF1()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MacroF1: 100.00%\nMacroF1: 33.33%\nMacroF1: 55.56%\nMacroF1: 55.56%\nMacroF1: 48.89%\n</code></pre></p>"},{"location":"api/metrics/MacroF1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/MacroFBeta/","title":"MacroFBeta","text":"<p>Macro-average F-Beta score.</p> <p>This works by computing the F-Beta score per class, and then performs a global average.</p>"},{"location":"api/metrics/MacroFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta</p> <p>Weight of precision in harmonic mean.</p> </li> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroFBeta/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MacroFBeta(beta=.8)\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MacroFBeta: 100.00%\nMacroFBeta: 31.06%\nMacroFBeta: 54.04%\nMacroFBeta: 54.04%\nMacroFBeta: 48.60%\n</code></pre></p>"},{"location":"api/metrics/MacroFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/MacroJaccard/","title":"MacroJaccard","text":"<p>Macro-average Jaccard score.</p>"},{"location":"api/metrics/MacroJaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroJaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroJaccard/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MacroJaccard()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MacroJaccard: 100.00%\nMacroJaccard: 25.00%\nMacroJaccard: 50.00%\nMacroJaccard: 50.00%\nMacroJaccard: 38.89%\n</code></pre></p>"},{"location":"api/metrics/MacroJaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/MacroPrecision/","title":"MacroPrecision","text":"<p>Macro-average precision score.</p>"},{"location":"api/metrics/MacroPrecision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroPrecision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroPrecision/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MacroPrecision()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MacroPrecision: 100.00%\nMacroPrecision: 25.00%\nMacroPrecision: 50.00%\nMacroPrecision: 50.00%\nMacroPrecision: 50.00%\n</code></pre></p>"},{"location":"api/metrics/MacroPrecision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/MacroRecall/","title":"MacroRecall","text":"<p>Macro-average recall score.</p>"},{"location":"api/metrics/MacroRecall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MacroRecall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MacroRecall/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MacroRecall()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MacroRecall: 100.00%\nMacroRecall: 50.00%\nMacroRecall: 66.67%\nMacroRecall: 66.67%\nMacroRecall: 55.56%\n</code></pre></p>"},{"location":"api/metrics/MacroRecall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/MicroF1/","title":"MicroF1","text":"<p>Micro-average F1 score.</p> <p>This computes the F1 score by merging all the predictions and true labels, and then computes a global F1 score.</p>"},{"location":"api/metrics/MicroF1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroF1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroF1/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 0]\ny_pred = [0, 1, 1, 2, 1]\n\nmetric = metrics.MicroF1()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>MicroF1: 60.00%\n</code></pre></p>"},{"location":"api/metrics/MicroF1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9</p> </li> </ol>"},{"location":"api/metrics/MicroFBeta/","title":"MicroFBeta","text":"<p>Micro-average F-Beta score.</p> <p>This computes the F-Beta score by merging all the predictions and true labels, and then computes a global F-Beta score.</p>"},{"location":"api/metrics/MicroFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta</p> <p>Type \u2192 float</p> <p>Weight of precision in the harmonic mean.</p> </li> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroFBeta/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 0]\ny_pred = [0, 1, 1, 2, 1]\n\nmetric = metrics.MicroFBeta(beta=2)\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>MicroFBeta: 60.00%\n</code></pre></p>"},{"location":"api/metrics/MicroFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p> 1. Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem?</p>"},{"location":"api/metrics/MicroJaccard/","title":"MicroJaccard","text":"<p>Micro-average Jaccard score.</p>"},{"location":"api/metrics/MicroJaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroJaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroJaccard/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MicroJaccard()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MicroJaccard: 100.00%\nMicroJaccard: 33.33%\nMicroJaccard: 50.00%\nMicroJaccard: 60.00%\nMicroJaccard: 42.86%\n</code></pre></p>"},{"location":"api/metrics/MicroJaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/MicroPrecision/","title":"MicroPrecision","text":"<p>Micro-average precision score.</p> <p>The micro-average precision score is exactly equivalent to the micro-average recall as well as the micro-average F1 score.</p>"},{"location":"api/metrics/MicroPrecision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroPrecision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroPrecision/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MicroPrecision()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MicroPrecision: 100.00%\nMicroPrecision: 50.00%\nMicroPrecision: 66.67%\nMicroPrecision: 75.00%\nMicroPrecision: 60.00%\n</code></pre></p>"},{"location":"api/metrics/MicroPrecision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9</p> </li> </ol>"},{"location":"api/metrics/MicroRecall/","title":"MicroRecall","text":"<p>Micro-average recall score.</p> <p>The micro-average recall is exactly equivalent to the micro-average precision as well as the micro-average F1 score.</p>"},{"location":"api/metrics/MicroRecall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MicroRecall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MicroRecall/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MicroRecall()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MicroRecall: 100.00%\nMicroRecall: 50.00%\nMicroRecall: 66.67%\nMicroRecall: 75.00%\nMicroRecall: 60.00%\n</code></pre></p>"},{"location":"api/metrics/MicroRecall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Why are precision, recall and F1 score equal when using micro averaging in a multi-class problem? \u21a9</p> </li> </ol>"},{"location":"api/metrics/MultiFBeta/","title":"MultiFBeta","text":"<p>Multi-class F-Beta score with different betas per class.</p> <p>The multiclass F-Beta score is the arithmetic average of the binary F-Beta scores of each class. The mean can be weighted by providing class weights.</p>"},{"location":"api/metrics/MultiFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>betas</p> <p>Weight of precision in the harmonic mean of each class.</p> </li> <li> <p>weights</p> <p>Class weights. If not provided then uniform weights will be used.</p> </li> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MultiFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MultiFBeta/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.MultiFBeta(\n    betas={0: 0.25, 1: 1, 2: 4},\n    weights={0: 1, 1: 1, 2: 2}\n)\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>MultiFBeta: 100.00%\nMultiFBeta: 25.76%\nMultiFBeta: 62.88%\nMultiFBeta: 62.88%\nMultiFBeta: 46.88%\n</code></pre></p>"},{"location":"api/metrics/MultiFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/MutualInfo/","title":"MutualInfo","text":"<p>Mutual Information between two clusterings.</p> <p>The Mutual Information <sup>1</sup> is a measure of the similarity between two labels of the same data. Where \\(|U_i|\\) is the number of samples in cluster \\(U_i\\) and \\(|V_j|\\) is the number of the samples in cluster \\(V_j\\), the Mutual Information between clusterings \\(U\\) and \\(V\\) can be calculated as: </p> \\[ MI(U,V) = \\sum_{i=1}^{|U|} \\sum_{v=1}^{|V|} \\frac{|U_i \\cup V_j|}{N} \\log \\frac{N |U_i \\cup V_j|}{|U_i| |V_j|} \\] <p>This metric is independent of the absolute values of the labels: a permutation of the class or cluster label values won't change the score. </p> <p>This metric is furthermore symmetric: switching <code>y_true</code> and <code>y_pred</code> will return the same score value. This can be useful to measure the agreement of two independent label assignments strategies on the same dataset when the real ground truth is not known. </p> <p>The Mutual Information can be equivalently expressed as: </p> \\[ MI(U,V) = H(U) - H(U | V) = H(V) - H(V | U) \\] <p>where \\(H(U)\\) and \\(H(V)\\) are the marginal entropies, \\(H(U | V)\\) and \\(H(V | U)\\) are the conditional entropies.</p>"},{"location":"api/metrics/MutualInfo/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/MutualInfo/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/MutualInfo/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [1, 1, 2, 2, 3, 3]\ny_pred = [1, 1, 1, 2, 2, 2]\n\nmetric = metrics.MutualInfo()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>0.0\n0.0\n0.0\n0.215761\n0.395752\n0.462098\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>MutualInfo: 0.462098\n</code></pre></p>"},{"location":"api/metrics/MutualInfo/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Wikipedia contributors. (2021, March 17). Mutual information.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Mutual_information&amp;oldid=1012714929\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/NormalizedMutualInfo/","title":"NormalizedMutualInfo","text":"<p>Normalized Mutual Information between two clusterings.</p> <p>Normalized Mutual Information (NMI) is a normalized version of the Mutual Information (MI) score to scale the results between the range of 0 (no mutual information) and 1 (perfectly mutual information). In the formula, the mutual information will be normalized by a generalized mean of the entropy of true and predicted labels, defined by the <code>average_method</code>. </p> <p>We note that this measure is not adjusted for chance (i.e corrected the effect of result agreement solely due to chance); as a result, the Adjusted Mutual Info Score will mostly be preferred. However, this metric is still symmetric, which means that switching true and predicted labels will not alter the score value. This fact can be useful when the metric is used to measure the agreement between two independent label solutions on the same dataset, when the ground truth remains unknown. </p> <p>Another advantage of the metric is that as it is based on the calculation of entropy-related measures, it is independent of the permutation of class/cluster labels.</p>"},{"location":"api/metrics/NormalizedMutualInfo/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>average_method</p> <p>Default \u2192 <code>arithmetic</code></p> <p>This parameter defines how to compute the normalizer in the denominator. Possible options include <code>min</code>, <code>max</code>, <code>arithmetic</code> and <code>geometric</code>.</p> </li> </ul>"},{"location":"api/metrics/NormalizedMutualInfo/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/NormalizedMutualInfo/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [1, 1, 2, 2, 3, 3]\ny_pred = [1, 1, 1, 2, 2, 2]\n\nmetric = metrics.NormalizedMutualInfo()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>1.0\n1.0\n0.0\n0.343711\n0.458065\n0.515803\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>NormalizedMutualInfo: 0.515804\n</code></pre></p>"},{"location":"api/metrics/NormalizedMutualInfo/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Wikipedia contributors. (2021, March 17). Mutual information.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Mutual_information&amp;oldid=1012714929\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Precision/","title":"Precision","text":"<p>Binary precision score.</p>"},{"location":"api/metrics/Precision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/Precision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Precision/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [True, False, True, True, True]\ny_pred = [True, True, False, True, True]\n\nmetric = metrics.Precision()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>Precision: 100.00%\nPrecision: 50.00%\nPrecision: 50.00%\nPrecision: 66.67%\nPrecision: 75.00%\n</code></pre></p>"},{"location":"api/metrics/Precision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/R2/","title":"R2","text":"<p>Coefficient of determination (\\(R^2\\)) score</p> <p>The coefficient of determination, denoted \\(R^2\\) or \\(r^2\\), is the proportion of the variance in the dependent variable that is predictable from the independent variable(s). <sup>1</sup> </p> <p>Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of \\(y\\), disregarding the input features, would get a \\(R^2\\) score of 0.0. </p> <p>\\(R^2\\) is not defined when less than 2 samples have been observed. This implementation returns 0.0 in this case.</p>"},{"location":"api/metrics/R2/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/R2/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmetric = metrics.R2()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>0.0\n0.9183\n0.9230\n0.9486\n</code></pre></p>"},{"location":"api/metrics/R2/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Coefficient of determination (Wikipedia) \u21a9</p> </li> </ol>"},{"location":"api/metrics/RMSE/","title":"RMSE","text":"<p>Root mean squared error.</p>"},{"location":"api/metrics/RMSE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/RMSE/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmetric = metrics.RMSE()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>0.5\n0.5\n0.408248\n0.612372\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>RMSE: 0.612372\n</code></pre></p>"},{"location":"api/metrics/RMSE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/RMSLE/","title":"RMSLE","text":"<p>Root mean squared logarithmic error.</p>"},{"location":"api/metrics/RMSLE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/RMSLE/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmetric = metrics.RMSLE()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>RMSLE: 0.357826\n</code></pre></p>"},{"location":"api/metrics/RMSLE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/ROCAUC/","title":"ROCAUC","text":"<p>Receiving Operating Characteristic Area Under the Curve.</p> <p>This metric is an approximation of the true ROC AUC. Computing the true ROC AUC would require storing all the predictions and ground truths, which isn't desirable. The approximation error is not significant as long as the predicted probabilities are well calibrated. In any case, this metric can still be used to reliably compare models between each other.</p>"},{"location":"api/metrics/ROCAUC/#parameters","title":"Parameters","text":"<ul> <li> <p>n_thresholds</p> <p>Default \u2192 <code>10</code></p> <p>The number of thresholds used for discretizing the ROC curve. A higher value will lead to more accurate results, but will also cost more time and memory.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/ROCAUC/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/ROCAUC/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [ 0,  0,   1,  1]\ny_pred = [.1, .4, .35, .8]\n\nmetric = metrics.ROCAUC()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 87.50%\n</code></pre></p> <p>The true ROC AUC is in fact 0.75. We can improve the accuracy by increasing the amount of thresholds. This comes at the cost more computation time and more memory usage.</p> <p><pre><code>metric = metrics.ROCAUC(n_thresholds=20)\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 75.00%\n</code></pre></p>"},{"location":"api/metrics/ROCAUC/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/Rand/","title":"Rand","text":"<p>Rand Index.</p> <p>The Rand Index <sup>1</sup> <sup>2</sup> is a measure of the similarity between two data clusterings. Given a set of elements <code>S</code> and two partitions of <code>S</code> to compare, <code>X</code> and <code>Y</code>, define the following: </p> <ul> <li> <p>a, the number of pairs of elements in <code>S</code> that are in the same subset in <code>X</code> and in the same subset in <code>Y</code> </p> </li> <li> <p>b, the number of pairs of elements in <code>S</code> that are in the different subset in <code>X</code> and in different subsets in <code>Y</code> </p> </li> <li> <p>c, the number of pairs of elements in <code>S</code> that are in the same subset in <code>X</code> and in different subsets in <code>Y</code> </p> </li> <li> <p>d, the number of pairs of elements in <code>S</code> that are in the different subset in <code>X</code> and in the same subset in <code>Y</code> </p> </li> </ul> <p>The Rand index, R, is </p> \\[ R = \frac{a+b}{a+b+c+d} = \frac{a+b}{\frac{n(n-1)}{2}}. \\]"},{"location":"api/metrics/Rand/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/Rand/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Rand/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 0, 0, 1, 1, 1]\ny_pred = [0, 0, 1, 1, 2, 2]\n\nmetric = metrics.Rand()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>Rand: 0.666667\n</code></pre></p>"},{"location":"api/metrics/Rand/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Wikipedia contributors. (2021, January 13). Rand index.   In Wikipedia, The Free Encyclopedia,   from https://en.wikipedia.org/w/index.php?title=Rand_index&amp;oldid=1000098911\u00a0\u21a9</p> </li> <li> <p>W. M. Rand (1971). \"Objective criteria for the evaluation of clustering methods\".   Journal of the American Statistical Association. American Statistical Association.   66 (336): 846\u2013850. arXiv:1704.01036. doi:10.2307/2284239. JSTOR 2284239.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/Recall/","title":"Recall","text":"<p>Binary recall score.</p>"},{"location":"api/metrics/Recall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/Recall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/Recall/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [True, False, True, True, True]\ny_pred = [True, True, False, True, True]\n\nmetric = metrics.Recall()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>Recall: 100.00%\nRecall: 100.00%\nRecall: 50.00%\nRecall: 66.67%\nRecall: 75.00%\n</code></pre></p>"},{"location":"api/metrics/Recall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/RollingROCAUC/","title":"RollingROCAUC","text":"<p>Rolling version of the Receiving Operating Characteristic Area Under the Curve.</p> <p>The RollingROCAUC calculates the metric using the instances in its window of size S. It keeps a queue of the instances, when an instance is added and the queue length is equal to S, the last instance is removed. The metric has a tree with ordered instances, in order to calculate the AUC efficiently. It was implemented based on the algorithm presented in Brzezinski and Stefanowski, 2017. </p> <p>The difference between this metric and the standard ROCAUC is that the latter calculates an approximation of the real metric considering all data from the beginning of the stream, while the RollingROCAUC calculates the exact value considering only the last S instances. This approach may be beneficial if it's necessary to evaluate the model's performance over time, since calculating the metric using the entire stream may hide the current performance of the classifier.</p>"},{"location":"api/metrics/RollingROCAUC/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Default \u2192 <code>1000</code></p> <p>The max length of the window.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/RollingROCAUC/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/RollingROCAUC/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [ 0,  1,  0,  1,  0,  1,  0,  0,   1,  1]\ny_pred = [.3, .5, .5, .7, .1, .3, .1, .4, .35, .8]\n\nmetric = metrics.RollingROCAUC(window_size=4)\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>RollingROCAUC: 75.00%\n</code></pre></p>"},{"location":"api/metrics/RollingROCAUC/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/SMAPE/","title":"SMAPE","text":"<p>Symmetric mean absolute percentage error.</p>"},{"location":"api/metrics/SMAPE/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/SMAPE/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 0.07533, 0.07533, 0.07533, 0.07533, 0.07533, 0.07533, 0.0672, 0.0672]\ny_pred = [0, 0.102, 0.107, 0.047, 0.1, 0.032, 0.047, 0.108, 0.089]\n\nmetric = metrics.SMAPE()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>SMAPE: 37.869392\n</code></pre></p>"},{"location":"api/metrics/SMAPE/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/Silhouette/","title":"Silhouette","text":"<p>Silhouette coefficient <sup>1</sup>, roughly speaking, is the ratio between cohesion and the average distances from the points to their second-closest centroid. It rewards the clustering algorithm where points are very close to their assigned centroids and far from any other centroids, that is, clustering results with good cohesion and good separation.</p> <p>It rewards clusterings where points are very close to their assigned centroids and far from any other centroids, that is clusterings with good cohesion and good separation. <sup>2</sup> </p> <p>The definition of Silhouette coefficient for online clustering evaluation is different from that of batch learning. It does not store information and calculate pairwise distances between all points at the same time, since the practice is too expensive for an incremental metric.</p>"},{"location":"api/metrics/Silhouette/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicates if a high value is better than a low one or not.</p> </li> </ul>"},{"location":"api/metrics/Silhouette/#examples","title":"Examples","text":"<p><pre><code>from river import cluster\nfrom river import stream\nfrom river import metrics\n\nX = [\n    [1, 2],\n    [1, 4],\n    [1, 0],\n    [4, 2],\n    [4, 4],\n    [4, 0],\n    [-2, 2],\n    [-2, 4],\n    [-2, 0]\n]\n\nk_means = cluster.KMeans(n_clusters=3, halflife=0.4, sigma=3, seed=0)\nmetric = metrics.Silhouette()\n\nfor x, _ in stream.iter_array(X):\n    k_means.learn_one(x)\n    y_pred = k_means.predict_one(x)\n    metric.update(x, y_pred, k_means.centers)\n\nmetric\n</code></pre> <pre><code>Silhouette: 0.32145\n</code></pre></p>"},{"location":"api/metrics/Silhouette/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>x </li> <li>y_pred </li> <li>centers </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>x </li> <li>y_pred </li> <li>centers </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Rousseeuw, P. (1987). Silhouettes: a graphical aid to the interpretation and validation   of cluster analysis 20, 53 - 65. DOI: 10.1016/0377-0427(87)90125-7\u00a0\u21a9</p> </li> <li> <p>Bifet, A. et al. (2018). \"Machine Learning for Data Streams\".   DOI: 10.7551/mitpress/10654.001.0001.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/VBeta/","title":"VBeta","text":"<p>VBeta.</p> <p>VBeta (or V-Measure) <sup>1</sup> is an external entropy-based cluster evaluation measure. It provides an elegant solution to many problems that affect previously defined cluster evaluation measures including </p> <ul> <li> <p>Dependence of clustering algorithm or dataset, </p> </li> <li> <p>The \"problem of matching\", where the clustering of only a portion of data points are evaluated, and </p> </li> <li> <p>Accurate evaluation and combination of two desirable aspects of clustering, homogeneity and completeness. </p> </li> </ul> <p>Based upon the calculations of homogeneity and completeness, a clustering solution's V-measure is calculated by computing the weighted harmonic mean of homogeneity and completeness, </p> \\[ V_{\\beta} = \\frac{(1 + \\beta) \\times h \\times c}{\\beta \\times h + c}. \\]"},{"location":"api/metrics/VBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>Weight of Homogeneity in the harmonic mean.</p> </li> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/VBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/VBeta/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [1, 1, 2, 2, 3, 3]\ny_pred = [1, 1, 1, 2, 2, 2]\n\nmetric = metrics.VBeta(beta=1.0)\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric.get())\n</code></pre> <pre><code>1.0\n1.0\n0.0\n0.3437110184854507\n0.4580652856440158\n0.5158037429793888\n</code></pre></p> <p><pre><code>metric\n</code></pre> <pre><code>VBeta: 51.58%\n</code></pre></p>"},{"location":"api/metrics/VBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p> <ol> <li> <p>Andrew Rosenberg and Julia Hirschberg (2007).   V-Measure: A conditional entropy-based external cluster evaluation measure.   Proceedings of the 2007 Joing Conference on Empirical Methods in Natural Language   Processing and Computational Natural Language Learning, pp. 410 - 420,   Prague, June 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/metrics/WeightedF1/","title":"WeightedF1","text":"<p>Weighted-average F1 score.</p> <p>This works by computing the F1 score per class, and then performs a global weighted average by using the support of each class.</p>"},{"location":"api/metrics/WeightedF1/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedF1/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedF1/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.WeightedF1()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>WeightedF1: 100.00%\nWeightedF1: 33.33%\nWeightedF1: 55.56%\nWeightedF1: 66.67%\nWeightedF1: 61.33%\n</code></pre></p>"},{"location":"api/metrics/WeightedF1/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/WeightedFBeta/","title":"WeightedFBeta","text":"<p>Weighted-average F-Beta score.</p> <p>This works by computing the F-Beta score per class, and then performs a global weighted average according to the support of each class.</p>"},{"location":"api/metrics/WeightedFBeta/#parameters","title":"Parameters","text":"<ul> <li> <p>beta</p> <p>Weight of precision in the harmonic mean.</p> </li> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedFBeta/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedFBeta/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.WeightedFBeta(beta=0.8)\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>WeightedFBeta: 100.00%\nWeightedFBeta: 31.06%\nWeightedFBeta: 54.04%\nWeightedFBeta: 65.53%\nWeightedFBeta: 62.63%\n</code></pre></p>"},{"location":"api/metrics/WeightedFBeta/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/WeightedJaccard/","title":"WeightedJaccard","text":"<p>Weighted average Jaccard score.</p>"},{"location":"api/metrics/WeightedJaccard/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedJaccard/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedJaccard/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.WeightedJaccard()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>WeightedJaccard: 100.00%\nWeightedJaccard: 25.00%\nWeightedJaccard: 50.00%\nWeightedJaccard: 62.50%\nWeightedJaccard: 50.00%\n</code></pre></p>"},{"location":"api/metrics/WeightedJaccard/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/WeightedPrecision/","title":"WeightedPrecision","text":"<p>Weighted-average precision score.</p> <p>This uses the support of each label to compute an average score, whereas <code>metrics.MacroPrecision</code> ignores the support.</p>"},{"location":"api/metrics/WeightedPrecision/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedPrecision/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedPrecision/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.WeightedPrecision()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>WeightedPrecision: 100.00%\nWeightedPrecision: 25.00%\nWeightedPrecision: 50.00%\nWeightedPrecision: 62.50%\nWeightedPrecision: 70.00%\n</code></pre></p>"},{"location":"api/metrics/WeightedPrecision/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/WeightedRecall/","title":"WeightedRecall","text":"<p>Weighted-average recall score.</p> <p>This uses the support of each label to compute an average score, whereas <code>MacroRecall</code> ignores the support.</p>"},{"location":"api/metrics/WeightedRecall/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/WeightedRecall/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/WeightedRecall/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [0, 1, 2, 2, 2]\ny_pred = [0, 0, 2, 2, 1]\n\nmetric = metrics.WeightedRecall()\n\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n    print(metric)\n</code></pre> <pre><code>WeightedRecall: 100.00%\nWeightedRecall: 50.00%\nWeightedRecall: 66.67%\nWeightedRecall: 75.00%\nWeightedRecall: 60.00%\n</code></pre></p>"},{"location":"api/metrics/WeightedRecall/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/base/BinaryMetric/","title":"BinaryMetric","text":"<p>Mother class for all binary classification metrics.</p>"},{"location":"api/metrics/base/BinaryMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> <li> <p>pos_val</p> <p>Default \u2192 <code>True</code></p> <p>Value to treat as \"positive\".</p> </li> </ul>"},{"location":"api/metrics/base/BinaryMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/BinaryMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'bool' </li> <li>y_pred     \u2014 'bool | float | dict[bool, float]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/base/ClassificationMetric/","title":"ClassificationMetric","text":"<p>Mother class for all classification metrics.</p>"},{"location":"api/metrics/base/ClassificationMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/base/ClassificationMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/ClassificationMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/base/Metric/","title":"Metric","text":"<p>Mother class for all metrics.</p>"},{"location":"api/metrics/base/Metric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/Metric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/base/Metrics/","title":"Metrics","text":"<p>A container class for handling multiple metrics at once.</p>"},{"location":"api/metrics/base/Metrics/#parameters","title":"Parameters","text":"<ul> <li> <p>metrics</p> </li> <li> <p>str_sep</p> <p>Default \u2192 </p> </li> </ul>"},{"location":"api/metrics/base/Metrics/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/Metrics/#methods","title":"Methods","text":"is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/base/MultiClassMetric/","title":"MultiClassMetric","text":"<p>Mother class for all multi-class classification metrics.</p>"},{"location":"api/metrics/base/MultiClassMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/base/MultiClassMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> <p>Indicates if labels are required, rather than probabilities.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/MultiClassMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/base/RegressionMetric/","title":"RegressionMetric","text":"<p>Mother class for all regression metrics.</p>"},{"location":"api/metrics/base/RegressionMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/RegressionMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'float' </li> <li>y_pred     \u2014 'float' </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/base/WrapperMetric/","title":"WrapperMetric","text":""},{"location":"api/metrics/base/WrapperMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/base/WrapperMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/multioutput/ExactMatch/","title":"ExactMatch","text":"<p>Exact match score.</p> <p>This is the most strict multi-label metric, defined as the number of samples that have all their labels correctly classified, divided by the total number of samples.</p>"},{"location":"api/metrics/multioutput/ExactMatch/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/ExactMatch/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [\n    {0: False, 1: True, 2: True},\n    {0: True, 1: True, 2: False},\n    {0: True, 1: True, 2: False},\n]\n\ny_pred = [\n    {0: True, 1: True, 2: True},\n    {0: True, 1: False, 2: False},\n    {0: True, 1: True, 2: False},\n]\n\nmetric = metrics.multioutput.ExactMatch()\nfor yt, yp in zip(y_true, y_pred):\n    metric.update(yt, yp)\n\nmetric\n</code></pre> <pre><code>ExactMatch: 33.33%\n</code></pre></p>"},{"location":"api/metrics/multioutput/ExactMatch/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'dict[str | int, base.typing.ClfTarget]' </li> <li>y_pred     \u2014 'dict[str | int, base.typing.ClfTarget] | dict[str | int, dict[base.typing.ClfTarget, float]]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'dict[str | int, base.typing.ClfTarget]' </li> <li>y_pred     \u2014 'dict[str | int, base.typing.ClfTarget] | dict[str | int, dict[base.typing.ClfTarget, float]]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model </li> </ul> <p></p>"},{"location":"api/metrics/multioutput/MacroAverage/","title":"MacroAverage","text":"<p>Macro-average wrapper.</p> <p>A copy of the provided metric is made for each output. The arithmetic average of all the metrics is returned.</p>"},{"location":"api/metrics/multioutput/MacroAverage/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>A classification or a regression metric.</p> </li> </ul>"},{"location":"api/metrics/multioutput/MacroAverage/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/MacroAverage/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/multioutput/MicroAverage/","title":"MicroAverage","text":"<p>Micro-average wrapper.</p> <p>The provided metric is updated with the value of each output.</p>"},{"location":"api/metrics/multioutput/MicroAverage/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>A classification or a regression metric.</p> </li> </ul>"},{"location":"api/metrics/multioutput/MicroAverage/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/MicroAverage/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/","title":"MultiLabelConfusionMatrix","text":"<p>Multi-label confusion matrix.</p> <p>Under the hood, this stores one <code>metrics.ConfusionMatrix</code> for each output.</p>"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ncm = metrics.multioutput.MultiLabelConfusionMatrix()\n\ny_true = [\n    {0: False, 1: True, 2: True},\n    {0: True, 1: True, 2: False}\n]\n\ny_pred = [\n    {0: True, 1: True, 2: True},\n    {0: True, 1: False, 2: False}\n]\n\nfor yt, yp in zip(y_true, y_pred):\n    cm.update(yt, yp)\n\ncm\n</code></pre> <pre><code>0\n            False   True\n    False       0      1\n     True       0      1\n&lt;BLANKLINE&gt;\n1\n            False   True\n    False       0      0\n     True       1      1\n&lt;BLANKLINE&gt;\n2\n            False   True\n    False       1      0\n     True       0      1\n</code></pre></p>"},{"location":"api/metrics/multioutput/MultiLabelConfusionMatrix/#methods","title":"Methods","text":"revert update"},{"location":"api/metrics/multioutput/PerOutput/","title":"PerOutput","text":"<p>Per-output wrapper.</p> <p>A copy of the metric is maintained for each output.</p>"},{"location":"api/metrics/multioutput/PerOutput/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>A classification or a regression metric.</p> </li> </ul>"},{"location":"api/metrics/multioutput/PerOutput/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/PerOutput/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/multioutput/SampleAverage/","title":"SampleAverage","text":"<p>Sample-average wrapper.</p> <p>The provided metric is evaluate on each sample. The arithmetic average over all the samples is returned. This is equivalent to using <code>average='samples'</code> in scikit-learn.</p>"},{"location":"api/metrics/multioutput/SampleAverage/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>A classification or a regression metric.</p> </li> </ul>"},{"location":"api/metrics/multioutput/SampleAverage/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>metric</p> <p>Gives access to the wrapped metric.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/SampleAverage/#examples","title":"Examples","text":"<p><pre><code>from river import metrics\n\ny_true = [\n    {0: False, 1: True, 2: True},\n    {0: True, 1: True, 2: False}\n]\ny_pred = [\n    {0: True, 1: True, 2: True},\n    {0: True, 1: False, 2: False}\n]\n\nsample_jaccard = metrics.multioutput.SampleAverage(metrics.Jaccard())\n\nfor yt, yp in zip(y_true, y_pred):\n    sample_jaccard.update(yt, yp)\n\nsample_jaccard\n</code></pre> <pre><code>SampleAverage(Jaccard): 58.33%\n</code></pre></p>"},{"location":"api/metrics/multioutput/SampleAverage/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/","title":"MultiOutputClassificationMetric","text":"<p>Mother class for all multi-output classification metrics.</p>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>cm</p> <p>Type \u2192 MultiLabelConfusionMatrix | None</p> <p>Default \u2192 <code>None</code></p> <p>This parameter allows sharing the same confusion matrix between multiple metrics. Sharing a confusion matrix reduces the amount of storage and computation time.</p> </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>requires_labels</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputClassificationMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'dict[str | int, base.typing.ClfTarget]' </li> <li>y_pred     \u2014 'dict[str | int, base.typing.ClfTarget] | dict[str | int, dict[base.typing.ClfTarget, float]]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'dict[str | int, base.typing.ClfTarget]' </li> <li>y_pred     \u2014 'dict[str | int, base.typing.ClfTarget] | dict[str | int, dict[base.typing.ClfTarget, float]]' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/","title":"MultiOutputRegressionMetric","text":"<p>Mother class for all multi-output regression metrics.</p>"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/#attributes","title":"Attributes","text":"<ul> <li> <p>bigger_is_better</p> <p>Indicate if a high value is better than a low one or not.</p> </li> <li> <p>works_with_weights</p> <p>Indicate whether the model takes into consideration the effect of sample weights</p> </li> </ul>"},{"location":"api/metrics/multioutput/base/MultiOutputRegressionMetric/#methods","title":"Methods","text":"get <p>Return the current value of the metric.</p> <p></p> is_better_than <p>Indicate if the current metric is better than another one.</p> <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> revert <p>Revert the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'dict[str | int, float | int]' </li> <li>y_pred     \u2014 'dict[str | int, float | int]' </li> </ul> <p></p> update <p>Update the metric.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'dict[str | int, float | int]' </li> <li>y_pred     \u2014 'dict[str | int, float | int]' </li> </ul> <p></p> works_with <p>Indicates whether or not a metric can work with a given model.</p> <p>Parameters</p> <ul> <li>model     \u2014 'base.Estimator' </li> </ul> <p></p>"},{"location":"api/misc/SDFT/","title":"SDFT","text":"<p>Sliding Discrete Fourier Transform (SDFT).</p> <p>Initially, the coefficients are all equal to 0, up until enough values have been seen. A call to <code>numpy.fft.fft</code> is triggered once <code>window_size</code> values have been seen. Subsequent values will update the coefficients online. This is much faster than recomputing an FFT from scratch for every new value.</p>"},{"location":"api/misc/SDFT/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>The size of the window.</p> </li> </ul>"},{"location":"api/misc/SDFT/#attributes","title":"Attributes","text":"<ul> <li>window_size</li> </ul>"},{"location":"api/misc/SDFT/#examples","title":"Examples","text":"<pre><code>import numpy as np\nfrom river import misc\n\nX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nwindow_size = 5\nsdft = misc.SDFT(window_size)\n\nfor i, x in enumerate(X):\n    sdft.update(x)\n    if i + 1 &gt;= window_size:\n        assert np.allclose(sdft.coefficients, np.fft.fft(X[i+1 - window_size:i+1]))\n</code></pre>"},{"location":"api/misc/SDFT/#methods","title":"Methods","text":"update <ol> <li> <p>Jacobsen, E. and Lyons, R., 2003. The sliding DFT. IEEE Signal Processing Magazine, 20(2), pp.74-80. \u21a9</p> </li> <li> <p>Understanding and Implementing the Sliding DFT \u21a9</p> </li> </ol>"},{"location":"api/misc/Skyline/","title":"Skyline","text":"<p>A skyline is set of points which is not dominated by any other point.</p> <p>This implementation uses a block nested loop. Identical observations are all part of the skyline if applicable.</p>"},{"location":"api/misc/Skyline/#parameters","title":"Parameters","text":"<ul> <li> <p>minimize</p> <p>Type \u2192 list[base.typing.FeatureName] | None</p> <p>Default \u2192 <code>None</code></p> <p>A list of features for which the values need to be minimized. Can be omitted as long as <code>maximize</code> is specified.</p> </li> <li> <p>maximize</p> <p>Type \u2192 list[base.typing.FeatureName] | None</p> <p>Default \u2192 <code>None</code></p> <p>A list of features for which the values need to be maximized. Can be omitted as long as <code>minimize</code> is specified.</p> </li> </ul>"},{"location":"api/misc/Skyline/#examples","title":"Examples","text":"<p>Here is an example taken from this blog post.</p> <p><pre><code>import random\nfrom river import misc\n\ncity_prices = {\n    'Bordeaux': 4045,\n    'Lyon': 4547,\n    'Toulouse': 3278\n}\n\ndef random_house():\n    city = random.choice(['Bordeaux', 'Lyon', 'Toulouse'])\n    size = round(random.gauss(200, 50))\n    price = round(random.uniform(0.8, 1.2) * city_prices[city] * size)\n    return {'city': city, 'size': size, 'price': price}\n\nskyline = misc.Skyline(minimize=['price'], maximize=['size'])\n\nrandom.seed(42)\n\nfor _ in range(100):\n    house = random_house()\n    skyline.update(house)\n\nprint(len(skyline))\n</code></pre> <pre><code>13\n</code></pre></p> <p><pre><code>print(skyline[0])\n</code></pre> <pre><code>{'city': 'Toulouse', 'size': 280, 'price': 763202}\n</code></pre></p> <p>Here is another example using the kart data from Mario Kart: Double Dash!!.</p> <p><pre><code>import collections\nfrom river import misc\n\nKart = collections.namedtuple(\n     'Kart',\n     'name speed off_road acceleration weight turbo'\n)\n\nkarts = [\n    Kart('Red Fire', 5, 4, 4, 5, 2),\n    Kart('Green Fire', 7, 3, 3, 4, 2),\n    Kart('Heart Coach', 4, 6, 6, 5, 2),\n    Kart('Bloom Coach', 6, 4, 5, 3, 2),\n    Kart('Turbo Yoshi', 4, 5, 6, 6, 2),\n    Kart('Turbo Birdo', 6, 4, 4, 7, 2),\n    Kart('Goo-Goo Buggy', 1, 9, 9, 2, 3),\n    Kart('Rattle Buggy', 2, 9, 8, 2, 3),\n    Kart('Toad Kart', 3, 9, 7, 2, 3),\n    Kart('Toadette Kart', 1, 9, 9, 2, 3),\n    Kart('Koopa Dasher', 2, 8, 8, 3, 3),\n    Kart('Para-Wing', 1, 8, 9, 3, 3),\n    Kart('DK Jumbo', 8, 2, 2, 8, 1),\n    Kart('Barrel Train', 8, 7, 3, 5, 3),\n    Kart('Koopa King', 9, 1, 1, 9, 1),\n    Kart('Bullet Blaster', 8, 1, 4, 1, 3),\n    Kart('Wario Car', 7, 3, 3, 7, 1),\n    Kart('Waluigi Racer', 5, 9, 5, 6, 2),\n    Kart('Piranha Pipes', 8, 7, 2, 9, 1),\n    Kart('Boo Pipes', 2, 9, 8, 9, 1),\n    Kart('Parade Kart', 7, 3, 4, 7, 3)\n]\n\nskyline = misc.Skyline(\n    maximize=['speed', 'off_road', 'acceleration', 'turbo'],\n    minimize=['weight']\n)\n\nfor kart in karts:\n    skyline.update(kart._asdict())\n\nbest_cart_names = [kart['name'] for kart in skyline]\nfor name in best_cart_names:\n    print(f'- {name}')\n</code></pre> <pre><code>- Green Fire\n- Heart Coach\n- Bloom Coach\n- Goo-Goo Buggy\n- Rattle Buggy\n- Toad Kart\n- Toadette Kart\n- Barrel Train\n- Koopa King\n- Bullet Blaster\n- Waluigi Racer\n- Parade Kart\n</code></pre></p> <p><pre><code>for name in sorted(set(kart.name for kart in karts) - set(best_cart_names)):\n    print(f'- {name}')\n</code></pre> <pre><code>- Boo Pipes\n- DK Jumbo\n- Koopa Dasher\n- Para-Wing\n- Piranha Pipes\n- Red Fire\n- Turbo Birdo\n- Turbo Yoshi\n- Wario Car\n</code></pre></p>"},{"location":"api/misc/Skyline/#methods","title":"Methods","text":"<ol> <li> <p>Skyline queries in Python \u21a9</p> </li> <li> <p>Borzsony, S., Kossmann, D. and Stocker, K., 2001, April. The skyline operator. In Proceedings 17th international conference on data engineering (pp. 421-430). IEEE. \u21a9</p> </li> <li> <p>Tao, Y. and Papadias, D., 2006. Maintaining sliding window skylines on data streams. IEEE Transactions on Knowledge and Data Engineering, 18(3), pp.377-391. \u21a9</p> </li> </ol>"},{"location":"api/model-selection/BanditClassifier/","title":"BanditClassifier","text":"<p>Bandit-based model selection for classification.</p> <p>Each model is associated with an arm. At each <code>learn_one</code> call, the policy decides which arm/model to pull. The reward is the performance of the model on the provided sample. The <code>predict_one</code> and <code>predict_proba_one</code> methods use the current best model.</p>"},{"location":"api/model-selection/BanditClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>The models to select from.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.ClassificationMetric</p> <p>The metric that is used to measure the performance of each model.</p> </li> <li> <p>policy</p> <p>Type \u2192 bandit.base.Policy</p> <p>The bandit policy to use.</p> </li> </ul>"},{"location":"api/model-selection/BanditClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/BanditClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import bandit\nfrom river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import model_selection\nfrom river import optim\nfrom river import preprocessing\n\nmodels = [\n    linear_model.LogisticRegression(optimizer=optim.SGD(lr=lr))\n    for lr in [0.0001, 0.001, 1e-05, 0.01]\n]\n\ndataset = datasets.Phishing()\nmodel = (\n    preprocessing.StandardScaler() |\n    model_selection.BanditClassifier(\n        models,\n        metric=metrics.Accuracy(),\n        policy=bandit.EpsilonGreedy(\n            epsilon=0.1,\n            decay=0.001,\n            burn_in=20,\n            seed=42\n        )\n    )\n)\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 88.96%\n</code></pre></p>"},{"location":"api/model-selection/BanditClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/model-selection/BanditRegressor/","title":"BanditRegressor","text":"<p>Bandit-based model selection for regression.</p> <p>Each model is associated with an arm. At each <code>learn_one</code> call, the policy decides which arm/model to pull. The reward is the performance of the model on the provided sample. The <code>predict_one</code> method uses the current best model.</p>"},{"location":"api/model-selection/BanditRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>The models to select from.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.RegressionMetric</p> <p>The metric that is used to measure the performance of each model.</p> </li> <li> <p>policy</p> <p>Type \u2192 bandit.base.Policy</p> <p>The bandit policy to use.</p> </li> </ul>"},{"location":"api/model-selection/BanditRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/BanditRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import bandit\nfrom river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import model_selection\nfrom river import optim\nfrom river import preprocessing\n\nmodels = [\n    linear_model.LinearRegression(optimizer=optim.SGD(lr=lr))\n    for lr in [0.0001, 0.001, 1e-05, 0.01]\n]\n\ndataset = datasets.TrumpApproval()\nmodel = (\n    preprocessing.StandardScaler() |\n    model_selection.BanditRegressor(\n        models,\n        metric=metrics.MAE(),\n        policy=bandit.EpsilonGreedy(\n            epsilon=0.1,\n            decay=0.001,\n            burn_in=100,\n            seed=42\n        )\n    )\n)\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 3.134089\n</code></pre></p> <p>Here's another example using the UCB policy. The latter is more sensitive to the target scale, and usually works better when the target is rescaled.</p> <p><pre><code>models = [\n    linear_model.LinearRegression(optimizer=optim.SGD(lr=lr))\n    for lr in [0.0001, 0.001, 1e-05, 0.01]\n]\n\nmodel = (\n    preprocessing.StandardScaler() |\n    preprocessing.TargetStandardScaler(\n        model_selection.BanditRegressor(\n            models,\n            metric=metrics.MAE(),\n            policy=bandit.UCB(\n                delta=1,\n                burn_in=100\n            )\n        )\n    )\n)\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.875333\n</code></pre></p>"},{"location":"api/model-selection/BanditRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/model-selection/GreedyRegressor/","title":"GreedyRegressor","text":"<p>Greedy selection regressor.</p> <p>This selection method simply updates each model at each time step. The current best model is used to make predictions. It's greedy in the sense that updating each model can be costly. On the other hand, bandit-like algorithms are more temperate in that only update a subset of the models at each step.</p>"},{"location":"api/model-selection/GreedyRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>Type \u2192 list[base.Regressor]</p> <p>The models to select from.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.RegressionMetric | None</p> <p>Default \u2192 <code>None</code></p> <p>The metric that is used to measure the performance of each model.</p> </li> </ul>"},{"location":"api/model-selection/GreedyRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/GreedyRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import model_selection\nfrom river import optim\nfrom river import preprocessing\n\nmodels = [\n    linear_model.LinearRegression(optimizer=optim.SGD(lr=lr))\n    for lr in [1e-5, 1e-4, 1e-3, 1e-2]\n]\n\ndataset = datasets.TrumpApproval()\nmetric = metrics.MAE()\nmodel = (\n    preprocessing.StandardScaler() |\n    model_selection.GreedyRegressor(models, metric)\n)\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 1.319678\n</code></pre></p>"},{"location":"api/model-selection/GreedyRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/model-selection/SuccessiveHalvingClassifier/","title":"SuccessiveHalvingClassifier","text":"<p>Successive halving algorithm for classification.</p> <p>Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most <code>budget</code> model updates will be performed in total. </p> <p>If you have <code>k</code> combinations of hyperparameters and that your dataset contains <code>n</code> observations, then the maximal budget you can allocate is: </p> \\[\\frac{2kn}{eta}\\] <p>It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. </p> <p>If you have a budget of <code>B</code>, and that your dataset contains <code>n</code> observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: </p> \\[\\left\\lceil\\left\\lfloor\\frac{B}{2n}\\right\\rfloor \\times eta \\right\\rceil\\]"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>The models to compare.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.Metric</p> <p>Metric used for comparing models with.</p> </li> <li> <p>budget</p> <p>Type \u2192 int</p> <p>Total number of model updates you wish to allocate.</p> </li> <li> <p>eta</p> <p>Default \u2192 <code>2</code></p> <p>Rate of elimination. At every rung, <code>math.ceil(k / eta)</code> models are kept, where <code>k</code> is the number of models that have reached the rung. A higher <code>eta</code> value will focus on less models but will allocate more iterations to the best models.</p> </li> <li> <p>verbose</p> <p>Default \u2192 <code>False</code></p> <p>Whether to display progress or not.</p> </li> <li> <p>print_kwargs</p> <p>Extra keyword arguments are passed to the <code>print</code> function. For instance, this allows providing a <code>file</code> argument, which indicates where to output progress.</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#examples","title":"Examples","text":"<p>As an example, let's use successive halving to tune the optimizer of a logistic regression. We'll first define the model.</p> <pre><code>from river import linear_model\nfrom river import preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression()\n)\n</code></pre> <p>Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates.</p> <pre><code>from river import utils\nfrom river import optim\n\nmodels = utils.expand_param_grid(model, {\n    'LogisticRegression': {\n        'optimizer': [\n            (optim.SGD, {'lr': [.1, .01, .005]}),\n            (optim.Adam, {'beta_1': [.01, .001], 'lr': [.1, .01, .001]}),\n            (optim.Adam, {'beta_1': [.1], 'lr': [.001]}),\n        ]\n    }\n})\n</code></pre> <p>We can check how many models we've created.</p> <p><pre><code>len(models)\n</code></pre> <pre><code>10\n</code></pre></p> <p>We can now pass these models to a <code>SuccessiveHalvingClassifier</code>. We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest.</p> <pre><code>from river import model_selection\n\nsh = model_selection.SuccessiveHalvingClassifier(\n    models,\n    metric=metrics.Accuracy(),\n    budget=2000,\n    eta=2,\n    verbose=True\n)\n</code></pre> <p>A <code>SuccessiveHalvingClassifier</code> is also a classifier with a <code>learn_one</code> and a <code>predict_proba_one</code> method. We can therefore evaluate it like any other classifier with <code>evaluate.progressive_val_score</code>.</p> <p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\n\nevaluate.progressive_val_score(\n    dataset=datasets.Phishing(),\n    model=sh,\n    metric=metrics.ROCAUC()\n)\n</code></pre> <pre><code>[1] 5 removed       5 left  50 iterations   budget used: 500        budget left: 1500       best Accuracy: 80.00%\n[2] 2 removed       3 left  100 iterations  budget used: 1000       budget left: 1000       best Accuracy: 84.00%\n[3] 1 removed       2 left  166 iterations  budget used: 1498       budget left: 502        best Accuracy: 86.14%\n[4] 1 removed       1 left  250 iterations  budget used: 1998       budget left: 2  best Accuracy: 84.80%\nROCAUC: 95.22%\n</code></pre></p> <p>We can now view the best model.</p> <p><pre><code>sh.best_model\n</code></pre> <pre><code>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LogisticRegression (\n    optimizer=Adam (\n      lr=Constant (\n        learning_rate=0.01\n      )\n      beta_1=0.01\n      beta_2=0.999\n      eps=1e-08\n    )\n    loss=Log (\n      weight_pos=1.\n      weight_neg=1.\n    )\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</code></pre></p>"},{"location":"api/model-selection/SuccessiveHalvingClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9</p> </li> </ol>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/","title":"SuccessiveHalvingRegressor","text":"<p>Successive halving algorithm for regression.</p> <p>Successive halving is a method for performing model selection without having to train each model on all the dataset. At certain points in time (called \"rungs\"), the worst performing will be discarded and the best ones will keep competing between each other. The rung values are designed so that at most <code>budget</code> model updates will be performed in total. </p> <p>If you have <code>k</code> combinations of hyperparameters and that your dataset contains <code>n</code> observations, then the maximal budget you can allocate is: </p> \\[\\frac{2kn}{eta}\\] <p>It is recommended that you check this beforehand. This bound can't be checked by the function because the size of the dataset is not known. In fact it is potentially infinite, in which case the algorithm will terminate once all the budget has been spent. </p> <p>If you have a budget of <code>B</code>, and that your dataset contains <code>n</code> observations, then the number of hyperparameter combinations that will spend all the budget and go through all the data is: </p> \\[\\left\\lceil\\left\\lfloor\\frac{B}{2n}\\right\\rfloor \\times eta \\right\\rceil\\]"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>The models to compare.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.Metric</p> <p>Metric used for comparing models with.</p> </li> <li> <p>budget</p> <p>Type \u2192 int</p> <p>Total number of model updates you wish to allocate.</p> </li> <li> <p>eta</p> <p>Default \u2192 <code>2</code></p> <p>Rate of elimination. At every rung, <code>math.ceil(k / eta)</code> models are kept, where <code>k</code> is the number of models that have reached the rung. A higher <code>eta</code> value will focus on less models but will allocate more iterations to the best models.</p> </li> <li> <p>verbose</p> <p>Default \u2192 <code>False</code></p> <p>Whether to display progress or not.</p> </li> <li> <p>print_kwargs</p> <p>Extra keyword arguments are passed to the <code>print</code> function. For instance, this allows providing a <code>file</code> argument, which indicates where to output progress.</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#examples","title":"Examples","text":"<p>As an example, let's use successive halving to tune the optimizer of a linear regression. We'll first define the model.</p> <pre><code>from river import linear_model\nfrom river import preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LinearRegression(intercept_lr=.1)\n)\n</code></pre> <p>Let's now define a grid of parameters which we would like to compare. We'll try different optimizers with various learning rates.</p> <pre><code>from river import optim\nfrom river import utils\n\nmodels = utils.expand_param_grid(model, {\n    'LinearRegression': {\n        'optimizer': [\n            (optim.SGD, {'lr': [.1, .01, .005]}),\n            (optim.Adam, {'beta_1': [.01, .001], 'lr': [.1, .01, .001]}),\n            (optim.Adam, {'beta_1': [.1], 'lr': [.001]}),\n        ]\n    }\n})\n</code></pre> <p>We can check how many models we've created.</p> <p><pre><code>len(models)\n</code></pre> <pre><code>10\n</code></pre></p> <p>We can now pass these models to a <code>SuccessiveHalvingRegressor</code>. We also need to pick a metric to compare the models, and a budget which indicates how many iterations to run before picking the best model and discarding the rest.</p> <pre><code>from river import model_selection\n\nsh = model_selection.SuccessiveHalvingRegressor(\n    models,\n    metric=metrics.MAE(),\n    budget=2000,\n    eta=2,\n    verbose=True\n)\n</code></pre> <p>A <code>SuccessiveHalvingRegressor</code> is also a regressor with a <code>learn_one</code> and a <code>predict_one</code> method. We can therefore evaluate it like any other classifier with <code>evaluate.progressive_val_score</code>.</p> <p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\n\nevaluate.progressive_val_score(\n    dataset=datasets.TrumpApproval(),\n    model=sh,\n    metric=metrics.MAE()\n)\n</code></pre> <pre><code>[1] 5 removed       5 left  50 iterations   budget used: 500        budget left: 1500       best MAE: 4.419643\n[2] 2 removed       3 left  100 iterations  budget used: 1000       budget left: 1000       best MAE: 2.392266\n[3] 1 removed       2 left  166 iterations  budget used: 1498       budget left: 502        best MAE: 1.541383\n[4] 1 removed       1 left  250 iterations  budget used: 1998       budget left: 2  best MAE: 1.112122\nMAE: 0.490688\n</code></pre></p> <p>We can now view the best model.</p> <p><pre><code>sh.best_model\n</code></pre> <pre><code>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=Adam (\n      lr=Constant (\n        learning_rate=0.1\n      )\n      beta_1=0.01\n      beta_2=0.999\n      eps=1e-08\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.1\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</code></pre></p>"},{"location":"api/model-selection/SuccessiveHalvingRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p> <ol> <li> <p>Jamieson, K. and Talwalkar, A., 2016, May. Non-stochastic best arm identification and hyperparameter optimization. In Artificial Intelligence and Statistics (pp. 240-248). \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., Rostamizadeh, A., Gonina, E., Hardt, M., Recht, B. and Talwalkar, A., 2018. Massively parallel hyperparameter tuning. arXiv preprint arXiv:1810.05934. \u21a9</p> </li> <li> <p>Li, L., Jamieson, K., DeSalvo, G., Rostamizadeh, A. and Talwalkar, A., 2017. Hyperband: A novel bandit-based approach to hyperparameter optimization. The Journal of Machine Learning Research, 18(1), pp.6765-6816. \u21a9</p> </li> </ol>"},{"location":"api/model-selection/base/ModelSelectionClassifier/","title":"ModelSelectionClassifier","text":"<p>A model selector for classification.</p>"},{"location":"api/model-selection/base/ModelSelectionClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>Type \u2192 Iterator[base.Estimator]</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.Metric</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/model-selection/base/ModelSelectionRegressor/","title":"ModelSelectionRegressor","text":"<p>A model selector for regression.</p>"},{"location":"api/model-selection/base/ModelSelectionRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>models</p> <p>Type \u2192 Iterator[base.Estimator]</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.Metric</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>best_model</p> <p>The current best model.</p> </li> <li> <p>models</p> </li> </ul>"},{"location":"api/model-selection/base/ModelSelectionRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/multiclass/OneVsOneClassifier/","title":"OneVsOneClassifier","text":"<p>One-vs-One (OvO) multiclass strategy.</p> <p>This strategy consists in fitting one binary classifier for each pair of classes. Because we are in a streaming context, the number of classes isn't known from the start, hence new classifiers are instantiated on the fly. </p> <p>The number of classifiers is <code>k * (k - 1) / 2</code>, where <code>k</code> is the number of classes. However, each call to <code>learn_one</code> only requires training <code>k - 1</code> models. Indeed, only the models that pertain to the given label have to be trained. Meanwhile, making a prediction requires going through each and every model.</p>"},{"location":"api/multiclass/OneVsOneClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>A binary classifier, although a multi-class classifier will work too.</p> </li> </ul>"},{"location":"api/multiclass/OneVsOneClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>classifiers (dict)</p> <p>A mapping between pairs of classes and classifiers. The keys are tuples which contain a pair of classes. Each pair is sorted in lexicographical order.</p> </li> </ul>"},{"location":"api/multiclass/OneVsOneClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import multiclass\nfrom river import preprocessing\n\ndataset = datasets.ImageSegments()\n\nscaler = preprocessing.StandardScaler()\novo = multiclass.OneVsOneClassifier(linear_model.LogisticRegression())\nmodel = scaler | ovo\n\nmetric = metrics.MacroF1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MacroF1: 80.76%\n</code></pre></p>"},{"location":"api/multiclass/OneVsOneClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/multiclass/OneVsRestClassifier/","title":"OneVsRestClassifier","text":"<p>One-vs-the-rest (OvR) multiclass strategy.</p> <p>This strategy consists in fitting one binary classifier per class. Because we are in a streaming context, the number of classes isn't known from the start. Hence, new classifiers are instantiated on the fly. Likewise, the predicted probabilities will only include the classes seen up to a given point in time. </p> <p>Note that this classifier supports mini-batches as well as single instances. </p> <p>The computational complexity for both learning and predicting grows linearly with the number of classes. If you have a very large number of classes, then you might want to consider using an <code>multiclass.OutputCodeClassifier</code> instead.</p>"},{"location":"api/multiclass/OneVsRestClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> <p>A binary classifier, although a multi-class classifier will work too.</p> </li> </ul>"},{"location":"api/multiclass/OneVsRestClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>classifiers (dict)</p> <p>A mapping between classes and classifiers.</p> </li> </ul>"},{"location":"api/multiclass/OneVsRestClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import multiclass\nfrom river import preprocessing\n\ndataset = datasets.ImageSegments()\n\nscaler = preprocessing.StandardScaler()\novr = multiclass.OneVsRestClassifier(linear_model.LogisticRegression())\nmodel = scaler | ovr\n\nmetric = metrics.MacroF1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MacroF1: 77.46%\n</code></pre></p> <p>This estimator also also supports mini-batching.</p> <pre><code>for X in pd.read_csv(dataset.path, chunksize=64):\n    y = X.pop('category')\n    y_pred = model.predict_many(X)\n    model.learn_many(X, y)\n</code></pre>"},{"location":"api/multiclass/OneVsRestClassifier/#methods","title":"Methods","text":"learn_many learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_many predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_many predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/multiclass/OutputCodeClassifier/","title":"OutputCodeClassifier","text":"<p>Output-code multiclass strategy.</p> <p>This also referred to as \"error-correcting output codes\". </p> <p>This class allows to learn a multi-class classification problem with a binary classifier. Each class is converted to a code of 0s and 1s. The length of the code is called  the code size. A copy of the classifier made for code. The codes associated with the classes are stored in a code book. </p> <p>When a new sample arrives, the label's code is retrieved from the code book. Then, each classifier is trained on the relevant part of code, which is either a 0 or a 1. </p> <p>For predicting, each classifier outputs a probability. These are then compared to each code in the code book, and the label which is the \"closest\" is chosen as the most likely class. Closeness is determined in terms of Manhattan distance. </p> <p>One specificity of online learning is that we don't how many classes there are initially. Therefore, a random procedure generates random codes on the fly whenever a previously unseed label appears.</p>"},{"location":"api/multiclass/OutputCodeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>classifier</p> <p>Type \u2192 base.Classifier</p> <p>A binary classifier, although a multi-class classifier will work too.</p> </li> <li> <p>code_size</p> <p>Type \u2192 int</p> <p>The code size, which dictates how many copies of the provided classifiers to train. Must be strictly positive.</p> </li> <li> <p>coding_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>random</code></p> <p>The method used to generate the codes. Can be either 'exact' or 'random'. The 'exact' method generates all possible codes of a given size in memory, and streams them in a random order. The 'random' method generates random codes of a given size on the fly. The 'exact' method necessarily generates different codes for each class, but requires more memory. The 'random' method can generate duplicate codes for different classes, but requires less memory.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>A random seed number that can be set for reproducibility.</p> </li> </ul>"},{"location":"api/multiclass/OutputCodeClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import multiclass\nfrom river import preprocessing\n\ndataset = datasets.ImageSegments()\n\nscaler = preprocessing.StandardScaler()\nooc = multiclass.OutputCodeClassifier(\n    classifier=linear_model.LogisticRegression(),\n    code_size=10,\n    coding_method='random',\n    seed=1\n)\nmodel = scaler | ooc\n\nmetric = metrics.MacroF1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MacroF1: 79.58%\n</code></pre></p>"},{"location":"api/multiclass/OutputCodeClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Dietterich, T.G. and Bakiri, G., 1994. Solving multiclass learning problems via error-correcting output codes. Journal of artificial intelligence research, 2, pp.263-286. \u21a9</p> </li> <li> <p>James, G. and Hastie, T., 1998. The error coding method and PICTs. Journal of Computational and Graphical statistics, 7(3), pp.377-387. \u21a9</p> </li> </ol>"},{"location":"api/multioutput/ClassifierChain/","title":"ClassifierChain","text":"<p>A multi-output model that arranges classifiers into a chain.</p> <p>This will create one model per output. The prediction of the first output will be used as a feature in the second model. The prediction for the second output will be used as a feature for the third model, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.</p>"},{"location":"api/multioutput/ClassifierChain/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>A classifier model used for each label.</p> </li> <li> <p>order</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>A list with the targets order in which to construct the chain. If <code>None</code> then the order will be inferred from the order of the keys in the target.</p> </li> </ul>"},{"location":"api/multioutput/ClassifierChain/#examples","title":"Examples","text":"<p><pre><code>from river import feature_selection\nfrom river import linear_model\nfrom river import metrics\nfrom river import multioutput\nfrom river import preprocessing\nfrom river import stream\nfrom sklearn import datasets\n\ndataset = stream.iter_sklearn_dataset(\n    dataset=datasets.fetch_openml('yeast', version=4, parser='auto', as_frame=False),\n    shuffle=True,\n    seed=42\n)\n\nmodel = feature_selection.VarianceThreshold(threshold=0.01)\nmodel |= preprocessing.StandardScaler()\nmodel |= multioutput.ClassifierChain(\n    model=linear_model.LogisticRegression(),\n    order=list(range(14))\n)\n\nmetric = metrics.multioutput.MicroAverage(metrics.Jaccard())\n\nfor x, y in dataset:\n    # Convert y values to booleans\n    y = {i: yi == 'TRUE' for i, yi in y.items()}\n    y_pred = model.predict_one(x)\n    metric.update(y, y_pred)\n    model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>MicroAverage(Jaccard): 41.81%\n</code></pre></p>"},{"location":"api/multioutput/ClassifierChain/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and the labels <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the labels of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[FeatureName, bool]:     The predicted labels.</p> <p></p> predict_proba_one <p>Predict the probability of each label appearing given dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Multi-Output Chain Models and their Application in Data Streams \u21a9</p> </li> </ol>"},{"location":"api/multioutput/MonteCarloClassifierChain/","title":"MonteCarloClassifierChain","text":"<p>Monte Carlo Sampling Classifier Chains.</p> <p>Probabilistic Classifier Chains using Monte Carlo sampling, as described in <sup>1</sup>. </p> <p>m samples are taken from the posterior distribution. Therefore we need a probabilistic interpretation of the output, and thus, this is a particular variety of ProbabilisticClassifierChain.</p>"},{"location":"api/multioutput/MonteCarloClassifierChain/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> </li> <li> <p>m</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>Number of samples to take from the posterior distribution.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/multioutput/MonteCarloClassifierChain/#examples","title":"Examples","text":"<p><pre><code>from river import feature_selection\nfrom river import linear_model\nfrom river import metrics\nfrom river import multioutput\nfrom river import preprocessing\nfrom river.datasets import synth\n\ndataset = synth.Logical(seed=42, n_tiles=100)\n\nmodel = multioutput.MonteCarloClassifierChain(\n    model=linear_model.LogisticRegression(),\n    m=10,\n    seed=42\n)\n\nmetric = metrics.multioutput.MicroAverage(metrics.Jaccard())\n\nfor x, y in dataset:\n   y_pred = model.predict_one(x)\n   y_pred = {k: y_pred.get(k, 0) for k in y}\n   metric.update(y, y_pred)\n   model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>MicroAverage(Jaccard): 51.79%\n</code></pre></p>"},{"location":"api/multioutput/MonteCarloClassifierChain/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and the labels <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the labels of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[FeatureName, bool]:     The predicted labels.</p> <p></p> predict_proba_one <p>Predict the probability of each label appearing given dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Read, J., Martino, L., &amp; Luengo, D. (2014). Efficient monte carlo   methods for multi-dimensional learning with classifier chains.   Pattern Recognition, 47(3), 1535-1546.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/multioutput/MultiClassEncoder/","title":"MultiClassEncoder","text":"<p>Convert a multi-label task into multiclass.</p> <p>Assigns a class to each unique combination of labels, and proceeds with training the supplied multi-class classifier. </p> <p>The transformation is done by converting the label set, which could be seen as a binary number, into an integer representing a class. At prediction time, the predicted integer is converted back to a binary number which is the predicted label set.</p>"},{"location":"api/multioutput/MultiClassEncoder/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> <p>The classifier used for learning.</p> </li> </ul>"},{"location":"api/multioutput/MultiClassEncoder/#examples","title":"Examples","text":"<p><pre><code>from river import forest\nfrom river import metrics\nfrom river import multioutput\nfrom river.datasets import synth\n\ndataset = synth.Logical(seed=42, n_tiles=100)\n\nmodel = multioutput.MultiClassEncoder(\n    model=forest.ARFClassifier(seed=7)\n)\n\nmetric = metrics.multioutput.MicroAverage(metrics.Jaccard())\n\nfor x, y in dataset:\n   y_pred = model.predict_one(x)\n   y_pred = {k: y_pred.get(k, 0) for k in y}\n   metric.update(y, y_pred)\n   model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>MicroAverage(Jaccard): 95.10%\n</code></pre></p>"},{"location":"api/multioutput/MultiClassEncoder/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and the labels <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>y     \u2014 'dict[FeatureName, bool]' </li> </ul> <p></p> predict_one <p>Predict the labels of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[FeatureName, bool]:     The predicted labels.</p> <p></p> predict_proba_one <p>Predict the probability of each label appearing given dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[FeatureName, dict[bool, float]]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/multioutput/ProbabilisticClassifierChain/","title":"ProbabilisticClassifierChain","text":"<p>Probabilistic Classifier Chains.</p> <p>The Probabilistic Classifier Chains (PCC) <sup>1</sup> is a Bayes-optimal method based on the Classifier Chains (CC). </p> <p>Consider the concept of chaining classifiers as searching a path in a binary tree whose leaf nodes are associated with a label \\(y \\in Y\\). While CC searches only a single path in the aforementioned binary tree, PCC looks at each of the \\(2^l\\) paths, where \\(l\\) is the number of labels. This limits the applicability of the method to data sets with a small to moderate number of labels. The authors recommend no more than about 15 labels for real-world applications.</p>"},{"location":"api/multioutput/ProbabilisticClassifierChain/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Classifier</p> </li> </ul>"},{"location":"api/multioutput/ProbabilisticClassifierChain/#examples","title":"Examples","text":"<p><pre><code>from river import linear_model\nfrom river import metrics\nfrom river import multioutput\nfrom river.datasets import synth\n\ndataset = synth.Logical(seed=42, n_tiles=100)\n\nmodel = multioutput.ProbabilisticClassifierChain(\n    model=linear_model.LogisticRegression()\n)\n\nmetric = metrics.multioutput.MicroAverage(metrics.Jaccard())\n\nfor x, y in dataset:\n   y_pred = model.predict_one(x)\n   y_pred = {k: y_pred.get(k, 0) for k in y}\n   metric.update(y, y_pred)\n   model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>MicroAverage(Jaccard): 51.84%\n</code></pre></p>"},{"location":"api/multioutput/ProbabilisticClassifierChain/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and the labels <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the labels of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[FeatureName, typing.Any]' </li> <li>kwargs     \u2014 'typing.Any' </li> </ul> <p>Returns</p> <p>dict[FeatureName, bool]:     The predicted labels.</p> <p></p> predict_proba_one <p>Predict the probability of each label appearing given dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Cheng, W., H\u00fcllermeier, E., &amp; Dembczynski, K. J. (2010).   Bayes optimal multilabel classification via probabilistic classifier   chains. In Proceedings of the 27th international conference on   machine learning (ICML-10) (pp. 279-286).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/multioutput/RegressorChain/","title":"RegressorChain","text":"<p>A multi-output model that arranges regressors into a chain.</p> <p>This will create one model per output. The prediction of the first output will be used as a feature in the second output. The prediction for the second output will be used as a feature for the third, etc. This \"chain model\" is therefore capable of capturing dependencies between outputs.</p>"},{"location":"api/multioutput/RegressorChain/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Regressor</p> <p>The regression model used to make predictions for each target.</p> </li> <li> <p>order</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>A list with the targets order in which to construct the chain. If <code>None</code> then the order will be inferred from the order of the keys in the target.</p> </li> </ul>"},{"location":"api/multioutput/RegressorChain/#examples","title":"Examples","text":"<p><pre><code>from river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import multioutput\nfrom river import preprocessing\nfrom river import stream\n\nfrom sklearn import datasets\n\ndataset = stream.iter_sklearn_dataset(\n    dataset=datasets.load_linnerud(),\n    shuffle=True,\n    seed=42\n)\n\nmodel = multioutput.RegressorChain(\n    model=(\n        preprocessing.StandardScaler() |\n        linear_model.LinearRegression(intercept_lr=0.3)\n    ),\n    order=[0, 1, 2]\n)\n\nmetric = metrics.multioutput.MicroAverage(metrics.MAE())\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MicroAverage(MAE): 12.733525\n</code></pre></p>"},{"location":"api/multioutput/RegressorChain/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the outputs of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The predictions.</p> <p></p>"},{"location":"api/naive-bayes/BernoulliNB/","title":"BernoulliNB","text":"<p>Bernoulli Naive Bayes.</p> <p>Bernoulli Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.</p>"},{"location":"api/naive-bayes/BernoulliNB/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Default \u2192 <code>1.0</code></p> <p>Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).</p> </li> <li> <p>true_threshold</p> <p>Default \u2192 <code>0.0</code></p> <p>Threshold for binarizing (mapping to booleans) features.</p> </li> </ul>"},{"location":"api/naive-bayes/BernoulliNB/#attributes","title":"Attributes","text":"<ul> <li> <p>class_counts (collections.Counter)</p> <p>Number of times each class has been seen.</p> </li> <li> <p>feature_counts (collections.defaultdict)</p> <p>Total frequencies per feature and class.</p> </li> </ul>"},{"location":"api/naive-bayes/BernoulliNB/#examples","title":"Examples","text":"<p><pre><code>import pandas as pd\nfrom river import compose\nfrom river import feature_extraction\nfrom river import naive_bayes\n\ndocs = [\n    (\"Chinese Beijing Chinese\", \"yes\"),\n    (\"Chinese Chinese Shanghai\", \"yes\"),\n    (\"Chinese Macao\", \"yes\"),\n    (\"Tokyo Japan Chinese\", \"no\")\n]\n\nmodel = compose.Pipeline(\n    (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n    (\"nb\", naive_bayes.BernoulliNB(alpha=1))\n)\n\nfor sentence, label in docs:\n    model.learn_one(sentence, label)\n\nmodel[\"nb\"].p_class(\"yes\")\n</code></pre> <pre><code>0.75\n</code></pre> <pre><code>model[\"nb\"].p_class(\"no\")\n</code></pre> <pre><code>0.25\n</code></pre></p> <p><pre><code>model.predict_proba_one(\"test\")\n</code></pre> <pre><code>{'yes': 0.883..., 'no': 0.116...}\n</code></pre></p> <p><pre><code>model.predict_one(\"test\")\n</code></pre> <pre><code>'yes'\n</code></pre></p> <p>You can train the model and make predictions in mini-batch mode using the class methods <code>learn_many</code> and <code>predict_many</code>.</p> <p><pre><code>df_docs = pd.DataFrame(docs, columns = [\"docs\", \"y\"])\n\nX = pd.Series([\n   \"Chinese Beijing Chinese\",\n   \"Chinese Chinese Shanghai\",\n   \"Chinese Macao\",\n   \"Tokyo Japan Chinese\"\n])\n\ny = pd.Series([\"yes\", \"yes\", \"yes\", \"no\"])\n\nmodel = compose.Pipeline(\n    (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n    (\"nb\", naive_bayes.BernoulliNB(alpha=1))\n)\n\nmodel.learn_many(X, y)\n\nunseen = pd.Series([\"Taiwanese Taipei\", \"Chinese Shanghai\"])\n\nmodel.predict_proba_many(unseen)\n</code></pre> <pre><code>         no       yes\n0  0.116846  0.883154\n1  0.047269  0.952731\n</code></pre></p> <p><pre><code>model.predict_many(unseen)\n</code></pre> <pre><code>0    yes\n1    yes\ndtype: object\n</code></pre></p>"},{"location":"api/naive-bayes/BernoulliNB/#methods","title":"Methods","text":"joint_log_likelihood <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>float:     Mapping between classes and joint log likelihood.</p> <p></p> joint_log_likelihood_many <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     Input samples joint log likelihood.</p> <p></p> learn_many <p>Learn from a batch of count vectors.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> </ul> <p></p> learn_one <p>Updates the model with a single observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> p_class p_class_many p_feature_given_class predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_many <p>Return probabilities using the log-likelihoods in mini-batchs setting.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> <ol> <li> <p>The Bernoulli model \u21a9</p> </li> </ol>"},{"location":"api/naive-bayes/ComplementNB/","title":"ComplementNB","text":"<p>Naive Bayes classifier for multinomial models.</p> <p>Complement Naive Bayes model learns from occurrences between features such as word counts and discrete classes. ComplementNB is suitable for imbalance dataset. The input vector must contain positive values, such as counts or TF-IDF values.</p>"},{"location":"api/naive-bayes/ComplementNB/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Default \u2192 <code>1.0</code></p> <p>Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).</p> </li> </ul>"},{"location":"api/naive-bayes/ComplementNB/#attributes","title":"Attributes","text":"<ul> <li> <p>class_counts (collections.Counter)</p> <p>Number of times each class has been seen.</p> </li> <li> <p>feature_counts (collections.defaultdict)</p> <p>Total frequencies per feature and class.</p> </li> <li> <p>class_totals (collections.Counter)</p> <p>Total frequencies per class.</p> </li> </ul>"},{"location":"api/naive-bayes/ComplementNB/#examples","title":"Examples","text":"<p><pre><code>import pandas as pd\nfrom river import compose\nfrom river import feature_extraction\nfrom river import naive_bayes\n\ndocs = [\n    (\"Chinese Beijing Chinese\", \"yes\"),\n    (\"Chinese Chinese Shanghai\", \"yes\"),\n    (\"Chinese Macao\", \"maybe\"),\n    (\"Tokyo Japan Chinese\", \"no\")\n]\n\nmodel = compose.Pipeline(\n    (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n    (\"nb\", naive_bayes.ComplementNB(alpha=1))\n)\n\nfor sentence, label in docs:\n    model.learn_one(sentence, label)\n\nmodel[\"nb\"].p_class(\"yes\")\n</code></pre> <pre><code>0.5\n</code></pre></p> <p><pre><code>model[\"nb\"].p_class(\"no\")\n</code></pre> <pre><code>0.25\n</code></pre></p> <p><pre><code>model[\"nb\"].p_class(\"maybe\")\n</code></pre> <pre><code>0.25\n</code></pre></p> <p><pre><code>model.predict_proba_one(\"test\")\n</code></pre> <pre><code>{'yes': 0.275, 'maybe': 0.375, 'no': 0.35}\n</code></pre></p> <p><pre><code>model.predict_one(\"test\")\n</code></pre> <pre><code>'maybe'\n</code></pre></p> <p>You can train the model and make predictions in mini-batch mode using the class methods <code>learn_many</code> and <code>predict_many</code>.</p> <p><pre><code>df_docs = pd.DataFrame(docs, columns = [\"docs\", \"y\"])\n\nX = pd.Series([\n   \"Chinese Beijing Chinese\",\n   \"Chinese Chinese Shanghai\",\n   \"Chinese Macao\",\n   \"Tokyo Japan Chinese\"\n])\n\ny = pd.Series([\"yes\", \"yes\", \"maybe\", \"no\"])\n\nmodel = compose.Pipeline(\n    (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n    (\"nb\", naive_bayes.ComplementNB(alpha=1))\n)\n\nmodel.learn_many(X, y)\n\nunseen = pd.Series([\"Taiwanese Taipei\", \"Chinese Shanghai\"])\n\nmodel.predict_proba_many(unseen)\n</code></pre> <pre><code>      maybe        no       yes\n0  0.415129  0.361624  0.223247\n1  0.248619  0.216575  0.534807\n</code></pre></p> <p><pre><code>model.predict_many(unseen)\n</code></pre> <pre><code>0    maybe\n1      yes\ndtype: object\n</code></pre></p>"},{"location":"api/naive-bayes/ComplementNB/#methods","title":"Methods","text":"joint_log_likelihood <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>float:     Mapping between classes and joint log likelihood.</p> <p></p> joint_log_likelihood_many <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     Input samples joint log likelihood.</p> <p></p> learn_many <p>Learn from a batch of count vectors.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> </ul> <p></p> learn_one <p>Updates the model with a single observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> p_class p_class_many predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_many <p>Return probabilities using the log-likelihoods in mini-batchs setting.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> <ol> <li> <p>Rennie, J.D., Shih, L., Teevan, J. and Karger, D.R., 2003. Tackling the poor assumptions of naive bayes text classifiers. In Proceedings of the 20th international conference on machine learning (ICML-03) (pp. 616-623) \u21a9</p> </li> <li> <p>StackExchange discussion \u21a9</p> </li> </ol>"},{"location":"api/naive-bayes/GaussianNB/","title":"GaussianNB","text":"<p>Gaussian Naive Bayes.</p> <p>A Gaussian distribution \\(G_{cf}\\) is maintained for each class \\(c\\) and each feature \\(f\\). Each Gaussian is updated using the amount associated with each feature; the details can be be found in <code>proba.Gaussian</code>. The joint log-likelihood is then obtained by summing the log probabilities of each feature associated with each class.</p>"},{"location":"api/naive-bayes/GaussianNB/#examples","title":"Examples","text":"<p><pre><code>from river import naive_bayes\nfrom river import stream\nimport numpy as np\n\nX = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])\nY = np.array([1, 1, 1, 2, 2, 2])\n\nmodel = naive_bayes.GaussianNB()\n\nfor x, y in stream.iter_array(X, Y):\n    model.learn_one(x, y)\n\nmodel.predict_one({0: -0.8, 1: -1})\n</code></pre> <pre><code>1\n</code></pre></p>"},{"location":"api/naive-bayes/GaussianNB/#methods","title":"Methods","text":"joint_log_likelihood joint_log_likelihood_many learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> p_class predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p>"},{"location":"api/naive-bayes/MultinomialNB/","title":"MultinomialNB","text":"<p>Naive Bayes classifier for multinomial models.</p> <p>Multinomial Naive Bayes model learns from occurrences between features such as word counts and discrete classes. The input vector must contain positive values, such as counts or TF-IDF values.</p>"},{"location":"api/naive-bayes/MultinomialNB/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Default \u2192 <code>1.0</code></p> <p>Additive (Laplace/Lidstone) smoothing parameter (use 0 for no smoothing).</p> </li> </ul>"},{"location":"api/naive-bayes/MultinomialNB/#attributes","title":"Attributes","text":"<ul> <li> <p>class_counts (collections.Counter)</p> <p>Number of times each class has been seen.</p> </li> <li> <p>feature_counts (collections.defaultdict)</p> <p>Total frequencies per feature and class.</p> </li> <li> <p>class_totals (collections.Counter)</p> <p>Total frequencies per class.</p> </li> </ul>"},{"location":"api/naive-bayes/MultinomialNB/#examples","title":"Examples","text":"<p><pre><code>import pandas as pd\nfrom river import compose\nfrom river import feature_extraction\nfrom river import naive_bayes\n\ndocs = [\n    (\"Chinese Beijing Chinese\", \"yes\"),\n    (\"Chinese Chinese Shanghai\", \"yes\"),\n    (\"Chinese Macao\", \"maybe\"),\n    (\"Tokyo Japan Chinese\", \"no\")\n]\n\nmodel = compose.Pipeline(\n    (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n    (\"nb\", naive_bayes.MultinomialNB(alpha=1))\n)\n\nfor sentence, label in docs:\n    model.learn_one(sentence, label)\n\nmodel[\"nb\"].p_class(\"yes\")\n</code></pre> <pre><code>0.5\n</code></pre></p> <p><pre><code>model[\"nb\"].p_class(\"no\")\n</code></pre> <pre><code>0.25\n</code></pre></p> <p><pre><code>model[\"nb\"].p_class(\"maybe\")\n</code></pre> <pre><code>0.25\n</code></pre></p> <p><pre><code>model.predict_proba_one(\"test\")\n</code></pre> <pre><code>{'yes': 0.413, 'maybe': 0.310, 'no': 0.275}\n</code></pre></p> <p><pre><code>model.predict_one(\"test\")\n</code></pre> <pre><code>'yes'\n</code></pre></p> <p>You can train the model and make predictions in mini-batch mode using the class methods <code>learn_many</code> and <code>predict_many</code>.</p> <p><pre><code>df_docs = pd.DataFrame(docs, columns = [\"docs\", \"y\"])\n\nX = pd.Series([\n   \"Chinese Beijing Chinese\",\n   \"Chinese Chinese Shanghai\",\n   \"Chinese Macao\",\n   \"Tokyo Japan Chinese\"\n])\n\ny = pd.Series([\"yes\", \"yes\", \"maybe\", \"no\"])\n\nmodel = compose.Pipeline(\n    (\"tokenize\", feature_extraction.BagOfWords(lowercase=False)),\n    (\"nb\", naive_bayes.MultinomialNB(alpha=1))\n)\n\nmodel.learn_many(X, y)\n\nunseen = pd.Series([\"Taiwanese Taipei\", \"Chinese Shanghai\"])\n\nmodel.predict_proba_many(unseen)\n</code></pre> <pre><code>      maybe        no       yes\n0  0.373272  0.294931  0.331797\n1  0.160396  0.126733  0.712871\n</code></pre></p> <p><pre><code>model.predict_many(unseen)\n</code></pre> <pre><code>0    maybe\n1      yes\ndtype: object\n</code></pre></p>"},{"location":"api/naive-bayes/MultinomialNB/#methods","title":"Methods","text":"joint_log_likelihood <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>float:     Mapping between classes and joint log likelihood.</p> <p></p> joint_log_likelihood_many <p>Computes the joint log likelihood of input features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     Input samples joint log likelihood.</p> <p></p> learn_many <p>Learn from a batch of count vectors.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.Series' </li> </ul> <p></p> learn_one <p>Updates the model with a single observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> p_class p_class_many p_feature_given_class predict_many <p>Predict the outcome for each given sample.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.Series:     The predicted labels.</p> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_many <p>Return probabilities using the log-likelihoods in mini-batchs setting.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> predict_proba_one <p>Return probabilities using the log-likelihoods.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> <ol> <li> <p>Naive Bayes text classification \u21a9</p> </li> </ol>"},{"location":"api/neighbors/KNNClassifier/","title":"KNNClassifier","text":"<p>K-Nearest Neighbors (KNN) for classification.</p> <p>Samples are stored using a first-in, first-out strategy. The strategy to perform search queries in the data buffer is defined by the <code>engine</code> parameter.</p>"},{"location":"api/neighbors/KNNClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>n_neighbors</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The number of nearest neighbors to search for.</p> </li> <li> <p>engine</p> <p>Type \u2192 BaseNN | None</p> <p>Default \u2192 <code>None</code></p> <p>The search engine used to store the instances and perform search queries. Depending on the choose engine, search will be exact or approximate. Please, consult the documentation of each available search engine for more details on its usage. By default, use the <code>SWINN</code> search engine for approximate search queries.</p> </li> <li> <p>weighted</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>Weight the contribution of each neighbor by its inverse distance.</p> </li> <li> <p>cleanup_every</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>This determines at which rate old classes are cleaned up. Classes that have been seen in the past but that are not present in the current window are dropped. Classes are never dropped when this is set to 0.</p> </li> <li> <p>softmax</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to use softmax normalization to normalize the neighbors contributions. Votes are divided by the total number of votes if this is <code>False</code>.</p> </li> </ul>"},{"location":"api/neighbors/KNNClassifier/#examples","title":"Examples","text":"<pre><code>import functools\nfrom river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import neighbors\nfrom river import preprocessing\nfrom river import utils\n\ndataset = datasets.Phishing()\n</code></pre> <p>To select a custom distance metric which takes one or several parameter, you can wrap your chosen distance using <code>functools.partial</code>:</p> <p><pre><code>l1_dist = functools.partial(utils.math.minkowski_distance, p=1)\n\nmodel = (\n    preprocessing.StandardScaler() |\n    neighbors.KNNClassifier(\n        engine=neighbors.SWINN(\n            dist_func=l1_dist,\n            seed=42\n        )\n    )\n)\n\nevaluate.progressive_val_score(dataset, model, metrics.Accuracy())\n</code></pre> <pre><code>Accuracy: 89.59%\n</code></pre></p>"},{"location":"api/neighbors/KNNClassifier/#methods","title":"Methods","text":"clean_up_classes <p>Clean up classes added to the window.</p> <p>Classes that are added (and removed) from the window may no longer be valid. This method cleans up the window and and ensures only known classes are added, and we do not consider \"None\" a class. It is called every <code>cleanup_every</code> step, or can be called manually.</p> <p></p> learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p>"},{"location":"api/neighbors/KNNClassifier/#notes","title":"Notes","text":"<p>Note that since the window is moving and we keep track of all classes that are added at some point, a class might be returned in a result (with a value of 0) if it is no longer in the window. You can call model.clean_up_classes(), or set <code>cleanup_every</code> to a non-zero value.</p>"},{"location":"api/neighbors/KNNRegressor/","title":"KNNRegressor","text":"<p>K-Nearest Neighbors regressor.</p> <p>Samples are stored using a first-in, first-out strategy. The strategy to perform search queries in the data buffer is defined by the <code>engine</code> parameter. Predictions are obtained by aggregating the values of the closest n_neighbors stored samples with respect to a query sample.</p>"},{"location":"api/neighbors/KNNRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>n_neighbors</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The number of nearest neighbors to search for.</p> </li> <li> <p>engine</p> <p>Type \u2192 BaseNN | None</p> <p>Default \u2192 <code>None</code></p> <p>The search engine used to store the instances and perform search queries. Depending on the choose engine, search will be exact or approximate. Please, consult the documentation of each available search engine for more details on its usage. By default, use the <code>SWINN</code> search engine for approximate search queries.</p> </li> <li> <p>aggregation_method</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>mean</code></p> <p>The method to aggregate the target values of neighbors.     | 'mean'     | 'median'     | 'weighted_mean'</p> </li> </ul>"},{"location":"api/neighbors/KNNRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import neighbors\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\n\nmodel = neighbors.KNNRegressor()\nevaluate.progressive_val_score(dataset, model, metrics.RMSE())\n</code></pre> <pre><code>RMSE: 1.427743\n</code></pre></p>"},{"location":"api/neighbors/KNNRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/neighbors/LazySearch/","title":"LazySearch","text":"<p>Exact nearest neighbors using a lazy search estrategy.</p>"},{"location":"api/neighbors/LazySearch/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>50</code></p> <p>Size of the sliding window use to search neighbors with.</p> </li> <li> <p>min_distance_keep</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>The minimum distance (similarity) to consider adding a point to the window. E.g., a value of 0.0 will add even exact duplicates.</p> </li> <li> <p>dist_func</p> <p>Type \u2192 DistanceFunc | FunctionWrapper | None</p> <p>Default \u2192 <code>None</code></p> <p>A distance function which accepts two input items to compare. If not set, use the Minkowski distance with <code>p=2</code>.</p> </li> </ul>"},{"location":"api/neighbors/LazySearch/#methods","title":"Methods","text":"append <p>Add a point to the window, optionally with extra metadata.</p> <p>Parameters</p> <ul> <li>item     \u2014 'typing.Any' </li> <li>extra     \u2014 'typing.Any | None'     \u2014 defaults to <code>None</code> </li> <li>kwargs </li> </ul> <p></p> search <p>Find the <code>n_neighbors</code> closest points to <code>item</code>, along with their distances.</p> <p>Parameters</p> <ul> <li>item     \u2014 'typing.Any' </li> <li>n_neighbors     \u2014 'int' </li> <li>kwargs </li> </ul> <p></p> update <p>Update the window with a new point, only added if &gt; min distance.</p> <p>If min distance is 0, we do not need to do the calculation. The item (and extra metadata) will not be added to the window if it is too close to an existing point.</p> <p>Parameters</p> <ul> <li>item     \u2014 'typing.Any' </li> <li>n_neighbors     \u2014 'int'     \u2014 defaults to <code>1</code> </li> <li>extra     \u2014 'typing.Any | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>A boolean (true/false) to indicate if the point was added.</p> <p></p>"},{"location":"api/neighbors/LazySearch/#notes","title":"Notes","text":"<p>Updates are by default stored by the FIFO (first in first out) method, which means that when the size limit is reached, old samples are dumped to give room for new samples. This is circular, meaning that older points are dumped first. This also gives the implementation a temporal aspect, because older samples are replaced with newer ones.</p> <p>The parameter <code>min_dinstance_keep</code> controls the addition of new items to the window - items that are far enough away (&gt; min_distance_keep) are added to the window. Thus a value of 0 indicates that we add all points, and increasing from 0 makes it less likely we will keep a new item.</p>"},{"location":"api/neighbors/SWINN/","title":"SWINN","text":"<p>Sliding WIndow-based Nearest Neighbor (SWINN) search using Graphs.</p> <p>Extends the NNDescent algorithm<sup>1</sup> to handle vertex addition and removal in a FIFO data ingestion policy. SWINN builds and keeps a directed graph where edges connect the nearest neighbors. Any distance metric can be used to build the graph. By using a directed graph, the user must set the desired number of neighbors. More neighbors imply more accurate search queries at the cost of increased running time and memory usage. Note that although the number of directed neighbors is limited by the user, there is no direct control on the number of reverse neighbors, i.e., the number of vertices that have an edge to a given vertex. </p> <p>The basic idea of SWINN and NNDescent is that \"the neighbor of my neighbors might as well be my neighbor\". Hence, the connections are constantly revisited to improve the graph structure. The algorithm for creating and maintaining the search graph can be described in general lines as follows: </p> <ul> <li> <p>Start with a random neighborhood graph; </p> </li> <li> <p>For each node in the search graph: refine the current neighborhood by checking if there are better neighborhood options among the neighbors of the current neighbors; </p> </li> <li> <p>If the total number of neighborhood changes is smaller than a given stopping criterion, then stop. </p> </li> </ul> <p>SWINN adds strategies to remove vertices from the search graph and pruning redundant edges. SWINN is more efficient when the selected <code>maxlen</code> is greater than 500. For small sized data windows, using the lazy/exhaustive search, i.e., <code>neighbors.LazySearch</code> might be a better idea.</p>"},{"location":"api/neighbors/SWINN/#parameters","title":"Parameters","text":"<ul> <li> <p>graph_k</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>20</code></p> <p>The maximum number of direct nearest neighbors each node has.</p> </li> <li> <p>dist_func</p> <p>Type \u2192 DistanceFunc | FunctionWrapper | None</p> <p>Default \u2192 <code>None</code></p> <p>The distance function used to compare two items. If not set, use the Minkowski distance with <code>p=2</code>.</p> </li> <li> <p>maxlen</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000</code></p> <p>The maximum size of the data buffer.</p> </li> <li> <p>warm_up</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>500</code></p> <p>How many data instances to observe before starting the search graph.</p> </li> <li> <p>max_candidates</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum number of vertices to consider when performing local neighborhood joins. If not set SWINN will use <code>min(50, max(50, self.graph_k))</code>.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0001</code></p> <p>Early stop parameter for the neighborhood refinement procedure. NNDescent will stop running if the maximum number of iterations is reached or the number of edge changes after an iteration is smaller than or equal to <code>delta * graph_k * n_nodes</code>. In the last expression, <code>n_nodes</code> refers to the number of graph nodes involved in the (local) neighborhood refinement.</p> </li> <li> <p>prune_prob</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>The probability of removing redundant edges. Must be between <code>0</code> and <code>1</code>. If set to zero, no edge will be pruned. When set to one, every potentially redundant edge will be dropped.</p> </li> <li> <p>n_iters</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The maximum number of NNDescent iterations to perform to refine the search index.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/neighbors/SWINN/#methods","title":"Methods","text":"append <p>Add a new item to the search index.</p> <p>Data is stored using the FIFO strategy. Both the data buffer and the search graph are updated. The addition of a new item will trigger the removal of the oldest item, if the maximum size was reached. All edges of the removed node are also dropped and safety procedures are applied to ensure its neighbors keep accessible. The addition of a new item also trigger local neighborhood refinement procedures, to ensure the search index is effective and the node degree constraints are met.</p> <p>Parameters</p> <ul> <li>item     \u2014 'typing.Any' </li> <li>kwargs </li> </ul> <p></p> connectivity <p>Get a list with the size of each connected component in the search graph.</p> <p>This metric provides an overview of reachability in the search index by using Kruskal's algorithm to build a forest of connected components.  We want our search index to have a single connected component, i.e., the case where we get a list containing a single number which is equal to <code>maxlen</code>. If that is not the case, not every node in the search graph can be reached from any given starting point. You may want to try increasing <code>graph_k</code> to improve connectivity. However, keep in mind the following aspects: 1) computing this metric is a costly operation (\\(O(E\\log V)\\)), where \\(E\\) and \\(V\\) are, respectively, the number of edges and vertices in the search graph; 2) often, connectivity comes at the price of increased computational costs. Tweaking the <code>sample_rate</code> might help in such situations. The best possible scenario is to decrease the value of <code>graph_k</code> while keeping a single connected component.</p> <p>Returns</p> <p>list[int]:     A list of the number of elements in each connected component of the graph.</p> <p></p> search <p>Search the underlying nearest neighbor graph given a query item.</p> <p>In case not enough samples were observed, i.e., the number of stored samples is smaller than <code>warm_up</code>, then the search switches to a brute force strategy.</p> <p>Parameters</p> <ul> <li>item     \u2014 'typing.Any' </li> <li>n_neighbors     \u2014 'int' </li> <li>epsilon     \u2014 'float'     \u2014 defaults to <code>0.1</code> </li> <li>kwargs </li> </ul> <p>Returns</p> <p>tuple[list, list]:     neighbors, dists</p> <p></p>"},{"location":"api/neighbors/SWINN/#notes","title":"Notes","text":"<p>There is an accuracy/speed trade-off between <code>graph_k</code> and <code>sample_rate</code>. To ensure a single connected component, and thus an effective search index, one can increase <code>graph_k</code>. The <code>connectivity</code> method is a helper to determine whether the search index has a single connected component. However, search accuracy might come at the cost of increased memory usage and slow processing. To alleviate that, one can rely on decreasing the <code>sample_rate</code> to avoid exploring all the undirected edges of a node during search queries and local graph refinements. Moreover, the edge pruning procedures also help decreasing the computational costs. Note that, anything that limits the number of explored neighbors or prunes edges might have a negative impact on search accuracy.</p> <ol> <li> <p>Dong, W., Moses, C., &amp; Li, K. (2011, March). Efficient k-nearest neighbor graph construction for generic similarity measures. In Proceedings of the 20th international conference on World wide web (pp. 577-586).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/neural-net/MLPRegressor/","title":"MLPRegressor","text":"<p>Multi-layer Perceptron for regression.</p> <p>This model is still work in progress. Here are some features that still need implementing: </p> <ul> <li> <p><code>learn_one</code> and <code>predict_one</code> just cast the input <code>dict</code> to a single row dataframe and then</p> <p>call <code>learn_many</code> and <code>predict_many</code> respectively. This is very inefficient. - Not all of the optimizers in the <code>optim</code> module can be used as they are not all vectorised.</p> </li> <li> <p>Emerging and disappearing features are not supported. Each instance/batch has to have the</p> <p>same features. - The gradient haven't been numerically checked.</p> </li> </ul>"},{"location":"api/neural-net/MLPRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>hidden_dims</p> <p>The dimensions of the hidden layers. For example, specifying <code>(10, 20)</code> means that there are two hidden layers with 10 and 20 neurons, respectively. Note that the number of layers the network contains is equal to the number of hidden layers plus two (to account for the input and output layers).</p> </li> <li> <p>activations</p> <p>The activation functions to use at each layer, including the input and output layers. Therefore you need to specify three activation if you specify one hidden layer.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.Loss | None</p> <p>Default \u2192 <code>None</code></p> <p>Loss function. Defaults to <code>optim.losses.Squared</code>.</p> </li> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>Optimizer. Defaults to <code>optim.SGD</code> with the learning rate set to <code>0.01</code>.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/neural-net/MLPRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>n_layers</p> <p>Return the number of layers in the network.  The number of layers is equal to the number of hidden layers plus 2. The 2 accounts for the input layer and the output layer.</p> </li> </ul>"},{"location":"api/neural-net/MLPRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import neural_net as nn\nfrom river import optim\nfrom river import preprocessing as pp\nfrom river import metrics\n\nmodel = (\n    pp.StandardScaler() |\n    nn.MLPRegressor(\n        hidden_dims=(5,),\n        activations=(\n            nn.activations.ReLU,\n            nn.activations.ReLU,\n            nn.activations.Identity\n        ),\n        optimizer=optim.SGD(1e-3),\n        seed=42\n    )\n)\n\ndataset = datasets.TrumpApproval()\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 1.580578\n</code></pre></p> <p>You can also use this to process mini-batches of data.</p> <p><pre><code>model = (\n    pp.StandardScaler() |\n    nn.MLPRegressor(\n        hidden_dims=(10,),\n        activations=(\n            nn.activations.ReLU,\n            nn.activations.ReLU,\n            nn.activations.ReLU\n        ),\n        optimizer=optim.SGD(1e-4),\n        seed=42\n    )\n)\n\ndataset = datasets.TrumpApproval()\nbatch_size = 32\n\nfor epoch in range(10):\n    for xb in pd.read_csv(dataset.path, chunksize=batch_size):\n        yb = xb.pop('five_thirty_eight')\n        y_pred = model.predict_many(xb)\n        model.learn_many(xb, yb)\n\nmodel.predict_many(xb)\n</code></pre> <pre><code>      five_thirty_eight\n992           39.405231\n993           46.447481\n994           42.121865\n995           40.251148\n996           40.836378\n997           40.893153\n998           40.949927\n999           48.416504\n1000          42.077830\n</code></pre></p>"},{"location":"api/neural-net/MLPRegressor/#methods","title":"Methods","text":"call <p>Make predictions.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> learn_many <p>Train the network.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 'pd.DataFrame' </li> </ul> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> </ul> <p></p> predict_many predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/neural-net/activations/Identity/","title":"Identity","text":"<p>Identity activation function.</p>"},{"location":"api/neural-net/activations/Identity/#methods","title":"Methods","text":"apply <p>Apply the activation function to a layer output z.</p> <ul> <li>z </li> </ul> <p></p> gradient <p>Return the gradient with respect to a layer output z.</p> <ul> <li>z </li> </ul> <p></p>"},{"location":"api/neural-net/activations/ReLU/","title":"ReLU","text":"<p>Rectified Linear Unit (ReLU) activation function.</p>"},{"location":"api/neural-net/activations/ReLU/#methods","title":"Methods","text":"apply <p>Apply the activation function to a layer output z.</p> <ul> <li>z </li> </ul> <p></p> gradient <p>Return the gradient with respect to a layer output z.</p> <ul> <li>z </li> </ul> <p></p>"},{"location":"api/neural-net/activations/Sigmoid/","title":"Sigmoid","text":"<p>Sigmoid activation function.</p>"},{"location":"api/neural-net/activations/Sigmoid/#methods","title":"Methods","text":"apply <p>Apply the activation function to a layer output z.</p> <ul> <li>z </li> </ul> <p></p> gradient <p>Return the gradient with respect to a layer output z.</p> <ul> <li>z </li> </ul> <p></p>"},{"location":"api/optim/AMSGrad/","title":"AMSGrad","text":"<p>AMSGrad optimizer.</p>"},{"location":"api/optim/AMSGrad/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Type \u2192 int | float | optim.base.Scheduler</p> <p>Default \u2192 <code>0.1</code></p> <p>The learning rate.</p> </li> <li> <p>beta_1</p> <p>Default \u2192 <code>0.9</code></p> </li> <li> <p>beta_2</p> <p>Default \u2192 <code>0.999</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> <li> <p>correct_bias</p> <p>Default \u2192 <code>True</code></p> </li> </ul>"},{"location":"api/optim/AMSGrad/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>v (collections.defaultdict)</p> </li> <li> <p>v_hat (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AMSGrad/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.AMSGrad()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 86.60%\n</code></pre></p>"},{"location":"api/optim/AMSGrad/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Reddi, S.J., Kale, S. and Kumar, S., 2019. On the convergence of adam and beyond. arXiv preprint arXiv:1904.09237 \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaBound/","title":"AdaBound","text":"<p>AdaBound optimizer.</p>"},{"location":"api/optim/AdaBound/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.001</code></p> <p>The learning rate.</p> </li> <li> <p>beta_1</p> <p>Default \u2192 <code>0.9</code></p> </li> <li> <p>beta_2</p> <p>Default \u2192 <code>0.999</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> <li> <p>gamma</p> <p>Default \u2192 <code>0.001</code></p> </li> <li> <p>final_lr</p> <p>Default \u2192 <code>0.1</code></p> </li> </ul>"},{"location":"api/optim/AdaBound/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>s (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AdaBound/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.AdaBound()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 88.06%\n</code></pre></p>"},{"location":"api/optim/AdaBound/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Luo, L., Xiong, Y., Liu, Y. and Sun, X., 2019. Adaptive gradient methods with dynamic bound of learning rate. arXiv preprint arXiv:1902.09843 \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaDelta/","title":"AdaDelta","text":"<p>AdaDelta optimizer.</p>"},{"location":"api/optim/AdaDelta/#parameters","title":"Parameters","text":"<ul> <li> <p>rho</p> <p>Default \u2192 <code>0.95</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/AdaDelta/#attributes","title":"Attributes","text":"<ul> <li> <p>g2 (collections.defaultdict)</p> </li> <li> <p>s2 (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AdaDelta/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.AdaDelta()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 80.56%\n</code></pre></p>"},{"location":"api/optim/AdaDelta/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Zeiler, M.D., 2012. Adadelta: an adaptive learning rate method. arXiv preprint arXiv:1212.5701. \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaGrad/","title":"AdaGrad","text":"<p>AdaGrad optimizer.</p>"},{"location":"api/optim/AdaGrad/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/AdaGrad/#attributes","title":"Attributes","text":"<ul> <li>g2 (collections.defaultdict)</li> </ul>"},{"location":"api/optim/AdaGrad/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.AdaGrad()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 88.01%\n</code></pre></p>"},{"location":"api/optim/AdaGrad/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Duchi, J., Hazan, E. and Singer, Y., 2011. Adaptive subgradient methods for online learning and stochastic optimization. Journal of machine learning research, 12(Jul), pp.2121-2159. \u21a9</p> </li> </ol>"},{"location":"api/optim/AdaMax/","title":"AdaMax","text":"<p>AdaMax optimizer.</p>"},{"location":"api/optim/AdaMax/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>beta_1</p> <p>Default \u2192 <code>0.9</code></p> </li> <li> <p>beta_2</p> <p>Default \u2192 <code>0.999</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/AdaMax/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>v (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/AdaMax/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.AdaMax()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.61%\n</code></pre></p>"},{"location":"api/optim/AdaMax/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9</p> </li> <li> <p>Ruder, S., 2016. An overview of gradient descent optimization algorithms. arXiv preprint arXiv:1609.04747. \u21a9</p> </li> </ol>"},{"location":"api/optim/Adam/","title":"Adam","text":"<p>Adam optimizer.</p>"},{"location":"api/optim/Adam/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>beta_1</p> <p>Default \u2192 <code>0.9</code></p> </li> <li> <p>beta_2</p> <p>Default \u2192 <code>0.999</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/Adam/#attributes","title":"Attributes","text":"<ul> <li> <p>m (collections.defaultdict)</p> </li> <li> <p>v (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/Adam/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.Adam()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 86.52%\n</code></pre></p>"},{"location":"api/optim/Adam/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Kingma, D.P. and Ba, J., 2014. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980. \u21a9</p> </li> </ol>"},{"location":"api/optim/Averager/","title":"Averager","text":"<p>Averaged stochastic gradient descent.</p> <p>This is a wrapper that can be applied to any stochastic gradient descent optimiser. Note that this implementation differs than what may be found elsewhere. Essentially, the average of the weights is usually only used at the end of the optimisation, once all the data has been seen. However, in this implementation the optimiser returns the current averaged weights.</p>"},{"location":"api/optim/Averager/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer</p> <p>An optimizer for which the produced weights will be averaged.</p> </li> <li> <p>start</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Indicates the number of iterations to wait before starting the average. Essentially, nothing happens differently before the number of iterations reaches this value.</p> </li> </ul>"},{"location":"api/optim/Averager/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/Averager/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.Averager(optim.SGD(0.01), 100)\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.97%\n</code></pre></p>"},{"location":"api/optim/Averager/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Bottou, L., 2010. Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT'2010 (pp. 177-186). Physica-Verlag HD. \u21a9</p> </li> <li> <p>Stochastic Algorithms for One-Pass Learning slides by L\u00e9on Bottou \u21a9</p> </li> <li> <p>Xu, W., 2011. Towards optimal one pass large scale learning with averaged stochastic gradient descent. arXiv preprint arXiv:1107.2490. \u21a9</p> </li> </ol>"},{"location":"api/optim/FTRLProximal/","title":"FTRLProximal","text":"<p>FTRL-Proximal optimizer.</p>"},{"location":"api/optim/FTRLProximal/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Default \u2192 <code>0.05</code></p> </li> <li> <p>beta</p> <p>Default \u2192 <code>1.0</code></p> </li> <li> <p>l1</p> <p>Default \u2192 <code>0.0</code></p> </li> <li> <p>l2</p> <p>Default \u2192 <code>1.0</code></p> </li> </ul>"},{"location":"api/optim/FTRLProximal/#attributes","title":"Attributes","text":"<ul> <li> <p>z (collections.defaultdict)</p> </li> <li> <p>n (collections.defaultdict)</p> </li> </ul>"},{"location":"api/optim/FTRLProximal/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.FTRLProximal()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.56%\n</code></pre></p>"},{"location":"api/optim/FTRLProximal/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>McMahan, H.B., Holt, G., Sculley, D., Young, M., Ebner, D., Grady, J., Nie, L., Phillips, T., Davydov, E., Golovin, D. and Chikkerur, S., 2013, August. Ad click prediction: a view from the trenches. In Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 1222-1230) \u21a9</p> </li> <li> <p>Tensorflow's <code>FtrlOptimizer</code> \u21a9</p> </li> </ol>"},{"location":"api/optim/Momentum/","title":"Momentum","text":"<p>Momentum optimizer.</p>"},{"location":"api/optim/Momentum/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>rho</p> <p>Default \u2192 <code>0.9</code></p> </li> </ul>"},{"location":"api/optim/Momentum/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/Momentum/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.Momentum()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 84.09%\n</code></pre></p>"},{"location":"api/optim/Momentum/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p>"},{"location":"api/optim/Nadam/","title":"Nadam","text":"<p>Nadam optimizer.</p>"},{"location":"api/optim/Nadam/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>beta_1</p> <p>Default \u2192 <code>0.9</code></p> </li> <li> <p>beta_2</p> <p>Default \u2192 <code>0.999</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/Nadam/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/Nadam/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.Nadam()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 86.60%\n</code></pre></p>"},{"location":"api/optim/Nadam/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Nadam: A combination of adam and nesterov \u21a9</p> </li> </ol>"},{"location":"api/optim/NesterovMomentum/","title":"NesterovMomentum","text":"<p>Nesterov Momentum optimizer.</p>"},{"location":"api/optim/NesterovMomentum/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>rho</p> <p>Default \u2192 <code>0.9</code></p> </li> </ul>"},{"location":"api/optim/NesterovMomentum/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/NesterovMomentum/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.NesterovMomentum()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 84.22%\n</code></pre></p>"},{"location":"api/optim/NesterovMomentum/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p>"},{"location":"api/optim/RMSProp/","title":"RMSProp","text":"<p>RMSProp optimizer.</p>"},{"location":"api/optim/RMSProp/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.1</code></p> </li> <li> <p>rho</p> <p>Default \u2192 <code>0.9</code></p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> </li> </ul>"},{"location":"api/optim/RMSProp/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/RMSProp/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.RMSProp()\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.24%\n</code></pre></p>"},{"location":"api/optim/RMSProp/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Divide the gradient by a running average of itsrecent magnitude \u21a9</p> </li> </ol>"},{"location":"api/optim/SGD/","title":"SGD","text":"<p>Plain stochastic gradient descent.</p>"},{"location":"api/optim/SGD/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Default \u2192 <code>0.01</code></p> </li> </ul>"},{"location":"api/optim/SGD/#attributes","title":"Attributes","text":"<ul> <li>learning_rate</li> </ul>"},{"location":"api/optim/SGD/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\n\ndataset = datasets.Phishing()\noptimizer = optim.SGD(0.1)\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(optimizer)\n)\nmetric = metrics.F1()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>F1: 87.85%\n</code></pre></p>"},{"location":"api/optim/SGD/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p> <ol> <li> <p>Robbins, H. and Monro, S., 1951. A stochastic approximation method. The annals of mathematical statistics, pp.400-407 \u21a9</p> </li> </ol>"},{"location":"api/optim/base/Initializer/","title":"Initializer","text":"<p>An initializer is used to set initial weights in a model.</p>"},{"location":"api/optim/base/Initializer/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2014 defaults to <code>1</code> </li> </ul> <p></p>"},{"location":"api/optim/base/Loss/","title":"Loss","text":"<p>Base class for all loss functions.</p>"},{"location":"api/optim/base/Loss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/base/Optimizer/","title":"Optimizer","text":"<p>Optimizer interface.</p> <p>Every optimizer inherits from this base interface.</p>"},{"location":"api/optim/base/Optimizer/#parameters","title":"Parameters","text":"<ul> <li> <p>lr</p> <p>Type \u2192 int | float | Scheduler</p> </li> </ul>"},{"location":"api/optim/base/Optimizer/#attributes","title":"Attributes","text":"<ul> <li> <p>learning_rate (float)</p> <p>Returns the current learning rate value.</p> </li> </ul>"},{"location":"api/optim/base/Optimizer/#methods","title":"Methods","text":"look_ahead <p>Updates a weight vector before a prediction is made.</p> <p>Parameters:     w (dict): A dictionary of weight parameters. The weights are modified in-place.  Returns:     The updated weights.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict' </li> </ul> <p></p> step <p>Updates a weight vector given a gradient.</p> <p>Parameters</p> <ul> <li>w     \u2014 'dict | VectorLike' </li> <li>g     \u2014 'dict | VectorLike' </li> </ul> <p>Returns</p> <p>dict | VectorLike:     The updated weights.</p> <p></p>"},{"location":"api/optim/base/Scheduler/","title":"Scheduler","text":"<p>Can be used to program the learning rate schedule of an <code>optim.base.Optimizer</code>.</p>"},{"location":"api/optim/base/Scheduler/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/optim/initializers/Constant/","title":"Constant","text":"<p>Constant initializer which always returns the same value.</p>"},{"location":"api/optim/initializers/Constant/#parameters","title":"Parameters","text":"<ul> <li> <p>value</p> <p>Type \u2192 float</p> </li> </ul>"},{"location":"api/optim/initializers/Constant/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\ninit = optim.initializers.Constant(value=3.14)\n\ninit(shape=1)\n</code></pre> <pre><code>3.14\n</code></pre></p> <p><pre><code>init(shape=2)\n</code></pre> <pre><code>array([3.14, 3.14])\n</code></pre></p>"},{"location":"api/optim/initializers/Constant/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2014 defaults to <code>1</code> </li> </ul> <p></p>"},{"location":"api/optim/initializers/Normal/","title":"Normal","text":"<p>Random normal initializer which simulate a normal distribution with specified parameters.</p>"},{"location":"api/optim/initializers/Normal/#parameters","title":"Parameters","text":"<ul> <li> <p>mu</p> <p>Default \u2192 <code>0.0</code></p> <p>The mean of the normal distribution</p> </li> <li> <p>sigma</p> <p>Default \u2192 <code>1.0</code></p> <p>The standard deviation of the normal distribution</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generation seed that can be set for reproducibility.</p> </li> </ul>"},{"location":"api/optim/initializers/Normal/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\ninit = optim.initializers.Normal(mu=0, sigma=1, seed=42)\n\ninit(shape=1)\n</code></pre> <pre><code>np.float64(0.4967141...)\n</code></pre></p> <p><pre><code>init(shape=2)\n</code></pre> <pre><code>array([-0.1382643 ,  0.64768854])\n</code></pre></p>"},{"location":"api/optim/initializers/Normal/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2014 defaults to <code>1</code> </li> </ul> <p></p>"},{"location":"api/optim/initializers/Zeros/","title":"Zeros","text":"<p>Constant initializer which always returns zeros.</p>"},{"location":"api/optim/initializers/Zeros/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\ninit = optim.initializers.Zeros()\n\ninit(shape=1)\n</code></pre> <pre><code>0.0\n</code></pre></p> <p><pre><code>init(shape=2)\n</code></pre> <pre><code>array([0., 0.])\n</code></pre></p>"},{"location":"api/optim/initializers/Zeros/#methods","title":"Methods","text":"call <p>Returns a fresh set of weights.</p> <p>Parameters</p> <ul> <li>shape     \u2014 defaults to <code>1</code> </li> </ul> <p></p>"},{"location":"api/optim/losses/Absolute/","title":"Absolute","text":"<p>Absolute loss, also known as the mean absolute error or L1 loss.</p> <p>Mathematically, it is defined as </p> \\[L = |p_i - y_i|\\] <p>Its gradient w.r.t. to \\(p_i\\) is </p> \\[\\frac{\\partial L}{\\partial p_i} = sgn(p_i - y_i)\\]"},{"location":"api/optim/losses/Absolute/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\nloss = optim.losses.Absolute()\nloss(-42, 42)\n</code></pre> <pre><code>84\n</code></pre> <pre><code>loss.gradient(1, 2)\n</code></pre> <pre><code>1\n</code></pre> <pre><code>loss.gradient(2, 1)\n</code></pre> <pre><code>-1\n</code></pre></p>"},{"location":"api/optim/losses/Absolute/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/losses/BinaryFocalLoss/","title":"BinaryFocalLoss","text":"<p>Binary focal loss.</p> <p>This implements the \"star\" algorithm from the appendix of the focal loss paper.</p>"},{"location":"api/optim/losses/BinaryFocalLoss/#parameters","title":"Parameters","text":"<ul> <li> <p>gamma</p> <p>Default \u2192 <code>2</code></p> </li> <li> <p>beta</p> <p>Default \u2192 <code>1</code></p> </li> </ul>"},{"location":"api/optim/losses/BinaryFocalLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p> 1. Lin, T.Y., Goyal, P., Girshick, R., He, K. and Doll\u00e1r, P., 2017. Focal loss for dense object detection. In Proceedings of the IEEE international conference on computer vision (pp. 2980-2988)</p>"},{"location":"api/optim/losses/BinaryLoss/","title":"BinaryLoss","text":"<p>A loss appropriate for binary classification tasks.</p>"},{"location":"api/optim/losses/BinaryLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/losses/Cauchy/","title":"Cauchy","text":"<p>Cauchy loss function.</p>"},{"location":"api/optim/losses/Cauchy/#parameters","title":"Parameters","text":"<ul> <li> <p>C</p> <p>Default \u2192 <code>80</code></p> </li> </ul>"},{"location":"api/optim/losses/Cauchy/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p> <ol> <li> <p>\"Effect of MAE\" Kaggle discussion \u21a9</p> </li> <li> <p>Paris Madness Kaggle kernel \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/CrossEntropy/","title":"CrossEntropy","text":"<p>Cross entropy loss.</p> <p>This is a generalization of logistic loss to multiple classes.</p>"},{"location":"api/optim/losses/CrossEntropy/#parameters","title":"Parameters","text":"<ul> <li> <p>class_weight</p> <p>Type \u2192 dict[base.typing.ClfTarget, float] | None</p> <p>Default \u2192 <code>None</code></p> <p>A dictionary that indicates what weight to associate with each class.</p> </li> </ul>"},{"location":"api/optim/losses/CrossEntropy/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\ny_true = [0, 1, 2, 2]\ny_pred = [\n    {0: 0.29450637, 1: 0.34216758, 2: 0.36332605},\n    {0: 0.21290077, 1: 0.32728332, 2: 0.45981591},\n    {0: 0.42860913, 1: 0.33380113, 2: 0.23758974},\n    {0: 0.44941979, 1: 0.32962558, 2: 0.22095463}\n]\n\nloss = optim.losses.CrossEntropy()\n\nfor yt, yp in zip(y_true, y_pred):\n    print(loss(yt, yp))\n</code></pre> <pre><code>1.222454\n1.116929\n1.437209\n1.509797\n</code></pre></p> <p><pre><code>for yt, yp in zip(y_true, y_pred):\n    print(loss.gradient(yt, yp))\n</code></pre> <pre><code>{0: -0.70549363, 1: 0.34216758, 2: 0.36332605}\n{0: 0.21290077, 1: -0.67271668, 2: 0.45981591}\n{0: 0.42860913, 1: 0.33380113, 2: -0.76241026}\n{0: 0.44941979, 1: 0.32962558, 2: -0.77904537}\n</code></pre></p>"},{"location":"api/optim/losses/CrossEntropy/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p> <ol> <li> <p>What is Softmax regression and how is it related to Logistic regression? \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/","title":"EpsilonInsensitiveHinge","text":"<p>Epsilon-insensitive hinge loss.</p>"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#parameters","title":"Parameters","text":"<ul> <li> <p>eps</p> <p>Default \u2192 <code>0.1</code></p> </li> </ul>"},{"location":"api/optim/losses/EpsilonInsensitiveHinge/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/losses/Hinge/","title":"Hinge","text":"<p>Computes the hinge loss.</p> <p>Mathematically, it is defined as </p> \\[L = max(0, 1 - p_i * y_i)\\] <p>Its gradient w.r.t. to \\(p_i\\) is </p> \\[ \\\\frac{\\\\partial L}{\\\\partial y_i} = \\\\left\\{ \\\\begin{array}{ll}     \\\\ 0  &amp;   p_iy_i \\geqslant 1  \\\\\\\\     \\\\ - y_i &amp; p_iy_i &lt; 1 \\\\end{array} \\\\right. \\]"},{"location":"api/optim/losses/Hinge/#parameters","title":"Parameters","text":"<ul> <li> <p>threshold</p> <p>Default \u2192 <code>1.0</code></p> <p>Margin threshold. 1 yield the loss used in SVMs, whilst 0 is equivalent to the loss used in the Perceptron algorithm.</p> </li> </ul>"},{"location":"api/optim/losses/Hinge/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\nloss = optim.losses.Hinge(threshold=1)\nloss(1, .2)\n</code></pre> <pre><code>0.8\n</code></pre></p> <p><pre><code>loss.gradient(1, .2)\n</code></pre> <pre><code>-1\n</code></pre></p>"},{"location":"api/optim/losses/Hinge/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/losses/Huber/","title":"Huber","text":"<p>Huber loss.</p> <p>Variant of the squared loss that is robust to outliers.</p>"},{"location":"api/optim/losses/Huber/#parameters","title":"Parameters","text":"<ul> <li> <p>epsilon</p> <p>Default \u2192 <code>0.1</code></p> </li> </ul>"},{"location":"api/optim/losses/Huber/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p> 1. Huber loss function - Wikipedia</p>"},{"location":"api/optim/losses/Log/","title":"Log","text":"<p>Logarithmic loss.</p> <p>This loss function expects each provided <code>y_pred</code> to be a logit. In other words if must be the raw output of a linear model or a neural network.</p>"},{"location":"api/optim/losses/Log/#parameters","title":"Parameters","text":"<ul> <li> <p>weight_pos</p> <p>Default \u2192 <code>1.0</code></p> </li> <li> <p>weight_neg</p> <p>Default \u2192 <code>1.0</code></p> </li> </ul>"},{"location":"api/optim/losses/Log/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p> <ol> <li> <p>Logit Wikipedia page \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/MultiClassLoss/","title":"MultiClassLoss","text":"<p>A loss appropriate for multi-class classification tasks.</p>"},{"location":"api/optim/losses/MultiClassLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/losses/Poisson/","title":"Poisson","text":"<p>Poisson loss.</p> <p>The Poisson loss is usually more suited for regression with count data than the squared loss. </p> <p>Mathematically, it is defined as </p> \\[L = exp(p_i) - y_i \\times p_i\\] <p>Its gradient w.r.t. to \\(p_i\\) is </p> \\[\\frac{\\partial L}{\\partial p_i} = exp(p_i) - y_i\\]"},{"location":"api/optim/losses/Poisson/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/losses/Quantile/","title":"Quantile","text":"<p>Quantile loss.</p>"},{"location":"api/optim/losses/Quantile/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Default \u2192 <code>0.5</code></p> <p>Desired quantile to attain.</p> </li> </ul>"},{"location":"api/optim/losses/Quantile/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\nloss = optim.losses.Quantile(0.5)\nloss(1, 3)\n</code></pre> <pre><code>1.0\n</code></pre></p> <p><pre><code>loss.gradient(1, 3)\n</code></pre> <pre><code>0.5\n</code></pre></p> <p><pre><code>loss.gradient(3, 1)\n</code></pre> <pre><code>-0.5\n</code></pre></p>"},{"location":"api/optim/losses/Quantile/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p> <ol> <li> <p>Wikipedia article on quantile regression \u21a9</p> </li> <li> <p>Derivative from WolframAlpha \u21a9</p> </li> </ol>"},{"location":"api/optim/losses/RegressionLoss/","title":"RegressionLoss","text":"<p>A loss appropriate for regression tasks.</p>"},{"location":"api/optim/losses/RegressionLoss/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/losses/Squared/","title":"Squared","text":"<p>Squared loss, also known as the L2 loss.</p> <p>Mathematically, it is defined as </p> \\[L = (p_i - y_i) ^ 2\\] <p>Its gradient w.r.t. to \\(p_i\\) is </p> \\[\\frac{\\partial L}{\\partial p_i} = 2 (p_i - y_i)\\] <p>One thing to note is that this convention is consistent with Vowpal Wabbit and PyTorch, but not with scikit-learn. Indeed, scikit-learn divides the loss by 2, making the 2 disappear in the gradient.</p>"},{"location":"api/optim/losses/Squared/#examples","title":"Examples","text":"<p><pre><code>from river import optim\n\nloss = optim.losses.Squared()\nloss(-4, 5)\n</code></pre> <pre><code>81\n</code></pre> <pre><code>loss.gradient(-4, 5)\n</code></pre> <pre><code>18\n</code></pre> <pre><code>loss.gradient(5, -4)\n</code></pre> <pre><code>-18\n</code></pre></p>"},{"location":"api/optim/losses/Squared/#methods","title":"Methods","text":"call <p>Returns the loss.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The loss(es).</p> <p></p> gradient <p>Return the gradient with respect to y_pred.</p> <p>Parameters</p> <ul> <li>y_true </li> <li>y_pred </li> </ul> <p>Returns</p> <p>The gradient(s).</p> <p></p> mean_func <p>Mean function.</p> <p>This is the inverse of the link function. Typically, a loss function takes as input the raw output of a model. In the case of classification, the raw output would be logits. The mean function can be used to convert the raw output into a value that makes sense to the user, such as a probability.</p> <p>Parameters</p> <ul> <li>y_pred </li> </ul> <p>Returns</p> <p>The adjusted prediction(s).</p> <p></p>"},{"location":"api/optim/schedulers/Constant/","title":"Constant","text":"<p>Always uses the same learning rate.</p>"},{"location":"api/optim/schedulers/Constant/#parameters","title":"Parameters","text":"<ul> <li> <p>learning_rate</p> <p>Type \u2192 int | float</p> </li> </ul>"},{"location":"api/optim/schedulers/Constant/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/optim/schedulers/InverseScaling/","title":"InverseScaling","text":"<p>Reduces the learning rate using a power schedule.</p> <p>Assuming an initial learning rate \\(\\eta\\), the learning rate at step \\(t\\) is: </p> \\[\\\\frac{eta}{(t + 1) ^ p}\\] <p>where \\(p\\) is a user-defined parameter.</p>"},{"location":"api/optim/schedulers/InverseScaling/#parameters","title":"Parameters","text":"<ul> <li> <p>learning_rate</p> <p>Type \u2192 float</p> </li> <li> <p>power</p> <p>Default \u2192 <code>0.5</code></p> </li> </ul>"},{"location":"api/optim/schedulers/InverseScaling/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     \u2014 'int' </li> </ul> <p></p>"},{"location":"api/optim/schedulers/Optimal/","title":"Optimal","text":"<p>Optimal learning schedule as proposed by L\u00e9on Bottou.</p>"},{"location":"api/optim/schedulers/Optimal/#parameters","title":"Parameters","text":"<ul> <li> <p>loss</p> <p>Type \u2192 optim.losses.Loss</p> </li> <li> <p>alpha</p> <p>Default \u2192 <code>0.0001</code></p> </li> </ul>"},{"location":"api/optim/schedulers/Optimal/#methods","title":"Methods","text":"get <p>Returns the learning rate at a given iteration.</p> <p>Parameters</p> <ul> <li>t     \u2014 'int' </li> </ul> <p></p> <ol> <li> <p>Bottou, L., 2012. Stochastic gradient descent tricks. In Neural networks: Tricks of the trade (pp. 421-436). Springer, Berlin, Heidelberg. \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/AdaptiveStandardScaler/","title":"AdaptiveStandardScaler","text":"<p>Scales data using exponentially weighted moving average and variance.</p> <p>Under the hood, a exponentially weighted running mean and variance are maintained for each feature. This can potentially provide better results for drifting data in comparison to <code>preprocessing.StandardScaler</code>. Indeed, the latter computes a global mean and variance for each feature, whereas this scaler weights data in proportion to their recency.</p>"},{"location":"api/preprocessing/AdaptiveStandardScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor</p> <p>Default \u2192 <code>0.3</code></p> <p>This parameter is passed to <code>stats.EWVar</code>. It is expected to be in [0, 1]. More weight is assigned to recent samples the closer <code>fading_factor</code> is to 1.</p> </li> </ul>"},{"location":"api/preprocessing/AdaptiveStandardScaler/#examples","title":"Examples","text":"<p>Consider the following series which contains a positive trend.</p> <p><pre><code>import random\n\nrandom.seed(42)\nX = [\n    {'x': random.uniform(4 + i, 6 + i)}\n    for i in range(8)\n]\nfor x in X:\n    print(x)\n</code></pre> <pre><code>{'x': 5.278}\n{'x': 5.050}\n{'x': 6.550}\n{'x': 7.446}\n{'x': 9.472}\n{'x': 10.353}\n{'x': 11.784}\n{'x': 11.173}\n</code></pre></p> <p>This scaler works well with this kind of data because it uses statistics that assign higher weight to more recent data.</p> <p><pre><code>from river import preprocessing\n\nscaler = preprocessing.AdaptiveStandardScaler(fading_factor=.6)\n\nfor x in X:\n    scaler.learn_one(x)\n    print(scaler.transform_one(x))\n</code></pre> <pre><code>{'x': 0.0}\n{'x': -0.816}\n{'x': 0.812}\n{'x': 0.695}\n{'x': 0.754}\n{'x': 0.598}\n{'x': 0.651}\n{'x': 0.124}\n</code></pre></p>"},{"location":"api/preprocessing/AdaptiveStandardScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/Binarizer/","title":"Binarizer","text":"<p>Binarizes the data to 0 or 1 according to a threshold.</p>"},{"location":"api/preprocessing/Binarizer/#parameters","title":"Parameters","text":"<ul> <li> <p>threshold</p> <p>Default \u2192 <code>0.0</code></p> <p>Values above this are replaced by 1 and the others by 0.</p> </li> <li> <p>dtype</p> <p>Default \u2192 <code>&lt;class 'bool'&gt;</code></p> <p>The desired data type to apply.</p> </li> </ul>"},{"location":"api/preprocessing/Binarizer/#examples","title":"Examples","text":"<p><pre><code>import river\nimport numpy as np\n\nrng = np.random.RandomState(42)\nX = [{'x1': v, 'x2': int(v)} for v in rng.uniform(low=-4, high=4, size=6)]\n\nbinarizer = river.preprocessing.Binarizer()\nfor x in X:\n    binarizer.learn_one(x)\n    print(binarizer.transform_one(x))\n</code></pre> <pre><code>{'x1': False, 'x2': False}\n{'x1': True, 'x2': True}\n{'x1': True, 'x2': True}\n{'x1': True, 'x2': False}\n{'x1': False, 'x2': False}\n{'x1': False, 'x2': False}\n</code></pre></p>"},{"location":"api/preprocessing/Binarizer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/FeatureHasher/","title":"FeatureHasher","text":"<p>Implements the hashing trick.</p> <p>Each pair of (name, value) features is hashed into a random integer. A module operator is then used to make sure the hash is in a certain range. We use the Murmurhash implementation from scikit-learn.</p>"},{"location":"api/preprocessing/FeatureHasher/#parameters","title":"Parameters","text":"<ul> <li> <p>n_features</p> <p>Default \u2192 <code>1048576</code></p> <p>The number by which each hash will be moduloed by.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Set the seed to produce identical results.</p> </li> </ul>"},{"location":"api/preprocessing/FeatureHasher/#examples","title":"Examples","text":"<p><pre><code>import river\n\nhasher = river.preprocessing.FeatureHasher(n_features=10, seed=42)\n\nX = [\n    {'dog': 1, 'cat': 2, 'elephant': 4},\n    {'dog': 2, 'run': 5}\n]\nfor x in X:\n    print(hasher.transform_one(x))\n</code></pre> <pre><code>Counter({1: 4, 9: 2, 8: 1})\nCounter({4: 5, 8: 2})\n</code></pre></p>"},{"location":"api/preprocessing/FeatureHasher/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>Wikipedia article on feature vectorization using the hashing trick \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/GaussianRandomProjector/","title":"GaussianRandomProjector","text":"<p>Gaussian random projector.</p> <p>This transformer reduces the dimensionality of inputs through Gaussian random projection. </p> <p>The components of the random projections matrix are drawn from <code>N(0, 1 / n_components)</code>.</p>"},{"location":"api/preprocessing/GaussianRandomProjector/#parameters","title":"Parameters","text":"<ul> <li> <p>n_components</p> <p>Default \u2192 <code>10</code></p> <p>Number of components to project the data onto.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/preprocessing/GaussianRandomProjector/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\nmodel = preprocessing.GaussianRandomProjector(\n    n_components=3,\n    seed=42\n)\n\nfor x, y in dataset:\n    x = model.transform_one(x)\n    print(x)\n    break\n</code></pre> <pre><code>{0: -61289.371..., 1: 141312.510..., 2: 279165.993...}\n</code></pre></p> <p><pre><code>model = (\n    preprocessing.GaussianRandomProjector(\n        n_components=5,\n        seed=42\n    ) |\n    preprocessing.StandardScaler() |\n    linear_model.LinearRegression()\n)\nevaluate.progressive_val_score(dataset, model, metrics.MAE())\n</code></pre> <pre><code>MAE: 0.933...\n</code></pre></p>"},{"location":"api/preprocessing/GaussianRandomProjector/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>Gaussian random projection \u21a9</p> </li> <li> <p>scikit-learn random projections module \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/LDA/","title":"LDA","text":"<p>Online Latent Dirichlet Allocation with Infinite Vocabulary.</p> <p>Latent Dirichlet allocation (LDA) is a probabilistic approach for exploring topics in document collections. The key advantage of this variant is that it assumes an infinite vocabulary, meaning that the set of tokens does not have to known in advance, as opposed to the implementation from sklearn The results produced by this implementation are identical to those from the original implementation proposed by the method's authors. </p> <p>This class takes as input token counts. Therefore, it requires you to tokenize beforehand. You can do so by using a <code>feature_extraction.BagOfWords</code> instance, as shown in the example below.</p>"},{"location":"api/preprocessing/LDA/#parameters","title":"Parameters","text":"<ul> <li> <p>n_components</p> <p>Default \u2192 <code>10</code></p> <p>Number of topics of the latent Drichlet allocation.</p> </li> <li> <p>number_of_documents</p> <p>Default \u2192 <code>1000000.0</code></p> <p>Estimated number of documents.</p> </li> <li> <p>alpha_theta</p> <p>Default \u2192 <code>0.5</code></p> <p>Hyper-parameter of the Dirichlet distribution of topics.</p> </li> <li> <p>alpha_beta</p> <p>Default \u2192 <code>100.0</code></p> <p>Hyper-parameter of the Dirichlet process of distribution over words.</p> </li> <li> <p>tau</p> <p>Default \u2192 <code>64.0</code></p> <p>Learning inertia to prevent premature convergence.</p> </li> <li> <p>kappa</p> <p>Default \u2192 <code>0.75</code></p> <p>The learning rate kappa controls how quickly new parameters estimates replace the old ones. kappa \u2208 (0.5, 1] is required for convergence.</p> </li> <li> <p>vocab_prune_interval</p> <p>Default \u2192 <code>10</code></p> <p>Interval at which to refresh the words topics distribution.</p> </li> <li> <p>number_of_samples</p> <p>Default \u2192 <code>10</code></p> <p>Number of iteration to computes documents topics distribution.</p> </li> <li> <p>ranking_smooth_factor</p> <p>Default \u2192 <code>1e-12</code></p> </li> <li> <p>burn_in_sweeps</p> <p>Default \u2192 <code>5</code></p> <p>Number of iteration necessaries while analyzing a document before updating document topics distribution.</p> </li> <li> <p>maximum_size_vocabulary</p> <p>Default \u2192 <code>4000</code></p> <p>Maximum size of the stored vocabulary.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number seed used for reproducibility.</p> </li> </ul>"},{"location":"api/preprocessing/LDA/#attributes","title":"Attributes","text":"<ul> <li> <p>counter (int)</p> <p>The current number of observed documents.</p> </li> <li> <p>truncation_size_prime (int)</p> <p>Number of distincts words stored in the vocabulary. Updated before processing a document.</p> </li> <li> <p>truncation_size (int)</p> <p>Number of distincts words stored in the vocabulary. Updated after processing a document.</p> </li> <li> <p>word_to_index (dict)</p> <p>Words as keys and indexes as values.</p> </li> <li> <p>index_to_word (dict)</p> <p>Indexes as keys and words as values.</p> </li> <li> <p>nu_1 (dict)</p> <p>Weights of the words. Component of the variational inference.</p> </li> <li> <p>nu_2 (dict)</p> <p>Weights of the words. Component of the variational inference.</p> </li> </ul>"},{"location":"api/preprocessing/LDA/#examples","title":"Examples","text":"<p><pre><code>from river import compose\nfrom river import feature_extraction\nfrom river import preprocessing\n\nX = [\n   'weather cold',\n   'weather hot dry',\n   'weather cold rainy',\n   'weather hot',\n   'weather cold humid',\n]\n\nlda = compose.Pipeline(\n    feature_extraction.BagOfWords(),\n    preprocessing.LDA(\n        n_components=2,\n        number_of_documents=60,\n        seed=42\n    )\n)\n\nfor x in X:\n    lda.learn_one(x)\n    topics = lda.transform_one(x)\n    print(topics)\n</code></pre> <pre><code>{0: 0.5, 1: 2.5}\n{0: 2.499..., 1: 1.5}\n{0: 0.5, 1: 3.5}\n{0: 0.5, 1: 2.5}\n{0: 1.5, 1: 2.5}\n</code></pre></p>"},{"location":"api/preprocessing/LDA/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> learn_transform_one <p>Equivalent to <code>lda.learn_one(x).transform_one(x)</code>s, but faster.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>dict:     Component attributions for the input document.</p> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>Zhai, K. and Boyd-Graber, J., 2013, February. Online latent Dirichlet allocation with infinite vocabulary. In International Conference on Machine Learning (pp. 561-569). \u21a9</p> </li> <li> <p>PyInfVoc on GitHub \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/MaxAbsScaler/","title":"MaxAbsScaler","text":"<p>Scales the data to a [-1, 1] range based on absolute maximum.</p> <p>Under the hood a running absolute max is maintained. This scaler is meant for data that is already centered at zero or sparse data. It does not shift/center the data, and thus does not destroy any sparsity.</p>"},{"location":"api/preprocessing/MaxAbsScaler/#attributes","title":"Attributes","text":"<ul> <li> <p>abs_max (dict)</p> <p>Mapping between features and instances of <code>stats.AbsMax</code>.</p> </li> </ul>"},{"location":"api/preprocessing/MaxAbsScaler/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import preprocessing\n\nrandom.seed(42)\nX = [{'x': random.uniform(8, 12)} for _ in range(5)]\nfor x in X:\n    print(x)\n</code></pre> <pre><code>{'x': 10.557707}\n{'x': 8.100043}\n{'x': 9.100117}\n{'x': 8.892842}\n{'x': 10.945884}\n</code></pre></p> <p><pre><code>scaler = preprocessing.MaxAbsScaler()\n\nfor x in X:\n    scaler.learn_one(x)\n    print(scaler.transform_one(x))\n</code></pre> <pre><code>{'x': 1.0}\n{'x': 0.767216}\n{'x': 0.861940}\n{'x': 0.842308}\n{'x': 1.0}\n</code></pre></p>"},{"location":"api/preprocessing/MaxAbsScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/MinMaxScaler/","title":"MinMaxScaler","text":"<p>Scales the data to a fixed range from 0 to 1.</p> <p>Under the hood a running min and a running peak to peak (max - min) are maintained.</p>"},{"location":"api/preprocessing/MinMaxScaler/#attributes","title":"Attributes","text":"<ul> <li> <p>min (dict)</p> <p>Mapping between features and instances of <code>stats.Min</code>.</p> </li> <li> <p>max (dict)</p> <p>Mapping between features and instances of <code>stats.Max</code>.</p> </li> </ul>"},{"location":"api/preprocessing/MinMaxScaler/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import preprocessing\n\nrandom.seed(42)\nX = [{'x': random.uniform(8, 12)} for _ in range(5)]\nfor x in X:\n    print(x)\n</code></pre> <pre><code>{'x': 10.557707}\n{'x': 8.100043}\n{'x': 9.100117}\n{'x': 8.892842}\n{'x': 10.945884}\n</code></pre></p> <p><pre><code>scaler = preprocessing.MinMaxScaler()\n\nfor x in X:\n    scaler.learn_one(x)\n    print(scaler.transform_one(x))\n</code></pre> <pre><code>{'x': 0.0}\n{'x': 0.0}\n{'x': 0.406920}\n{'x': 0.322582}\n{'x': 1.0}\n</code></pre></p>"},{"location":"api/preprocessing/MinMaxScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/Normalizer/","title":"Normalizer","text":"<p>Scales a set of features so that it has unit norm.</p> <p>This is particularly useful when used after a <code>feature_extraction.TFIDF</code>.</p>"},{"location":"api/preprocessing/Normalizer/#parameters","title":"Parameters","text":"<ul> <li> <p>order</p> <p>Default \u2192 <code>2</code></p> <p>Order of the norm (e.g. 2 corresponds to the \\(L^2\\) norm).</p> </li> </ul>"},{"location":"api/preprocessing/Normalizer/#examples","title":"Examples","text":"<p><pre><code>from river import preprocessing\nfrom river import stream\n\nscaler = preprocessing.Normalizer(order=2)\n\nX = [[4, 1, 2, 2],\n     [1, 3, 9, 3],\n     [5, 7, 5, 1]]\n\nfor x, _ in stream.iter_array(X):\n    print(scaler.transform_one(x))\n</code></pre> <pre><code>{0: 0.8, 1: 0.2, 2: 0.4, 3: 0.4}\n{0: 0.1, 1: 0.3, 2: 0.9, 3: 0.3}\n{0: 0.5, 1: 0.7, 2: 0.5, 3: 0.1}\n</code></pre></p>"},{"location":"api/preprocessing/Normalizer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/OneHotEncoder/","title":"OneHotEncoder","text":"<p>One-hot encoding.</p> <p>This transformer will encode every feature it is provided with. If a list or set is provided, this transformer will encode every entry in the list/set. You can apply it to a subset of features by composing it  with <code>compose.Select</code> or <code>compose.SelectType</code>.</p>"},{"location":"api/preprocessing/OneHotEncoder/#parameters","title":"Parameters","text":"<ul> <li> <p>drop_zeros</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not 0s should be made explicit or not.</p> </li> <li> <p>drop_first</p> <p>Default \u2192 <code>False</code></p> <p>Whether to get <code>k - 1</code> dummies out of <code>k</code> categorical levels by removing the first key. This is useful in some statistical models where perfectly collinear features cause problems.</p> </li> </ul>"},{"location":"api/preprocessing/OneHotEncoder/#examples","title":"Examples","text":"<p>Let us first create an example dataset.</p> <p><pre><code>from pprint import pprint\nimport random\nimport string\n\nrandom.seed(42)\nalphabet = list(string.ascii_lowercase)\nX = [\n    {\n        'c1': random.choice(alphabet),\n        'c2': random.choice(alphabet),\n    }\n    for _ in range(4)\n]\npprint(X)\n</code></pre> <pre><code>[{'c1': 'u', 'c2': 'd'},\n    {'c1': 'a', 'c2': 'x'},\n    {'c1': 'i', 'c2': 'h'},\n    {'c1': 'h', 'c2': 'e'}]\n</code></pre></p> <p>e can now apply one-hot encoding. All the provided are one-hot encoded, there is therefore no need to specify which features to encode.</p> <p><pre><code>from river import preprocessing\n\noh = preprocessing.OneHotEncoder()\nfor x in X[:2]:\n    oh.learn_one(x)\n    pprint(oh.transform_one(x))\n</code></pre> <pre><code>{'c1_u': 1, 'c2_d': 1}\n{'c1_a': 1, 'c1_u': 0, 'c2_d': 0, 'c2_x': 1}\n</code></pre></p> <p>The <code>drop_zeros</code> parameter can be set to <code>True</code> if you don't want the past features to be included in the output. Otherwise, all the past features will be included in the output.</p> <p><pre><code>oh = preprocessing.OneHotEncoder(drop_zeros=True)\nfor x in X:\n    oh.learn_one(x)\n    pprint(oh.transform_one(x))\n</code></pre> <pre><code>{'c1_u': 1, 'c2_d': 1}\n{'c1_a': 1, 'c2_x': 1}\n{'c1_i': 1, 'c2_h': 1}\n{'c1_h': 1, 'c2_e': 1}\n</code></pre></p> <p>You can encode only <code>k - 1</code> features out of <code>k</code> by setting <code>drop_first</code> to <code>True</code>.</p> <p><pre><code>oh = preprocessing.OneHotEncoder(drop_first=True, drop_zeros=True)\nfor x in X:\n    oh.learn_one(x)\n    pprint(oh.transform_one(x))\n</code></pre> <pre><code>{'c2_d': 1}\n{'c2_x': 1}\n{'c2_h': 1}\n{'c2_e': 1}\n</code></pre></p> <p>A subset of the features can be one-hot encoded by piping a <code>compose.Select</code> into the <code>OneHotEncoder</code>.</p> <p><pre><code>from river import compose\n\npp = compose.Select('c1') | preprocessing.OneHotEncoder()\n\nfor x in X:\n    pp.learn_one(x)\n    pprint(pp.transform_one(x))\n</code></pre> <pre><code>{'c1_u': 1}\n{'c1_a': 1, 'c1_u': 0}\n{'c1_a': 0, 'c1_i': 1, 'c1_u': 0}\n{'c1_a': 0, 'c1_h': 1, 'c1_i': 0, 'c1_u': 0}\n</code></pre></p> <p>You can preserve the <code>c2</code> feature by using a union:</p> <p><pre><code>pp = compose.Select('c1') | preprocessing.OneHotEncoder()\npp += compose.Select('c2')\n\nfor x in X:\n    pp.learn_one(x)\n    pprint(pp.transform_one(x))\n</code></pre> <pre><code>{'c1_u': 1, 'c2': 'd'}\n{'c1_a': 1, 'c1_u': 0, 'c2': 'x'}\n{'c1_a': 0, 'c1_i': 1, 'c1_u': 0, 'c2': 'h'}\n{'c1_a': 0, 'c1_h': 1, 'c1_i': 0, 'c1_u': 0, 'c2': 'e'}\n</code></pre></p> <p>Similar to the above examples, we can also pass values as a list. This will one-hot encode all of the entries individually.</p> <p><pre><code>X = [{'c1': ['u', 'a'], 'c2': ['d']},\n    {'c1': ['a', 'b'], 'c2': ['x']},\n    {'c1': ['i'], 'c2': ['h', 'z']},\n    {'c1': ['h', 'b'], 'c2': ['e']}]\n\noh = preprocessing.OneHotEncoder(drop_zeros=True)\nfor x in X:\n    oh.learn_one(x)\n    pprint(oh.transform_one(x))\n</code></pre> <pre><code>{'c1_a': 1, 'c1_u': 1, 'c2_d': 1}\n{'c1_a': 1, 'c1_b': 1, 'c2_x': 1}\n{'c1_i': 1, 'c2_h': 1, 'c2_z': 1}\n{'c1_b': 1, 'c1_h': 1, 'c2_e': 1}\n</code></pre></p> <p>Processing mini-batches is also possible.</p> <p><pre><code>from pprint import pprint\nimport random\nimport string\n\nrandom.seed(42)\nalphabet = list(string.ascii_lowercase)\nX = pd.DataFrame(\n    {\n        'c1': random.choice(alphabet),\n        'c2': random.choice(alphabet),\n    }\n    for _ in range(3)\n)\nX\n</code></pre> <pre><code>  c1 c2\n0  u  d\n1  a  x\n2  i  h\n</code></pre></p> <p><pre><code>oh = preprocessing.OneHotEncoder(drop_zeros=True)\ndf = oh.transform_many(X)\ndf.sort_index(axis=\"columns\")\n</code></pre> <pre><code>   c1_a  c1_i  c1_u  c2_d  c2_h  c2_x\n0     0     0     1     1     0     0\n1     1     0     0     0     0     1\n2     0     1     0     0     1     0\n</code></pre></p> <p><pre><code>oh = preprocessing.OneHotEncoder(drop_zeros=True, drop_first=True)\ndf = oh.transform_many(X)\ndf.sort_index(axis=\"columns\")\n</code></pre> <pre><code>   c1_i  c1_u  c2_d  c2_h  c2_x\n0     0     1     1     0     0\n1     0     0     0     0     1\n2     1     0     0     1     0\n</code></pre></p> <p>Here's an example where the zeros are kept:</p> <p><pre><code>oh = preprocessing.OneHotEncoder(drop_zeros=False)\nX_init = pd.DataFrame([{\"c1\": \"Oranges\", \"c2\": \"Apples\"}])\noh.learn_many(X_init)\noh.learn_many(X)\n\ndf = oh.transform_many(X)\ndf.sort_index(axis=\"columns\")\n</code></pre> <pre><code>   c1_Oranges  c1_a  c1_i  c1_u  c2_Apples  c2_d  c2_h  c2_x\n0           0     0     0     1          0     1     0     0\n1           0     1     0     0          0     0     0     1\n2           0     0     1     0          0     0     1     0\n</code></pre></p> <p><pre><code>df.dtypes.sort_index()\n</code></pre> <pre><code>c1_Oranges    Sparse[uint8, 0]\nc1_a          Sparse[uint8, 0]\nc1_i          Sparse[uint8, 0]\nc1_u          Sparse[uint8, 0]\nc2_Apples     Sparse[uint8, 0]\nc2_d          Sparse[uint8, 0]\nc2_h          Sparse[uint8, 0]\nc2_x          Sparse[uint8, 0]\ndtype: object\n</code></pre></p>"},{"location":"api/preprocessing/OneHotEncoder/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/OrdinalEncoder/","title":"OrdinalEncoder","text":"<p>Ordinal encoder.</p> <p>This transformer maps each feature to integers. It can useful when a feature has string values (i.e. categorical variables).</p>"},{"location":"api/preprocessing/OrdinalEncoder/#parameters","title":"Parameters","text":"<ul> <li> <p>unknown_value</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>0</code></p> <p>The value to use for unknown categories seen during <code>transform_one</code>. Unknown categories will be mapped to an integer once they are seen during <code>learn_one</code>. This value can be set to <code>None</code> in order to categories to <code>None</code> if they've never been seen before.</p> </li> <li> <p>none_value</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>-1</code></p> <p>The value to encode <code>None</code> with.</p> </li> </ul>"},{"location":"api/preprocessing/OrdinalEncoder/#attributes","title":"Attributes","text":"<ul> <li> <p>categories</p> <p>A dict of dicts. The outer dict maps each feature to its inner dict. The inner dict maps each category to its code.</p> </li> </ul>"},{"location":"api/preprocessing/OrdinalEncoder/#examples","title":"Examples","text":"<p><pre><code>from river import preprocessing\n\nX = [\n    {\"country\": \"France\", \"place\": \"Taco Bell\"},\n    {\"country\": None, \"place\": None},\n    {\"country\": \"Sweden\", \"place\": \"Burger King\"},\n    {\"country\": \"France\", \"place\": \"Burger King\"},\n    {\"country\": \"Russia\", \"place\": \"Starbucks\"},\n    {\"country\": \"Russia\", \"place\": \"Starbucks\"},\n    {\"country\": \"Sweden\", \"place\": \"Taco Bell\"},\n    {\"country\": None, \"place\": None},\n]\n\nencoder = preprocessing.OrdinalEncoder()\nfor x in X:\n    print(encoder.transform_one(x))\n    encoder.learn_one(x)\n</code></pre> <pre><code>{'country': 0, 'place': 0}\n{'country': -1, 'place': -1}\n{'country': 0, 'place': 0}\n{'country': 1, 'place': 2}\n{'country': 0, 'place': 0}\n{'country': 3, 'place': 3}\n{'country': 2, 'place': 1}\n{'country': -1, 'place': -1}\n</code></pre></p> <p><pre><code>xb1 = pd.DataFrame(X[0:4], index=[0, 1, 2, 3])\nxb2 = pd.DataFrame(X[4:8], index=[4, 5, 6, 7])\n\nencoder = preprocessing.OrdinalEncoder()\nencoder.transform_many(xb1)\n</code></pre> <pre><code>   country  place\n0        0      0\n1       -1     -1\n2        0      0\n3        0      0\n</code></pre></p> <p><pre><code>encoder.learn_many(xb1)\nencoder.transform_many(xb2)\n</code></pre> <pre><code>   country  place\n4        0      0\n5        0      0\n6        2      1\n7       -1     -1\n</code></pre></p>"},{"location":"api/preprocessing/OrdinalEncoder/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_many</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_many</code> can override this method.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> <li>y     \u2014 defaults to <code>None</code> </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_many <p>Transform a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p>Returns</p> <p>pd.DataFrame:     A new DataFrame.</p> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/PredClipper/","title":"PredClipper","text":"<p>Clips the target after predicting.</p>"},{"location":"api/preprocessing/PredClipper/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 base.Regressor</p> <p>Regressor model for which to clip the predictions.</p> </li> <li> <p>y_min</p> <p>Type \u2192 float</p> <p>minimum value.</p> </li> <li> <p>y_max</p> <p>Type \u2192 float</p> <p>maximum value.</p> </li> </ul>"},{"location":"api/preprocessing/PredClipper/#examples","title":"Examples","text":"<p><pre><code>from river import linear_model\nfrom river import preprocessing\n\ndataset = (\n    ({'a': 2, 'b': 4}, 80),\n    ({'a': 3, 'b': 5}, 100),\n    ({'a': 4, 'b': 6}, 120)\n)\n\nmodel = preprocessing.PredClipper(\n    regressor=linear_model.LinearRegression(),\n    y_min=0,\n    y_max=200\n)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel.predict_one({'a': -100, 'b': -200})\n</code></pre> <pre><code>0\n</code></pre></p> <p><pre><code>model.predict_one({'a': 50, 'b': 60})\n</code></pre> <pre><code>200\n</code></pre></p>"},{"location":"api/preprocessing/PredClipper/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>kwargs </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/preprocessing/PreviousImputer/","title":"PreviousImputer","text":"<p>Imputes missing values by using the most recent value.</p>"},{"location":"api/preprocessing/PreviousImputer/#examples","title":"Examples","text":"<p><pre><code>from river import preprocessing\n\nimputer = preprocessing.PreviousImputer()\n\nimputer.learn_one({'x': 1, 'y': 2})\nimputer.transform_one({'y': None})\n</code></pre> <pre><code>{'y': 2}\n</code></pre></p> <p><pre><code>imputer.transform_one({'x': None})\n</code></pre> <pre><code>{'x': 1}\n</code></pre></p>"},{"location":"api/preprocessing/PreviousImputer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/RobustScaler/","title":"RobustScaler","text":"<p>Scale features using statistics that are robust to outliers.</p> <p>This Scaler removes the median and scales the data according to the interquantile range.</p>"},{"location":"api/preprocessing/RobustScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>with_centering</p> <p>Default \u2192 <code>True</code></p> <p>Whether to centre the data before scaling.</p> </li> <li> <p>with_scaling</p> <p>Default \u2192 <code>True</code></p> <p>Whether to scale data to IQR.</p> </li> <li> <p>q_inf</p> <p>Default \u2192 <code>0.25</code></p> <p>Desired inferior quantile, must be between 0 and 1.</p> </li> <li> <p>q_sup</p> <p>Default \u2192 <code>0.75</code></p> <p>Desired superior quantile, must be between 0 and 1.</p> </li> </ul>"},{"location":"api/preprocessing/RobustScaler/#attributes","title":"Attributes","text":"<ul> <li> <p>median (dict)</p> <p>Mapping between features and instances of <code>stats.Quantile</code>(0.5)`.</p> </li> <li> <p>iqr (dict)</p> <p>Mapping between features and instances of <code>stats.IQR</code>.</p> </li> </ul>"},{"location":"api/preprocessing/RobustScaler/#examples","title":"Examples","text":"<p><pre><code>from pprint import pprint\nimport random\nfrom river import preprocessing\n\nrandom.seed(42)\nX = [{'x': random.uniform(8, 12)} for _ in range(5)]\npprint(X)\n</code></pre> <pre><code>[{'x': 10.557707},\n    {'x': 8.100043},\n    {'x': 9.100117},\n    {'x': 8.892842},\n    {'x': 10.945884}]\n</code></pre></p> <p><pre><code>scaler = preprocessing.RobustScaler()\n\nfor x in X:\n    scaler.learn_one(x)\n    print(scaler.transform_one(x))\n</code></pre> <pre><code>    {'x': 0.0}\n    {'x': -1.0}\n    {'x': 0.0}\n    {'x': -0.12449923287875722}\n    {'x': 1.1086595155704708}\n</code></pre></p>"},{"location":"api/preprocessing/RobustScaler/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/SparseRandomProjector/","title":"SparseRandomProjector","text":"<p>Sparse random projector.</p> <p>This transformer reduces the dimensionality of inputs by projecting them onto a sparse random projection matrix. </p> <p>Ping Li et al. recommend using a minimum density of <code>1 / sqrt(n_features)</code>. The transformer is not aware of how many features will be seen, so the user must specify the density manually.</p>"},{"location":"api/preprocessing/SparseRandomProjector/#parameters","title":"Parameters","text":"<ul> <li> <p>n_components</p> <p>Default \u2192 <code>10</code></p> <p>Number of components to project the data onto.</p> </li> <li> <p>density</p> <p>Default \u2192 <code>0.1</code></p> <p>Density of the random projection matrix. The density is defined as the ratio of non-zero components in the matrix. It is equal to <code>1 - sparsity</code>.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/preprocessing/SparseRandomProjector/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\nmodel = preprocessing.SparseRandomProjector(\n    n_components=3,\n    seed=42\n)\n\nfor x, y in dataset:\n    x = model.transform_one(x)\n    print(x)\n    break\n</code></pre> <pre><code>{0: 92.89572746525327, 1: 1344540.5692342375, 2: 0}\n</code></pre></p> <p><pre><code>model = (\n    preprocessing.SparseRandomProjector(\n        n_components=5,\n        seed=42\n    ) |\n    preprocessing.StandardScaler() |\n    linear_model.LinearRegression()\n)\nevaluate.progressive_val_score(dataset, model, metrics.MAE())\n</code></pre> <pre><code>MAE: 1.292572\n</code></pre></p>"},{"location":"api/preprocessing/SparseRandomProjector/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>D. Achlioptas. 2003. Database-friendly random projections: Johnson-Lindenstrauss with binary coins. Journal of Computer and System Sciences 66 (2003) 671-687\u00a0\u21a9</p> </li> <li> <p>Ping Li, Trevor J. Hastie, and Kenneth W. Church. 2006. Very sparse random projections. In Proceedings of the 12th ACM SIGKDD international conference on Knowledge discovery and data mining (KDD'06). ACM, New York, NY, USA, 287-296.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/preprocessing/StandardScaler/","title":"StandardScaler","text":"<p>Scales the data so that it has zero mean and unit variance.</p> <p>Under the hood, a running mean and a running variance are maintained. The scaling is slightly different than when scaling the data in batch because the exact means and variances are not known in advance. However, this doesn't have a detrimental impact on performance in the long run. </p> <p>This transformer supports mini-batches as well as single instances. In the mini-batch case, the number of columns and the ordering of the columns are allowed to change between subsequent calls. In other words, this transformer will keep working even if you add and/or remove features every time you call <code>learn_many</code> and <code>transform_many</code>.</p>"},{"location":"api/preprocessing/StandardScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>with_std</p> <p>Default \u2192 <code>True</code></p> <p>Whether or not each feature should be divided by its standard deviation.</p> </li> </ul>"},{"location":"api/preprocessing/StandardScaler/#examples","title":"Examples","text":"<p><pre><code>import random\nfrom river import preprocessing\n\nrandom.seed(42)\nX = [{'x': random.uniform(8, 12), 'y': random.uniform(8, 12)} for _ in range(6)]\nfor x in X:\n    print(x)\n</code></pre> <pre><code>{'x': 10.557, 'y': 8.100}\n{'x': 9.100, 'y': 8.892}\n{'x': 10.945, 'y': 10.706}\n{'x': 11.568, 'y': 8.347}\n{'x': 9.687, 'y': 8.119}\n{'x': 8.874, 'y': 10.021}\n</code></pre></p> <p><pre><code>scaler = preprocessing.StandardScaler()\n\nfor x in X:\n    scaler.learn_one(x)\n    print(scaler.transform_one(x))\n</code></pre> <pre><code>{'x': 0.0, 'y': 0.0}\n{'x': -0.999, 'y': 0.999}\n{'x': 0.937, 'y': 1.350}\n{'x': 1.129, 'y': -0.651}\n{'x': -0.776, 'y': -0.729}\n{'x': -1.274, 'y': 0.992}\n</code></pre></p> <p>This transformer also supports mini-batch updates. You can call <code>learn_many</code> and provide a <code>pandas.DataFrame</code>:</p> <pre><code>import pandas as pd\nX = pd.DataFrame.from_dict(X)\n\nscaler = preprocessing.StandardScaler()\nscaler.learn_many(X[:3])\nscaler.learn_many(X[3:])\n</code></pre> <p>You can then call <code>transform_many</code> to scale a mini-batch of features:</p> <p><pre><code>scaler.transform_many(X)\n</code></pre> <pre><code>    x         y\n0  0.444600 -0.933384\n1 -1.044259 -0.138809\n2  0.841106  1.679208\n3  1.477301 -0.685117\n4 -0.444084 -0.914195\n5 -1.274664  0.992296\n</code></pre></p>"},{"location":"api/preprocessing/StandardScaler/#methods","title":"Methods","text":"learn_many <p>Update with a mini-batch of features.</p> <p>Note that the update formulas for mean and variance are slightly different than in the single instance case, but they produce exactly the same result.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_many <p>Scale a mini-batch of features.</p> <p>Parameters</p> <ul> <li>X     \u2014 'pd.DataFrame' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p> <ol> <li> <p>Welford's Method (and Friends) \u21a9</p> </li> <li> <p>Batch updates for simple statistics \u21a9</p> </li> </ol>"},{"location":"api/preprocessing/StatImputer/","title":"StatImputer","text":"<p>Replaces missing values with a statistic.</p> <p>This transformer allows you to replace missing values with the value of a running statistic. During a call to <code>learn_one</code>, for each feature, a statistic is updated whenever a numeric feature is observed. When <code>transform_one</code> is called, each feature with a <code>None</code> value is replaced with the current value of the corresponding statistic.</p>"},{"location":"api/preprocessing/StatImputer/#parameters","title":"Parameters","text":"<ul> <li> <p>imputers</p> <p>A list of tuples where each tuple has two elements. The first elements is a feature name and the second value is an instance of <code>stats.base.Univariate</code>. The second value can also be an arbitrary value, such as -1, in which case the missing values will be replaced with it.</p> </li> </ul>"},{"location":"api/preprocessing/StatImputer/#examples","title":"Examples","text":"<pre><code>from river import preprocessing\nfrom river import stats\n</code></pre> <p>For numeric data, we can use a <code>stats.Mean</code>()` to replace missing values by the running average of the previously seen values:</p> <p><pre><code>X = [\n    {'temperature': 1},\n    {'temperature': 8},\n    {'temperature': 3},\n    {'temperature': None},\n    {'temperature': 4}\n]\n\nimp = preprocessing.StatImputer(('temperature', stats.Mean()))\n\nfor x in X:\n    imp.learn_one(x)\n    print(imp.transform_one(x))\n</code></pre> <pre><code>{'temperature': 1}\n{'temperature': 8}\n{'temperature': 3}\n{'temperature': 4.0}\n{'temperature': 4}\n</code></pre></p> <p>For discrete/categorical data, a common practice is to <code>stats.Mode</code> to replace missing values by the most commonly seen value:</p> <p><pre><code>X = [\n    {'weather': 'sunny'},\n    {'weather': 'rainy'},\n    {'weather': 'sunny'},\n    {'weather': None},\n    {'weather': 'rainy'},\n    {'weather': 'rainy'},\n    {'weather': None}\n]\n\nimp = preprocessing.StatImputer(('weather', stats.Mode()))\n\nfor x in X:\n    imp.learn_one(x)\n    print(imp.transform_one(x))\n</code></pre> <pre><code>{'weather': 'sunny'}\n{'weather': 'rainy'}\n{'weather': 'sunny'}\n{'weather': 'sunny'}\n{'weather': 'rainy'}\n{'weather': 'rainy'}\n{'weather': 'rainy'}\n</code></pre></p> <p>You can also choose to replace missing values with a constant value, as so:</p> <p><pre><code>imp = preprocessing.StatImputer(('weather', 'missing'))\n\nfor x in X:\n    imp.learn_one(x)\n    print(imp.transform_one(x))\n</code></pre> <pre><code>{'weather': 'sunny'}\n{'weather': 'rainy'}\n{'weather': 'sunny'}\n{'weather': 'missing'}\n{'weather': 'rainy'}\n{'weather': 'rainy'}\n{'weather': 'missing'}\n</code></pre></p> <p>Multiple imputers can be defined by providing a tuple for each feature which you want to impute:</p> <p><pre><code>X = [\n    {'weather': 'sunny', 'temperature': 8},\n    {'weather': 'rainy', 'temperature': 3},\n    {'weather': 'sunny', 'temperature': None},\n    {'weather': None, 'temperature': 4},\n    {'weather': 'snowy', 'temperature': -4},\n    {'weather': 'snowy', 'temperature': -3},\n    {'weather': 'snowy', 'temperature': -3},\n    {'weather': None, 'temperature': None}\n]\n\nimp = preprocessing.StatImputer(\n    ('temperature', stats.Mean()),\n    ('weather', stats.Mode())\n)\n\nfor x in X:\n    imp.learn_one(x)\n    print(imp.transform_one(x))\n</code></pre> <pre><code>{'weather': 'sunny', 'temperature': 8}\n{'weather': 'rainy', 'temperature': 3}\n{'weather': 'sunny', 'temperature': 5.5}\n{'weather': 'sunny', 'temperature': 4}\n{'weather': 'snowy', 'temperature': -4}\n{'weather': 'snowy', 'temperature': -3}\n{'weather': 'snowy', 'temperature': -3}\n{'weather': 'snowy', 'temperature': 0.8333}\n</code></pre></p> <p>A sophisticated way to go about imputation is condition the statistics on a given feature. For instance, we might want to replace a missing temperature with the average temperature of a particular weather condition. As an example, consider the following dataset where the temperature is missing, but not the weather condition:</p> <pre><code>X = [\n    {'weather': 'sunny', 'temperature': 8},\n    {'weather': 'rainy', 'temperature': 3},\n    {'weather': 'sunny', 'temperature': None},\n    {'weather': 'rainy', 'temperature': 4},\n    {'weather': 'sunny', 'temperature': 10},\n    {'weather': 'sunny', 'temperature': None},\n    {'weather': 'sunny', 'temperature': 12},\n    {'weather': 'rainy', 'temperature': None}\n]\n</code></pre> <p>Each missing temperature can be replaced with the average temperature of the corresponding weather condition as so:</p> <p><pre><code>from river import compose\n\nimp = compose.Grouper(\n    preprocessing.StatImputer(('temperature', stats.Mean())),\n    by='weather'\n)\n\nfor x in X:\n    imp.learn_one(x)\n    print(imp.transform_one(x))\n</code></pre> <pre><code>{'weather': 'sunny', 'temperature': 8}\n{'weather': 'rainy', 'temperature': 3}\n{'weather': 'sunny', 'temperature': 8.0}\n{'weather': 'rainy', 'temperature': 4}\n{'weather': 'sunny', 'temperature': 10}\n{'weather': 'sunny', 'temperature': 9.0}\n{'weather': 'sunny', 'temperature': 12}\n{'weather': 'rainy', 'temperature': 3.5}\n</code></pre></p> <p>Note that you can also create a <code>Grouper</code> with the <code>*</code> operator:</p> <pre><code>imp = preprocessing.StatImputer(('temperature', stats.Mean())) * 'weather'\n</code></pre>"},{"location":"api/preprocessing/StatImputer/#methods","title":"Methods","text":"learn_one <p>Update with a set of features <code>x</code>.</p> <p>A lot of transformers don't actually have to do anything during the <code>learn_one</code> step because they are stateless. For this reason the default behavior of this function is to do nothing. Transformers that however do something during the <code>learn_one</code> can override this method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p></p> transform_one <p>Transform a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> </ul> <p>Returns</p> <p>dict[base.typing.FeatureName, Any]:     The transformed values.</p> <p></p>"},{"location":"api/preprocessing/TargetMinMaxScaler/","title":"TargetMinMaxScaler","text":"<p>Applies min-max scaling to the target.</p>"},{"location":"api/preprocessing/TargetMinMaxScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 base.Regressor</p> <p>Regression model to wrap.</p> </li> </ul>"},{"location":"api/preprocessing/TargetMinMaxScaler/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\nmodel = (\n    preprocessing.StandardScaler() |\n    preprocessing.TargetMinMaxScaler(\n        regressor=linear_model.LinearRegression(intercept_lr=0.15)\n    )\n)\nmetric = metrics.MSE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MSE: 2.018905\n</code></pre></p>"},{"location":"api/preprocessing/TargetMinMaxScaler/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/preprocessing/TargetStandardScaler/","title":"TargetStandardScaler","text":"<p>Applies standard scaling to the target.</p>"},{"location":"api/preprocessing/TargetStandardScaler/#parameters","title":"Parameters","text":"<ul> <li> <p>regressor</p> <p>Type \u2192 base.Regressor</p> <p>Regression model to wrap.</p> </li> </ul>"},{"location":"api/preprocessing/TargetStandardScaler/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\nmodel = (\n    preprocessing.StandardScaler() |\n    preprocessing.TargetStandardScaler(\n        regressor=linear_model.LinearRegression(intercept_lr=0.15)\n    )\n)\nmetric = metrics.MSE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MSE: 2.005999\n</code></pre></p>"},{"location":"api/preprocessing/TargetStandardScaler/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>The prediction.</p> <p></p>"},{"location":"api/proba/Beta/","title":"Beta","text":"<p>Beta distribution for binary data.</p> <p>A Beta distribution is very similar to a Bernoulli distribution in that it counts occurrences of boolean events. The differences lies in what is being measured. A Binomial distribution models the probability of an event occurring, whereas a Beta distribution models the probability distribution itself. In other words, it's a probability distribution over probability distributions.</p>"},{"location":"api/proba/Beta/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1</code></p> <p>Initial alpha parameter.</p> </li> <li> <p>beta</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1</code></p> <p>Initial beta parameter.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/Beta/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/Beta/#examples","title":"Examples","text":"<p><pre><code>from river import proba\n\nsuccesses = 81\nfailures = 219\nbeta = proba.Beta(successes, failures)\n\nbeta(.21), beta(.35)\n</code></pre> <pre><code>(0.867..., 0.165...)\n</code></pre></p> <p><pre><code>for success in range(100):\n    beta.update(True)\nfor failure in range(200):\n    beta.update(False)\n\nbeta(.21), beta(.35)\n</code></pre> <pre><code>(2.525...e-05, 0.841...)\n</code></pre></p> <p><pre><code>beta.cdf(.35)\n</code></pre> <pre><code>0.994168...\n</code></pre></p>"},{"location":"api/proba/Beta/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>p     \u2014 'float' </li> </ul> <p></p> cdf <p>Cumulative density function, i.e. P(X &lt;= x).</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> </ul> <p></p> revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p> update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> </ul> <p></p> <ol> <li> <p>What is the intuition behind beta distribution? \u21a9</p> </li> </ol>"},{"location":"api/proba/Gaussian/","title":"Gaussian","text":"<p>Normal distribution with parameters mu and sigma.</p>"},{"location":"api/proba/Gaussian/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/Gaussian/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>mu</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> <li> <p>sigma</p> </li> </ul>"},{"location":"api/proba/Gaussian/#examples","title":"Examples","text":"<p><pre><code>from river import proba\n\np = proba.Gaussian()\np.update(6)\np.update(7)\n\np\n</code></pre> <pre><code>\ud835\udca9(\u03bc=6.500, \u03c3=0.707)\n</code></pre></p> <p><pre><code>p(6.5)\n</code></pre> <pre><code>0.564189\n</code></pre></p> <p><pre><code>p.revert(7)\np\n</code></pre> <pre><code>\ud835\udca9(\u03bc=6.000, \u03c3=0.000)\n</code></pre></p>"},{"location":"api/proba/Gaussian/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Any' </li> </ul> <p></p> cdf <p>Cumulative density function, i.e. P(X &lt;= x).</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> </ul> <p></p> revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p> update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p>"},{"location":"api/proba/Multinomial/","title":"Multinomial","text":"<p>Multinomial distribution for categorical data.</p>"},{"location":"api/proba/Multinomial/#parameters","title":"Parameters","text":"<ul> <li> <p>events</p> <p>Type \u2192 dict | list | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional list of events that already occurred.</p> </li> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/Multinomial/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/Multinomial/#examples","title":"Examples","text":"<p><pre><code>from river import proba\n\np = proba.Multinomial(['green'] * 3)\np.update('red')\np('red')\n</code></pre> <pre><code>0.25\n</code></pre></p> <p><pre><code>p.update('red')\np.update('red')\np('green')\n</code></pre> <pre><code>0.5\n</code></pre></p> <p><pre><code>p.revert('red')\np.revert('red')\np('red')\n</code></pre> <pre><code>0.25\n</code></pre></p> <p>You can wrap this with a <code>utils.Rolling</code> to measure a distribution over a window:</p> <p><pre><code>from river import utils\n\nX = ['red', 'green', 'green', 'blue', 'blue']\n\ndist = utils.Rolling(\n    proba.Multinomial(),\n    window_size=3\n)\n\nfor x in X:\n    dist.update(x)\n    print(dist)\n    print()\n</code></pre> <pre><code>P(red) = 1.000\n&lt;BLANKLINE&gt;\nP(red) = 0.500\nP(green) = 0.500\n&lt;BLANKLINE&gt;\nP(green) = 0.667\nP(red) = 0.333\n&lt;BLANKLINE&gt;\nP(green) = 0.667\nP(blue) = 0.333\nP(red) = 0.000\n&lt;BLANKLINE&gt;\nP(blue) = 0.667\nP(green) = 0.333\nP(red) = 0.000\n&lt;BLANKLINE&gt;\n</code></pre></p> <p>You can wrap this with a <code>utils.Rolling</code> to measure a distribution over a window of time:</p> <p><pre><code>import datetime as dt\n\nX = ['red', 'green', 'green', 'blue']\ndays = [1, 2, 3, 4]\n\ndist = utils.TimeRolling(\n    proba.Multinomial(),\n    period=dt.timedelta(days=2)\n)\n\nfor x, day in zip(X, days):\n    dist.update(x, t=dt.datetime(2019, 1, day))\n    print(dist)\n    print()\n</code></pre> <pre><code>P(red) = 1.000\n&lt;BLANKLINE&gt;\nP(red) = 0.500\nP(green) = 0.500\n&lt;BLANKLINE&gt;\nP(green) = 1.000\nP(red) = 0.000\n&lt;BLANKLINE&gt;\nP(green) = 0.500\nP(blue) = 0.500\nP(red) = 0.000\n&lt;BLANKLINE&gt;\n</code></pre></p>"},{"location":"api/proba/Multinomial/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Any' </li> </ul> <p></p> revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Hashable' </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p> update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Hashable' </li> </ul> <p></p>"},{"location":"api/proba/MultivariateGaussian/","title":"MultivariateGaussian","text":"<p>Multivariate normal distribution with parameters mu and var.</p>"},{"location":"api/proba/MultivariateGaussian/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/MultivariateGaussian/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>mu</p> <p>The mean value of the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> <li> <p>sigma</p> <p>The standard deviation of the distribution.</p> </li> <li> <p>var</p> <p>The variance of the distribution.</p> </li> </ul>"},{"location":"api/proba/MultivariateGaussian/#examples","title":"Examples","text":"<p><pre><code>import numpy as np\nimport pandas as pd\nfrom river import proba\n\nnp.random.seed(42)\nX = pd.DataFrame(\n    np.random.random((8, 3)),\n    columns=[\"red\", \"green\", \"blue\"]\n)\nX\n</code></pre> <pre><code>        red     green      blue\n0  0.374540  0.950714  0.731994\n1  0.598658  0.156019  0.155995\n2  0.058084  0.866176  0.601115\n3  0.708073  0.020584  0.969910\n4  0.832443  0.212339  0.181825\n5  0.183405  0.304242  0.524756\n6  0.431945  0.291229  0.611853\n7  0.139494  0.292145  0.366362\n</code></pre></p> <p><pre><code>p = proba.MultivariateGaussian(seed=42)\np.n_samples\n</code></pre> <pre><code>0.0\n</code></pre></p> <p><pre><code>for x in X.to_dict(orient=\"records\"):\n    p.update(x)\np.var\n</code></pre> <pre><code>           blue     green       red\nblue   0.076119  0.020292 -0.010128\ngreen  0.020292  0.112931 -0.053268\nred   -0.010128 -0.053268  0.078961\n</code></pre></p> <p>Retrieving current state in nice format is simple <pre><code>p\n</code></pre> <pre><code>\ud835\udca9(\n    \u03bc=(0.518, 0.387, 0.416),\n    \u03c3^2=(\n        [ 0.076  0.020 -0.010]\n        [ 0.020  0.113 -0.053]\n        [-0.010 -0.053  0.079]\n    )\n)\n</code></pre></p> <p>To retrieve number of samples and mode:</p> <p><pre><code>p.n_samples\n</code></pre> <pre><code>8.0\n</code></pre> <pre><code>p.mode\n</code></pre> <pre><code>{'blue': 0.5179..., 'green': 0.3866..., 'red': 0.4158...}\n</code></pre></p> <p>To retrieve the PDF and CDF:</p> <p><pre><code>p(x)\n</code></pre> <pre><code>0.97967...\n</code></pre> <pre><code>p.cdf(x)\n</code></pre> <pre><code>0.00787...\n</code></pre></p> <p>To sample data from distribution:</p> <p><pre><code>p.sample()\n</code></pre> <pre><code>{'blue': -0.179..., 'green': -0.051..., 'red': 0.376...}\n</code></pre></p> <p>MultivariateGaussian works with <code>utils.Rolling</code>:</p> <p><pre><code>from river import utils\n\np = utils.Rolling(MultivariateGaussian(), window_size=5)\nfor x in X.to_dict(orient=\"records\"):\n    p.update(x)\np.var\n</code></pre> <pre><code>           blue     green       red\nblue   0.087062 -0.022873  0.007765\ngreen -0.022873  0.014279 -0.025181\nred    0.007765 -0.025181  0.095066\n</code></pre></p> <p>MultivariateGaussian works with <code>utils.TimeRolling</code>:</p> <p><pre><code>from datetime import datetime as dt, timedelta as td\nX.index = [dt(2023, 3, 28, 0, 0, 0) + td(seconds=x) for x in range(8)]\np = utils.TimeRolling(MultivariateGaussian(), period=td(seconds=5))\nfor t, x in X.iterrows():\n    p.update(x.to_dict(), t=t)\np.var\n</code></pre> <pre><code>           blue     green       red\nblue   0.087062 -0.022873  0.007765\ngreen -0.022873  0.014279 -0.025181\nred    0.007765 -0.025181  0.095066\n</code></pre></p> <p>Variance on diagonal is consistent with <code>proba.Gaussian</code>.</p> <p><pre><code>multi = proba.MultivariateGaussian()\nsingle = proba.Gaussian()\nfor x in X.to_dict(orient='records'):\n    multi.update(x)\n    single.update(x['blue'])\nmulti.mu['blue'] == single.mu\n</code></pre> <pre><code>True\n</code></pre> <pre><code>multi.sigma['blue']['blue'] == single.sigma\n</code></pre> <pre><code>np.True_\n</code></pre></p>"},{"location":"api/proba/MultivariateGaussian/#methods","title":"Methods","text":"call <p>PDF(x) method.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[str, float]' </li> </ul> <p></p> cdf <p>Cumulative density function, i.e. P(X &lt;= x).</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[str, float]' </li> </ul> <p></p> revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[str, float]' </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p> update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[str, float]' </li> </ul> <p></p>"},{"location":"api/proba/base/BinaryDistribution/","title":"BinaryDistribution","text":"<p>A probability distribution for discrete values.</p>"},{"location":"api/proba/base/BinaryDistribution/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/base/BinaryDistribution/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/base/BinaryDistribution/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Any' </li> </ul> <p></p> revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p> update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'bool' </li> </ul> <p></p>"},{"location":"api/proba/base/ContinuousDistribution/","title":"ContinuousDistribution","text":"<p>A probability distribution for continuous values.</p>"},{"location":"api/proba/base/ContinuousDistribution/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/base/ContinuousDistribution/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/base/ContinuousDistribution/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Any' </li> </ul> <p></p> cdf <p>Cumulative density function, i.e. P(X &lt;= x).</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> </ul> <p></p> revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p> update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'float' </li> </ul> <p></p>"},{"location":"api/proba/base/DiscreteDistribution/","title":"DiscreteDistribution","text":"<p>A probability distribution for discrete values.</p>"},{"location":"api/proba/base/DiscreteDistribution/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/base/DiscreteDistribution/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/base/DiscreteDistribution/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Any' </li> </ul> <p></p> revert <p>Reverts the parameters of the distribution for a given observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Hashable' </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p> update <p>Updates the parameters of the distribution given a new observation.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Hashable' </li> </ul> <p></p>"},{"location":"api/proba/base/Distribution/","title":"Distribution","text":"<p>General distribution.</p>"},{"location":"api/proba/base/Distribution/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generator seed for reproducibility.</p> </li> </ul>"},{"location":"api/proba/base/Distribution/#attributes","title":"Attributes","text":"<ul> <li> <p>mode</p> <p>The most likely value in the distribution.</p> </li> <li> <p>n_samples</p> <p>The number of observed samples.</p> </li> </ul>"},{"location":"api/proba/base/Distribution/#methods","title":"Methods","text":"call <p>Probability mass/density function.</p> <p>Parameters</p> <ul> <li>x     \u2014 'typing.Any' </li> </ul> <p></p> sample <p>Sample a random value from the distribution.</p> <p></p>"},{"location":"api/reco/Baseline/","title":"Baseline","text":"<p>Baseline for recommender systems.</p> <p>A first-order approximation of the bias involved in target. The model equation is defined as: </p> \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i}\\] <p>Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. </p> <p>This model expects a dict input with a <code>user</code> and an <code>item</code> entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.</p>"},{"location":"api/reco/Baseline/#parameters","title":"Parameters","text":"<ul> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the weights.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.Loss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2</p> <p>Default \u2192 <code>0.0</code></p> <p>regularization amount used to push weights towards 0.</p> </li> <li> <p>initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/Baseline/#attributes","title":"Attributes","text":"<ul> <li> <p>global_mean (stats.Mean)</p> <p>The target arithmetic mean.</p> </li> <li> <p>u_biases (collections.defaultdict)</p> <p>The user bias weights.</p> </li> <li> <p>i_biases (collections.defaultdict)</p> <p>The item bias weights.</p> </li> <li> <p>u_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user bias weights.</p> </li> <li> <p>i_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item bias weights.</p> </li> </ul>"},{"location":"api/reco/Baseline/#examples","title":"Examples","text":"<p><pre><code>from river import optim\nfrom river import reco\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, 8),\n    ({'user': 'Alice', 'item': 'Terminator'}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n    ({'user': 'Bob', 'item': 'Superman'}, 8),\n    ({'user': 'Bob', 'item': 'Terminator'}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n)\n\nmodel = reco.Baseline(optimizer=optim.SGD(0.005))\n\nfor x, y in dataset:\n    model.learn_one(**x, y=y)\n\nmodel.predict_one(user='Bob', item='Harry Potter')\n</code></pre> <pre><code>6.538120\n</code></pre></p>"},{"location":"api/reco/Baseline/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>y     \u2014 'Reward' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Reward:     The predicted preference from the user for the item.</p> <p></p> rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>items     \u2014 'set[ID]' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> <ol> <li> <p>Matrix factorization techniques for recommender systems \u21a9</p> </li> </ol>"},{"location":"api/reco/BiasedMF/","title":"BiasedMF","text":"<p>Biased Matrix Factorization for recommender systems.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle\\] <p>Where \\(bu_{u}\\) and \\(bi_{i}\\) are respectively the user and item biases. The last term being simply the dot product between the latent vectors of the given user-item pair: </p> \\[\\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] <p>where \\(k\\) is the number of latent factors. </p> <p>This model expects a dict input with a <code>user</code> and an <code>item</code> entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.</p>"},{"location":"api/reco/BiasedMF/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>bias_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the bias weights.</p> </li> <li> <p>latent_optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent weights.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.Loss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2_bias</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push bias weights towards 0.</p> </li> <li> <p>l2_latent</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push latent weights towards 0.</p> </li> <li> <p>weight_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Weights initialization scheme.</p> </li> <li> <p>latent_initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/BiasedMF/#attributes","title":"Attributes","text":"<ul> <li> <p>global_mean (stats.Mean)</p> <p>The target arithmetic mean.</p> </li> <li> <p>u_biases (collections.defaultdict)</p> <p>The user bias weights.</p> </li> <li> <p>i_biases (collections.defaultdict)</p> <p>The item bias weights.</p> </li> <li> <p>u_latents (collections.defaultdict)</p> <p>The user latent vectors randomly initialized.</p> </li> <li> <p>i_latents (collections.defaultdict)</p> <p>The item latent vectors randomly initialized.</p> </li> <li> <p>u_bias_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user bias weights.</p> </li> <li> <p>i_bias_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item bias weights.</p> </li> <li> <p>u_latent_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user latent weights.</p> </li> <li> <p>i_latent_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item latent weights.</p> </li> </ul>"},{"location":"api/reco/BiasedMF/#examples","title":"Examples","text":"<p><pre><code>from river import optim\nfrom river import reco\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, 8),\n    ({'user': 'Alice', 'item': 'Terminator'}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n    ({'user': 'Bob', 'item': 'Superman'}, 8),\n    ({'user': 'Bob', 'item': 'Terminator'}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n)\n\nmodel = reco.BiasedMF(\n    n_factors=10,\n    bias_optimizer=optim.SGD(0.025),\n    latent_optimizer=optim.SGD(0.025),\n    latent_initializer=optim.initializers.Normal(mu=0., sigma=0.1, seed=71)\n)\n\nfor x, y in dataset:\n    model.learn_one(**x, y=y)\n\nmodel.predict_one(user='Bob', item='Harry Potter')\n</code></pre> <pre><code>6.489025\n</code></pre></p>"},{"location":"api/reco/BiasedMF/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>y     \u2014 'Reward' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Reward:     The predicted preference from the user for the item.</p> <p></p> rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>items     \u2014 'set[ID]' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> <ol> <li> <p>Paterek, A., 2007, August. Improving regularized singular value decomposition for collaborative filtering. In Proceedings of KDD cup and workshop (Vol. 2007, pp. 5-8) \u21a9</p> </li> <li> <p>Matrix factorization techniques for recommender systems \u21a9</p> </li> </ol>"},{"location":"api/reco/FunkMF/","title":"FunkMF","text":"<p>Funk Matrix Factorization for recommender systems.</p> <p>The model equation is defined as: </p> \\[\\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f}\\] <p>where \\(k\\) is the number of latent factors. </p> <p>This model expects a dict input with a <code>user</code> and an <code>item</code> entries without any type constraint on their values (i.e. can be strings or numbers). Other entries are ignored.</p>"},{"location":"api/reco/FunkMF/#parameters","title":"Parameters","text":"<ul> <li> <p>n_factors</p> <p>Default \u2192 <code>10</code></p> <p>Dimensionality of the factorization or number of latent factors.</p> </li> <li> <p>optimizer</p> <p>Type \u2192 optim.base.Optimizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The sequential optimizer used for updating the latent factors.</p> </li> <li> <p>loss</p> <p>Type \u2192 optim.losses.Loss | None</p> <p>Default \u2192 <code>None</code></p> <p>The loss function to optimize for.</p> </li> <li> <p>l2</p> <p>Default \u2192 <code>0.0</code></p> <p>Amount of L2 regularization used to push weights towards 0.</p> </li> <li> <p>initializer</p> <p>Type \u2192 optim.initializers.Initializer | None</p> <p>Default \u2192 <code>None</code></p> <p>Latent factors initialization scheme.</p> </li> <li> <p>clip_gradient</p> <p>Default \u2192 <code>1000000000000.0</code></p> <p>Clips the absolute value of each gradient value.</p> </li> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/FunkMF/#attributes","title":"Attributes","text":"<ul> <li> <p>u_latents (collections.defaultdict)</p> <p>The user latent vectors randomly initialized.</p> </li> <li> <p>i_latents (collections.defaultdict)</p> <p>The item latent vectors randomly initialized.</p> </li> <li> <p>u_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the user latent weights.</p> </li> <li> <p>i_optimizer (optim.base.Optimizer)</p> <p>The sequential optimizer used for updating the item latent weights.</p> </li> </ul>"},{"location":"api/reco/FunkMF/#examples","title":"Examples","text":"<p><pre><code>from river import optim\nfrom river import reco\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, 8),\n    ({'user': 'Alice', 'item': 'Terminator'}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n    ({'user': 'Bob', 'item': 'Superman'}, 8),\n    ({'user': 'Bob', 'item': 'Terminator'}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n)\n\nmodel = reco.FunkMF(\n    n_factors=10,\n    optimizer=optim.SGD(0.1),\n    initializer=optim.initializers.Normal(mu=0., sigma=0.1, seed=11),\n)\n\nfor x, y in dataset:\n    model.learn_one(**x, y=y)\n\nmodel.predict_one(user='Bob', item='Harry Potter')\n</code></pre> <pre><code>1.866272\n</code></pre></p>"},{"location":"api/reco/FunkMF/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>y     \u2014 'Reward' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Reward:     The predicted preference from the user for the item.</p> <p></p> rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>items     \u2014 'set[ID]' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> <ol> <li> <p>Netflix update: Try this at home \u21a9</p> </li> <li> <p>Matrix factorization techniques for recommender systems \u21a9</p> </li> </ol>"},{"location":"api/reco/RandomNormal/","title":"RandomNormal","text":"<p>Predicts random values sampled from a normal distribution.</p> <p>The parameters of the normal distribution are fitted with running statistics. They parameters are independent of the user, the item, or the context, and are instead fitted globally. This recommender therefore acts as a dummy model that any serious model should easily outperform.</p>"},{"location":"api/reco/RandomNormal/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Default \u2192 <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/RandomNormal/#attributes","title":"Attributes","text":"<ul> <li> <p>mean</p> <p>stats.Mean</p> </li> <li> <p>variance</p> <p>stats.Var</p> </li> </ul>"},{"location":"api/reco/RandomNormal/#examples","title":"Examples","text":"<p><pre><code>from river import reco\n\ndataset = (\n    ({'user': 'Alice', 'item': 'Superman'}, 8),\n    ({'user': 'Alice', 'item': 'Terminator'}, 9),\n    ({'user': 'Alice', 'item': 'Star Wars'}, 8),\n    ({'user': 'Alice', 'item': 'Notting Hill'}, 2),\n    ({'user': 'Alice', 'item': 'Harry Potter'}, 5),\n    ({'user': 'Bob', 'item': 'Superman'}, 8),\n    ({'user': 'Bob', 'item': 'Terminator'}, 9),\n    ({'user': 'Bob', 'item': 'Star Wars'}, 8),\n    ({'user': 'Bob', 'item': 'Notting Hill'}, 2)\n)\n\nmodel = reco.RandomNormal(seed=42)\n\nfor x, y in dataset:\n    model.learn_one(**x, y=y)\n\nmodel.predict_one(user='Bob', item='Harry Potter')\n</code></pre> <pre><code>6.147299621751425\n</code></pre></p>"},{"location":"api/reco/RandomNormal/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>y     \u2014 'Reward' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Reward:     The predicted preference from the user for the item.</p> <p></p> rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>items     \u2014 'set[ID]' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p>"},{"location":"api/reco/base/Ranker/","title":"Ranker","text":"<p>Base class for ranking models.</p>"},{"location":"api/reco/base/Ranker/#parameters","title":"Parameters","text":"<ul> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random number generation seed. Set this for reproducibility.</p> </li> </ul>"},{"location":"api/reco/base/Ranker/#attributes","title":"Attributes","text":"<ul> <li>is_contextual</li> </ul>"},{"location":"api/reco/base/Ranker/#methods","title":"Methods","text":"learn_one <p>Fits a <code>user</code>-<code>item</code> pair and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>y     \u2014 'Reward' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> predict_one <p>Predicts the target value of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>item     \u2014 'ID' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p>Returns</p> <p>Reward:     The predicted preference from the user for the item.</p> <p></p> rank <p>Rank models by decreasing order of preference for a given user.</p> <p>Parameters</p> <ul> <li>user     \u2014 'ID' </li> <li>items     \u2014 'set[ID]' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p>"},{"location":"api/rules/AMRules/","title":"AMRules","text":"<p>Adaptive Model Rules.</p> <p>AMRules<sup>1</sup> is a rule-based algorithm for incremental regression tasks. AMRules relies on the Hoeffding bound to build its rule set, similarly to Hoeffding Trees. The Variance-Ratio heuristic is used to evaluate rules' splits. Moreover, this rule-based regressor has additional capacities not usually found in decision trees. </p> <p>Firstly, each created decision rule has a built-in drift detection mechanism. Every time a drift is detected, the affected decision rule is removed. In addition, AMRules' rules also have anomaly detection capabilities. After a warm-up period, each rule tests whether or not the incoming instances are anomalies. Anomalous instances are not used for training. </p> <p>Every time no rule is covering an incoming example, a default rule is used to learn from it. A rule covers an instance when all of the rule's literals (tests joined by the logical operation <code>and</code>) match the input case. The default rule is also applied for predicting examples not covered by any rules from the rule set.</p>"},{"location":"api/rules/AMRules/#parameters","title":"Parameters","text":"<ul> <li> <p>n_min</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>The total weight that must be observed by a rule between expansion attempts.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>The split test significance. The split confidence is given by <code>1 - delta</code>.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>The tie-breaking threshold.</p> </li> <li> <p>pred_type</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>adaptive</code></p> <p>The prediction strategy used by the decision rules. Can be either: - <code>\"mean\"</code>: outputs the target mean within the partitions defined by the decision rules. - <code>\"model\"</code>: always use instances of the model passed <code>pred_model</code> to make predictions. - <code>\"adaptive\"</code>: dynamically selects between \"mean\" and \"model\" for each incoming example. The most accurate option at the moment will be used.</p> </li> <li> <p>pred_model</p> <p>Type \u2192 base.Regressor | None</p> <p>Default \u2192 <code>None</code></p> <p>The regression model that will be replicated for every rule when <code>pred_type</code> is either <code>\"model\"</code> or <code>\"adaptive\"</code>.</p> </li> <li> <p>splitter</p> <p>Type \u2192 spl.Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>The drift detection model that is used by each rule. Care must be taken to avoid the triggering of too many false alarms or delaying too much the concept drift detection. By default, <code>drift.ADWIN</code> is used if <code>drift_detector</code> is <code>None</code>.</p> </li> <li> <p>fading_factor</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.99</code></p> <p>The exponential decaying factor applied to the learning models' absolute errors, that are monitored if <code>pred_type='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>anomaly_threshold</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>-0.75</code></p> <p>The threshold below which instances will be considered anomalies by the rules.</p> </li> <li> <p>m_min</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>30</code></p> <p>The minimum total weight a rule must observe before it starts to skip anomalous instances during training.</p> </li> <li> <p>ordered_rule_set</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If <code>True</code>, only the first rule that covers an instance will be used for training or prediction. If <code>False</code>, all the rules covering an instance will be updated during training, and the predictions for an instance will be the average prediction of all rules covering that example.</p> </li> <li> <p>min_samples_split</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The minimum number of samples each partition of a binary split candidate must have to be considered valid.</p> </li> </ul>"},{"location":"api/rules/AMRules/#attributes","title":"Attributes","text":"<ul> <li> <p>n_drifts_detected</p> <p>The number of detected concept drifts.</p> </li> </ul>"},{"location":"api/rules/AMRules/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import drift\nfrom river import evaluate\nfrom river import metrics\nfrom river import preprocessing\nfrom river import rules\n\ndataset = datasets.TrumpApproval()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    rules.AMRules(\n        delta=0.01,\n        n_min=50,\n        drift_detector=drift.ADWIN()\n    )\n)\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 1.119553\n</code></pre></p>"},{"location":"api/rules/AMRules/#methods","title":"Methods","text":"anomaly_score <p>Aggregated anomaly score computed using all the rules that cover the input instance.</p> <p>Returns the mean anomaly score, the standard deviation of the score, and the proportion of rules that cover the instance (support). If the support is zero, it means that the default rule was used (not other rule covered <code>x</code>).</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>tuple[float, float, float]:     mean_anomaly_score, std_anomaly_score, support</p> <p></p> debug_one <p>Return an explanation of how <code>x</code> is predicted</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>str:     A representation of the rules that cover the input and their prediction.</p> <p></p> learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>w     \u2014 'int'     \u2014 defaults to <code>1</code> </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/rules/AMRules/#notes","title":"Notes","text":"<p>AMRules treats all the non-numerical inputs as nominal features. All instances of <code>numbers.Number</code> will be treated as continuous, even if they represent integer categories. When using nominal features, <code>pred_type</code> should be set to \"mean\", otherwise errors will be thrown while trying to update the underlying rules' prediction models. Prediction strategies other than \"mean\" can be used, as long as the prediction model passed to <code>pred_model</code> supports nominal features.</p> <ol> <li> <p>Duarte, J., Gama, J. and Bifet, A., 2016. Adaptive model rules from high-speed data streams. ACM Transactions on Knowledge Discovery from Data (TKDD), 10(3), pp.1-22.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/sketch/Counter/","title":"Counter","text":"<p>Counting using the Count-Min Sketch (CMS) algorithm.</p> <p>Contrary to an exhaustive approach, e.g., using a <code>collections.Counter</code>, CMS uses a limited and fixed amount of memory. The CMS algorithm uses a sketch structure consisting of a matrix \\(w \\times d\\). </p> <p>These dimensions are obtained via: </p> <ul> <li> <p>\\(w = \\lceil \\frac{e}{\\epsilon} \\rceil\\), where \\(e\\) is the Euler number.</p> </li> <li> <p>\\(d = \\lceil \\ln\\left(\\frac{1}{\\delta} \\right) \\rceil\\).</p> </li> </ul> <p>Decreasing the values of \\(\\epsilon\\) (<code>epsilon</code>) and \\(\\delta\\) (<code>delta</code>) increase the accuracy of the algorithm, at the cost of increased memory usage. The values of <code>w</code> and <code>d</code> control the hash tables' capability and the amount of hash collisions, respectively. </p> <p>CMS works by keeping <code>d</code> hash tables with <code>w</code> slots each. Elements are mapped to a slot in each hash table. These tables store the counting estimates. This implementation assumes the turnstile case described in the paper, i.e., count values and updates can be negative. </p> <p>The count values obtained by CMS are always overestimates. Suppose \\(c_i\\) and \\(\\hat{c}_i\\) are the ground truth and estimated count values, respectively, for a given element \\(i\\). CMS guarantees that \\(c_i \\le \\hat{c}_i\\) and, with probability \\(1 - \\delta\\), \\(\\hat{c}_i \\le c_i + \\epsilon||\\mathbf{c}||_1\\). In the expression, \\(||\\mathbf{c}||_1 = \\sum_i |c_i|\\).</p>"},{"location":"api/sketch/Counter/#parameters","title":"Parameters","text":"<ul> <li> <p>epsilon</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.1</code></p> <p>The approximation error parameter. The error in answering a query is within a factor of <code>epsilon</code> with probability <code>delta</code>.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>A query estimates have a probability of <code>1 - delta</code> of having errors which are a factor of <code>epsilon</code>. See the CMS description above for more details.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/sketch/Counter/#attributes","title":"Attributes","text":"<ul> <li> <p>n_slots</p> <p>The number of slots in each hash table.</p> </li> <li> <p>n_tables</p> <p>The number of stored hash tables.</p> </li> </ul>"},{"location":"api/sketch/Counter/#examples","title":"Examples","text":"<pre><code>import collections\nfrom river import sketch\n\ncms = sketch.Counter(epsilon=0.005, seed=0)\n\nrng = random.Random(7)\n\ncounter = collections.Counter()\n</code></pre> <p>We can check the number of slots per hash table: <pre><code>cms.n_slots\n</code></pre> <pre><code>544\n</code></pre></p> <p>And the number of hash tables: <pre><code>cms.n_tables\n</code></pre> <pre><code>3\n</code></pre></p> <p>Let's compare the sketch against a brute force approach:</p> <pre><code>vals = []\nfor _ in range(10000):\n    v = rng.randint(-1000, 1000)\n    cms.update(v)\n    counter[v] += 1\n    vals.append(v)\n</code></pre> <p>Now, we can compare the estimates of CMS against the exhaustive counting strategy:</p> <p><pre><code>counter[7]\n</code></pre> <pre><code>5\n</code></pre> <pre><code>cms[7]\n</code></pre> <pre><code>12\n</code></pre> <pre><code>counter[532]\n</code></pre> <pre><code>4\n</code></pre> <pre><code>cms[532]\n</code></pre> <pre><code>15\n</code></pre></p> <p>Keep in mind that CMS is an approximate sketch algorithm. Counting estimates for unseen values might not be always reliable:</p> <p><pre><code>cms[1001]\n</code></pre> <pre><code>9\n</code></pre></p> <p>We can check the number of elements stored by each approach:</p> <p><pre><code>len(counter), len(cms)\n</code></pre> <pre><code>(1982, 1632)\n</code></pre></p> <p>And also retrieve the total sum of counts:</p> <p><pre><code>cms.total()\n</code></pre> <pre><code>10000\n</code></pre></p> <p>We can decrease the error by allocating more memory in the CMS:</p> <p><pre><code>cms_a = sketch.Counter(epsilon=0.001, delta=0.01, seed=0)\nfor v in vals:\n    cms_a.update(v)\n\ncms_a[7]\n</code></pre> <pre><code>5\n</code></pre> <pre><code>cms_a[532]\n</code></pre> <pre><code>4\n</code></pre></p> <p>We can also obtain estimates of the dot product between two instances of <code>river.collections.Counter</code>. This could be useful, for instance, to estimate the cosine distance between the data monitored in two different counter sketch instances. Suppose we create another CMS instance (the number of slots and hash tables must match) that monitors another sample of the same data generating process:</p> <pre><code>cms_b = sketch.Counter(epsilon=0.001, delta=0.01, seed=7)\n\nfor _ in range(10000):\n    v = rng.randint(-1000, 1000)\n    cms_b.update(v)\n</code></pre> <p>Now, we can define a cosine distance function:</p> <pre><code>def cosine_dist(cms_a, cms_b):\n    num = cms_a @ cms_b\n    den = math.sqrt(cms_a @ cms_a) * math.sqrt(cms_b @ cms_b)\n    return (num / den).item()\n</code></pre> <p>And use it to calculate the cosine distance between the elements monitored in <code>cms_a</code> and <code>cms_b</code>:</p> <p><pre><code>cosine_dist(cms_a, cms_b)\n</code></pre> <pre><code>0.175363...\n</code></pre></p>"},{"location":"api/sketch/Counter/#methods","title":"Methods","text":"total <p>Return the total count.</p> <p></p> update <ol> <li> <p>Cormode, G., &amp; Muthukrishnan, S. (2005). An improved data stream summary: the count-min sketch and its applications. Journal of Algorithms, 55(1), 58-75. \u21a9</p> </li> <li> <p>Count-Min Sketch \u21a9</p> </li> <li> <p>Hash functions family generator in Python \u21a9</p> </li> </ol>"},{"location":"api/sketch/HeavyHitters/","title":"HeavyHitters","text":"<p>Find the Heavy Hitters using the Lossy Count with Forgetting factor algorithm<sup>1</sup>.</p> <p>Keep track of the most frequent item(set)s in a data stream and apply a forgetting factor to discard previous frequent items that do not often appear anymore. This is an approximation algorithm designed to work with a limited amount of memory rather than accounting for every possible solution (thus using an unbounded memory footprint). Any hashable type can be passed as input, hence tuples or frozensets can also be monitored. </p> <p>Considering a data stream where <code>n</code> elements were observed so far, the Lossy Count algorithm has the following properties: </p> <ul> <li>All item(set)s whose true frequency exceeds <code>support * n</code> are output. There are no</li> </ul> <p>false negatives; </p> <ul> <li> <p>No item(set) whose true frequency is less than <code>(support - epsilon) * n</code> is outputted;</p> </li> <li> <p>Estimated frequencies are less than the true frequencies by at most <code>epsilon * n</code>.</p> </li> </ul>"},{"location":"api/sketch/HeavyHitters/#parameters","title":"Parameters","text":"<ul> <li> <p>support</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.001</code></p> <p>The support threshold used to determine if an item is frequent. The value of <code>support</code> must be in \\([0, 1]\\). Elements whose frequency is higher than <code>support</code> times the number of observations seen so far are outputted.</p> </li> <li> <p>epsilon</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.005</code></p> <p>Error parameter to control the accuracy-memory tradeoff. The value of <code>epsilon</code> must be in \\((0, 1]\\) and typically <code>epsilon</code> \\(\\ll\\) <code>support</code>. The smaller the <code>epsilon</code>, the more accurate the estimates will be, but the count sketch will have an increased memory footprint.</p> </li> <li> <p>fading_factor</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.999</code></p> <p>Forgetting factor applied to the frequency estimates to reduce the impact of old items. The value of <code>fading_factor</code> must be in \\((0, 1]\\).</p> </li> </ul>"},{"location":"api/sketch/HeavyHitters/#examples","title":"Examples","text":"<pre><code>import random\nimport string\nfrom river import sketch\n\nrng = random.Random(42)\nhh = sketch.HeavyHitters()\n</code></pre> <p>We will feed the counter with printable ASCII characters:</p> <pre><code>for _ in range(10_000):\n    hh.update(rng.choice(string.printable))\n</code></pre> <p>We can retrieve estimates of the <code>n</code> top elements and their frequencies. Let's try <code>n=3</code> <pre><code>hh.most_common(3)\n</code></pre> <pre><code>[(',', 122.099142...), ('[', 116.049510...), ('W', 115.013402...)]\n</code></pre></p> <p>We can also access estimates of individual elements:</p> <p><pre><code>hh['A']\n</code></pre> <pre><code>99.483575...\n</code></pre></p> <p>Unobserved elements are handled just fine: <pre><code>hh[(1, 2, 3)]\n</code></pre> <pre><code>0.0\n</code></pre></p>"},{"location":"api/sketch/HeavyHitters/#methods","title":"Methods","text":"most_common update <ol> <li> <p>Veloso, B., Tabassum, S., Martins, C., Espanha, R., Azevedo, R., &amp; Gama, J. (2020). Interconnect bypass fraud detection: a case study. Annals of Telecommunications, 75(9), 583-596.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/sketch/Histogram/","title":"Histogram","text":"<p>Streaming histogram.</p>"},{"location":"api/sketch/Histogram/#parameters","title":"Parameters","text":"<ul> <li> <p>max_bins</p> <p>Default \u2192 <code>256</code></p> <p>Maximal number of bins.</p> </li> </ul>"},{"location":"api/sketch/Histogram/#attributes","title":"Attributes","text":"<ul> <li> <p>n</p> <p>Total number of seen values.</p> </li> </ul>"},{"location":"api/sketch/Histogram/#examples","title":"Examples","text":"<p><pre><code>from river import sketch\nimport numpy as np\n\nnp.random.seed(42)\n\nvalues = np.hstack((\n    np.random.normal(-3, 1, 1000),\n    np.random.normal(3, 1, 1000),\n))\n\nhist = sketch.Histogram(max_bins=15)\n\nfor x in values:\n    hist.update(x)\n\nfor bin in hist:\n    print(bin)\n</code></pre> <pre><code>[-6.24127, -6.24127]: 1\n[-5.69689, -5.19881]: 8\n[-5.12390, -4.43014]: 57\n[-4.42475, -3.72574]: 158\n[-3.71984, -3.01642]: 262\n[-3.01350, -2.50668]: 206\n[-2.50329, -0.81020]: 294\n[-0.80954, 0.29677]: 19\n[0.40896, 0.82733]: 7\n[0.84661, 1.25147]: 24\n[1.26029, 2.30758]: 178\n[2.31081, 3.05701]: 284\n[3.05963, 3.69695]: 242\n[3.69822, 5.64434]: 258\n[6.13775, 6.19311]: 2\n</code></pre></p>"},{"location":"api/sketch/Histogram/#methods","title":"Methods","text":"cdf <p>Cumulative distribution function.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p></p> iter_cdf <p>Yields CDF values for a sorted iterable of values.</p> <p>This is faster than calling <code>cdf</code> with many values.</p> <p>Parameters</p> <ul> <li>X </li> <li>verbose     \u2014 defaults to <code>False</code> </li> </ul> <p></p> <ol> <li> <p>Ben-Haim, Y. and Tom-Tov, E., 2010. A streaming parallel decision tree algorithm. Journal of Machine Learning Research, 11(Feb), pp.849-872. \u21a9</p> </li> <li> <p>Go implementation \u21a9</p> </li> </ol>"},{"location":"api/sketch/Set/","title":"Set","text":"<p>Approximate tracking of observed items using Bloom filters.</p> <p>Bloom filters enable using a limited amount of memory to check whether a given item was already observed in a stream. They can be used similarly to Python's built-in sets with the difference that items are not explicitly stored. For that reason, element removal and set difference are not currently supported. </p> <p>Bloom filters store a bit array and map incoming items to <code>k</code> index positions in the such array. The selected positions are set to <code>True</code>. Therefore, a binary code representation is created for each item. Membership works by projecting the query item and checking if every position of its binary code is <code>True</code>. If that is not the case, the item was not observed yet. A nice property of Bloom filters is that they do not yield false negatives: unobserved items might be signalized as observed, but observed items are never signalized as unobserved. </p> <p>If more than one item has the same binary code, i.e., hash collisions happen, the accuracy of the Bloom filter decreases, and false positives are produced. For instance, a previously unobserved item is signalized as observed. Increasing the size of the binary array and the value of <code>k</code> increase the filter's accuracy as hash collisions are avoided. Nonetheless, even using an increased number of hash functions, hash collisions will frequently happen if the array capacity is too small. The length of the bit array and the number of hash functions are inferred automatically from the supplied <code>capacity</code> and <code>fp_rate</code>.</p>"},{"location":"api/sketch/Set/#parameters","title":"Parameters","text":"<ul> <li> <p>capacity</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2048</code></p> <p>The maximum capacity of the Bloom filter, i.e., the maximum number of distinct items to store given the selected <code>fp_rate</code>.</p> </li> <li> <p>fp_rate</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>The allowed rate of false positives. The probability of obtaining a true positive is <code>1 - fp_rate</code>.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/sketch/Set/#attributes","title":"Attributes","text":"<ul> <li> <p>n_bits</p> <p>Return the size of the binary array used by the Bloom filter.</p> </li> <li> <p>n_hash</p> <p>Return the number of used hash functions.</p> </li> </ul>"},{"location":"api/sketch/Set/#examples","title":"Examples","text":"<pre><code>import random\nfrom river import sketch\n\nrng = random.Random(42)\ns_set = sketch.Set(capacity=100, seed=0)\n</code></pre> <p>We can retrieve the number of selected hash functions:</p> <p><pre><code>s_set.n_hash\n</code></pre> <pre><code>7\n</code></pre></p> <p>And the size of the binary array used by the Bloom filter: <pre><code>s_set.n_bits\n</code></pre> <pre><code>959\n</code></pre></p> <p>We can add new items and check for membership using the same calls used by Python's standard sets: <pre><code>for _ in range(1000):\n    s_set.add(rng.randint(0, 200))\n\n1 in s_set\n</code></pre> <pre><code>True\n</code></pre></p> <p>False positives might happen if the capacity is not large enough: <pre><code>-10 in s_set\n</code></pre> <pre><code>True\n</code></pre></p> <p>Iterables can also be supplied to perform multiple updates with a single call to <code>update</code>: <pre><code>s_set = s_set.update([1, 2, 3, 4, 5, 6, 7])\n</code></pre></p> <p>We can also combine instances of <code>sketch.Set</code> using the intersection and union operations, as long as they share the same hash functions and capability. In other words, all they hyperparameters match. Let's create two instances that will monitor different portions of a stream of random numbers:</p> <p><pre><code>s1 = sketch.Set(seed=8)\ns2 = sketch.Set(seed=8)\n\nfor _ in range(1000):\n    s1.add(rng.randint(0, 5000))\n\nfor _ in range(1000):\n    s2.add(rng.randint(0, 5000))\n\n43 in s1\n</code></pre> <pre><code>True\n</code></pre> <pre><code>43 in s2\n</code></pre> <pre><code>False\n</code></pre></p> <p>We can get the intersection between the two instances by using:</p> <p><pre><code>s_intersection = s1 &amp; s2\n43 in s_intersection\n</code></pre> <pre><code>False\n</code></pre></p> <p>We can also obtain the set union:</p> <p><pre><code>s_union = s1 | s2\n\n43 in s_union\n</code></pre> <pre><code>True\n</code></pre></p> <p>The same effect of the non-inplace dunder methods can be achieved via explicit method calls:</p> <p><pre><code>43 in s1.intersection(s2)\n</code></pre> <pre><code>False\n</code></pre></p> <p><pre><code>43 in s1.union(s2)\n</code></pre> <pre><code>True\n</code></pre></p>"},{"location":"api/sketch/Set/#methods","title":"Methods","text":"add intersection <p>Set intersection.</p> <p>Return a new instance that results from the set intersection between the current <code>Set</code> object and <code>other</code>. Dunder operators can be used to replace the method call, i.e., <code>a &amp;= b</code> and <code>a &amp; b</code> for inplace and non-inplace intersections, respectively.</p> <p>Parameters</p> <ul> <li>other     \u2014 'Set' </li> </ul> <p></p> union <p>Set union.</p> <p>Return a new instance that results from the set union between the current <code>Set</code> object and <code>other</code>. Dunder operators can be used to replace the method call, i.e., <code>a |= b</code> and <code>a | b</code> for inplace and non-inplace unions, respectively.</p> <p>Parameters</p> <ul> <li>other     \u2014 'Set' </li> </ul> <p></p> update"},{"location":"api/sketch/Set/#notes","title":"Notes","text":"<p>This implementation uses an integer to represent the binary array. Bitwise operations are performed in the integer to reflect the Bloom filter updates.</p> <ol> <li> <p>Florian Hartmann's blog article on Bloom Filters.\u00a0\u21a9</p> </li> <li> <p>Wikipedia entry on Bloom filters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/stats/AbsMax/","title":"AbsMax","text":"<p>Running absolute max.</p>"},{"location":"api/stats/AbsMax/#attributes","title":"Attributes","text":"<ul> <li> <p>abs_max (float)</p> <p>The current absolute max.</p> </li> </ul>"},{"location":"api/stats/AbsMax/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, -4, 3, -2, 5, -6]\nabs_max = stats.AbsMax()\nfor x in X:\n    abs_max.update(x)\n    print(abs_max.get())\n</code></pre> <pre><code>1\n4\n4\n4\n5\n6\n</code></pre></p>"},{"location":"api/stats/AbsMax/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/AutoCorr/","title":"AutoCorr","text":"<p>Measures the serial correlation.</p> <p>This method computes the Pearson correlation between the current value and the value seen <code>n</code> steps before.</p>"},{"location":"api/stats/AutoCorr/#parameters","title":"Parameters","text":"<ul> <li> <p>lag</p> <p>Type \u2192 int</p> </li> </ul>"},{"location":"api/stats/AutoCorr/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/AutoCorr/#examples","title":"Examples","text":"<p>The following examples are taken from the pandas documentation.</p> <p><pre><code>from river import stats\n\nauto_corr = stats.AutoCorr(lag=1)\nfor x in [0.25, 0.5, 0.2, -0.05]:\n    auto_corr.update(x)\n    print(auto_corr.get())\n</code></pre> <pre><code>0\n0\n-1.0\n0.103552\n</code></pre></p> <p><pre><code>auto_corr = stats.AutoCorr(lag=2)\nfor x in [0.25, 0.5, 0.2, -0.05]:\n    auto_corr.update(x)\n    print(auto_corr.get())\n</code></pre> <pre><code>0\n0\n0\n-1.0\n</code></pre></p> <p><pre><code>auto_corr = stats.AutoCorr(lag=1)\nfor x in [1, 0, 0, 0]:\n    auto_corr.update(x)\n    print(auto_corr.get())\n</code></pre> <pre><code>0\n0\n0\n0\n</code></pre></p>"},{"location":"api/stats/AutoCorr/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/BayesianMean/","title":"BayesianMean","text":"<p>Estimates a mean using outside information.</p>"},{"location":"api/stats/BayesianMean/#parameters","title":"Parameters","text":"<ul> <li> <p>prior</p> <p>Type \u2192 float</p> </li> <li> <p>prior_weight</p> <p>Type \u2192 float</p> </li> </ul>"},{"location":"api/stats/BayesianMean/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/BayesianMean/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Additive smoothing \u21a9</p> </li> <li> <p>Bayesian average \u21a9</p> </li> <li> <p>Practical example of Bayes estimators \u21a9</p> </li> </ol>"},{"location":"api/stats/Count/","title":"Count","text":"<p>A simple counter.</p>"},{"location":"api/stats/Count/#attributes","title":"Attributes","text":"<ul> <li> <p>n (int)</p> <p>The current number of observations.</p> </li> </ul>"},{"location":"api/stats/Count/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number'     \u2014 defaults to <code>None</code> </li> </ul> <p></p>"},{"location":"api/stats/Cov/","title":"Cov","text":"<p>Covariance.</p>"},{"location":"api/stats/Cov/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof</p> <p>Default \u2192 <code>1</code></p> <p>Delta Degrees of Freedom.</p> </li> </ul>"},{"location":"api/stats/Cov/#attributes","title":"Attributes","text":"<ul> <li>n</li> </ul>"},{"location":"api/stats/Cov/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nx = [-2.1,  -1,  4.3]\ny = [   3, 1.1, 0.12]\n\ncov = stats.Cov()\n\nfor xi, yi in zip(x, y):\n    cov.update(xi, yi)\n    print(cov.get())\n</code></pre> <pre><code>0.0\n-1.044999\n-4.286\n</code></pre></p> <p>This class has a <code>revert</code> method, and can thus be wrapped by <code>utils.Rolling</code>:</p> <p><pre><code>from river import utils\n\nx = [-2.1,  -1, 4.3, 1, -2.1,  -1, 4.3]\ny = [   3, 1.1, .12, 1,    3, 1.1, .12]\n\nrcov = utils.Rolling(stats.Cov(), window_size=3)\n\nfor xi, yi in zip(x, y):\n    rcov.update(xi, yi)\n    print(rcov.get())\n</code></pre> <pre><code>0.0\n-1.045\n-4.286\n-1.382\n-4.589\n-1.415\n-4.286\n</code></pre></p>"},{"location":"api/stats/Cov/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update_many"},{"location":"api/stats/Cov/#notes","title":"Notes","text":"<p>The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\).</p> <ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> <li> <p>Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-) variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/stats/EWMean/","title":"EWMean","text":"<p>Exponentially weighted mean.</p>"},{"location":"api/stats/EWMean/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor</p> <p>Default \u2192 <code>0.5</code></p> <p>The closer <code>fading_factor</code> is to 1 the more the statistic will adapt to recent values.</p> </li> </ul>"},{"location":"api/stats/EWMean/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/EWMean/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, 3, 5, 4, 6, 8, 7, 9, 11]\newm = stats.EWMean(fading_factor=0.5)\nfor x in X:\n    ewm.update(x)\n    print(ewm.get())\n</code></pre> <pre><code>1.0\n2.0\n3.5\n3.75\n4.875\n6.4375\n6.71875\n7.859375\n9.4296875\n</code></pre></p>"},{"location":"api/stats/EWMean/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9</p> </li> <li> <p>Exponential Moving Average on Streaming Data \u21a9</p> </li> </ol>"},{"location":"api/stats/EWVar/","title":"EWVar","text":"<p>Exponentially weighted variance.</p> <p>To calculate the variance we use the fact that Var(X) = Mean(x^2) - Mean(x)^2 and internally we use the exponentially weighted mean of x/x^2 to calculate this.</p>"},{"location":"api/stats/EWVar/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor</p> <p>Default \u2192 <code>0.5</code></p> <p>The closer <code>fading_factor</code> is to 1 the more the statistic will adapt to recent values.</p> </li> </ul>"},{"location":"api/stats/EWVar/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/EWVar/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, 3, 5, 4, 6, 8, 7, 9, 11]\newv = stats.EWVar(fading_factor=0.5)\nfor x in X:\n    ewv.update(x)\n    print(ewv.get())\n</code></pre> <pre><code>0.0\n1.0\n2.75\n1.4375\n1.984375\n3.43359375\n1.7958984375\n2.198974609375\n3.56536865234375\n</code></pre></p>"},{"location":"api/stats/EWVar/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9</p> </li> <li> <p>Exponential Moving Average on Streaming Data \u21a9</p> </li> </ol>"},{"location":"api/stats/Entropy/","title":"Entropy","text":"<p>Running entropy.</p>"},{"location":"api/stats/Entropy/#parameters","title":"Parameters","text":"<ul> <li> <p>fading_factor</p> <p>Default \u2192 <code>1</code></p> <p>Fading factor.</p> </li> <li> <p>eps</p> <p>Default \u2192 <code>1e-08</code></p> <p>Small value that will be added to the denominator to avoid division by zero.</p> </li> </ul>"},{"location":"api/stats/Entropy/#attributes","title":"Attributes","text":"<ul> <li> <p>entropy (float)</p> <p>The running entropy.</p> </li> <li> <p>n (int)</p> <p>The current number of observations.</p> </li> <li> <p>counter (collections.Counter)</p> <p>Count the number of times the values have occurred</p> </li> </ul>"},{"location":"api/stats/Entropy/#examples","title":"Examples","text":"<p><pre><code>import math\nimport random\nimport numpy as np\nfrom scipy.stats import entropy\nfrom river import stats\n\ndef entropy_list(labels, base=None):\n    value,counts = np.unique(labels, return_counts=True)\n    return entropy(counts, base=base)\n\nSEED = 42 * 1337\nrandom.seed(SEED)\n\nentro = stats.Entropy(fading_factor=1)\n\nlist_animal = []\nfor animal, num_val in zip(['cat', 'dog', 'bird'],[301, 401, 601]):\n    list_animal += [animal for i in range(num_val)]\nrandom.shuffle(list_animal)\n\nfor animal in list_animal:\n    entro.update(animal)\n\nprint(f'{entro.get():.6f}')\n</code></pre> <pre><code>1.058093\n</code></pre> <pre><code>print(f'{entropy_list(list_animal):.6f}')\n</code></pre> <pre><code>1.058093\n</code></pre></p>"},{"location":"api/stats/Entropy/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Sovdat, B., 2014. Updating Formulas and Algorithms for Computing Entropy and Gini Index from Time-Changing Data Streams. arXiv preprint arXiv:1403.6348. \u21a9</p> </li> </ol>"},{"location":"api/stats/IQR/","title":"IQR","text":"<p>Computes the interquartile range.</p>"},{"location":"api/stats/IQR/#parameters","title":"Parameters","text":"<ul> <li> <p>q_inf</p> <p>Default \u2192 <code>0.25</code></p> <p>Desired inferior quantile, must be between 0 and 1. Defaults to <code>0.25</code>.</p> </li> <li> <p>q_sup</p> <p>Default \u2192 <code>0.75</code></p> <p>Desired superior quantile, must be between 0 and 1. Defaults to <code>0.75</code>.</p> </li> </ul>"},{"location":"api/stats/IQR/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/IQR/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\niqr = stats.IQR(q_inf=0.25, q_sup=0.75)\n\nfor i in range(0, 1001):\n    iqr.update(i)\n    if i % 100 == 0:\n        print(iqr.get())\n</code></pre> <pre><code>0.0\n50.0\n100.0\n150.0\n200.0\n250.0\n300.0\n350.0\n400.0\n450.0\n500.0\n</code></pre></p>"},{"location":"api/stats/IQR/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/KolmogorovSmirnov/","title":"KolmogorovSmirnov","text":"<p>Incremental Kolmogorov-Smirnov statistics.</p> <p>The two-sample Kolmogorov-Smirnov test quantifies the distance between the empirical functions of two samples, with the null distribution of this statistic is calculated under the null hypothesis that the samples are drawn from the same distribution. The formula can be described as </p> \\[ D_{n, m} = \\sup_x \\| F_{1, n}(x) - F_{2, m}(x) \\|. \\] <p>This implementation is the incremental version of the previously mentioned statistics, with the change being in the ability to insert and remove an observation through time. This can be done using a randomized tree called Treap (or Cartesian Tree) <sup>2</sup> with bulk operation and lazy propagation. </p> <p>The implemented algorithm is able to perform the insertion and removal operations in O(logN) with high probability and calculate the Kolmogorov-Smirnov test in O(1), where N is the number of sample observations. This is a significant improvement compared to the O(N logN) cost of non-incremental implementation. </p> <p>This implementation also supports the calculation of the Kuiper statistics. Different from the original Kolmogorov-Smirnov statistics, Kuiper's test <sup>3</sup> calculates the sum of the absolute sizes of the most positive and most negative differences between the two cumulative distribution functions taken into account. As such, Kuiper's test is very sensitive in the tails as at the median. </p> <p>Last but not least, this implementation is also based on the original implementation within the supplementary material of the authors of paper <sup>1</sup>, at the following Github repository.</p>"},{"location":"api/stats/KolmogorovSmirnov/#parameters","title":"Parameters","text":"<ul> <li> <p>statistic</p> <p>Default \u2192 <code>ks</code></p> <p>The method used to calculate the statistic, can be either \"ks\" or \"kuiper\". The default value is set as \"ks\".</p> </li> </ul>"},{"location":"api/stats/KolmogorovSmirnov/#examples","title":"Examples","text":"<p><pre><code>import numpy as np\nfrom river import stats\n\nstream_a = [1, 1, 2, 2, 3, 3, 4, 4]\nstream_b = [1, 1, 1, 1, 2, 2, 2, 2]\n\nincremental_ks = stats.KolmogorovSmirnov(statistic=\"ks\")\nfor a, b in zip(stream_a, stream_b):\n    incremental_ks.update(a, b)\n\nincremental_ks\n</code></pre> <pre><code>KolmogorovSmirnov: 0.5\n</code></pre></p> <p><pre><code>incremental_ks.n_samples\n</code></pre> <pre><code>8\n</code></pre></p>"},{"location":"api/stats/KolmogorovSmirnov/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> <ol> <li> <p>dos Reis, D.M. et al. (2016) \u2018Fast unsupervised online drift detection using incremental Kolmogorov-Smirnov test\u2019, Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. doi:10.1145/2939672.2939836.\u00a0\u21a9</p> </li> <li> <p>C. R. Aragon and R. G. Seidel. Randomized search trees. In FOCS, pages 540\u2013545. IEEE, 1989.\u00a0\u21a9</p> </li> <li> <p>Kuiper, N. H. (1960). \"Tests concerning random points on a circle\". Proceedings of the Koninklijke Nederlandse Akademie van Wetenschappen, Series A. 63: 38\u201347.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/stats/Kurtosis/","title":"Kurtosis","text":"<p>Running kurtosis using Welford's algorithm.</p>"},{"location":"api/stats/Kurtosis/#parameters","title":"Parameters","text":"<ul> <li> <p>bias</p> <p>Default \u2192 <code>False</code></p> <p>If <code>False</code>, then the calculations are corrected for statistical bias.</p> </li> </ul>"},{"location":"api/stats/Kurtosis/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Kurtosis/#examples","title":"Examples","text":"<p><pre><code>from river import stats\nimport scipy.stats\nimport numpy as np\n\nnp.random.seed(42)\nX = np.random.normal(loc=0, scale=1, size=10)\n\nkurtosis = stats.Kurtosis(bias=False)\nfor x in X:\n    kurtosis.update(x)\n    print(kurtosis.get())\n</code></pre> <pre><code>-3.0\n-2.0\n-1.5\n1.4130027920707047\n0.15367976585756438\n0.46142633246812653\n-1.620647789230658\n-1.3540178492487054\n-1.2310268787102745\n-0.9490372374384453\n</code></pre></p> <p><pre><code>for i in range(2, len(X)+1):\n    print(scipy.stats.kurtosis(X[:i], bias=False))\n</code></pre> <pre><code>-2.0\n-1.4999999999999998\n1.4130027920707082\n0.15367976585756082\n0.46142633246812403\n-1.620647789230658\n-1.3540178492487063\n-1.2310268787102738\n-0.9490372374384459\n</code></pre></p> <p><pre><code>kurtosis = stats.Kurtosis(bias=True)\nfor x in X:\n    kurtosis.update(x)\n    print(kurtosis.get())\n</code></pre> <pre><code>-3.0\n-2.0\n-1.5\n-1.011599627723906\n-0.9615800585356089\n-0.6989395431537853\n-1.4252699121794408\n-1.311437071070812\n-1.246289111322894\n-1.082283689864171\n</code></pre></p> <p><pre><code>for i in range(2, len(X)+1):\n    print(scipy.stats.kurtosis(X[:i], bias=True))\n</code></pre> <pre><code>-2.0\n-1.4999999999999998\n-1.0115996277239057\n-0.9615800585356098\n-0.6989395431537861\n-1.425269912179441\n-1.3114370710708125\n-1.2462891113228936\n-1.0822836898641714\n</code></pre></p>"},{"location":"api/stats/Kurtosis/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> </ol>"},{"location":"api/stats/Link/","title":"Link","text":"<p>A link joins two univariate statistics as a sequence.</p> <p>This can be used to pipe the output of one statistic to the input of another. This can be used, for instance, to calculate the mean of the variance of a variable. It can also be used to compute shifted statistics by piping statistics with an instance of <code>stats.Shift</code>. </p> <p>Note that a link is not meant to be instantiated via this class definition. Instead, users can link statistics together via the <code>|</code> operator.</p>"},{"location":"api/stats/Link/#parameters","title":"Parameters","text":"<ul> <li> <p>left</p> <p>Type \u2192 stats.base.Univariate</p> </li> <li> <p>right</p> <p>Type \u2192 stats.base.Univariate</p> <p>The output from <code>left</code>'s <code>get</code> method is passed to <code>right</code>'s <code>update</code> method if <code>left</code>'s <code>get</code> method doesn't produce <code>None.</code></p> </li> </ul>"},{"location":"api/stats/Link/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Link/#examples","title":"Examples","text":"<pre><code>from river import stats\nstat = stats.Shift(1) | stats.Mean()\n</code></pre> <p>No values have been seen, therefore <code>get</code> defaults to the initial value of <code>stats.Mean</code>, which is 0.</p> <p><pre><code>stat.get()\n</code></pre> <pre><code>0.\n</code></pre></p> <p>Let us now call <code>update</code>.</p> <pre><code>stat.update(1)\n</code></pre> <p>The output from <code>get</code> will still be 0. The reason is that <code>stats.Shift</code> has not enough values, and therefore outputs its default value, which is <code>None</code>. The <code>stats.Mean</code> instance is therefore not updated.</p> <p><pre><code>stat.get()\n</code></pre> <pre><code>0.0\n</code></pre></p> <p>On the next call to <code>update</code>, the <code>stats.Shift</code> instance has seen enough values, and therefore the mean can be updated. The mean is therefore equal to 1, because that's the only value from the past.</p> <p><pre><code>stat.update(3)\nstat.get()\n</code></pre> <pre><code>1.0\n</code></pre></p> <p>On the subsequent call to update, the mean will be updated with the value 3.</p> <p><pre><code>stat.update(4)\nstat.get()\n</code></pre> <pre><code>2.0\n</code></pre></p> <p>Note that composing statistics returns a new statistic with its own name.</p> <p><pre><code>stat.name\n</code></pre> <pre><code>'mean_of_shift_1'\n</code></pre></p>"},{"location":"api/stats/Link/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/MAD/","title":"MAD","text":"<p>Median Absolute Deviation (MAD).</p> <p>The median absolute deviation is the median of the absolute differences between each data point and the data's overall median. In an online setting, the median of the data is unknown beforehand. Therefore, both the median of the data and the median of the differences of the data with respect to the latter are updated online. To be precise, the median of the data is updated before the median of the differences. As a consequence, this online version of the MAD does not coincide exactly with its batch counterpart.</p>"},{"location":"api/stats/MAD/#attributes","title":"Attributes","text":"<ul> <li> <p>median (stats.Median)</p> <p>The median of the data.</p> </li> </ul>"},{"location":"api/stats/MAD/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [4, 2, 5, 3, 0, 4]\n\nmad = stats.MAD()\nfor x in X:\n    mad.update(x)\n    print(mad.get())\n</code></pre> <pre><code>0.0\n2.0\n1.0\n1.0\n1.0\n1.0\n</code></pre></p>"},{"location":"api/stats/MAD/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Median absolute deviation article on Wikipedia \u21a9</p> </li> </ol>"},{"location":"api/stats/Max/","title":"Max","text":"<p>Running max.</p>"},{"location":"api/stats/Max/#attributes","title":"Attributes","text":"<ul> <li> <p>max (float)</p> <p>The current max.</p> </li> </ul>"},{"location":"api/stats/Max/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, -4, 3, -2, 5, -6]\nmaximum = stats.Max()\nfor x in X:\n    maximum.update(x)\n    print(maximum.get())\n</code></pre> <pre><code>1\n1\n3\n3\n5\n5\n</code></pre></p>"},{"location":"api/stats/Max/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/Mean/","title":"Mean","text":"<p>Running mean.</p>"},{"location":"api/stats/Mean/#attributes","title":"Attributes","text":"<ul> <li> <p>n (float)</p> <p>The current sum of weights. If each passed weight was 1, then this is equal to the number of seen observations.</p> </li> </ul>"},{"location":"api/stats/Mean/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [-5, -3, -1, 1, 3, 5]\nmean = stats.Mean()\nfor x in X:\n    mean.update(x)\n    print(mean.get())\n</code></pre> <pre><code>-5.0\n-4.0\n-3.0\n-2.0\n-1.0\n0.0\n</code></pre></p> <p>You can calculate a rolling average by wrapping a <code>utils.Rolling</code> around:</p> <p><pre><code>from river import utils\n\nX = [1, 2, 3, 4, 5, 6]\nrmean = utils.Rolling(stats.Mean(), window_size=2)\n\nfor x in X:\n    rmean.update(x)\n    print(rmean.get())\n</code></pre> <pre><code>1.0\n1.5\n2.5\n3.5\n4.5\n5.5\n</code></pre></p>"},{"location":"api/stats/Mean/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update_many <ol> <li> <p>West, D. H. D. (1979). Updating mean and variance estimates: An improved method. Communications of the ACM, 22(9), 532-535. \u21a9</p> </li> <li> <p>Finch, T., 2009. Incremental calculation of weighted mean and variance. University of Cambridge, 4(11-5), pp.41-42. \u21a9</p> </li> <li> <p>Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9</p> </li> </ol>"},{"location":"api/stats/Min/","title":"Min","text":"<p>Running min.</p>"},{"location":"api/stats/Min/#attributes","title":"Attributes","text":"<ul> <li> <p>min (float)</p> <p>The current min.</p> </li> </ul>"},{"location":"api/stats/Min/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/Mode/","title":"Mode","text":"<p>Running mode.</p> <p>The mode is simply the most common value. An approximate mode can be computed by setting the number of first unique values to count.</p>"},{"location":"api/stats/Mode/#parameters","title":"Parameters","text":"<ul> <li> <p>k</p> <p>Default \u2192 <code>25</code></p> <p>Only the first <code>k</code> unique values will be included. If <code>k</code> equals -1, the exact mode is computed.</p> </li> </ul>"},{"location":"api/stats/Mode/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Mode/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = ['sunny', 'cloudy', 'cloudy', 'rainy', 'rainy', 'rainy']\nmode = stats.Mode(k=2)\nfor x in X:\n    mode.update(x)\n    print(mode.get())\n</code></pre> <pre><code>sunny\nsunny\ncloudy\ncloudy\ncloudy\ncloudy\n</code></pre></p> <p><pre><code>mode = stats.Mode(k=-1)\nfor x in X:\n    mode.update(x)\n    print(mode.get())\n</code></pre> <pre><code>sunny\nsunny\ncloudy\ncloudy\ncloudy\nrainy\n</code></pre></p>"},{"location":"api/stats/Mode/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/NUnique/","title":"NUnique","text":"<p>Approximate number of unique values counter.</p> <p>This is basically an implementation of the HyperLogLog algorithm. Adapted from <code>hypy</code>. The code is a bit too terse but it will do for now.</p>"},{"location":"api/stats/NUnique/#parameters","title":"Parameters","text":"<ul> <li> <p>error_rate</p> <p>Default \u2192 <code>0.01</code></p> <p>Desired error rate. Memory usage is inversely proportional to this value.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Set the seed to produce identical results.</p> </li> </ul>"},{"location":"api/stats/NUnique/#attributes","title":"Attributes","text":"<ul> <li> <p>n_bits (int)</p> </li> <li> <p>n_buckets (int)</p> </li> <li> <p>buckets (list)</p> </li> </ul>"},{"location":"api/stats/NUnique/#examples","title":"Examples","text":"<p><pre><code>import string\nfrom river import stats\n\nalphabet = string.ascii_lowercase\nn_unique = stats.NUnique(error_rate=0.2, seed=42)\n\nn_unique.update('a')\nn_unique.get()\n</code></pre> <pre><code>1\n</code></pre></p> <p><pre><code>n_unique.update('b')\nn_unique.get()\n</code></pre> <pre><code>2\n</code></pre></p> <p><pre><code>for letter in alphabet:\n    n_unique.update(letter)\nn_unique.get()\n</code></pre> <pre><code>31\n</code></pre></p> <p>Lowering the <code>error_rate</code> parameter will increase the precision.</p> <p><pre><code>n_unique = stats.NUnique(error_rate=0.01, seed=42)\nfor letter in alphabet:\n    n_unique.update(letter)\nn_unique.get()\n</code></pre> <pre><code>26\n</code></pre></p>"},{"location":"api/stats/NUnique/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>My favorite algorithm (and data structure): HyperLogLog \u21a9</p> </li> <li> <p>Flajolet, P., Fusy, \u00c9., Gandouet, O. and Meunier, F., 2007, June. Hyperloglog: the analysis of a near-optimal cardinality estimation algorithm. \u21a9</p> </li> </ol>"},{"location":"api/stats/PeakToPeak/","title":"PeakToPeak","text":"<p>Running peak to peak (max - min).</p>"},{"location":"api/stats/PeakToPeak/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/PeakToPeak/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, -4, 3, -2, 2, 4]\nptp = stats.PeakToPeak()\nfor x in X:\n    ptp.update(x)\n    print(ptp.get())\n</code></pre> <pre><code>0.\n5.\n7.\n7.\n7.\n8.\n</code></pre></p>"},{"location":"api/stats/PeakToPeak/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/PearsonCorr/","title":"PearsonCorr","text":"<p>Online Pearson correlation.</p>"},{"location":"api/stats/PearsonCorr/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof</p> <p>Default \u2192 <code>1</code></p> <p>Delta Degrees of Freedom.</p> </li> </ul>"},{"location":"api/stats/PearsonCorr/#attributes","title":"Attributes","text":"<ul> <li> <p>var_x (stats.Var)</p> <p>Running variance of <code>x</code>.</p> </li> <li> <p>var_y (stats.Var)</p> <p>Running variance of <code>y</code>.</p> </li> <li> <p>cov_xy (stats.Cov)</p> <p>Running covariance of <code>x</code> and <code>y</code>.</p> </li> </ul>"},{"location":"api/stats/PearsonCorr/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nx = [0, 0, 0, 1, 1, 1, 1]\ny = [0, 1, 2, 3, 4, 5, 6]\n\npearson = stats.PearsonCorr()\n\nfor xi, yi in zip(x, y):\n    pearson.update(xi, yi)\n    print(pearson.get())\n</code></pre> <pre><code>0\n0\n0\n0.774596\n0.866025\n0.878310\n0.866025\n</code></pre></p> <p>You can also do this in a rolling fashion:</p> <p><pre><code>from river import utils\n\nx = [0, 0, 0, 1, 1, 1, 1]\ny = [0, 1, 2, 3, 4, 5, 6]\n\npearson = utils.Rolling(stats.PearsonCorr(), window_size=4)\n\nfor xi, yi in zip(x, y):\n    pearson.update(xi, yi)\n    print(pearson.get())\n</code></pre> <pre><code>0\n0\n0\n0.7745966692414834\n0.8944271909999159\n0.7745966692414832\n-4.712160915387242e-09\n</code></pre></p>"},{"location":"api/stats/PearsonCorr/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p> update_many"},{"location":"api/stats/Quantile/","title":"Quantile","text":"<p>Running quantile.</p> <p>Uses the P\u00b2 algorithm, which is also known as the \"Piecewise-Parabolic quantile estimator\". The code is inspired by LiveStat's implementation <sup>2</sup>.</p>"},{"location":"api/stats/Quantile/#parameters","title":"Parameters","text":"<ul> <li> <p>q</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.5</code></p> <p>Determines which quantile to compute, must be comprised between 0 and 1.</p> </li> </ul>"},{"location":"api/stats/Quantile/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Quantile/#examples","title":"Examples","text":"<p><pre><code>from river import stats\nimport numpy as np\n\nnp.random.seed(42 * 1337)\nmu, sigma = 0, 1\ns = np.random.normal(mu, sigma, 500)\n\nmedian = stats.Quantile(0.5)\nfor x in s:\n   _ = median.update(x)\nprint(f'The estimated value of the 50th (median) quantile is {median.get():.4f}')\n</code></pre> <pre><code>The estimated value of the 50th (median) quantile is -0.0275\n</code></pre></p> <p><pre><code>print(f'The real value of the 50th (median) quantile is {np.median(s):.4f}')\n</code></pre> <pre><code>The real value of the 50th (median) quantile is -0.0135\n</code></pre></p> <p><pre><code>percentile_17 = stats.Quantile(0.17)\nfor x in s:\n   _ = percentile_17.update(x)\nprint(f'The estimated value of the 17th quantile is {percentile_17.get():.4f}')\n</code></pre> <pre><code>The estimated value of the 17th quantile is -0.8652\n</code></pre></p> <p><pre><code>print(f'The real value of the 17th quantile is {np.percentile(s,17):.4f}')\n</code></pre> <pre><code>The real value of the 17th quantile is -0.9072\n</code></pre></p>"},{"location":"api/stats/Quantile/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>The P\u00b2 Algorithm for Dynamic Univariateal Computing Calculation of Quantiles and Editor Histograms Without Storing Observations \u21a9</p> </li> <li> <p>LiveStats \u21a9</p> </li> <li> <p>P\u00b2 quantile estimator: estimating the median without storing values \u21a9</p> </li> </ol>"},{"location":"api/stats/RollingAbsMax/","title":"RollingAbsMax","text":"<p>Running absolute max over a window.</p>"},{"location":"api/stats/RollingAbsMax/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingAbsMax/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingAbsMax/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, -4, 3, -2, 2, 1]\nrolling_absmax = stats.RollingAbsMax(window_size=2)\nfor x in X:\n    rolling_absmax.update(x)\n    print(rolling_absmax.get())\n</code></pre> <pre><code>1\n4\n4\n3\n2\n2\n</code></pre></p>"},{"location":"api/stats/RollingAbsMax/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/RollingIQR/","title":"RollingIQR","text":"<p>Computes the rolling interquartile range.</p>"},{"location":"api/stats/RollingIQR/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the window.</p> </li> <li> <p>q_inf</p> <p>Default \u2192 <code>0.25</code></p> <p>Desired inferior quantile, must be between 0 and 1. Defaults to <code>0.25</code>.</p> </li> <li> <p>q_sup</p> <p>Default \u2192 <code>0.75</code></p> <p>Desired superior quantile, must be between 0 and 1. Defaults to <code>0.75</code>.</p> </li> </ul>"},{"location":"api/stats/RollingIQR/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingIQR/#examples","title":"Examples","text":"<p><pre><code>from river import stats\nrolling_iqr = stats.RollingIQR(\n    q_inf=0.25,\n    q_sup=0.75,\n    window_size=101\n)\n\nfor i in range(0, 1001):\n    rolling_iqr.update(i)\n    if i % 100 == 0:\n        print(rolling_iqr.get())\n</code></pre> <pre><code>0.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n50.0\n</code></pre></p>"},{"location":"api/stats/RollingIQR/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/RollingMax/","title":"RollingMax","text":"<p>Running max over a window.</p>"},{"location":"api/stats/RollingMax/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingMax/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingMax/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, -4, 3, -2, 2, 1]\nrolling_max = stats.RollingMax(window_size=2)\nfor x in X:\n    rolling_max.update(x)\n    print(rolling_max.get())\n</code></pre> <pre><code>1\n1\n3\n3\n2\n2\n</code></pre></p>"},{"location":"api/stats/RollingMax/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/RollingMin/","title":"RollingMin","text":"<p>Running min over a window.</p>"},{"location":"api/stats/RollingMin/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingMin/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingMin/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, -4, 3, -2, 2, 1]\nrolling_min = stats.RollingMin(2)\nfor x in X:\n    rolling_min.update(x)\n    print(rolling_min.get())\n</code></pre> <pre><code>1\n-4\n-4\n-2\n-2\n1\n</code></pre></p>"},{"location":"api/stats/RollingMin/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/RollingMode/","title":"RollingMode","text":"<p>Running mode over a window.</p> <p>The mode is the most common value.</p>"},{"location":"api/stats/RollingMode/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingMode/#attributes","title":"Attributes","text":"<ul> <li> <p>counts (collections.defaultdict)</p> <p>Value counts.</p> </li> </ul>"},{"location":"api/stats/RollingMode/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = ['sunny', 'sunny', 'sunny', 'rainy', 'rainy', 'rainy', 'rainy']\nrolling_mode = stats.RollingMode(window_size=2)\nfor x in X:\n    rolling_mode.update(x)\n    print(rolling_mode.get())\n</code></pre> <pre><code>sunny\nsunny\nsunny\nsunny\nrainy\nrainy\nrainy\n</code></pre></p> <p><pre><code>rolling_mode = stats.RollingMode(window_size=5)\nfor x in X:\n    rolling_mode.update(x)\n    print(rolling_mode.get())\n</code></pre> <pre><code>sunny\nsunny\nsunny\nsunny\nsunny\nrainy\nrainy\n</code></pre></p>"},{"location":"api/stats/RollingMode/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/RollingPeakToPeak/","title":"RollingPeakToPeak","text":"<p>Running peak to peak (max - min) over a window.</p>"},{"location":"api/stats/RollingPeakToPeak/#parameters","title":"Parameters","text":"<ul> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the rolling window.</p> </li> </ul>"},{"location":"api/stats/RollingPeakToPeak/#attributes","title":"Attributes","text":"<ul> <li> <p>max (stats.RollingMax)</p> <p>The running rolling max.</p> </li> <li> <p>min (stats.RollingMin)</p> <p>The running rolling min.</p> </li> </ul>"},{"location":"api/stats/RollingPeakToPeak/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [1, -4, 3, -2, 2, 1]\nptp = stats.RollingPeakToPeak(window_size=2)\nfor x in X:\n    ptp.update(x)\n    print(ptp.get())\n</code></pre> <pre><code>0\n5\n7\n5\n4\n1\n</code></pre></p>"},{"location":"api/stats/RollingPeakToPeak/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/RollingQuantile/","title":"RollingQuantile","text":"<p>Running quantile over a window.</p>"},{"location":"api/stats/RollingQuantile/#parameters","title":"Parameters","text":"<ul> <li> <p>q</p> <p>Type \u2192 float</p> <p>Determines which quantile to compute, must be comprised between 0 and 1.</p> </li> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the window.</p> </li> </ul>"},{"location":"api/stats/RollingQuantile/#attributes","title":"Attributes","text":"<ul> <li> <p>name</p> </li> <li> <p>window_size</p> </li> </ul>"},{"location":"api/stats/RollingQuantile/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nrolling_quantile = stats.RollingQuantile(\n    q=.5,\n    window_size=101,\n)\n\nfor i in range(1001):\n    rolling_quantile.update(i)\n    if i % 100 == 0:\n        print(rolling_quantile.get())\n</code></pre> <pre><code>0.0\n50.0\n150.0\n250.0\n350.0\n450.0\n550.0\n650.0\n750.0\n850.0\n950.0\n</code></pre></p>"},{"location":"api/stats/RollingQuantile/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Left sorted \u21a9</p> </li> </ol>"},{"location":"api/stats/SEM/","title":"SEM","text":"<p>Running standard error of the mean using Welford's algorithm.</p>"},{"location":"api/stats/SEM/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof</p> <p>Default \u2192 <code>1</code></p> <p>Delta Degrees of Freedom. The divisor used in calculations is <code>n - ddof</code>, where <code>n</code> is the number of seen elements.</p> </li> </ul>"},{"location":"api/stats/SEM/#attributes","title":"Attributes","text":"<ul> <li> <p>n (int)</p> <p>Number of observations.</p> </li> </ul>"},{"location":"api/stats/SEM/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [3, 5, 4, 7, 10, 12]\n\nsem = stats.SEM()\nfor x in X:\n    sem.update(x)\n    print(sem.get())\n</code></pre> <pre><code>0.0\n1.0\n0.577350\n0.853912\n1.240967\n1.447219\n</code></pre></p> <p><pre><code>from river import utils\n\nX = [1, 4, 2, -4, -8, 0]\n\nrolling_sem = utils.Rolling(stats.SEM(ddof=1), window_size=3)\nfor x in X:\n    rolling_sem.update(x)\n    print(rolling_sem.get())\n</code></pre> <pre><code>0.0\n1.5\n0.881917\n2.403700\n2.905932\n2.309401\n</code></pre></p>"},{"location":"api/stats/SEM/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update_many <ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> </ol>"},{"location":"api/stats/Shift/","title":"Shift","text":"<p>Shifts a data stream by returning past values.</p> <p>This can be used to compute statistics over past data. For instance, if you're computing daily averages, then shifting by 7 will be equivalent to computing averages from a week ago. </p> <p>Shifting values is useful when you're calculating an average over a target value. Indeed, in this case it's important to shift the values in order not to introduce leakage. The recommended way to do this is to <code>feature_extraction.TargetAgg</code>, which already takes care of shifting the target values once.</p>"},{"location":"api/stats/Shift/#parameters","title":"Parameters","text":"<ul> <li> <p>amount</p> <p>Default \u2192 <code>1</code></p> <p>Shift amount. The <code>get</code> method will return the <code>t - amount</code> value, where <code>t</code> is the current moment.</p> </li> <li> <p>fill_value</p> <p>Default \u2192 <code>None</code></p> <p>This value will be returned by the <code>get</code> method if not enough values have been observed.</p> </li> </ul>"},{"location":"api/stats/Shift/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Shift/#examples","title":"Examples","text":"<p>It is rare to have to use <code>Shift</code> by itself. A more common usage is to compose it with other statistics. This can be done via the <code>|</code> operator.</p> <p><pre><code>from river import stats\n\nstat = stats.Shift(1) | stats.Mean()\n\nfor i in range(5):\n    stat.update(i)\n    print(stat.get())\n</code></pre> <pre><code>0.0\n0.0\n0.5\n1.0\n1.5\n</code></pre></p> <p>A common usecase for using <code>Shift</code> is when computing statistics on shifted data. For instance, say you have a dataset which records the amount of sales for a set of shops. You might then have a <code>shop</code> field and a <code>sales</code> field. Let's say you want to look at the average amount of sales per shop. You can do this by using a <code>feature_extraction.Agg</code>. When you call <code>transform_one</code>, you're expecting it to return the average amount of sales, without including today's sales. You can do this by prepending an instance of <code>stats.Mean</code> with an instance of <code>stats.Shift</code>.</p> <pre><code>from river import feature_extraction\n\nagg = feature_extraction.Agg(\n    on='sales',\n    how=stats.Shift(1) | stats.Mean(),\n    by='shop'\n)\n</code></pre> <p>Let's define a little example dataset.</p> <pre><code>X = iter([\n    {'shop': 'Ikea', 'sales': 10},\n    {'shop': 'Ikea', 'sales': 15},\n    {'shop': 'Ikea', 'sales': 20}\n])\n</code></pre> <p>Now let's call the <code>learn_one</code> method to update our feature extractor.</p> <pre><code>x = next(X)\nagg.learn_one(x)\n</code></pre> <p>At this point, the average defaults to the initial value of <code>stats.Mean</code>, which is 0.</p> <p><pre><code>agg.transform_one(x)\n</code></pre> <pre><code>{'sales_mean_of_shift_1_by_shop': 0.0}\n</code></pre></p> <p>We can now update our feature extractor with the next data point and check the output.</p> <p><pre><code>agg.learn_one(next(X))\nagg.transform_one(x)\n</code></pre> <pre><code>{'sales_mean_of_shift_1_by_shop': 10.0}\n</code></pre></p> <p><pre><code>agg.learn_one(next(X))\nagg.transform_one(x)\n</code></pre> <pre><code>{'sales_mean_of_shift_1_by_shop': 12.5}\n</code></pre></p>"},{"location":"api/stats/Shift/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/Skew/","title":"Skew","text":"<p>Running skew using Welford's algorithm.</p>"},{"location":"api/stats/Skew/#parameters","title":"Parameters","text":"<ul> <li> <p>bias</p> <p>Default \u2192 <code>False</code></p> <p>If <code>False</code>, then the calculations are corrected for statistical bias.</p> </li> </ul>"},{"location":"api/stats/Skew/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/Skew/#examples","title":"Examples","text":"<p><pre><code>from river import stats\nimport numpy as np\n\nnp.random.seed(42)\nX = np.random.normal(loc=0, scale=1, size=10)\n\nskew = stats.Skew(bias=False)\nfor x in X:\n    skew.update(x)\n    print(skew.get())\n</code></pre> <pre><code>0.0\n0.0\n-1.4802398132849872\n0.5127437186677888\n0.7803466510704751\n1.056115628922055\n0.5057840774320389\n0.3478402420400934\n0.4536710660918704\n0.4123070197493227\n</code></pre></p> <p><pre><code>skew = stats.Skew(bias=True)\nfor x in X:\n    skew.update(x)\n    print(skew.get())\n</code></pre> <pre><code>0.0\n0.0\n-0.6043053732501439\n0.2960327239981376\n0.5234724473423674\n0.7712778043924866\n0.39022088752624845\n0.278892645224261\n0.37425953513864063\n0.3476878073823696\n</code></pre></p>"},{"location":"api/stats/Skew/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p> <ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> </ol>"},{"location":"api/stats/Sum/","title":"Sum","text":"<p>Running sum.</p>"},{"location":"api/stats/Sum/#attributes","title":"Attributes","text":"<ul> <li> <p>sum (float)</p> <p>The running sum.</p> </li> </ul>"},{"location":"api/stats/Sum/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [-5, -3, -1, 1, 3, 5]\nmean = stats.Sum()\nfor x in X:\n    mean.update(x)\n    print(mean.get())\n</code></pre> <pre><code>-5.0\n-8.0\n-9.0\n-8.0\n-5.0\n0.0\n</code></pre></p> <p><pre><code>from river import utils\n\nX = [1, -4, 3, -2, 2, 1]\nrolling_sum = utils.Rolling(stats.Sum(), window_size=2)\nfor x in X:\n    rolling_sum.update(x)\n    print(rolling_sum.get())\n</code></pre> <pre><code>1.0\n-3.0\n-1.0\n1.0\n0.0\n3.0\n</code></pre></p>"},{"location":"api/stats/Sum/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stats/Var/","title":"Var","text":"<p>Running variance using Welford's algorithm.</p>"},{"location":"api/stats/Var/#parameters","title":"Parameters","text":"<ul> <li> <p>ddof</p> <p>Default \u2192 <code>1</code></p> <p>Delta Degrees of Freedom. The divisor used in calculations is <code>n - ddof</code>, where <code>n</code> represents the number of seen elements.</p> </li> </ul>"},{"location":"api/stats/Var/#attributes","title":"Attributes","text":"<ul> <li> <p>mean</p> <p>It is necessary to calculate the mean of the data in order to calculate its variance.</p> </li> </ul>"},{"location":"api/stats/Var/#examples","title":"Examples","text":"<p><pre><code>from river import stats\n\nX = [3, 5, 4, 7, 10, 12]\n\nvar = stats.Var()\nfor x in X:\n    var.update(x)\n    print(var.get())\n</code></pre> <pre><code>0.0\n2.0\n1.0\n2.916666\n7.7\n12.56666\n</code></pre></p> <p>You can measure a rolling variance by using a <code>utils.Rolling</code> wrapper:</p> <p><pre><code>from river import utils\n\nX = [1, 4, 2, -4, -8, 0]\nrvar = utils.Rolling(stats.Var(ddof=1), window_size=3)\nfor x in X:\n    rvar.update(x)\n    print(rvar.get())\n</code></pre> <pre><code>0.0\n4.5\n2.333333\n17.333333\n25.333333\n16.0\n</code></pre></p>"},{"location":"api/stats/Var/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> revert update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> update_many"},{"location":"api/stats/Var/#notes","title":"Notes","text":"<p>The outcomes of the incremental and parallel updates are consistent with numpy's batch processing when \\(\\text{ddof} \\le 1\\).</p> <ol> <li> <p>Wikipedia article on algorithms for calculating variance \u21a9</p> </li> <li> <p>Chan, T.F., Golub, G.H. and LeVeque, R.J., 1983. Algorithms for computing the sample variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247. \u21a9</p> </li> <li> <p>Schubert, E. and Gertz, M., 2018, July. Numerically stable parallel computation of (co-)variance. In Proceedings of the 30th International Conference on Scientific and Statistical Database Management (pp. 1-12).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/stats/base/Bivariate/","title":"Bivariate","text":"<p>A bivariate statistic measures a relationship between two variables.</p>"},{"location":"api/stats/base/Bivariate/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> </ul> <p></p>"},{"location":"api/stats/base/Univariate/","title":"Univariate","text":"<p>A univariate statistic measures a property of a variable.</p>"},{"location":"api/stats/base/Univariate/#attributes","title":"Attributes","text":"<ul> <li>name</li> </ul>"},{"location":"api/stats/base/Univariate/#methods","title":"Methods","text":"get <p>Return the current value of the statistic.</p> <p></p> update <p>Update the called instance.</p> <p>Parameters</p> <ul> <li>x     \u2014 'numbers.Number' </li> </ul> <p></p>"},{"location":"api/stream/Cache/","title":"Cache","text":"<p>Utility for caching iterables.</p> <p>This can be used to save a stream of data to the disk in order to iterate over it faster the following time. This can save time depending on the nature of stream. The more processing happens in a stream, the more time will be saved. Even in the case where no processing is done apart from reading the data, the cache will save some time because it is using the pickle binary protocol. It can thus improve the speed in common cases such as reading from a CSV file.</p>"},{"location":"api/stream/Cache/#parameters","title":"Parameters","text":"<ul> <li> <p>directory</p> <p>Default \u2192 <code>None</code></p> <p>The path where to store the pickled data streams. If not provided, then it will be automatically inferred whenever possible, if not an exception will be raised.</p> </li> </ul>"},{"location":"api/stream/Cache/#attributes","title":"Attributes","text":"<ul> <li> <p>keys (set)</p> <p>The set of keys that are being cached.</p> </li> </ul>"},{"location":"api/stream/Cache/#examples","title":"Examples","text":"<pre><code>import time\nfrom river import datasets\nfrom river import stream\n\ndataset = datasets.Phishing()\ncache = stream.Cache()\n</code></pre> <p>The cache can be used by wrapping it around an iterable. Because this is the first time are iterating over the data, nothing is cached.</p> <p><pre><code>tic = time.time()\nfor x, y in cache(dataset, key='phishing'):\n    pass\ntoc = time.time()\nprint(toc - tic)  # doctest: +SKIP\n</code></pre> <pre><code>0.012813\n</code></pre></p> <p>If we do the same thing again, we can see the loop is now faster.</p> <p><pre><code>tic = time.time()\nfor x, y in cache(dataset, key='phishing'):\n    pass\ntoc = time.time()\nprint(toc - tic)  # doctest: +SKIP\n</code></pre> <pre><code>0.001927\n</code></pre></p> <p>We can see an overview of the cache. The first line indicates the location of the cache.</p> <p><pre><code>cache  # doctest: +SKIP\n</code></pre> <pre><code>/tmp\nphishing - 125.2KiB\n</code></pre></p> <p>Finally, we can clear the stream from the cache.</p> <p><pre><code>cache.clear('phishing')\ncache  # doctest: +SKIP\n</code></pre> <pre><code>/tmp\n</code></pre></p> <p>There is also a <code>clear_all</code> method to remove all the items in the cache.</p> <pre><code>cache.clear_all()\n</code></pre>"},{"location":"api/stream/Cache/#methods","title":"Methods","text":"call <p>Call self as a function.</p> <p>Parameters</p> <ul> <li>stream </li> <li>key     \u2014 defaults to <code>None</code> </li> </ul> <p></p> clear <p>Delete the cached stream associated with the given key.</p> <p>Parameters</p> <ul> <li>key     \u2014 'str' </li> </ul> <p></p> clear_all <p>Delete all the cached streams.</p> <p></p>"},{"location":"api/stream/TwitchChatStream/","title":"TwitchChatStream","text":"<p>Twitch chat stream client.</p> <p>This client gives access to a live stream of chat messages in Twitch channels using IRC protocol. You need to have a Twitch account and receive an OAuth token from https://twitchapps.com/tmi/.</p>"},{"location":"api/stream/TwitchChatStream/#parameters","title":"Parameters","text":"<ul> <li> <p>nickname</p> <p>Type \u2192 str</p> <p>The nickname of your account.</p> </li> <li> <p>token</p> <p>Type \u2192 str</p> <p>OAuth token which has been generated.</p> </li> <li> <p>channels</p> <p>Type \u2192 list[str]</p> <p>A list of channel names like <code>[\"asmongold\", \"shroud\"]</code> you want to collect messages from.</p> </li> <li> <p>buffer_size</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>2048</code></p> <p>Size of buffer in bytes used for receiving responses from Twitch with IRC (default 2 KiB).</p> </li> <li> <p>timeout</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>60</code></p> <p>A timeout value in seconds for waiting response from Twitch (default 60s). It can be useful if all requested channels are offline or chat is not active enough.</p> </li> </ul>"},{"location":"api/stream/TwitchChatStream/#examples","title":"Examples","text":"<p>The live stream is instantiated by passing your Twitch account nickname, OAuth token and list of channels. Other parameters are optional.</p> <pre><code>from river import stream\n\ntwitch_chat = stream.TwitchChatStream(\n    nickname=\"twitch_user1\",\n    token=\"oauth:okrip6j6fjio8n5xpy2oum1lph4fbve\",\n    channels=[\"asmongold\", \"shroud\"]\n)\n</code></pre> <p>The stream can be iterated over like this:</p> <pre><code>for item in twitch_chat:\n    print(item)\n</code></pre> <p>Here's a single stream item example: <pre><code>{\n    'dt': datetime.datetime(2022, 9, 14, 10, 33, 37, 989560),\n    'channel': 'asmongold',\n    'username': 'moojiejaa',\n    'msg': 'damn this chat mod are wild'\n}\n</code></pre></p> <ol> <li> <p>Twitch IRC doc \u21a9</p> </li> </ol>"},{"location":"api/stream/TwitterLiveStream/","title":"TwitterLiveStream","text":"<p>Twitter API v2 live stream client.</p> <p>This client gives access to a live stream of Tweets. That is, Tweets that have just been     published. This is different to <code>stream.TwitterRecentStream</code>, which also covers Tweets that     have been published over recent days, and not necessarily in real-time. </p> <p>A list of filtering rules has to be provided. For instance, this allows focusing on a subset of     topics and/or users. </p> <p>Note</p> <p>Using this requires having the <code>requests</code>         package installed.</p>"},{"location":"api/stream/TwitterLiveStream/#parameters","title":"Parameters","text":"<ul> <li> <p>rules</p> <p>See the documentation[^2] for a comprehensive overview of filtering rules.</p> </li> <li> <p>bearer_token</p> <p>A bearer token that is available in each account's developer portal.</p> </li> </ul>"},{"location":"api/stream/TwitterLiveStream/#examples","title":"Examples","text":"<p>The live stream is instantiated by passing a list of filtering rules, as well as a bearer     token. For instance, we can listen to all the breaking news Tweets from the BBC and CNN.</p> <pre><code>from river import stream\n\ntweets = stream.TwitterLiveStream(\n    rules=[\"from:BBCBreaking\", \"from:cnnbrk\"],\n    bearer_token=\"&lt;insert_bearer_token&gt;\"\n)\n</code></pre> <pre><code>The stream can then be iterated over, possibly in an infinite loop. This will listen to the\nlive feed of Tweets and produce a Tweet right after it's been published.\n\n```py\nimport logging\n\nwhile True:\n    try:\n        for tweet in tweets:\n            print(tweet)\n    except requests.exceptions.RequestException as e:\n        logging.warning(str(e))\n        time.sleep(10)\n```\n\nHere's a Tweet example:\n\n```py\n{\n    'data': {\n        'author_id': '428333',\n        'created_at': '2022-08-26T12:59:48.000Z',\n        'id': '1563149212774445058',\n        'text': \"Ukraine's Zaporizhzhia nuclear power plant, which is currently held by\n</code></pre> <p>Russian forces, has been reconnected to Ukraine's electricity grid, according to the country's nuclear operator https://t.co/xfylkBs4JR\"         },         'includes': {             'users': [                 {                     'created_at': '2007-01-02T01:48:14.000Z',                     'id': '428333',                     'name': 'CNN Breaking News',                     'username': 'cnnbrk'                 }             ]         },         'matching_rules': [{'id': '1563148866333151233', 'tag': 'from:cnnbrk'}]     }     ```     [^1]: Filtered stream introduction     [^2]: Building rules for filtered stream     [^3]: Stream Tweets in real-time</p>"},{"location":"api/stream/iter-arff/","title":"iter_arff","text":"<p>Iterates over rows from an ARFF file.</p>"},{"location":"api/stream/iter-arff/#parameters","title":"Parameters","text":"<ul> <li> <p>filepath_or_buffer</p> <p>Either a string indicating the location of a file, or a buffer object that has a <code>read</code> method.</p> </li> <li> <p>target</p> <p>Type \u2192 str | list[str] | None</p> <p>Default \u2192 <code>None</code></p> <p>Name(s) of the target field. If <code>None</code>, then the target field is ignored. If a list of names is passed, then a dictionary is returned instead of a single value.</p> </li> <li> <p>compression</p> <p>Default \u2192 <code>infer</code></p> <p>For on-the-fly decompression of on-disk data. If this is set to 'infer' and <code>filepath_or_buffer</code> is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.</p> </li> <li> <p>sparse</p> <p>Default \u2192 <code>False</code></p> <p>Whether the data is sparse or not.</p> </li> </ul>"},{"location":"api/stream/iter-arff/#examples","title":"Examples","text":"<p><pre><code>cars = '''\n@relation CarData\n@attribute make {Toyota, Honda, Ford, Chevrolet}\n@attribute model string\n@attribute year numeric\n@attribute price numeric\n@attribute mpg numeric\n@data\nToyota, Corolla, 2018, 15000, 30.5\nHonda, Civic, 2019, 16000, 32.2\nFord, Mustang, 2020, 25000, 25.0\nChevrolet, Malibu, 2017, 18000, 28.9\nToyota, Camry, 2019, 22000, 29.8\n'''\nwith open('cars.arff', mode='w') as f:\n    _ = f.write(cars)\n\nfrom river import stream\n\nfor x, y in stream.iter_arff('cars.arff', target='price'):\n    print(x, y)\n</code></pre> <pre><code>{'make': 'Toyota', 'model': ' Corolla', 'year': 2018.0, 'mpg': 30.5} 15000.0\n{'make': 'Honda', 'model': ' Civic', 'year': 2019.0, 'mpg': 32.2} 16000.0\n{'make': 'Ford', 'model': ' Mustang', 'year': 2020.0, 'mpg': 25.0} 25000.0\n{'make': 'Chevrolet', 'model': ' Malibu', 'year': 2017.0, 'mpg': 28.9} 18000.0\n{'make': 'Toyota', 'model': ' Camry', 'year': 2019.0, 'mpg': 29.8} 22000.0\n</code></pre></p> <p>Finally, let's delete the example file.</p> <pre><code>import os; os.remove('cars.arff')\n</code></pre> <p>ARFF files support sparse data. Let's create a sparse ARFF file.</p> <pre><code>sparse = '''\n% traindata\n@RELATION \"traindata: -C 6\"\n@ATTRIBUTE y0 {0, 1}\n@ATTRIBUTE y1 {0, 1}\n@ATTRIBUTE y2 {0, 1}\n@ATTRIBUTE y3 {0, 1}\n@ATTRIBUTE y4 {0, 1}\n@ATTRIBUTE y5 {0, 1}\n@ATTRIBUTE X0 NUMERIC\n@ATTRIBUTE X1 NUMERIC\n@ATTRIBUTE X2 NUMERIC\n@DATA\n{ 3 1,6 0.863382,8 0.820094 }\n{ 2 1,6 0.659761 }\n{ 0 1,3 1,6 0.437881,8 0.818882 }\n{ 2 1,6 0.676477,7 0.724635,8 0.755123 }\n'''\n\nwith open('sparse.arff', mode='w') as f:\n    _ = f.write(sparse)\n</code></pre> <p>In addition, we'll specify that there are several target fields.</p> <p><pre><code>arff_stream = stream.iter_arff(\n    'sparse.arff',\n    target=['y0', 'y1', 'y2', 'y3', 'y4', 'y5'],\n    sparse=True\n)\n\nfor x, y in arff_stream:\n    print(x)\n    print(y)\n</code></pre> <pre><code>{'X0': '0.863382', 'X2': '0.820094'}\n{'y0': 0, 'y1': 0, 'y2': 0, 'y3': '1', 'y4': 0, 'y5': 0}\n{'X0': '0.659761'}\n{'y0': 0, 'y1': 0, 'y2': '1', 'y3': 0, 'y4': 0, 'y5': 0}\n{'X0': '0.437881', 'X2': '0.818882'}\n{'y0': '1', 'y1': 0, 'y2': 0, 'y3': '1', 'y4': 0, 'y5': 0}\n{'X0': '0.676477', 'X1': '0.724635', 'X2': '0.755123'}\n{'y0': 0, 'y1': 0, 'y2': '1', 'y3': 0, 'y4': 0, 'y5': 0}\n</code></pre></p> <p>This function can also deal with missing features in non-sparse data. These are indicated with a question mark.</p> <p><pre><code>data = '''\n@relation giveMeLoan-weka.filters.unsupervised.attribute.Remove-R1\n@attribute RevolvingUtilizationOfUnsecuredLines numeric\n@attribute age numeric\n@attribute NumberOfTime30-59DaysPastDueNotWorse numeric\n@attribute DebtRatio numeric\n@attribute MonthlyIncome numeric\n@attribute NumberOfOpenCreditLinesAndLoans numeric\n@attribute NumberOfTimes90DaysLate numeric\n@attribute NumberRealEstateLoansOrLines numeric\n@attribute NumberOfTime60-89DaysPastDueNotWorse numeric\n@attribute NumberOfDependents numeric\n@attribute isFraud {0,1}\n@data\n0.213179,74,0,0.375607,3500,3,0,1,0,1,0\n0.305682,57,0,5710,?,8,0,3,0,0,0\n0.754464,39,0,0.20994,3500,8,0,0,0,0,0\n0.116951,27,0,46,?,2,0,0,0,0,0\n0.189169,57,0,0.606291,23684,9,0,4,0,2,0\n'''\n\nwith open('data.arff', mode='w') as f:\n    _ = f.write(data)\n\nfor x, y in stream.iter_arff('data.arff', target='isFraud'):\n    print(len(x))\n</code></pre> <pre><code>10\n9\n10\n9\n10\n</code></pre></p> <ol> <li> <p>ARFF format description from Weka \u21a9</p> </li> </ol>"},{"location":"api/stream/iter-array/","title":"iter_array","text":"<p>Iterates over the rows from an array of features and an array of targets.</p> <p>This method is intended to work with <code>numpy</code> arrays, but should also work with Python lists.</p>"},{"location":"api/stream/iter-array/#parameters","title":"Parameters","text":"<ul> <li> <p>X</p> <p>Type \u2192 np.ndarray</p> <p>A 2D array of features. This can also be a 1D array of strings, which can be the case if you're working with text.</p> </li> <li> <p>y</p> <p>Type \u2192 np.ndarray | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional array of targets.</p> </li> <li> <p>feature_names</p> <p>Type \u2192 list[base.typing.FeatureName] | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional list of feature names. The features will be labeled with integers if no names are provided.</p> </li> <li> <p>target_names</p> <p>Type \u2192 list[base.typing.FeatureName] | None</p> <p>Default \u2192 <code>None</code></p> <p>An optional list of output names. The outputs will be labeled with integers if no names are provided. Only applies if there are multiple outputs, i.e. if <code>y</code> is a 2D array.</p> </li> <li> <p>shuffle</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>Indicates whether or not to shuffle the input arrays before iterating over them.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed used for shuffling the data.</p> </li> </ul>"},{"location":"api/stream/iter-array/#examples","title":"Examples","text":"<p><pre><code>from river import stream\nimport numpy as np\n\nX = np.array([[1, 2, 3], [11, 12, 13]])\nY = np.array([True, False])\n\ndataset = stream.iter_array(\n    X, Y,\n    feature_names=['x1', 'x2', 'x3']\n)\nfor x, y in dataset:\n    print(x, y)\n</code></pre> <pre><code>{'x1': 1, 'x2': 2, 'x3': 3} True\n{'x1': 11, 'x2': 12, 'x3': 13} False\n</code></pre></p> <p>This also works with a array of texts:</p> <p><pre><code>X = [\"foo\", \"bar\"]\ndataset = stream.iter_array(\n    X, Y,\n    feature_names=['x1', 'x2', 'x3']\n)\nfor x, y in dataset:\n    print(x, y)\n</code></pre> <pre><code>foo True\nbar False\n</code></pre></p>"},{"location":"api/stream/iter-csv/","title":"iter_csv","text":"<p>Iterates over rows from a CSV file.</p> <p>Reading CSV files can be quite slow. If, for whatever reason, you're going to loop through the same file multiple times, then we recommend that you to use the <code>stream.Cache</code> utility.</p>"},{"location":"api/stream/iter-csv/#parameters","title":"Parameters","text":"<ul> <li> <p>filepath_or_buffer</p> <p>Either a string indicating the location of a file, or a buffer object that has a <code>read</code> method.</p> </li> <li> <p>target</p> <p>Type \u2192 str | list[str] | None</p> <p>Default \u2192 <code>None</code></p> <p>A single target column is assumed if a string is passed. A multiple output scenario is assumed if a list of strings is passed. A <code>None</code> value will be assigned to each <code>y</code> if this parameter is omitted.</p> </li> <li> <p>converters</p> <p>Type \u2192 dict | None</p> <p>Default \u2192 <code>None</code></p> <p>All values in the CSV are interpreted as strings by default. You can use this parameter to cast values to the desired type. This should be a <code>dict</code> mapping feature names to callables used to parse their associated values. Note that a callable may be a type, such as <code>float</code> and <code>int</code>.</p> </li> <li> <p>parse_dates</p> <p>Type \u2192 dict | None</p> <p>Default \u2192 <code>None</code></p> <p>A <code>dict</code> mapping feature names to a format passed to the <code>datetime.datetime.strptime</code> method.</p> </li> <li> <p>drop</p> <p>Type \u2192 list[str] | None</p> <p>Default \u2192 <code>None</code></p> <p>Fields to ignore.</p> </li> <li> <p>drop_nones</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to drop fields where the value is a <code>None</code>.</p> </li> <li> <p>fraction</p> <p>Default \u2192 <code>1.0</code></p> <p>Sampling fraction.</p> </li> <li> <p>compression</p> <p>Default \u2192 <code>infer</code></p> <p>For on-the-fly decompression of on-disk data. If this is set to 'infer' and <code>filepath_or_buffer</code> is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>If specified, the sampling will be deterministic.</p> </li> <li> <p>field_size_limit</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>If not <code>None</code>, this will be passed to the <code>csv.field_size_limit</code> function.</p> </li> <li> <p>kwargs</p> <p>All other keyword arguments are passed to the underlying <code>csv.DictReader</code>.</p> </li> </ul>"},{"location":"api/stream/iter-csv/#examples","title":"Examples","text":"<p>Although this function is designed to handle different kinds of inputs, the most common use case is to read a file on the disk. We'll first create a little CSV file to illustrate.</p> <pre><code>tv_shows = '''name,year,rating\nPlanet Earth II,2016,9.5\nPlanet Earth,2006,9.4\nBand of Brothers,2001,9.4\nBreaking Bad,2008,9.4\nChernobyl,2019,9.4\n'''\nwith open('tv_shows.csv', mode='w') as f:\n    _ = f.write(tv_shows)\n</code></pre> <p>We can now go through the rows one by one. We can use the <code>converters</code> parameter to cast the <code>rating</code> field value as a <code>float</code>. We can also convert the <code>year</code> to a <code>datetime</code> via the <code>parse_dates</code> parameter.</p> <p><pre><code>from river import stream\n\nparams = {\n    'converters': {'rating': float},\n    'parse_dates': {'year': '%Y'}\n}\nfor x, y in stream.iter_csv('tv_shows.csv', **params):\n    print(x, y)\n</code></pre> <pre><code>{'name': 'Planet Earth II', 'year': datetime.datetime(2016, 1, 1, 0, 0), 'rating': 9.5} None\n{'name': 'Planet Earth', 'year': datetime.datetime(2006, 1, 1, 0, 0), 'rating': 9.4} None\n{'name': 'Band of Brothers', 'year': datetime.datetime(2001, 1, 1, 0, 0), 'rating': 9.4} None\n{'name': 'Breaking Bad', 'year': datetime.datetime(2008, 1, 1, 0, 0), 'rating': 9.4} None\n{'name': 'Chernobyl', 'year': datetime.datetime(2019, 1, 1, 0, 0), 'rating': 9.4} None\n</code></pre></p> <p>The value of <code>y</code> is always <code>None</code> because we haven't provided a value for the <code>target</code> parameter. Here is an example where a <code>target</code> is provided:</p> <p><pre><code>dataset = stream.iter_csv('tv_shows.csv', target='rating', **params)\nfor x, y in dataset:\n    print(x, y)\n</code></pre> <pre><code>{'name': 'Planet Earth II', 'year': datetime.datetime(2016, 1, 1, 0, 0)} 9.5\n{'name': 'Planet Earth', 'year': datetime.datetime(2006, 1, 1, 0, 0)} 9.4\n{'name': 'Band of Brothers', 'year': datetime.datetime(2001, 1, 1, 0, 0)} 9.4\n{'name': 'Breaking Bad', 'year': datetime.datetime(2008, 1, 1, 0, 0)} 9.4\n{'name': 'Chernobyl', 'year': datetime.datetime(2019, 1, 1, 0, 0)} 9.4\n</code></pre></p> <p>Finally, let's delete the example file.</p> <pre><code>import os; os.remove('tv_shows.csv')\n</code></pre>"},{"location":"api/stream/iter-libsvm/","title":"iter_libsvm","text":"<p>Iterates over a dataset in LIBSVM format.</p> <p>The LIBSVM format is a popular way in the machine learning community to store sparse datasets. Only numerical feature values are supported. The feature names will be considered as strings.</p>"},{"location":"api/stream/iter-libsvm/#parameters","title":"Parameters","text":"<ul> <li> <p>filepath_or_buffer</p> <p>Type \u2192 str</p> <p>Either a string indicating the location of a file, or a buffer object that has a <code>read</code> method.</p> </li> <li> <p>target_type</p> <p>Default \u2192 <code>&lt;class 'float'&gt;</code></p> <p>The type of the target value.</p> </li> <li> <p>compression</p> <p>Default \u2192 <code>infer</code></p> <p>For on-the-fly decompression of on-disk data. If this is set to 'infer' and <code>filepath_or_buffer</code> is a path, then the decompression method is inferred for the following extensions: '.gz', '.zip'.</p> </li> </ul>"},{"location":"api/stream/iter-libsvm/#examples","title":"Examples","text":"<p><pre><code>import io\nfrom river import stream\n\ndata = io.StringIO('''+1 x:-134.26 y:0.2563\n1 x:-12 z:0.3\n-1 y:.25\n''')\n\nfor x, y in stream.iter_libsvm(data, target_type=int):\n    print(y, x)\n</code></pre> <pre><code>1 {'x': -134.26, 'y': 0.2563}\n1 {'x': -12.0, 'z': 0.3}\n-1 {'y': 0.25}\n</code></pre></p> <ol> <li> <p>LIBSVM documentation \u21a9</p> </li> </ol>"},{"location":"api/stream/iter-pandas/","title":"iter_pandas","text":"<p>Iterates over the rows of a <code>pandas.DataFrame</code>.</p>"},{"location":"api/stream/iter-pandas/#parameters","title":"Parameters","text":"<ul> <li> <p>X</p> <p>Type \u2192 pd.DataFrame</p> <p>A dataframe of features.</p> </li> <li> <p>y</p> <p>Type \u2192 pd.Series | pd.DataFrame | None</p> <p>Default \u2192 <code>None</code></p> <p>A series or a dataframe with one column per target.</p> </li> <li> <p>kwargs</p> <p>Extra keyword arguments are passed to the underlying call to <code>stream.iter_array</code>.</p> </li> </ul>"},{"location":"api/stream/iter-pandas/#examples","title":"Examples","text":"<p><pre><code>import pandas as pd\nfrom river import stream\n\nX = pd.DataFrame({\n    'x1': [1, 2, 3, 4],\n    'x2': ['blue', 'yellow', 'yellow', 'blue'],\n    'y': [True, False, False, True]\n})\ny = X.pop('y')\n\nfor xi, yi in stream.iter_pandas(X, y):\n    print(xi, yi)\n</code></pre> <pre><code>{'x1': 1, 'x2': 'blue'} True\n{'x1': 2, 'x2': 'yellow'} False\n{'x1': 3, 'x2': 'yellow'} False\n{'x1': 4, 'x2': 'blue'} True\n</code></pre></p>"},{"location":"api/stream/iter-polars/","title":"iter_polars","text":"<p>Iterates over the rows of a <code>polars.DataFrame</code>.</p>"},{"location":"api/stream/iter-polars/#parameters","title":"Parameters","text":"<ul> <li> <p>X</p> <p>Type \u2192 pl.DataFrame</p> <p>A dataframe of features.</p> </li> <li> <p>y</p> <p>Type \u2192 pl.Series | pl.DataFrame | None</p> <p>Default \u2192 <code>None</code></p> <p>A series or a dataframe with one column per target.</p> </li> <li> <p>kwargs</p> <p>Extra keyword arguments are passed to the underlying call to <code>stream.iter_array</code>.</p> </li> </ul>"},{"location":"api/stream/iter-polars/#examples","title":"Examples","text":"<p><pre><code>import polars as pl\nfrom river import stream\n\nX = pl.DataFrame({\n    'x1': [1, 2, 3, 4],\n    'x2': ['blue', 'yellow', 'yellow', 'blue'],\n    'y': [True, False, False, True]\n})\ny = X.get_column('y')\nX=X.drop(\"y\")\n\nfor xi, yi in stream.iter_polars(X, y):\n    print(xi, yi)\n</code></pre> <pre><code>{'x1': 1, 'x2': 'blue'} True\n{'x1': 2, 'x2': 'yellow'} False\n{'x1': 3, 'x2': 'yellow'} False\n{'x1': 4, 'x2': 'blue'} True\n</code></pre></p>"},{"location":"api/stream/iter-sklearn-dataset/","title":"iter_sklearn_dataset","text":"<p>Iterates rows from one of the datasets provided by scikit-learn.</p> <p>This allows you to use any dataset from scikit-learn's <code>datasets</code> module. For instance, you can use the <code>fetch_openml</code> function to get access to all of the datasets from the OpenML website.</p>"},{"location":"api/stream/iter-sklearn-dataset/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset</p> <p>Type \u2192 sklearn.utils.Bunch</p> <p>A scikit-learn dataset.</p> </li> <li> <p>kwargs</p> <p>Extra keyword arguments are passed to the underlying call to <code>stream.iter_array</code>.</p> </li> </ul>"},{"location":"api/stream/iter-sklearn-dataset/#examples","title":"Examples","text":"<p><pre><code>import pprint\nfrom sklearn import datasets\nfrom river import stream\n\ndataset = datasets.load_diabetes()\n\nfor xi, yi in stream.iter_sklearn_dataset(dataset):\n    pprint.pprint(xi)\n    print(yi)\n    break\n</code></pre> <pre><code>{'age': 0.038075906433423026,\n 'bmi': 0.061696206518683294,\n 'bp': 0.0218723855140367,\n 's1': -0.04422349842444599,\n 's2': -0.03482076283769895,\n 's3': -0.04340084565202491,\n 's4': -0.002592261998183278,\n 's5': 0.019907486170462722,\n 's6': -0.01764612515980379,\n 'sex': 0.05068011873981862}\n151.0\n</code></pre></p>"},{"location":"api/stream/iter-sql/","title":"iter_sql","text":"<p>Iterates over the results from an SQL query.</p> <p>By default, SQLAlchemy prefetches results. Therefore, even though you can iterate over the resulting rows one by one, the results are in fact loaded in batch. You can modify this behavior by configuring the connection you pass to <code>iter_sql</code>. For instance, you can set the <code>stream_results</code> parameter to <code>True</code>, as explained in SQLAlchemy's documentation. Note, however, that this isn't available for all database engines.</p>"},{"location":"api/stream/iter-sql/#parameters","title":"Parameters","text":"<ul> <li> <p>query</p> <p>Type \u2192 str | sqlalchemy.TextClause | sqlalchemy.Select</p> <p>SQL query to be executed.</p> </li> <li> <p>conn</p> <p>Type \u2192 sqlalchemy.Connection</p> <p>An SQLAlchemy construct which has an <code>execute</code> method. In other words you can pass an engine, a connection, or a session.</p> </li> <li> <p>target_name</p> <p>Type \u2192 str | None</p> <p>Default \u2192 <code>None</code></p> <p>The name of the target field. If this is <code>None</code>, then <code>y</code> will also be <code>None</code>.</p> </li> </ul>"},{"location":"api/stream/iter-sql/#examples","title":"Examples","text":"<p>As an example we'll create an in-memory database with SQLAlchemy.</p> <pre><code>import datetime as dt\nimport sqlalchemy\n\nengine = sqlalchemy.create_engine('sqlite://')\n\nmetadata = sqlalchemy.MetaData()\n\nt_sales = sqlalchemy.Table('sales', metadata,\n    sqlalchemy.Column('shop', sqlalchemy.String, primary_key=True),\n    sqlalchemy.Column('date', sqlalchemy.Date, primary_key=True),\n    sqlalchemy.Column('amount', sqlalchemy.Integer)\n)\n\nmetadata.create_all(engine)\n\nsales = [\n    {'shop': 'Hema', 'date': dt.date(2016, 8, 2), 'amount': 20},\n    {'shop': 'Ikea', 'date': dt.date(2016, 8, 2), 'amount': 18},\n    {'shop': 'Hema', 'date': dt.date(2016, 8, 3), 'amount': 22},\n    {'shop': 'Ikea', 'date': dt.date(2016, 8, 3), 'amount': 14},\n    {'shop': 'Hema', 'date': dt.date(2016, 8, 4), 'amount': 12},\n    {'shop': 'Ikea', 'date': dt.date(2016, 8, 4), 'amount': 16}\n]\n\nwith engine.connect() as conn:\n    _ = conn.execute(t_sales.insert(), sales)\n    conn.commit()\n</code></pre> <p>We can now query the database. We will set <code>amount</code> to be the target field.</p> <p><pre><code>from river import stream\n\nwith engine.connect() as conn:\n    query = sqlalchemy.sql.select(t_sales)\n    dataset = stream.iter_sql(query, conn, target_name='amount')\n    for x, y in dataset:\n        print(x, y)\n</code></pre> <pre><code>{'shop': 'Hema', 'date': datetime.date(2016, 8, 2)} 20\n{'shop': 'Ikea', 'date': datetime.date(2016, 8, 2)} 18\n{'shop': 'Hema', 'date': datetime.date(2016, 8, 3)} 22\n{'shop': 'Ikea', 'date': datetime.date(2016, 8, 3)} 14\n{'shop': 'Hema', 'date': datetime.date(2016, 8, 4)} 12\n{'shop': 'Ikea', 'date': datetime.date(2016, 8, 4)} 16\n</code></pre></p> <p>This also with raw SQL queries.</p> <p><pre><code>with engine.connect() as conn:\n    query = \"SELECT * FROM sales WHERE shop = 'Hema'\"\n    dataset = stream.iter_sql(query, conn, target_name='amount')\n    for x, y in dataset:\n        print(x, y)\n</code></pre> <pre><code>{'shop': 'Hema', 'date': '2016-08-02'} 20\n{'shop': 'Hema', 'date': '2016-08-03'} 22\n{'shop': 'Hema', 'date': '2016-08-04'} 12\n</code></pre></p>"},{"location":"api/stream/shuffle/","title":"shuffle","text":"<p>Shuffles a stream of data.</p> <p>This works by maintaining a buffer of elements. The first <code>buffer_size</code> elements are stored in memory. Once the buffer is full, a random element inside the buffer is yielded. Every time an element is yielded, the next element in the stream replaces it and the buffer is sampled again. Increasing <code>buffer_size</code> will improve the quality of the shuffling. </p> <p>If you really want to stream over your dataset in a \"good\" random order, the best way is to split your dataset into smaller datasets and loop over them in a round-robin fashion. You may do this by using the <code>roundrobin</code> recipe from the <code>itertools</code> module.</p>"},{"location":"api/stream/shuffle/#parameters","title":"Parameters","text":"<ul> <li> <p>stream</p> <p>Type \u2192 typing.Iterator</p> <p>The stream to shuffle.</p> </li> <li> <p>buffer_size</p> <p>Type \u2192 int</p> <p>The size of the buffer which contains the elements help in memory. Increasing this will increase randomness but will incur more memory usage.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed used for sampling.</p> </li> </ul>"},{"location":"api/stream/shuffle/#examples","title":"Examples","text":"<p><pre><code>from river import stream\n\nfor i in stream.shuffle(range(15), buffer_size=5, seed=42):\n    print(i)\n</code></pre> <pre><code>0\n5\n2\n1\n8\n9\n6\n4\n11\n12\n10\n7\n14\n13\n3\n</code></pre></p> <ol> <li> <p>Visualizing TensorFlow's streaming shufflers \u21a9</p> </li> </ol>"},{"location":"api/stream/simulate-qa/","title":"simulate_qa","text":"<p>Simulate a time-ordered question and answer session.</p> <p>This method allows looping through a dataset in the order in which it arrived. Indeed, it usually is the case that labels arrive after features. Being able to go through a dataset in arrival order enables assessing a model's performance in a reliable manner. For instance, the <code>evaluate.progressive_val_score</code> is a high-level method that can be used to score a model on a dataset. Under the hood it uses this method to determine the correct arrival order.</p>"},{"location":"api/stream/simulate-qa/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset</p> <p>Type \u2192 base.typing.Dataset</p> <p>A stream of (features, target) tuples.</p> </li> <li> <p>moment</p> <p>Type \u2192 str | typing.Callable[[dict], dt.datetime] | None</p> <p>The attribute used for measuring time. If a callable is passed, then it is expected to take as input a <code>dict</code> of features. If <code>None</code>, then the observations are implicitly timestamped in the order in which they arrive. If a <code>str</code> is passed, then it will be used to obtain the time from the input features.</p> </li> <li> <p>delay</p> <p>Type \u2192 str | int | dt.timedelta | typing.Callable | None</p> <p>The amount of time to wait before revealing the target associated with each observation to the model. This value is expected to be able to sum with the <code>moment</code> value. For instance, if <code>moment</code> is a <code>datetime.date</code>, then <code>delay</code> is expected to be a <code>datetime.timedelta</code>. If a callable is passed, then it is expected to take as input a <code>dict</code> of features and the target. If a <code>str</code> is passed, then it will be used to access the relevant field from the features. If <code>None</code> is passed, then no delay will be used, which leads to doing standard online validation. If a scalar is passed, such an <code>int</code> or a <code>datetime.timedelta</code>, then the delay is constant.</p> </li> <li> <p>copy</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If <code>True</code>, then a separate copy of the features are yielded the second time around. This ensures that inadvertent modifications in downstream code don't have any effect.</p> </li> </ul>"},{"location":"api/stream/simulate-qa/#examples","title":"Examples","text":"<p>The arrival delay isn't usually indicated in a dataset, but it might be able to be inferred from the features. As an example, we'll simulate the departure and arrival time of taxi trips. Let's first create a time table which records the departure time and the duration of seconds of several taxi trips.</p> <pre><code>import datetime as dt\ntime_table = [\n    (dt.datetime(2020, 1, 1, 20,  0, 0),  900),\n    (dt.datetime(2020, 1, 1, 20, 10, 0), 1800),\n    (dt.datetime(2020, 1, 1, 20, 20, 0),  300),\n    (dt.datetime(2020, 1, 1, 20, 45, 0),  400),\n    (dt.datetime(2020, 1, 1, 20, 50, 0),  240),\n    (dt.datetime(2020, 1, 1, 20, 55, 0),  450)\n]\n</code></pre> <p>We can now create a streaming dataset where the features are the departure dates and the targets are the durations.</p> <pre><code>dataset = (\n    ({'date': date}, duration)\n    for date, duration in time_table\n)\n</code></pre> <p>Now, we can use <code>simulate_qa</code> to iterate over the events in the order in which they are meant to occur.</p> <p><pre><code>delay = lambda _, y: dt.timedelta(seconds=y)\n\nfor i, x, y in simulate_qa(dataset, moment='date', delay=delay):\n    if y is None:\n        print(f'{x[\"date\"]} - trip #{i} departs')\n    else:\n        arrival_date = x['date'] + dt.timedelta(seconds=y)\n        print(f'{arrival_date} - trip #{i} arrives after {y} seconds')\n</code></pre> <pre><code>2020-01-01 20:00:00 - trip #0 departs\n2020-01-01 20:10:00 - trip #1 departs\n2020-01-01 20:15:00 - trip #0 arrives after 900 seconds\n2020-01-01 20:20:00 - trip #2 departs\n2020-01-01 20:25:00 - trip #2 arrives after 300 seconds\n2020-01-01 20:40:00 - trip #1 arrives after 1800 seconds\n2020-01-01 20:45:00 - trip #3 departs\n2020-01-01 20:50:00 - trip #4 departs\n2020-01-01 20:51:40 - trip #3 arrives after 400 seconds\n2020-01-01 20:54:00 - trip #4 arrives after 240 seconds\n2020-01-01 20:55:00 - trip #5 departs\n2020-01-01 21:02:30 - trip #5 arrives after 450 seconds\n</code></pre></p> <p>This function is extremely practical because it provides a reliable way to evaluate the performance of a model in a real scenario. Indeed, it allows to make predictions and perform model updates in exactly the same manner that would happen live. For instance, it is used in <code>evaluate.progressive_val_score</code>, which is a higher level function for evaluating models in an online manner.</p>"},{"location":"api/time-series/ForecastingMetric/","title":"ForecastingMetric","text":""},{"location":"api/time-series/ForecastingMetric/#methods","title":"Methods","text":"get <p>Return the current performance along the horizon.</p> <p>Returns</p> <p>list[float]:     The current performance.</p> <p></p> update <p>Update the metric at each step along the horizon.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'list[Number]' </li> <li>y_pred     \u2014 'list[Number]' </li> </ul> <p></p>"},{"location":"api/time-series/HoltWinters/","title":"HoltWinters","text":"<p>Holt-Winters forecaster.</p> <p>This is a standard implementation of the Holt-Winters forecasting method. Certain parametrisations result in special cases, such as simple exponential smoothing. </p> <p>Optimal parameters and initialisation values can be determined in a batch setting. However, in an online setting, it is necessary to wait and observe enough values. The first <code>k = max(2, seasonality)</code> values are indeed used to initialize the components. </p> <p>Level initialization </p> \\[l = \\frac{1}{k} \\sum_{i=1}{k} y_i\\] <p>Trend initialization </p> \\[t = \\frac{1}{k - 1} \\sum_{i=2}{k} y_i - y_{i-1}\\] <p>Trend initialization </p> \\[s_i = \\frac{y_i}{k}\\]"},{"location":"api/time-series/HoltWinters/#parameters","title":"Parameters","text":"<ul> <li> <p>alpha</p> <p>Smoothing parameter for the level.</p> </li> <li> <p>beta</p> <p>Default \u2192 <code>None</code></p> <p>Smoothing parameter for the trend.</p> </li> <li> <p>gamma</p> <p>Default \u2192 <code>None</code></p> <p>Smoothing parameter for the seasonality.</p> </li> <li> <p>seasonality</p> <p>Default \u2192 <code>0</code></p> <p>The number of periods in a season. For instance, this should be 4 for quarterly data, and 12 for yearly data.</p> </li> <li> <p>multiplicative</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not to use a multiplicative formulation.</p> </li> </ul>"},{"location":"api/time-series/HoltWinters/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import metrics\nfrom river import time_series\n\ndataset = datasets.AirlinePassengers()\n\nmodel = time_series.HoltWinters(\n    alpha=0.3,\n    beta=0.1,\n    gamma=0.6,\n    seasonality=12,\n    multiplicative=True\n)\n\nmetric = metrics.MAE()\n\ntime_series.evaluate(\n    dataset,\n    model,\n    metric,\n    horizon=12\n)\n</code></pre> <pre><code>+1  MAE: 25.899087\n+2  MAE: 26.26131\n+3  MAE: 25.735903\n+4  MAE: 25.625678\n+5  MAE: 26.093842\n+6  MAE: 26.90249\n+7  MAE: 28.634398\n+8  MAE: 29.284769\n+9  MAE: 31.018351\n+10 MAE: 32.252349\n+11 MAE: 33.518946\n+12 MAE: 33.975057\n</code></pre></p>"},{"location":"api/time-series/HoltWinters/#methods","title":"Methods","text":"forecast <p>Makes forecast at each step of the given horizon.</p> <p>Parameters</p> <ul> <li>horizon     \u2014 'int' </li> <li>xs     \u2014 'list[dict] | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> learn_one <p>Updates the model.</p> <p>Parameters</p> <ul> <li>y     \u2014 'float' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> <ol> <li> <p>Exponential smoothing \u2014 Wikipedia \u21a9</p> </li> <li> <p>Exponential smoothing \u2014 Forecasting: Principles and Practice \u21a9</p> </li> <li> <p>What is Exponential Smoothing? \u2014 Engineering statistics handbook \u21a9</p> </li> </ol>"},{"location":"api/time-series/HorizonAggMetric/","title":"HorizonAggMetric","text":"<p>Same as <code>HorizonMetric</code>, but aggregates the result based on an provided function.</p> <p>This allows, for instance, to measure the average performance of a forecasting model along the horizon.</p>"},{"location":"api/time-series/HorizonAggMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>Type \u2192 metrics.base.RegressionMetric</p> <p>A regression metric.</p> </li> <li> <p>agg_func</p> <p>Type \u2192 typing.Callable[[list[float]], float]</p> <p>A function that takes as input a list of floats and outputs a single float. You may want to <code>min</code>, <code>max</code>, as well as <code>statistics.mean</code> and <code>statistics.median</code>.</p> </li> </ul>"},{"location":"api/time-series/HorizonAggMetric/#examples","title":"Examples","text":"<p>This is used internally by the <code>time_series.evaluate</code> function when you pass an <code>agg_func</code>.</p> <p><pre><code>import statistics\nfrom river import datasets\nfrom river import metrics\nfrom river import time_series\n\nmetric = time_series.evaluate(\n    dataset=datasets.AirlinePassengers(),\n    model=time_series.HoltWinters(alpha=0.1),\n    metric=metrics.MAE(),\n    agg_func=statistics.mean,\n    horizon=4\n)\n\nmetric\n</code></pre> <pre><code>mean(MAE): 42.901748\n</code></pre></p>"},{"location":"api/time-series/HorizonAggMetric/#methods","title":"Methods","text":"get <p>Return the current performance along the horizon.</p> <p>Returns</p> <p>list[float]:     The current performance.</p> <p></p> update <p>Update the metric at each step along the horizon.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'list[Number]' </li> <li>y_pred     \u2014 'list[Number]' </li> </ul> <p></p>"},{"location":"api/time-series/HorizonMetric/","title":"HorizonMetric","text":"<p>Measures performance at each time step ahead.</p> <p>This allows to measure the performance of a model at each time step along the horizon. A copy of the provided regression metric is made for each time step. At each time step ahead, the metric is thus evaluated on each prediction for said time step, and not for the time steps before or after that.</p>"},{"location":"api/time-series/HorizonMetric/#parameters","title":"Parameters","text":"<ul> <li> <p>metric</p> <p>Type \u2192 metrics.base.RegressionMetric</p> <p>A regression metric.</p> </li> </ul>"},{"location":"api/time-series/HorizonMetric/#examples","title":"Examples","text":"<p>This is used internally by the <code>time_series.evaluate</code> function.</p> <p><pre><code>from river import datasets\nfrom river import metrics\nfrom river import time_series\n\nmetric = time_series.evaluate(\n    dataset=datasets.AirlinePassengers(),\n    model=time_series.HoltWinters(alpha=0.1),\n    metric=metrics.MAE(),\n    horizon=4\n)\n\nmetric\n</code></pre> <pre><code>+1 MAE: 40.931286\n+2 MAE: 42.667998\n+3 MAE: 44.158092\n+4 MAE: 43.849617\n</code></pre></p>"},{"location":"api/time-series/HorizonMetric/#methods","title":"Methods","text":"get <p>Return the current performance along the horizon.</p> <p>Returns</p> <p>list[float]:     The current performance.</p> <p></p> update <p>Update the metric at each step along the horizon.</p> <p>Parameters</p> <ul> <li>y_true     \u2014 'list[Number]' </li> <li>y_pred     \u2014 'list[Number]' </li> </ul> <p></p>"},{"location":"api/time-series/SNARIMAX/","title":"SNARIMAX","text":"<p>SNARIMAX model.</p> <p>SNARIMAX stands for (S)easonal (N)on-linear (A)uto(R)egressive (I)ntegrated (M)oving-(A)verage with e(X)ogenous inputs model. </p> <p>This model generalizes many established time series models in a single interface that can be trained online. It assumes that the provided training data is ordered in time and is uniformly spaced. It is made up of the following components: </p> <ul> <li> <p>S (Seasonal)</p> </li> <li> <p>N (Non-linear): Any online regression model can be used, not necessarily a linear regression</p> <p>as is done in textbooks. - AR (Autoregressive): Lags of the target variable are used as features.</p> </li> <li> <p>I (Integrated): The model can be fitted on a differenced version of a time series. In this</p> <p>context, integration is the reverse of differencing. - MA (Moving average): Lags of the errors are used as features.</p> </li> <li> <p>X (Exogenous): Users can provide additional features. Care has to be taken to include</p> <p>features that will be available both at training and prediction time. </p> </li> </ul> <p>Each of these components can be switched on and off by specifying the appropriate parameters. Classical time series models such as AR, MA, ARMA, and ARIMA can thus be seen as special parametrizations of the SNARIMAX model. </p> <p>This model is tailored for time series that are homoskedastic. In other words, it might not work well if the variance of the time series varies widely along time.</p>"},{"location":"api/time-series/SNARIMAX/#parameters","title":"Parameters","text":"<ul> <li> <p>p</p> <p>Type \u2192 int</p> <p>Order of the autoregressive part. This is the number of past target values that will be included as features.</p> </li> <li> <p>d</p> <p>Type \u2192 int</p> <p>Differencing order.</p> </li> <li> <p>q</p> <p>Type \u2192 int</p> <p>Order of the moving average part. This is the number of past error terms that will be included as features.</p> </li> <li> <p>m</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1</code></p> <p>Season length used for extracting seasonal features. If you believe your data has a seasonal pattern, then set this accordingly. For instance, if the data seems to exhibit a yearly seasonality, and that your data is spaced by month, then you should set this to 12. Note that for this parameter to have any impact you should also set at least one of the <code>p</code>, <code>d</code>, and <code>q</code> parameters.</p> </li> <li> <p>sp</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Seasonal order of the autoregressive part. This is the number of past target values that will be included as features.</p> </li> <li> <p>sd</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Seasonal differencing order.</p> </li> <li> <p>sq</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Seasonal order of the moving average part. This is the number of past error terms that will be included as features.</p> </li> <li> <p>regressor</p> <p>Type \u2192 base.Regressor | compose.Pipeline | None</p> <p>Default \u2192 <code>None</code></p> <p>The online regression model to use. By default, a <code>preprocessing.StandardScaler</code> piped with a <code>linear_model.LinearRegression</code> will be used.</p> </li> </ul>"},{"location":"api/time-series/SNARIMAX/#attributes","title":"Attributes","text":"<ul> <li> <p>differencer (Differencer)</p> </li> <li> <p>y_trues (collections.deque)</p> <p>The <code>p</code> past target values.</p> </li> <li> <p>errors (collections.deque)</p> <p>The <code>q</code> past error values.</p> </li> </ul>"},{"location":"api/time-series/SNARIMAX/#examples","title":"Examples","text":"<p><pre><code>import datetime as dt\nfrom river import datasets\nfrom river import time_series\nfrom river import utils\n\nperiod = 12\nmodel = time_series.SNARIMAX(\n    p=period,\n    d=1,\n    q=period,\n    m=period,\n    sd=1\n)\n\nfor t, (x, y) in enumerate(datasets.AirlinePassengers()):\n    model.learn_one(y)\n\nhorizon = 12\nfuture = [\n    {'month': dt.date(year=1961, month=m, day=1)}\n    for m in range(1, horizon + 1)\n]\nforecast = model.forecast(horizon=horizon)\nfor x, y_pred in zip(future, forecast):\n    print(x['month'], f'{y_pred:.3f}')\n</code></pre> <pre><code>1961-01-01 494.542\n1961-02-01 450.825\n1961-03-01 484.972\n1961-04-01 576.401\n1961-05-01 559.489\n1961-06-01 612.251\n1961-07-01 722.410\n1961-08-01 674.604\n1961-09-01 575.716\n1961-10-01 562.808\n1961-11-01 477.049\n1961-12-01 515.191\n</code></pre></p> <p>Classic ARIMA models learn solely on the time series values. You can also include features built at each step.</p> <p><pre><code>import calendar\nimport math\nfrom river import compose\nfrom river import linear_model\nfrom river import optim\nfrom river import preprocessing\n\ndef get_month_distances(x):\n    return {\n        calendar.month_name[month]: math.exp(-(x['month'].month - month) ** 2)\n        for month in range(1, 13)\n    }\n\ndef get_ordinal_date(x):\n    return {'ordinal_date': x['month'].toordinal()}\n\nextract_features = compose.TransformerUnion(\n    get_ordinal_date,\n    get_month_distances\n)\n\nmodel = (\n    extract_features |\n    time_series.SNARIMAX(\n        p=1,\n        d=0,\n        q=0,\n        m=12,\n        sp=3,\n        sq=6,\n        regressor=(\n            preprocessing.StandardScaler() |\n            linear_model.LinearRegression(\n                intercept_init=110,\n                optimizer=optim.SGD(0.01),\n                intercept_lr=0.3\n            )\n        )\n    )\n)\n\nfor x, y in datasets.AirlinePassengers():\n    model.learn_one(x, y)\n\nforecast = model.forecast(horizon=horizon)\nfor x, y_pred in zip(future, forecast):\n    print(x['month'], f'{y_pred:.3f}')\n</code></pre> <pre><code>1961-01-01 444.821\n1961-02-01 432.612\n1961-03-01 457.739\n1961-04-01 465.544\n1961-05-01 476.575\n1961-06-01 516.255\n1961-07-01 565.405\n1961-08-01 572.470\n1961-09-01 512.645\n1961-10-01 475.919\n1961-11-01 438.033\n1961-12-01 456.892\n</code></pre></p>"},{"location":"api/time-series/SNARIMAX/#methods","title":"Methods","text":"forecast <p>Makes forecast at each step of the given horizon.</p> <p>Parameters</p> <ul> <li>horizon     \u2014 'int' </li> <li>xs     \u2014 'list[dict] | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> learn_one <p>Updates the model.</p> <p>Parameters</p> <ul> <li>y     \u2014 'float' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> <ol> <li> <p>ARMA - Wikipedia \u21a9</p> </li> <li> <p>NARX - Wikipedia \u21a9</p> </li> <li> <p>ARIMA - Forecasting: Principles and Practice \u21a9</p> </li> <li> <p>Anava, O., Hazan, E., Mannor, S. and Shamir, O., 2013, June. Online learning for time series prediction. In Conference on learning theory (pp. 172-184) \u21a9</p> </li> </ol>"},{"location":"api/time-series/evaluate/","title":"evaluate","text":"<p>Evaluates the performance of a forecaster on a time series dataset.</p> <p>To understand why this method is useful, it's important to understand the difference between nowcasting and forecasting. Nowcasting is about predicting a value at the next time step. This can be seen as a special case of regression, where the value to predict is the value at the next time step. In this case, the <code>evaluate.progressive_val_score</code> function may be used to evaluate a model via progressive validation. </p> <p>Forecasting models can also be evaluated via progressive validation. This is the purpose of this function. At each time step <code>t</code>, the forecaster is asked to predict the values at <code>t + 1</code>, <code>t + 2</code>, ..., <code>t + horizon</code>. The performance at each time step is measured and returned.</p>"},{"location":"api/time-series/evaluate/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset</p> <p>Type \u2192 base.typing.Dataset</p> <p>A sequential time series.</p> </li> <li> <p>model</p> <p>Type \u2192 time_series.base.Forecaster</p> <p>A forecaster.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.RegressionMetric</p> <p>A regression metric.</p> </li> <li> <p>horizon</p> <p>Type \u2192 int</p> </li> <li> <p>agg_func</p> <p>Type \u2192 typing.Callable[[list[float]], float] | None</p> <p>Default \u2192 <code>None</code></p> </li> <li> <p>grace_period</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.</p> </li> </ul>"},{"location":"api/time-series/iter-evaluate/","title":"iter_evaluate","text":"<p>Evaluates the performance of a forecaster on a time series dataset and yields results.</p> <p>This does exactly the same as <code>evaluate.progressive_val_score</code>. The only difference is that this function returns an iterator, yielding results at every step. This can be useful if you want to have control over what you do with the results. For instance, you might want to plot the results.</p>"},{"location":"api/time-series/iter-evaluate/#parameters","title":"Parameters","text":"<ul> <li> <p>dataset</p> <p>Type \u2192 base.typing.Dataset</p> <p>A sequential time series.</p> </li> <li> <p>model</p> <p>Type \u2192 time_series.base.Forecaster</p> <p>A forecaster.</p> </li> <li> <p>metric</p> <p>Type \u2192 metrics.base.RegressionMetric</p> <p>A regression metric.</p> </li> <li> <p>horizon</p> <p>Type \u2192 int</p> </li> <li> <p>agg_func</p> <p>Type \u2192 typing.Callable[[list[float]], float] | None</p> <p>Default \u2192 <code>None</code></p> </li> <li> <p>grace_period</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Initial period during which the metric is not updated. This is to fairly evaluate models which need a warming up period to start producing meaningful forecasts. The value of this parameter is equal to the horizon by default.</p> </li> </ul>"},{"location":"api/time-series/base/Forecaster/","title":"Forecaster","text":""},{"location":"api/time-series/base/Forecaster/#methods","title":"Methods","text":"forecast <p>Makes forecast at each step of the given horizon.</p> <p>Parameters</p> <ul> <li>horizon     \u2014 'int' </li> <li>xs     \u2014 'list[dict] | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p> learn_one <p>Updates the model.</p> <p>Parameters</p> <ul> <li>y     \u2014 'float' </li> <li>x     \u2014 'dict | None'     \u2014 defaults to <code>None</code> </li> </ul> <p></p>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/","title":"ExtremelyFastDecisionTreeClassifier","text":"<p>Extremely Fast Decision Tree (EFDT) classifier.</p> <p>Also referred to as the Hoeffding AnyTime Tree (HATT) classifier. In practice, despite the name, EFDTs are typically slower than a vanilla Hoeffding Tree to process data. The speed differences come from the mechanism of split re-evaluation present in EFDT. Nonetheless, EFDT has theoretical properties that ensure it converges faster than the vanilla Hoeffding Tree to the structure that would be created by a batch decision tree model (such as Classification and Regression Trees - CART). Keep in mind that such propositions hold when processing a stationary data stream. When dealing with non-stationary data, EFDT is somewhat robust to concept drifts as it continually revisits and updates its internal decision tree structure. Still, in such cases, the Hoeffind Adaptive Tree might be a better option, as it was specifically designed to handle non-stationarity.</p>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</p> </li> <li> <p>min_samples_reevaluate</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>20</code></p> <p>Number of instances a node should observe before reevaluating the best split.</p> </li> <li> <p>split_criterion</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>min_branch_fraction</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>The minimum percentage of observed data required for branches resulting from split candidates. To validate a split candidate, at least two resulting branches must have a percentage of samples greater than <code>min_branch_fraction</code>. This criterion prevents unnecessary splits when the majority of instances are concentrated in a single branch.</p> </li> <li> <p>max_share_to_split</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.99</code></p> <p>Only perform a split in a leaf if the proportion of elements in the majority class is smaller than this parameter value. This parameter avoids performing splits when most of the data belongs to a single class.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>100.0</code></p> <p>The max size of the tree, in mebibytes (MiB).</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MiB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\n\ngen = synth.Agrawal(classification_function=0, seed=42)\ndataset = iter(gen.take(1000))\n\nmodel = tree.ExtremelyFastDecisionTreeClassifier(\n    grace_period=100,\n    delta=1e-5,\n    nominal_attributes=['elevel', 'car', 'zipcode'],\n    min_samples_reevaluate=100\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 87.29%\n</code></pre></p>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>str | None:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p> <p></p> draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</li> </ul> <p></p> learn_one <p>Incrementally train the model</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p> <p></p>"},{"location":"api/tree/ExtremelyFastDecisionTreeClassifier/#notes","title":"Notes","text":"<p>The Extremely Fast Decision Tree (EFDT) <sup>1</sup> constructs a tree incrementally. The EFDT seeks to select and deploy a split as soon as it is confident the split is useful, and then revisits that decision, replacing the split if it subsequently becomes evident that a better split is available. The EFDT learns rapidly from a stationary distribution and eventually it learns the asymptotic batch tree if the distribution from which the data are drawn is stationary.</p> <ol> <li> <p>C. Manapragada, G. Webb, and M. Salehi. Extremely Fast Decision Tree. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining (KDD '18). ACM, New York, NY, USA, 1953-1962. DOI: https://doi.org/10.1145/3219819.3220005\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/","title":"HoeffdingAdaptiveTreeClassifier","text":"<p>Hoeffding Adaptive Tree classifier.</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</p> </li> <li> <p>split_criterion</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>bootstrap_sampling</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, perform bootstrap sampling in the leaf nodes.</p> </li> <li> <p>drift_window_threshold</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>300</code></p> <p>Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>The drift detector used to build the tree. If <code>None</code> then <code>drift.ADWIN</code> is used.</p> </li> <li> <p>switch_significance</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>The significance level to assess whether alternate subtrees are significantly better than their main subtree counterparts.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>min_branch_fraction</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>The minimum percentage of observed data required for branches resulting from split candidates. To validate a split candidate, at least two resulting branches must have a percentage of samples greater than <code>min_branch_fraction</code>. This criterion prevents unnecessary splits when the majority of instances are concentrated in a single branch.</p> </li> <li> <p>max_share_to_split</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.99</code></p> <p>Only perform a split in a leaf if the proportion of elements in the majority class is smaller than this parameter value. This parameter avoids performing splits when most of the data belongs to a single class.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>100.0</code></p> <p>The max size of the tree, in mebibytes (MiB).</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MiB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_alternate_trees</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_pruned_alternate_trees</p> </li> <li> <p>n_switch_alternate_trees</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\n\ngen = synth.ConceptDriftStream(stream=synth.SEA(seed=42, variant=0),\n                               drift_stream=synth.SEA(seed=42, variant=1),\n                               seed=1, position=500, width=50)\ndataset = iter(gen.take(1000))\n\nmodel = tree.HoeffdingAdaptiveTreeClassifier(\n    grace_period=100,\n    delta=1e-5,\n    leaf_prediction='nb',\n    nb_threshold=10,\n    seed=0\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 91.49%\n</code></pre></p>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>str | None:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p> <p></p> draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</li> </ul> <p></p> learn_one <p>Train the model on instance x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p> <p></p>"},{"location":"api/tree/HoeffdingAdaptiveTreeClassifier/#notes","title":"Notes","text":"<p>The Hoeffding Adaptive Tree <sup>1</sup> uses a drift detector to monitor performance of branches in the tree and to replace them with new branches when their accuracy decreases.</p> <p>The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance.</p> <ol> <li> <p>Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\"    In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin,    Heidelberg, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/","title":"HoeffdingAdaptiveTreeRegressor","text":"<p>Hoeffding Adaptive Tree regressor (HATR).</p> <p>This class implements a regression version of the Hoeffding Adaptive Tree Classifier. Hence, it also uses an ADWIN concept-drift detector instance at each decision node to monitor possible changes in the data distribution. If a drift is detected in a node, an alternate tree begins to be induced in the background. When enough information is gathered, HATR swaps the node where the change was detected by its alternate tree.</p>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>adaptive</code></p> <p>Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model</p> <p>Type \u2192 base.Regressor | None</p> <p>Default \u2192 <code>None</code></p> <p>The regression model used to provide responses if <code>leaf_prediction='model'</code>. If not provided an instance of <code>linear_model.LinearRegression</code> with the default hyperparameters is used.</p> </li> <li> <p>model_selector_decay</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.95</code></p> <p>The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List of Nominal attributes. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>bootstrap_sampling</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, perform bootstrap sampling in the leaf nodes.</p> </li> <li> <p>drift_window_threshold</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>300</code></p> <p>Minimum number of examples an alternate tree must observe before being considered as a potential replacement to the current one.</p> </li> <li> <p>drift_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>The drift detector used to build the tree. If <code>None</code> then <code>drift.ADWIN</code> is used. Only detectors that support arbitrarily valued continuous data can be used for regression.</p> </li> <li> <p>switch_significance</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>The significance level to assess whether alternate subtrees are significantly better than their main subtree counterparts.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>500.0</code></p> <p>The max size of the tree, in mebibytes (MiB).</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> <li> <p>seed</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>Random seed for reproducibility.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MiB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_alternate_trees</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_pruned_alternate_trees</p> </li> <li> <p>n_switch_alternate_trees</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    tree.HoeffdingAdaptiveTreeRegressor(\n        grace_period=50,\n        model_selector_decay=0.3,\n        seed=0\n    )\n)\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.917576\n</code></pre></p>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>str | None:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p> <p></p> draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</li> </ul> <p></p> learn_one <p>Train the tree model on sample x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the target value using one of the leaf prediction strategies.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>Predicted target value.</p> <p></p> to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p> <p></p>"},{"location":"api/tree/HoeffdingAdaptiveTreeRegressor/#notes","title":"Notes","text":"<p>The Hoeffding Adaptive Tree <sup>1</sup> uses drift detectors to monitor performance of branches in the tree and to replace them with new branches when their accuracy decreases.</p> <p>The bootstrap sampling strategy is an improvement over the original Hoeffding Adaptive Tree algorithm. It is enabled by default since, in general, it results in better performance.</p> <p>To cope with ADWIN's requirements of bounded input data, HATR uses a novel error normalization strategy based on the empiral rule of Gaussian distributions. We assume the deviations of the predictions from the expected values follow a normal distribution. Hence, we subject these errors to a min-max normalization assuming that most of the data lies in the \\(\\left[-3\\sigma, 3\\sigma\\right]\\) range. These normalized errors are passed to the ADWIN instances. This is the same strategy used by Adaptive Random Forest Regressor.</p> <ol> <li> <p>Bifet, Albert, and Ricard Gavald\u00e0. \"Adaptive learning from evolving data streams.\" In International Symposium on Intelligent Data Analysis, pp. 249-260. Springer, Berlin, Heidelberg, 2009.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingTreeClassifier/","title":"HoeffdingTreeClassifier","text":"<p>Hoeffding Tree or Very Fast Decision Tree classifier.</p>"},{"location":"api/tree/HoeffdingTreeClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</p> </li> <li> <p>split_criterion</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>nb_threshold</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>min_branch_fraction</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>The minimum percentage of observed data required for branches resulting from split candidates. To validate a split candidate, at least two resulting branches must have a percentage of samples greater than <code>min_branch_fraction</code>. This criterion prevents unnecessary splits when the majority of instances are concentrated in a single branch.</p> </li> <li> <p>max_share_to_split</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.99</code></p> <p>Only perform a split in a leaf if the proportion of elements in the majority class is smaller than this parameter value. This parameter avoids performing splits when most of the data belongs to a single class.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>100.0</code></p> <p>The max size of the tree, in mebibytes (MiB).</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MiB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeClassifier/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\n\ngen = synth.Agrawal(classification_function=0, seed=42)\ndataset = iter(gen.take(1000))\n\nmodel = tree.HoeffdingTreeClassifier(\n    grace_period=100,\n    delta=1e-5,\n    nominal_attributes=['elevel', 'car', 'zipcode']\n)\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 84.58%\n</code></pre></p>"},{"location":"api/tree/HoeffdingTreeClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>str | None:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p> <p></p> draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</li> </ul> <p></p> learn_one <p>Train the model on instance x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p> <p></p>"},{"location":"api/tree/HoeffdingTreeClassifier/#notes","title":"Notes","text":"<p>A Hoeffding Tree <sup>1</sup> is an incremental, anytime decision tree induction algorithm that is capable of learning from massive data streams, assuming that the distribution generating examples does not change over time. Hoeffding trees exploit the fact that a small sample can often be enough to choose an optimal splitting attribute. This idea is supported mathematically by the Hoeffding bound, which quantifies the number of observations (in our case, examples) needed to estimate some statistics within a prescribed precision (in our case, the goodness of an attribute).</p> <p>A theoretically appealing feature of Hoeffding Trees not shared by other incremental decision tree learners is that it has sound guarantees of performance. Using the Hoeffding bound one can show that its output is asymptotically nearly identical to that of a non-incremental learner using infinitely many examples. Implementation based on MOA <sup>2</sup>.</p> <ol> <li> <p>G. Hulten, L. Spencer, and P. Domingos. Mining time-changing data streams.    In KDD\u201901, pages 97\u2013106, San Francisco, CA, 2001. ACM Press.\u00a0\u21a9</p> </li> <li> <p>Albert Bifet, Geoff Holmes, Richard Kirkby, Bernhard Pfahringer.    MOA: Massive Online Analysis; Journal of Machine Learning Research 11: 1601-1604, 2010.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/HoeffdingTreeRegressor/","title":"HoeffdingTreeRegressor","text":"<p>Hoeffding Tree regressor.</p>"},{"location":"api/tree/HoeffdingTreeRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Significance level to calculate the Hoeffding bound. The significance level is given by <code>1 - delta</code>. Values closer to zero imply longer split decision delays.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>adaptive</code></p> <p>Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model</p> <p>Type \u2192 base.Regressor | None</p> <p>Default \u2192 <code>None</code></p> <p>The regression model used to provide responses if <code>leaf_prediction='model'</code>. If not provided an instance of <code>linear_model.LinearRegression</code> with the default hyperparameters is used.</p> </li> <li> <p>model_selector_decay</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.95</code></p> <p>The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>500.0</code></p> <p>The max size of the tree, in mebibytes (MiB).</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MiB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/HoeffdingTreeRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\nfrom river import preprocessing\n\ndataset = datasets.TrumpApproval()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    tree.HoeffdingTreeRegressor(\n        grace_period=100,\n        model_selector_decay=0.9\n    )\n)\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.793345\n</code></pre></p>"},{"location":"api/tree/HoeffdingTreeRegressor/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>str | None:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p> <p></p> draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</li> </ul> <p></p> learn_one <p>Train the tree model on sample x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the target value using one of the leaf prediction strategies.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>Predicted target value.</p> <p></p> to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p> <p></p>"},{"location":"api/tree/HoeffdingTreeRegressor/#notes","title":"Notes","text":"<p>The Hoeffding Tree Regressor (HTR) is an adaptation of the incremental tree algorithm of the same name for classification. Similarly to its classification counterpart, HTR uses the Hoeffding bound to control its split decisions. Differently from the classification algorithm, HTR relies on calculating the reduction of variance in the target space to decide among the split candidates. The smallest the variance at its leaf nodes, the more homogeneous the partitions are. At its leaf nodes, HTR fits either linear models or uses the target average as the predictor.</p>"},{"location":"api/tree/LASTClassifier/","title":"LASTClassifier","text":"<p>Local Adaptive Streaming Tree Classifier.</p> <p>Local Adaptive Streaming Tree <sup>1</sup> (LAST) is an incremental decision tree with adaptive splitting mechanisms. LAST maintains a change detector at each leaf and splits this node if a change is detected in the error or the leaf`s data distribution. </p> <p>LAST is still not suitable for use as a base classifier in ensembles due to the change detectors. The authors in <sup>1</sup> are working on a version of LAST that overcomes this limitation.</p>"},{"location":"api/tree/LASTClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow until the system recursion limit.</p> </li> <li> <p>split_criterion</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>info_gain</code></p> <p>Split criterion to use. - 'gini' - Gini - 'info_gain' - Information Gain - 'hellinger' - Helinger Distance</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>nba</code></p> <p>Prediction mechanism used at leafs. - 'mc' - Majority Class - 'nb' - Naive Bayes - 'nba' - Naive Bayes Adaptive</p> </li> <li> <p>change_detector</p> <p>Type \u2192 base.DriftDetector | None</p> <p>Default \u2192 <code>None</code></p> <p>Change detector that will be created at each leaf of the tree.</p> </li> <li> <p>track_error</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, the change detector will have binary inputs for error predictions, otherwise the input will be the split criteria.</p> </li> <li> <p>nb_threshold</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>0</code></p> <p>Number of instances a leaf should observe before allowing Naive Bayes.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.GaussianSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>min_branch_fraction</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.01</code></p> <p>The minimum percentage of observed data required for branches resulting from split candidates. To validate a split candidate, at least two resulting branches must have a percentage of samples greater than <code>min_branch_fraction</code>. This criterion prevents unnecessary splits when the majority of instances are concentrated in a single branch.</p> </li> <li> <p>max_share_to_split</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.99</code></p> <p>Only perform a split in a leaf if the proportion of elements in the majority class is smaller than this parameter value. This parameter avoids performing splits when most of the data belongs to a single class.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>100.0</code></p> <p>The max size of the tree, in Megabytes (MB).</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/LASTClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MiB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/LASTClassifier/#examples","title":"Examples","text":"<p><pre><code>from river.datasets import synth\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\n\ngen = synth.ConceptDriftStream(stream=synth.SEA(seed=42, variant=0),\n                       drift_stream=synth.SEA(seed=42, variant=1),\n                       seed=1, position=1500, width=50)\ndataset = iter(gen.take(3000))\n\nmodel = tree.LASTClassifier()\n\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 91.10%\n</code></pre></p>"},{"location":"api/tree/LASTClassifier/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>str | None:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p> <p></p> draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow until the system recursion limit.</li> </ul> <p></p> learn_one <p>Train the model on instance x and corresponding target y.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>A dictionary that associates a probability which each label.</p> <p></p> to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p> <p></p> <ol> <li> <p>Daniel Nowak Assis, Jean Paul Barddal, and Fabr\u00edcio Enembreck. Just Change on Change: Adaptive Splitting Time for Decision Trees in Data Stream Classification . In Proceedings of ACM SAC Conference (SAC\u201924).\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"api/tree/SGTClassifier/","title":"SGTClassifier","text":"<p>Stochastic Gradient Tree<sup>1</sup> for binary classification.</p> <p>Binary decision tree classifier that minimizes the binary cross-entropy to guide its growth. </p> <p>Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but data impurity-related heuristics.</p>"},{"location":"api/tree/SGTClassifier/#parameters","title":"Parameters","text":"<ul> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Define the significance level of the F-tests performed to decide upon creating splits or updating predictions.</p> </li> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Interval between split attempts or prediction updates.</p> </li> <li> <p>init_pred</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial value predicted by the tree.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth the tree might reach. If set to <code>None</code>, the trees will grow indefinitely.</p> </li> <li> <p>lambda_value</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.1</code></p> <p>Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions.</p> </li> <li> <p>gamma</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric.</p> </li> <li> <p>feature_quantizer</p> <p>Type \u2192 tree.splitter.Quantizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of <code>tree.splitter.StaticQuantizer</code> (with default parameters) is used if this parameter is not set.</p> </li> </ul>"},{"location":"api/tree/SGTClassifier/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_node_updates</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_observations</p> </li> <li> <p>n_splits</p> </li> </ul>"},{"location":"api/tree/SGTClassifier/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\n\ndataset = datasets.Phishing()\nmodel = tree.SGTClassifier(\n    feature_quantizer=tree.splitter.StaticQuantizer(\n        n_bins=32, warm_start=10\n    )\n)\nmetric = metrics.Accuracy()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>Accuracy: 82.24%\n</code></pre></p>"},{"location":"api/tree/SGTClassifier/#methods","title":"Methods","text":"learn_one <p>Update the model with a set of features <code>x</code> and a label <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.ClfTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the label of a set of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>base.typing.ClfTarget | None:     The predicted label.</p> <p></p> predict_proba_one <p>Predict the probability of each label for a dictionary of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> <li>kwargs     \u2014 'Any' </li> </ul> <p>Returns</p> <p>dict[base.typing.ClfTarget, float]:     A dictionary that associates a probability which each label.</p> <p></p> <ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/SGTRegressor/","title":"SGTRegressor","text":"<p>Stochastic Gradient Tree for regression.</p> <p>Incremental decision tree regressor that minimizes the mean square error to guide its growth. </p> <p>Stochastic Gradient Trees (SGT) directly minimize a loss function to guide tree growth and update their predictions. Thus, they differ from other incrementally tree learners that do not directly optimize the loss, but a data impurity-related heuristic.</p>"},{"location":"api/tree/SGTRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Define the significance level of the F-tests performed to decide upon creating splits or updating predictions.</p> </li> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Interval between split attempts or prediction updates.</p> </li> <li> <p>init_pred</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.0</code></p> <p>Initial value predicted by the tree.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth the tree might reach. If set to <code>None</code>, the trees will grow indefinitely.</p> </li> <li> <p>lambda_value</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.1</code></p> <p>Positive float value used to impose a penalty over the tree's predictions and force them to become smaller. The greater the lambda value, the more constrained are the predictions.</p> </li> <li> <p>gamma</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> <p>Positive float value used to impose a penalty over the tree's splits and force them to be avoided when possible. The greater the gamma value, the smaller the chance of a split occurring.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List with identifiers of the nominal attributes. If None, all features containing numbers are assumed to be numeric.</p> </li> <li> <p>feature_quantizer</p> <p>Type \u2192 tree.splitter.Quantizer | None</p> <p>Default \u2192 <code>None</code></p> <p>The algorithm used to quantize numeric features. Either a static quantizer (as in the original implementation) or a dynamic quantizer can be used. The correct choice and setup of the feature quantizer is a crucial step to determine the performance of SGTs. Feature quantizers are akin to the attribute observers used in Hoeffding Trees. By default, an instance of <code>tree.splitter.StaticQuantizer</code> (with default parameters) is used if this parameter is not set.</p> </li> </ul>"},{"location":"api/tree/SGTRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_node_updates</p> </li> <li> <p>n_nodes</p> </li> <li> <p>n_observations</p> </li> <li> <p>n_splits</p> </li> </ul>"},{"location":"api/tree/SGTRegressor/#examples","title":"Examples","text":"<p><pre><code>from river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import tree\n\ndataset = datasets.TrumpApproval()\nmodel = tree.SGTRegressor(\n    delta=0.01,\n    lambda_value=0.01,\n    grace_period=20,\n    feature_quantizer=tree.splitter.DynamicQuantizer(std_prop=0.1)\n)\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 1.721818\n</code></pre></p>"},{"location":"api/tree/SGTRegressor/#methods","title":"Methods","text":"learn_one <p>Fits to a set of features <code>x</code> and a real-valued target <code>y</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict[base.typing.FeatureName, Any]' </li> <li>y     \u2014 'base.typing.RegTarget' </li> <li>w     \u2014 defaults to <code>1.0</code> </li> </ul> <p></p> predict_one <p>Predict the output of features <code>x</code>.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>base.typing.RegTarget:     The prediction.</p> <p></p>"},{"location":"api/tree/SGTRegressor/#notes","title":"Notes","text":"<p>This implementation enhances the original proposal <sup>1</sup> by using an incremental strategy to discretize numerical features dynamically, rather than relying on a calibration set and parameterized number of bins. The strategy used is an adaptation of the Quantization Observer (QO) <sup>2</sup>. Different bin size setting policies are available for selection. They directly related to number of split candidates the tree is going to explore, and thus, how accurate its split decisions are going to be. Besides, the number of stored bins per feature is directly related to the tree's memory usage and runtime.</p> <ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> <li> <p>Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/iSOUPTreeRegressor/","title":"iSOUPTreeRegressor","text":"<p>Incremental Structured Output Prediction Tree (iSOUP-Tree) for multi-target regression.</p> <p>This is an implementation of the iSOUP-Tree proposed by A. Osojnik, P. Panov, and S. D\u017eeroski <sup>1</sup>.</p>"},{"location":"api/tree/iSOUPTreeRegressor/#parameters","title":"Parameters","text":"<ul> <li> <p>grace_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>200</code></p> <p>Number of instances a leaf should observe between split attempts.</p> </li> <li> <p>max_depth</p> <p>Type \u2192 int | None</p> <p>Default \u2192 <code>None</code></p> <p>The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</p> </li> <li> <p>delta</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1e-07</code></p> <p>Allowed error in split decision, a value closer to 0 takes longer to decide.</p> </li> <li> <p>tau</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.05</code></p> <p>Threshold below which a split will be forced to break ties.</p> </li> <li> <p>leaf_prediction</p> <p>Type \u2192 str</p> <p>Default \u2192 <code>adaptive</code></p> <p>Prediction mechanism used at leafs. - 'mean' - Target mean - 'model' - Uses the model defined in <code>leaf_model</code> - 'adaptive' - Chooses between 'mean' and 'model' dynamically</p> </li> <li> <p>leaf_model</p> <p>Type \u2192 base.Regressor | dict | None</p> <p>Default \u2192 <code>None</code></p> <p>The regression model(s) used to provide responses if <code>leaf_prediction='model'</code>. It can be either a regressor (in which case it is going to be replicated to all the targets) or a dictionary whose keys are target identifiers, and the values are instances of <code>base.Regressor</code>.<code>If not provided, instances of [</code>linear_model.LinearRegression`](../../linear-model/LinearRegression) with the default hyperparameters are used for all the targets. If a dictionary is passed and not all target models are specified, copies from the first model match in the dictionary will be used to the remaining targets.</p> </li> <li> <p>model_selector_decay</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.95</code></p> <p>The exponential decaying factor applied to the learning models' squared errors, that are monitored if <code>leaf_prediction='adaptive'</code>. Must be between <code>0</code> and <code>1</code>. The closer to <code>1</code>, the more importance is going to be given to past observations. On the other hand, if its value approaches <code>0</code>, the recent observed errors are going to have more influence on the final decision.</p> </li> <li> <p>nominal_attributes</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>List of Nominal attributes identifiers. If empty, then assume that all numeric attributes should be treated as continuous.</p> </li> <li> <p>splitter</p> <p>Type \u2192 Splitter | None</p> <p>Default \u2192 <code>None</code></p> <p>The Splitter or Attribute Observer (AO) used to monitor the class statistics of numeric features and perform splits. Splitters are available in the <code>tree.splitter</code> module. Different splitters are available for classification and regression tasks. Classification and regression splitters can be distinguished by their property <code>is_target_class</code>. This is an advanced option. Special care must be taken when choosing different splitters. By default, <code>tree.splitter.TEBSTSplitter</code> is used if <code>splitter</code> is <code>None</code>.</p> </li> <li> <p>min_samples_split</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>5</code></p> <p>The minimum number of samples every branch resulting from a split candidate must have to be considered valid.</p> </li> <li> <p>binary_split</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, only allow binary splits.</p> </li> <li> <p>max_size</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>500.0</code></p> <p>The max size of the tree, in mebibytes (MiB).</p> </li> <li> <p>memory_estimate_period</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1000000</code></p> <p>Interval (number of processed instances) between memory consumption checks.</p> </li> <li> <p>stop_mem_management</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, stop growing as soon as memory limit is hit.</p> </li> <li> <p>remove_poor_attrs</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>False</code></p> <p>If True, disable poor attributes to reduce memory usage.</p> </li> <li> <p>merit_preprune</p> <p>Type \u2192 bool</p> <p>Default \u2192 <code>True</code></p> <p>If True, enable merit-based tree pre-pruning.</p> </li> </ul>"},{"location":"api/tree/iSOUPTreeRegressor/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>leaf_prediction</p> <p>Return the prediction strategy used by the tree at its leaves.</p> </li> <li> <p>max_size</p> <p>Max allowed size tree can reach (in MiB).</p> </li> <li> <p>n_active_leaves</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_inactive_leaves</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> <li> <p>split_criterion</p> <p>Return a string with the name of the split criterion being used by the tree.</p> </li> <li> <p>summary</p> <p>Collect metrics corresponding to the current status of the tree in a string buffer.</p> </li> </ul>"},{"location":"api/tree/iSOUPTreeRegressor/#examples","title":"Examples","text":"<p><pre><code>import numbers\nfrom river import compose\nfrom river import datasets\nfrom river import evaluate\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\nfrom river import tree\n\ndataset = datasets.SolarFlare()\n\nnum = compose.SelectType(numbers.Number) | preprocessing.MinMaxScaler()\ncat = compose.SelectType(str) | preprocessing.OneHotEncoder()\n\nmodel = tree.iSOUPTreeRegressor(\n    grace_period=100,\n    leaf_prediction='model',\n    leaf_model={\n        'c-class-flares': linear_model.LinearRegression(l2=0.02),\n        'm-class-flares': linear_model.PARegressor(),\n        'x-class-flares': linear_model.LinearRegression(l2=0.1)\n    }\n)\n\npipeline = (num + cat) | model\nmetric = metrics.multioutput.MicroAverage(metrics.MAE())\n\nevaluate.progressive_val_score(dataset, pipeline, metric)\n</code></pre> <pre><code>MicroAverage(MAE): 0.426177\n</code></pre></p>"},{"location":"api/tree/iSOUPTreeRegressor/#methods","title":"Methods","text":"debug_one <p>Print an explanation of how <code>x</code> is predicted.</p> <p>Parameters</p> <ul> <li>x     \u2014 'dict' </li> </ul> <p>Returns</p> <p>str | None:     A representation of the path followed by the tree to predict <code>x</code>; <code>None</code> if</p> <p></p> draw <p>Draw the tree using the <code>graphviz</code> library.</p> <p>Since the tree is drawn without passing incoming samples, classification trees will show the majority class in their leaves, whereas regression trees will use the target mean.</p> <p>Parameters</p> <ul> <li>max_depth     \u2014 'int | None'     \u2014 defaults to <code>None</code>      The maximum depth a tree can reach. If <code>None</code>, the tree will grow until   the system recursion limit.</li> </ul> <p></p> learn_one <p>Incrementally train the model with one sample.</p> <p>Training tasks:  * If the tree is empty, create a leaf node as the root. * If the tree is already initialized, find the corresponding leaf for   the instance and update the leaf node statistics. * If growth is allowed and the number of instances that the leaf has   observed between split attempts exceed the grace period then attempt   to split.</p> <p>Parameters</p> <ul> <li>x </li> <li>y </li> <li>w     \u2014 'float'     \u2014 defaults to <code>1.0</code> </li> <li>kwargs </li> </ul> <p></p> predict_one <p>Predict the target value using one of the leaf prediction strategies.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p>Returns</p> <p>Predicted target value.</p> <p></p> to_dataframe <p>Return a representation of the current tree structure organized in a <code>pandas.DataFrame</code> object.</p> <p>In case the tree is empty or it only contains a single node (a leaf), <code>None</code> is returned.</p> <p>Returns</p> <p>df</p> <p></p> <ol> <li> <p>Alja\u017e Osojnik, Pan\u010de Panov, and Sa\u0161o D\u017eeroski. \"Tree-based methods for online multi-target regression.\" Journal of Intelligent Information Systems 50.2 (2018): 315-339.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/base/Branch/","title":"Branch","text":"<p>A generic tree branch.</p>"},{"location":"api/tree/base/Branch/#parameters","title":"Parameters","text":"<ul> <li> <p>children</p> <p>Child branches and/or leaves.</p> </li> </ul>"},{"location":"api/tree/base/Branch/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> <p>Distance to the deepest descendant.</p> </li> <li> <p>n_branches</p> <p>Number of branches, including thyself.</p> </li> <li> <p>n_leaves</p> <p>Number of leaves.</p> </li> <li> <p>n_nodes</p> <p>Number of descendants, including thyself.</p> </li> <li> <p>repr_split</p> <p>String representation of the split.</p> </li> </ul>"},{"location":"api/tree/base/Branch/#methods","title":"Methods","text":"iter_bfs <p>Iterate over nodes in breadth-first order.</p> <p></p> iter_branches <p>Iterate over branches in depth-first order.</p> <p></p> iter_dfs <p>Iterate over nodes in depth-first order.</p> <p></p> iter_edges <p>Iterate over edges in depth-first order.</p> <p></p> iter_leaves <p>Iterate over leaves from the left-most one to the right-most one.</p> <p></p> most_common_path <p>Return a tuple with the branch index and the child node related to the most traversed path.</p> <p>Used in case the split feature is missing from an instance.</p> <p></p> next <p>Move to the next node down the tree.</p> <p>Parameters</p> <ul> <li>x </li> </ul> <p></p> to_dataframe <p>Build a DataFrame containing one record for each node.</p> <p></p> traverse <p>Return the leaf corresponding to the given input.</p> <p>Parameters</p> <ul> <li>x </li> <li>until_leaf     \u2014 defaults to <code>True</code> </li> </ul> <p></p> walk <p>Iterate over the nodes of the path induced by x.</p> <p>Parameters</p> <ul> <li>x </li> <li>until_leaf     \u2014 defaults to <code>True</code> </li> </ul> <p></p>"},{"location":"api/tree/base/Leaf/","title":"Leaf","text":"<p>A generic tree node.</p>"},{"location":"api/tree/base/Leaf/#parameters","title":"Parameters","text":"<ul> <li> <p>kwargs</p> <p>Each provided keyword argument is stored in the leaf as an attribute.</p> </li> </ul>"},{"location":"api/tree/base/Leaf/#attributes","title":"Attributes","text":"<ul> <li> <p>height</p> </li> <li> <p>n_branches</p> </li> <li> <p>n_leaves</p> </li> <li> <p>n_nodes</p> </li> </ul>"},{"location":"api/tree/base/Leaf/#methods","title":"Methods","text":"iter_branches iter_dfs iter_edges iter_leaves walk"},{"location":"api/tree/splitter/DynamicQuantizer/","title":"DynamicQuantizer","text":"<p>Adapted version of the Quantizer Observer (QO)<sup>1</sup> that is applied to Stochastic Gradient Trees (SGT).</p> <p>This feature quantizer starts by partitioning the inputs using the passed <code>radius</code> value. As more splits are created in the SGTs, new feature quantizers will use <code>std * std_prop</code> as the quantization radius. In the expression, <code>std</code> represents the standard deviation of the input data, which is calculated incrementally.</p>"},{"location":"api/tree/splitter/DynamicQuantizer/#parameters","title":"Parameters","text":"<ul> <li> <p>radius</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.5</code></p> <p>The initial quantization radius.</p> </li> <li> <p>std_prop</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.25</code></p> <p>The proportion of the standard deviation that is going to be used to define the radius value for new quantizer instances following the initial one.</p> </li> </ul>"},{"location":"api/tree/splitter/DynamicQuantizer/#methods","title":"Methods","text":"update <ol> <li> <p>Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/EBSTSplitter/","title":"EBSTSplitter","text":"<p>iSOUP-Tree's Extended Binary Search Tree (E-BST).</p> <p>This class implements the Extended Binary Search Tree<sup>1</sup> (E-BST) structure, using the variant employed by Osojnik et al.<sup>2</sup> in the iSOUP-Tree algorithm. This structure is employed to observe the target space distribution. </p> <p>Proposed along with Fast Incremental Model Tree with Drift Detection<sup>1</sup> (FIMT-DD), E-BST was the first attribute observer (AO) proposed for incremental Hoeffding Tree regressors. This AO works by storing all observations between splits in an extended binary search tree structure. E-BST stores the input feature realizations and statistics of the target(s) that enable calculating the split heuristic at any time. To alleviate time and memory costs, E-BST implements a memory management routine, where the worst split candidates are pruned from the binary tree. </p> <p>In this variant, only the left branch statistics are stored and the complete split-enabling statistics are calculated with an in-order traversal of the binary search tree.</p>"},{"location":"api/tree/splitter/EBSTSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/EBSTSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     \u2014 'SplitCriterion' </li> <li>pre_split_dist     \u2014 'list | dict' </li> <li>att_idx     \u2014 'base.typing.FeatureName' </li> <li>binary_only     \u2014 'bool'     \u2014 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p> <p></p> cond_proba <p>Not implemented in regression splitters.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> remove_bad_splits <p>Remove bad splits.</p> <p>Based on FIMT-DD's <sup>1</sup> procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed).  Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound (\\(\\epsilon\\)) are used to decide upon creating a split. A split occurs when \\(r &lt; 1 - \\epsilon\\). A split candidate, with merit \\(m_i\\), is considered badr if \\(m_i / m_1 &lt; r - 2\\epsilon\\). The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\), then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed.  To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in <sup>1</sup>.</p> <p>Parameters</p> <ul> <li>criterion </li> <li>last_check_ratio     \u2014 'float' </li> <li>last_check_vr     \u2014 'float' </li> <li>last_check_e     \u2014 'float' </li> <li>pre_split_dist     \u2014 'list | dict' </li> </ul> <p></p> update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.Target' </li> <li>w     \u2014 'float' </li> </ul> <p></p> <ol> <li> <p>Ikonomovska, E., Gama, J., &amp; D\u017eeroski, S. (2011). Learning model trees from evolving data streams. Data mining and knowledge discovery, 23(1), 128-168.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Osojnik, Alja\u017e. 2017. Structured output prediction on Data Streams (Doctoral Dissertation) \u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/ExhaustiveSplitter/","title":"ExhaustiveSplitter","text":"<p>Numeric attribute observer for classification tasks that is based on a Binary Search Tree.</p> <p>This algorithm<sup>1</sup> is also referred to as exhaustive attribute observer, since it ends up storing all the observations between split attempts<sup>2</sup>. </p> <p>This splitter cannot perform probability density estimations, so it does not work well when coupled with tree leaves using naive bayes models.</p>"},{"location":"api/tree/splitter/ExhaustiveSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/ExhaustiveSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     \u2014 'SplitCriterion' </li> <li>pre_split_dist     \u2014 'list | dict' </li> <li>att_idx     \u2014 'base.typing.FeatureName' </li> <li>binary_only     \u2014 'bool' </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p> <p></p> cond_proba <p>The underlying data structure used to monitor the input does not allow probability density estimations. Hence, it always returns zero for any given input.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.Target' </li> <li>w     \u2014 'float' </li> </ul> <p></p> <ol> <li> <p>Domingos, P. and Hulten, G., 2000, August. Mining high-speed data streams. In Proceedings of the sixth ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 71-80).\u00a0\u21a9</p> </li> <li> <p>Pfahringer, B., Holmes, G. and Kirkby, R., 2008, May. Handling numeric attributes in hoeffding trees. In Pacific-Asia Conference on Knowledge Discovery and Data Mining (pp. 296-307). Springer, Berlin, Heidelberg.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/GaussianSplitter/","title":"GaussianSplitter","text":"<p>Numeric attribute observer for classification tasks that is based on Gaussian estimators.</p> <p>The distribution of each class is approximated using a Gaussian distribution. Hence, the probability density function can be easily calculated.</p>"},{"location":"api/tree/splitter/GaussianSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>n_splits</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>10</code></p> <p>The number of partitions to consider when querying for split candidates.</p> </li> </ul>"},{"location":"api/tree/splitter/GaussianSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/GaussianSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     \u2014 'SplitCriterion' </li> <li>pre_split_dist     \u2014 'list | dict' </li> <li>att_idx     \u2014 'base.typing.FeatureName' </li> <li>binary_only     \u2014 'bool' </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p> <p></p> cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.ClfTarget' </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p> <p></p> update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.Target' </li> <li>w     \u2014 'float' </li> </ul> <p></p>"},{"location":"api/tree/splitter/HistogramSplitter/","title":"HistogramSplitter","text":"<p>Numeric attribute observer for classification tasks that discretizes features using histograms.</p>"},{"location":"api/tree/splitter/HistogramSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>n_bins</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>256</code></p> <p>The maximum number of bins in the histogram.</p> </li> <li> <p>n_splits</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>32</code></p> <p>The number of split points to evaluate when querying for the best split candidate.</p> </li> </ul>"},{"location":"api/tree/splitter/HistogramSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/HistogramSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     \u2014 'SplitCriterion' </li> <li>pre_split_dist     \u2014 'list | dict' </li> <li>att_idx     \u2014 'base.typing.FeatureName' </li> <li>binary_only     \u2014 'bool' </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p> <p></p> cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.ClfTarget' </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p> <p></p> update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.Target' </li> <li>w     \u2014 'float' </li> </ul> <p></p>"},{"location":"api/tree/splitter/QOSplitter/","title":"QOSplitter","text":"<p>Quantization observer (QO).</p> <p>This splitter utilizes a hash-based quantization algorithm to keep track of the target statistics and evaluate split candidates. QO, relies on the radius parameter to define discretization intervals for each incoming feature. Split candidates are defined as the midpoints between two consecutive hash slots. Both binary splits and multi-way splits can be created by this attribute observer. This class implements the algorithm described in <sup>1</sup>. </p> <p>The smaller the quantization radius, the more hash slots will be created to accommodate the discretized data. Hence, both the running time and memory consumption increase, but the resulting splits ought to be closer to the ones obtained by a batch exhaustive approach. On the other hand, if the radius is too large, fewer slots will be created, less memory and running time will be required, but at the cost of coarse split suggestions. </p> <p>QO assumes that all features have the same range. It is always advised to scale the features to apply this splitter. That can be done using the <code>preprocessing</code> module. A good \"rule of thumb\" is to scale data using <code>preprocessing.StandardScaler</code> and define the radius as a proportion of the features' standard deviation. For instance, the default radius value would correspond to one quarter of the normalized features' standard deviation (since the scaled data has zero mean and unit variance). If the features come from normal distributions, by following the empirical rule, roughly <code>32</code> hash slots will be created.</p>"},{"location":"api/tree/splitter/QOSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>radius</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>0.25</code></p> <p>The quantization radius. QO discretizes the incoming feature in intervals of equal length that are defined by this parameter.</p> </li> <li> <p>allow_multiway_splits</p> <p>Default \u2192 <code>False</code></p> <p>Whether or not allow that multiway splits are evaluated. Numeric multi-way splits use the same quantization strategy of QO to create multiple tree branches. The same quantization radius is used, and each stored slot represents the split enabling statistics of one branch.</p> </li> </ul>"},{"location":"api/tree/splitter/QOSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/QOSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     \u2014 'SplitCriterion' </li> <li>pre_split_dist     \u2014 'list | dict' </li> <li>att_idx     \u2014 'base.typing.FeatureName' </li> <li>binary_only     \u2014 'bool'     \u2014 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p> <p></p> cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.ClfTarget' </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p> <p></p> update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.Target' </li> <li>w     \u2014 'float' </li> </ul> <p></p> <ol> <li> <p>Mastelini, S.M. and de Leon Ferreira, A.C.P., 2021. Using dynamical quantization to perform split attempts in online tree regressors. Pattern Recognition Letters.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/Quantizer/","title":"Quantizer","text":"<p>Base class for the feature quantizers used in Stochastic Gradient Trees<sup>1</sup>.</p>"},{"location":"api/tree/splitter/Quantizer/#methods","title":"Methods","text":"update <ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/Splitter/","title":"Splitter","text":"<p>Base class for the tree splitters.</p> <p>Each Attribute Observer (AO) or Splitter monitors one input feature and finds the best split point for this attribute. AOs can also perform other tasks related to the monitored feature, such as estimating its probability density function (classification case). </p> <p>This class should not be instantiated, as none of its methods are implemented.</p>"},{"location":"api/tree/splitter/Splitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/Splitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     \u2014 'SplitCriterion' </li> <li>pre_split_dist     \u2014 'list | dict' </li> <li>att_idx     \u2014 'base.typing.FeatureName' </li> <li>binary_only     \u2014 'bool' </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p> <p></p> cond_proba <p>Get the probability for an attribute value given a class.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.ClfTarget' </li> </ul> <p>Returns</p> <p>float:     Probability for an attribute value given a class.</p> <p></p> update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.Target' </li> <li>w     \u2014 'float' </li> </ul> <p></p>"},{"location":"api/tree/splitter/StaticQuantizer/","title":"StaticQuantizer","text":"<p>Quantization strategy originally used in Stochastic Gradient Trees (SGT)<sup>1</sup>.</p> <p>Firstly, a buffer of size <code>warm_start</code> is stored. The data stored in the buffer is then used to quantize the input feature into <code>n_bins</code> intervals. These intervals will be replicated to every new quantizer. Feature values lying outside of the limits defined by the initial buffer will be mapped to the head or tail of the list of intervals.</p>"},{"location":"api/tree/splitter/StaticQuantizer/#parameters","title":"Parameters","text":"<ul> <li> <p>n_bins</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>64</code></p> <p>The number of bins (intervals) to divide the input feature.</p> </li> <li> <p>warm_start</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>100</code></p> <p>The number of observations used to initialize the quantization intervals.</p> </li> <li> <p>buckets</p> <p>Type \u2192 list | None</p> <p>Default \u2192 <code>None</code></p> <p>This parameter is only used internally by the quantizer, so it must not be set. Once the intervals are defined, new instances of this quantizer will receive the quantization information via this parameter.</p> </li> </ul>"},{"location":"api/tree/splitter/StaticQuantizer/#methods","title":"Methods","text":"update <ol> <li> <p>Gouk, H., Pfahringer, B., &amp; Frank, E. (2019, October). Stochastic Gradient Trees. In Asian Conference on Machine Learning (pp. 1094-1109).\u00a0\u21a9</p> </li> </ol>"},{"location":"api/tree/splitter/TEBSTSplitter/","title":"TEBSTSplitter","text":"<p>Truncated E-BST.</p> <p>Variation of E-BST that rounds the incoming feature values before passing them to the binary search tree (BST). By doing so, the attribute observer might reduce its processing time and memory usage since small variations in the input values will end up being mapped to the same BST node.</p>"},{"location":"api/tree/splitter/TEBSTSplitter/#parameters","title":"Parameters","text":"<ul> <li> <p>digits</p> <p>Type \u2192 int</p> <p>Default \u2192 <code>1</code></p> <p>The number of decimal places used to round the input feature values.</p> </li> </ul>"},{"location":"api/tree/splitter/TEBSTSplitter/#attributes","title":"Attributes","text":"<ul> <li> <p>is_numeric</p> <p>Determine whether or not the splitter works with numerical features.</p> </li> <li> <p>is_target_class</p> <p>Check on which kind of learning task the splitter is designed to work.  If <code>True</code>, the splitter works with classification trees, otherwise it is designed for regression trees.</p> </li> </ul>"},{"location":"api/tree/splitter/TEBSTSplitter/#methods","title":"Methods","text":"best_evaluated_split_suggestion <p>Get the best split suggestion given a criterion and the target's statistics.</p> <p>Parameters</p> <ul> <li>criterion     \u2014 'SplitCriterion' </li> <li>pre_split_dist     \u2014 'list | dict' </li> <li>att_idx     \u2014 'base.typing.FeatureName' </li> <li>binary_only     \u2014 'bool'     \u2014 defaults to <code>True</code> </li> </ul> <p>Returns</p> <p>BranchFactory:     Suggestion of the best attribute split.</p> <p></p> cond_proba <p>Not implemented in regression splitters.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.ClfTarget' </li> </ul> <p></p> remove_bad_splits <p>Remove bad splits.</p> <p>Based on FIMT-DD's [^1] procedure to remove bad split candidates from the E-BST. This mechanism is triggered every time a split attempt fails. The rationale is to remove points whose split merit is much worse than the best candidate overall (for which the growth decision already failed).  Let \\(m_1\\) be the merit of the best split point and \\(m_2\\) be the merit of the second best split candidate. The ratio \\(r = m_2/m_1\\) along with the Hoeffding bound (\\(\\epsilon\\)) are used to decide upon creating a split. A split occurs when \\(r &lt; 1 - \\epsilon\\). A split candidate, with merit \\(m_i\\), is considered badr if \\(m_i / m_1 &lt; r - 2\\epsilon\\). The rationale is the following: if the merit ratio for this point is smaller than the lower bound of \\(r\\), then the true merit of that split relative to the best one is small. Hence, this candidate can be safely removed.  To avoid excessive and costly manipulations of the E-BST to update the stored statistics, only the nodes whose children are all bad split points are pruned, as defined in [^1].</p> <p>Parameters</p> <ul> <li>criterion </li> <li>last_check_ratio     \u2014 'float' </li> <li>last_check_vr     \u2014 'float' </li> <li>last_check_e     \u2014 'float' </li> <li>pre_split_dist     \u2014 'list | dict' </li> </ul> <p></p> update <p>Update statistics of this observer given an attribute value, its target value and the weight of the instance observed.</p> <p>Parameters</p> <ul> <li>att_val </li> <li>target_val     \u2014 'base.typing.Target' </li> <li>w     \u2014 'float' </li> </ul> <p></p>"},{"location":"api/utils/Rolling/","title":"Rolling","text":"<p>A generic wrapper for performing rolling computations.</p> <p>This can be wrapped around any object which implements both an <code>update</code> and a <code>revert</code> method. Inputs to <code>update</code> are stored in a queue. Elements of the queue are popped when the window is full.</p>"},{"location":"api/utils/Rolling/#parameters","title":"Parameters","text":"<ul> <li> <p>obj</p> <p>Type \u2192 Rollable</p> <p>An object that implements both an <code>update</code> method and a <code>rolling</code>method.</p> </li> <li> <p>window_size</p> <p>Type \u2192 int</p> <p>Size of the window.</p> </li> </ul>"},{"location":"api/utils/Rolling/#attributes","title":"Attributes","text":"<ul> <li>window_size</li> </ul>"},{"location":"api/utils/Rolling/#examples","title":"Examples","text":"<p>For instance, here is how you can compute a rolling average over a window of size 3:</p> <p><pre><code>from river import stats, utils\n\nX = [1, 3, 5, 7]\nrmean = utils.Rolling(stats.Mean(), window_size=3)\n\nfor x in X:\n    rmean.update(x)\n    print(rmean.get())\n</code></pre> <pre><code>1.0\n2.0\n3.0\n5.0\n</code></pre></p>"},{"location":"api/utils/Rolling/#methods","title":"Methods","text":"update"},{"location":"api/utils/SortedWindow/","title":"SortedWindow","text":"<p>Sorted running window data structure.</p>"},{"location":"api/utils/SortedWindow/#parameters","title":"Parameters","text":"<ul> <li> <p>size</p> <p>Type \u2192 int</p> <p>Size of the window to compute the rolling quantile.</p> </li> </ul>"},{"location":"api/utils/SortedWindow/#attributes","title":"Attributes","text":"<ul> <li>size</li> </ul>"},{"location":"api/utils/SortedWindow/#examples","title":"Examples","text":"<p><pre><code>from river import utils\n\nwindow = utils.SortedWindow(size=3)\n\nfor i in reversed(range(9)):\n    window.append(i)\n    print(window)\n</code></pre> <pre><code>[8]\n[7, 8]\n[6, 7, 8]\n[5, 6, 7]\n[4, 5, 6]\n[3, 4, 5]\n[2, 3, 4]\n[1, 2, 3]\n[0, 1, 2]\n</code></pre></p>"},{"location":"api/utils/SortedWindow/#methods","title":"Methods","text":"<ol> <li> <p>Left sorted inserts in Python \u21a9</p> </li> </ol>"},{"location":"api/utils/TimeRolling/","title":"TimeRolling","text":"<p>A generic wrapper for performing time rolling computations.</p> <p>This can be wrapped around any object which implements both an <code>update</code> and a <code>revert</code> method. Inputs to <code>update</code> are stored in a queue. Elements of the queue are popped when they are too old.</p>"},{"location":"api/utils/TimeRolling/#parameters","title":"Parameters","text":"<ul> <li> <p>obj</p> <p>Type \u2192 Rollable</p> <p>An object that implements both an <code>update</code> method and a <code>rolling</code>method.</p> </li> <li> <p>period</p> <p>Type \u2192 dt.timedelta</p> <p>A duration of time, expressed as a <code>datetime.timedelta</code>.</p> </li> </ul>"},{"location":"api/utils/TimeRolling/#examples","title":"Examples","text":"<p>For instance, here is how you can compute a rolling average over a period of 3 days:</p> <p><pre><code>from river import stats, utils\n\nX = {\n    dt.datetime(2019, 1, 1): 1,\n    dt.datetime(2019, 1, 2): 5,\n    dt.datetime(2019, 1, 3): 9,\n    dt.datetime(2019, 1, 4): 13\n}\n\nrmean = utils.TimeRolling(stats.Mean(), period=dt.timedelta(days=3))\nfor t, x in X.items():\n    rmean.update(x, t=t)\n    print(rmean.get())\n</code></pre> <pre><code>1.0\n3.0\n5.0\n9.0\n</code></pre></p>"},{"location":"api/utils/TimeRolling/#methods","title":"Methods","text":"update"},{"location":"api/utils/VectorDict/","title":"VectorDict","text":""},{"location":"api/utils/VectorDict/#methods","title":"Methods","text":"abs clear get <p>Parameters</p> <ul> <li>key </li> <li>args </li> <li>kwargs </li> </ul> <p></p> items <p></p> keys <p></p> max <p></p> maximum <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> min <p></p> minimum <p>Parameters</p> <ul> <li>other </li> </ul> <p></p> pop <p>Parameters</p> <ul> <li>args </li> <li>kwargs </li> </ul> <p></p> popitem <p></p> setdefault <p>Parameters</p> <ul> <li>key </li> <li>args </li> <li>kwargs </li> </ul> <p></p> to_dict <p></p> to_numpy <p>Parameters</p> <ul> <li>fields </li> </ul> <p></p> update <p>Parameters</p> <ul> <li>args </li> <li>kwargs </li> </ul> <p></p> values <p></p> with_mask <p>Parameters</p> <ul> <li>mask </li> <li>copy     \u2014 defaults to <code>False</code> </li> </ul> <p></p>"},{"location":"api/utils/expand-param-grid/","title":"expand_param_grid","text":"<p>Expands a grid of parameters.</p> <p>This method can be used to generate a list of model parametrizations from a dictionary where each parameter is associated with a list of possible parameters. In other words, it expands a grid of parameters. </p> <p>Typically, this method can be used to create copies of a given model with different parameter choices. The models can then be used as part of a model selection process, such as a <code>selection.SuccessiveHalvingClassifier</code> or a <code>selection.EWARegressor</code>. </p> <p>The syntax for the parameter grid is quite flexible. It allows nesting parameters and can therefore be used to generate parameters for a pipeline.</p>"},{"location":"api/utils/expand-param-grid/#parameters","title":"Parameters","text":"<ul> <li> <p>model</p> <p>Type \u2192 base.Estimator</p> </li> <li> <p>grid</p> <p>Type \u2192 dict</p> <p>The grid of parameters to expand. The provided dictionary can be nested. The only requirement is that the values at the leaves need to be lists.</p> </li> </ul>"},{"location":"api/utils/expand-param-grid/#examples","title":"Examples","text":"<p>As an initial example, we can expand a grid of parameters for a single model.</p> <p><pre><code>from river import linear_model\nfrom river import optim\nfrom river import utils\n\nmodel = linear_model.LinearRegression()\n\ngrid = {'optimizer': [optim.SGD(.1), optim.SGD(.01), optim.SGD(.001)]}\nmodels = utils.expand_param_grid(model, grid)\nlen(models)\n</code></pre> <pre><code>3\n</code></pre></p> <p><pre><code>models[0]\n</code></pre> <pre><code>LinearRegression (\n  optimizer=SGD (\n    lr=Constant (\n      learning_rate=0.1\n    )\n  )\n  loss=Squared ()\n  l2=0.\n  l1=0.\n  intercept_init=0.\n  intercept_lr=Constant (\n    learning_rate=0.01\n  )\n  clip_gradient=1e+12\n  initializer=Zeros ()\n)\n</code></pre></p> <p>You can expand parameters for multiple choices like so:</p> <p><pre><code>grid = {\n    'optimizer': [\n        (optim.SGD, {'lr': [.1, .01, .001]}),\n        (optim.Adam, {'lr': [.1, .01, .01]})\n    ]\n}\nmodels = utils.expand_param_grid(model, grid)\nlen(models)\n</code></pre> <pre><code>6\n</code></pre></p> <p>You may specify a grid of parameters for a pipeline via nesting:</p> <p><pre><code>from river import feature_extraction\n\nmodel = (\n    feature_extraction.BagOfWords() |\n    linear_model.LinearRegression()\n)\n\ngrid = {\n    'BagOfWords': {\n        'strip_accents': [False, True]\n    },\n    'LinearRegression': {\n        'optimizer': [\n            (optim.SGD, {'lr': [.1, .01]}),\n            (optim.Adam, {'lr': [.1, .01]})\n        ]\n    }\n}\n\nmodels = utils.expand_param_grid(model, grid)\nlen(models)\n</code></pre> <pre><code>8\n</code></pre></p>"},{"location":"api/utils/log-method-calls/","title":"log_method_calls","text":"<p>A context manager to log method calls.</p> <p>All method calls will be logged by default. This behavior can be overridden by passing filtering functions.</p>"},{"location":"api/utils/log-method-calls/#parameters","title":"Parameters","text":"<ul> <li> <p>class_condition</p> <p>Type \u2192 typing.Callable[[typing.Any], bool] | None</p> <p>Default \u2192 <code>None</code></p> <p>A function which determines if a class should be logged or not.</p> </li> <li> <p>method_condition</p> <p>Type \u2192 typing.Callable[[typing.Any], bool] | None</p> <p>Default \u2192 <code>None</code></p> <p>A function which determines if a method should be logged or not.</p> </li> </ul>"},{"location":"api/utils/log-method-calls/#examples","title":"Examples","text":"<p><pre><code>import io\nimport logging\nfrom river import anomaly\nfrom river import compose\nfrom river import datasets\nfrom river import preprocessing\nfrom river import utils\n\nmodel = compose.Pipeline(\n    preprocessing.MinMaxScaler(),\n    anomaly.HalfSpaceTrees(seed=42)\n)\n\nclass_condition = lambda x: x.__class__.__name__ in ('MinMaxScaler', 'HalfSpaceTrees')\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.DEBUG)\n\nlogs = io.StringIO()\nsh = logging.StreamHandler(logs)\nsh.setLevel(logging.DEBUG)\nlogger.addHandler(sh)\n\nwith utils.log_method_calls(class_condition):\n    for x, y in datasets.CreditCard().take(1):\n        score = model.score_one(x)\n        model.learn_one(x)\n\nprint(logs.getvalue())\n</code></pre> <pre><code>MinMaxScaler.transform_one\nHalfSpaceTrees.score_one\nMinMaxScaler.learn_one\nMinMaxScaler.transform_one\nHalfSpaceTrees.learn_one\n</code></pre></p> <pre><code>logs.close()\n</code></pre>"},{"location":"api/utils/math/argmax/","title":"argmax","text":"<p>Argmax function.</p>"},{"location":"api/utils/math/argmax/#parameters","title":"Parameters","text":"<ul> <li> <p>lst</p> <p>Type \u2192 list</p> </li> </ul>"},{"location":"api/utils/math/chain-dot/","title":"chain_dot","text":"<p>Returns the dot product of multiple vectors represented as dicts.</p>"},{"location":"api/utils/math/chain-dot/#parameters","title":"Parameters","text":"<ul> <li>xs</li> </ul>"},{"location":"api/utils/math/chain-dot/#examples","title":"Examples","text":"<p><pre><code>from river import utils\n\nx = {'x0': 1, 'x1': 2, 'x2': 1}\ny = {'x1': 21, 'x2': 3}\nz = {'x1': 2, 'x2': 1 / 3}\n\nutils.math.chain_dot(x, y, z)\n</code></pre> <pre><code>85.0\n</code></pre></p>"},{"location":"api/utils/math/clamp/","title":"clamp","text":"<p>Clamp a number.</p> <p>This is a synonym of clipping.</p>"},{"location":"api/utils/math/clamp/#parameters","title":"Parameters","text":"<ul> <li> <p>x</p> <p>Type \u2192 float</p> </li> <li> <p>minimum</p> <p>Default \u2192 <code>0.0</code></p> </li> <li> <p>maximum</p> <p>Default \u2192 <code>1.0</code></p> </li> </ul>"},{"location":"api/utils/math/dot/","title":"dot","text":"<p>Returns the dot product of two vectors represented as dicts.</p>"},{"location":"api/utils/math/dot/#parameters","title":"Parameters","text":"<ul> <li> <p>x</p> <p>Type \u2192 dict</p> </li> <li> <p>y</p> <p>Type \u2192 dict</p> </li> </ul>"},{"location":"api/utils/math/dot/#examples","title":"Examples","text":"<p><pre><code>from river import utils\n\nx = {'x0': 1, 'x1': 2}\ny = {'x1': 21, 'x2': 3}\n\nutils.math.dot(x, y)\n</code></pre> <pre><code>42\n</code></pre></p>"},{"location":"api/utils/math/dotvecmat/","title":"dotvecmat","text":"<p>Vector times matrix from left side, i.e. transpose(x)A.</p>"},{"location":"api/utils/math/dotvecmat/#parameters","title":"Parameters","text":"<ul> <li> <p>x</p> </li> <li> <p>A</p> </li> </ul>"},{"location":"api/utils/math/dotvecmat/#examples","title":"Examples","text":"<p><pre><code>from river import utils\n\nx = {0: 4, 1: 5}\n\nA = {\n    (0, 0): 0, (0, 1): 1,\n    (1, 0): 2, (1, 1): 3\n}\n\nC = utils.math.dotvecmat(x, A)\nprint(C)\n</code></pre> <pre><code>{0: 10.0, 1: 19.0}\n</code></pre></p>"},{"location":"api/utils/math/log-sum-2-exp/","title":"log_sum_2_exp","text":"<p>Computation of log( (e^a + e^b) / 2) in an overflow-proof way</p>"},{"location":"api/utils/math/log-sum-2-exp/#parameters","title":"Parameters","text":"<ul> <li> <p>a</p> <p>Type \u2192 float</p> <p>First number</p> </li> <li> <p>b</p> <p>Type \u2192 float</p> <p>Second number</p> </li> </ul>"},{"location":"api/utils/math/matmul2d/","title":"matmul2d","text":"<p>Multiplication for 2D matrices.</p>"},{"location":"api/utils/math/matmul2d/#parameters","title":"Parameters","text":"<ul> <li> <p>A</p> </li> <li> <p>B</p> </li> </ul>"},{"location":"api/utils/math/matmul2d/#examples","title":"Examples","text":"<p><pre><code>import pprint\nfrom river import utils\n\nA = {\n    (0, 0): 2, (0, 1): 0, (0, 2): 4,\n    (1, 0): 5, (1, 1): 6, (1, 2): 0\n}\n\nB = {\n    (0, 0): 1, (0, 1): 1, (0, 2): 0, (0, 3): 0,\n    (1, 0): 2, (1, 1): 0, (1, 2): 1, (1, 3): 3,\n    (2, 0): 4, (2, 1): 0, (2, 2): 0, (2, 3): 0\n}\n\nC = utils.math.matmul2d(A, B)\npprint.pprint(C)\n</code></pre> <pre><code>{(0, 0): 18.0,\n    (0, 1): 2.0,\n    (0, 2): 0.0,\n    (0, 3): 0.0,\n    (1, 0): 17.0,\n    (1, 1): 5.0,\n    (1, 2): 6.0,\n    (1, 3): 18.0}\n</code></pre></p>"},{"location":"api/utils/math/minkowski-distance/","title":"minkowski_distance","text":"<p>Minkowski distance.</p>"},{"location":"api/utils/math/minkowski-distance/#parameters","title":"Parameters","text":"<ul> <li> <p>a</p> <p>Type \u2192 dict</p> </li> <li> <p>b</p> <p>Type \u2192 dict</p> </li> <li> <p>p</p> <p>Type \u2192 int</p> <p>Parameter for the Minkowski distance. When <code>p=1</code>, this is equivalent to using the Manhattan distance. When <code>p=2</code>, this is equivalent to using the Euclidean distance.</p> </li> </ul>"},{"location":"api/utils/math/norm/","title":"norm","text":"<p>Compute the norm of a dictionaries values.</p>"},{"location":"api/utils/math/norm/#parameters","title":"Parameters","text":"<ul> <li> <p>x</p> <p>Type \u2192 dict</p> </li> <li> <p>order</p> <p>Default \u2192 <code>None</code></p> </li> </ul>"},{"location":"api/utils/math/outer/","title":"outer","text":"<p>Outer-product between two vectors.</p>"},{"location":"api/utils/math/outer/#parameters","title":"Parameters","text":"<ul> <li> <p>u</p> <p>Type \u2192 dict</p> </li> <li> <p>v</p> <p>Type \u2192 dict</p> </li> </ul>"},{"location":"api/utils/math/outer/#examples","title":"Examples","text":"<p><pre><code>import pprint\nfrom river import utils\n\nu = dict(enumerate((1, 2, 3)))\nv = dict(enumerate((2, 4, 8)))\n\nuTv = utils.math.outer(u, v)\npprint.pprint(uTv)\n</code></pre> <pre><code>{(0, 0): 2,\n    (0, 1): 4,\n    (0, 2): 8,\n    (1, 0): 4,\n    (1, 1): 8,\n    (1, 2): 16,\n    (2, 0): 6,\n    (2, 1): 12,\n    (2, 2): 24}\n</code></pre></p>"},{"location":"api/utils/math/prod/","title":"prod","text":"<p>Product function.</p>"},{"location":"api/utils/math/prod/#parameters","title":"Parameters","text":"<ul> <li>iterable</li> </ul>"},{"location":"api/utils/math/sherman-morrison/","title":"sherman_morrison","text":"<p>Sherman-Morrison formula.</p> <p>This is an inplace function.</p>"},{"location":"api/utils/math/sherman-morrison/#parameters","title":"Parameters","text":"<ul> <li> <p>A</p> <p>Type \u2192 np.ndarray</p> </li> <li> <p>u</p> <p>Type \u2192 np.ndarray</p> </li> <li> <p>v</p> <p>Type \u2192 np.ndarray</p> </li> </ul> <ol> <li> <p>Fast rank-one updates to matrix inverse? \u2014 Tim Vieira \u21a9</p> </li> </ol>"},{"location":"api/utils/math/sigmoid/","title":"sigmoid","text":"<p>Sigmoid function.</p>"},{"location":"api/utils/math/sigmoid/#parameters","title":"Parameters","text":"<ul> <li> <p>x</p> <p>Type \u2192 float</p> </li> </ul>"},{"location":"api/utils/math/sign/","title":"sign","text":"<p>Sign function.</p>"},{"location":"api/utils/math/sign/#parameters","title":"Parameters","text":"<ul> <li> <p>x</p> <p>Type \u2192 float</p> </li> </ul>"},{"location":"api/utils/math/softmax/","title":"softmax","text":"<p>Normalizes a dictionary of predicted probabilities, in-place.</p>"},{"location":"api/utils/math/softmax/#parameters","title":"Parameters","text":"<ul> <li> <p>y_pred</p> <p>Type \u2192 dict</p> </li> </ul>"},{"location":"api/utils/math/woodbury-matrix/","title":"woodbury_matrix","text":"<p>Woodbury matrix identity.</p> <p>This is an inplace function.</p>"},{"location":"api/utils/math/woodbury-matrix/#parameters","title":"Parameters","text":"<ul> <li> <p>A</p> <p>Type \u2192 np.ndarray</p> </li> <li> <p>U</p> <p>Type \u2192 np.ndarray</p> </li> <li> <p>V</p> <p>Type \u2192 np.ndarray</p> </li> </ul> <ol> <li> <p>Matrix inverse mini-batch updates \u2014 Max Halford \u21a9</p> </li> </ol>"},{"location":"api/utils/norm/normalize-values-in-dict/","title":"normalize_values_in_dict","text":"<p>Normalize the values in a dictionary using the given factor.</p> <p>For each element in the dictionary, applies <code>value/factor</code>.</p>"},{"location":"api/utils/norm/normalize-values-in-dict/#parameters","title":"Parameters","text":"<ul> <li> <p>dictionary</p> <p>Dictionary to normalize.</p> </li> <li> <p>factor</p> <p>Default \u2192 <code>None</code></p> <p>Normalization factor value. If not set, use the sum of values.</p> </li> <li> <p>inplace</p> <p>Default \u2192 <code>True</code></p> <p>If True, perform operation in-place</p> </li> <li> <p>raise_error</p> <p>Default \u2192 <code>False</code></p> <p>In case the normalization factor is either <code>0</code> or <code>None</code>: - <code>True</code>: raise an error. - <code>False</code>: return gracefully (if <code>inplace=False</code>, a copy of) <code>dictionary</code>.</p> </li> </ul>"},{"location":"api/utils/norm/scale-values-in-dict/","title":"scale_values_in_dict","text":"<p>Scale the values in a dictionary.</p> <p>For each element in the dictionary, applies <code>value * multiplier</code>.</p>"},{"location":"api/utils/norm/scale-values-in-dict/#parameters","title":"Parameters","text":"<ul> <li> <p>dictionary</p> <p>Dictionary to scale.</p> </li> <li> <p>multiplier</p> <p>Scaling value.</p> </li> <li> <p>inplace</p> <p>Default \u2192 <code>True</code></p> <p>If True, perform operation in-place</p> </li> </ul>"},{"location":"api/utils/pretty/humanize-bytes/","title":"humanize_bytes","text":"<p>Returns a human-friendly byte size.</p>"},{"location":"api/utils/pretty/humanize-bytes/#parameters","title":"Parameters","text":"<ul> <li> <p>n_bytes</p> <p>Type \u2192 int</p> </li> </ul>"},{"location":"api/utils/pretty/print-table/","title":"print_table","text":"<p>Pretty-prints a table.</p>"},{"location":"api/utils/pretty/print-table/#parameters","title":"Parameters","text":"<ul> <li> <p>headers</p> <p>Type \u2192 list[str]</p> <p>The column names.</p> </li> <li> <p>columns</p> <p>Type \u2192 list[list[str]]</p> <p>The column values.</p> </li> <li> <p>order</p> <p>Type \u2192 list[int] | None</p> <p>Default \u2192 <code>None</code></p> <p>Order in which to print the column the values. Defaults to the order in which the values are given.</p> </li> </ul>"},{"location":"api/utils/random/exponential/","title":"exponential","text":"<p>Sample a random value from a Poisson distribution.</p>"},{"location":"api/utils/random/exponential/#parameters","title":"Parameters","text":"<ul> <li> <p>rate</p> <p>Type \u2192 float</p> <p>Default \u2192 <code>1.0</code></p> </li> <li> <p>rng</p> <p>Default \u2192 <code>&lt;module 'random' from '/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/random.py'&gt;</code></p> </li> </ul> <ol> <li> <p>Wikipedia article \u21a9</p> </li> </ol>"},{"location":"api/utils/random/poisson/","title":"poisson","text":"<p>Sample a random value from a Poisson distribution.</p>"},{"location":"api/utils/random/poisson/#parameters","title":"Parameters","text":"<ul> <li> <p>rate</p> <p>Type \u2192 float</p> </li> <li> <p>rng</p> <p>Default \u2192 <code>&lt;module 'random' from '/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/random.py'&gt;</code></p> </li> </ul> <p>[^1] Wikipedia article</p>"},{"location":"benchmarks/Binary%20classification/","title":"Binary classification","text":""},{"location":"benchmarks/Binary%20classification/#bananas","title":"Bananas","text":""},{"location":"benchmarks/Binary%20classification/#summary","title":"Summary","text":"Model Accuracy F1 Memory in Mb Time in s ADWIN Bagging 0.625967 0.448218 0.400658 942.73 ALMA 0.506415 0.482595 0.0029211 68.9731 AdaBoost 0.677864 0.645041 0.453154 876.714 Adaptive Random Forest 0.88696 0.871707 15.3551 2603.02 Aggregated Mondrian Forest 0.889413 0.874249 17.2377 2954.75 Bagging 0.634082 0.459437 0.703124 1170.85 Hoeffding Adaptive Tree 0.616531 0.42825 0.0618467 163.516 Hoeffding Tree 0.642197 0.503405 0.0594654 93.5302 Leveraging Bagging 0.828269 0.802689 3.23571 2747.95 Logistic regression 0.543208 0.197015 0.00424099 82.0689 Naive Bayes 0.61521 0.413912 0.0140247 97.154 Stacking 0.876203 0.859649 19.1946 5236.84 Streaming Random Patches 0.871674 0.854265 10.5381 3551.41 Voting 0.872617 0.849162 4.58403 2790.97 Vowpal Wabbit logistic regression 0.551321 0 0.000646591 88.7248 [baseline] Last Class 0.50953 0.452957 0.000510216 30.809 k-Nearest Neighbors 0.885073 0.870838 4.50996 2974.33 sklearn SGDClassifier 0.546415 0.205026 0.00557804 621.426"},{"location":"benchmarks/Binary%20classification/#charts","title":"Charts","text":""},{"location":"benchmarks/Binary%20classification/#elec2","title":"Elec2","text":""},{"location":"benchmarks/Binary%20classification/#summary_1","title":"Summary","text":"Model Accuracy F1 Memory in Mb Time in s ADWIN Bagging 0.823773 0.776587 0.598438 8970.15 ALMA 0.906427 0.889767 0.00435829 836.498 AdaBoost 0.880581 0.858687 13.5424 10153.7 Adaptive Random Forest 0.876608 0.852391 22.3949 12397.6 Aggregated Mondrian Forest 0.849904 0.819731 287.315 18206.6 Bagging 0.840436 0.80208 2.28896 13164.5 Hoeffding Adaptive Tree 0.821258 0.787344 0.435328 2980.69 Hoeffding Tree 0.795635 0.750834 0.938466 1485.98 Leveraging Bagging 0.892653 0.871966 7.56535 18763.3 Logistic regression 0.822144 0.777086 0.005373 953.54 Naive Bayes 0.728741 0.603785 0.0510378 1230.66 Stacking 0.885458 0.864157 40.7547 22944.4 Streaming Random Patches 0.868884 0.843009 107.322 22969 Voting 0.84368 0.797958 5.7575 13925.5 Vowpal Wabbit logistic regression 0.697475 0.459592 0.000646591 937.011 [baseline] Last Class 0.853303 0.827229 0.000510216 341.39 k-Nearest Neighbors 0.853148 0.823642 4.76604 13503.4 sklearn SGDClassifier 0.819099 0.772892 0.00680161 4291.77"},{"location":"benchmarks/Binary%20classification/#charts_1","title":"Charts","text":""},{"location":"benchmarks/Binary%20classification/#phishing","title":"Phishing","text":""},{"location":"benchmarks/Binary%20classification/#summary_2","title":"Summary","text":"Model Accuracy F1 Memory in Mb Time in s ADWIN Bagging 0.893515 0.879201 1.31008 568.218 ALMA 0.8256 0.810764 0.0045805 29.7613 AdaBoost 0.878303 0.863555 0.873312 552.609 Adaptive Random Forest 0.907926 0.896116 4.10291 743.377 Aggregated Mondrian Forest 0.904724 0.892112 3.39106 807.573 Bagging 0.893515 0.879201 1.38826 633.136 Hoeffding Adaptive Tree 0.874299 0.856095 0.142962 77.865 Hoeffding Tree 0.879904 0.860595 0.132719 54.2758 Leveraging Bagging 0.894315 0.877323 4.0114 1619.65 Logistic regression 0.8872 0.871233 0.00556469 29.2066 Naive Bayes 0.884708 0.871429 0.05723 38.528 Stacking 0.895116 0.882722 8.72124 2411.41 Streaming Random Patches 0.913531 0.901996 6.59559 1436.69 Voting 0.896717 0.884512 4.8203 1436.72 Vowpal Wabbit logistic regression 0.7736 0.669778 0.000646591 27.8334 [baseline] Last Class 0.515612 0.447489 0.000510216 11.9196 k-Nearest Neighbors 0.881505 0.867145 4.59643 1552.65 sklearn SGDClassifier 0.8896 0.876122 0.00701618 167.984"},{"location":"benchmarks/Binary%20classification/#charts_2","title":"Charts","text":""},{"location":"benchmarks/Binary%20classification/#smtp","title":"SMTP","text":""},{"location":"benchmarks/Binary%20classification/#summary_3","title":"Summary","text":"Model Accuracy F1 Memory in Mb Time in s ADWIN Bagging 0.999685 0 0.164217 8006.78 ALMA 0.764986 0.00178548 0.00309372 1361.61 AdaBoost 0.999443 0.404494 1.33633 6617.5 Adaptive Random Forest 0.999685 0 0.327095 11543.4 Aggregated Mondrian Forest 0.999863 0.734694 0.211749 5848.87 Bagging 0.999685 0 0.207971 8814.84 Hoeffding Adaptive Tree 0.999685 0 0.0241137 2094.95 Hoeffding Tree 0.999685 0 0.0170441 1543.56 Leveraging Bagging 0.999674 0 0.164603 17549.6 Logistic regression 0.999769 0.421053 0.00438309 1531.37 Naive Bayes 0.993484 0.0490798 0.0201406 1826.47 Stacking 0.999685 0 4.88868 24733.2 Streaming Random Patches 0.999685 0 0.17817 18142.3 Voting 0.999779 0.487805 4.60205 18069.8 Vowpal Wabbit logistic regression 0.999695 0.121212 0.000646591 1631.37 [baseline] Last Class 0.999601 0.366667 0.000510216 532.359 k-Nearest Neighbors 0.999821 0.666667 4.51822 17961.1 sklearn SGDClassifier 0.999706 0.363636 0.00574303 7118.18"},{"location":"benchmarks/Binary%20classification/#charts_3","title":"Charts","text":""},{"location":"benchmarks/Binary%20classification/#datasets","title":"Datasets","text":"Bananas <p>Bananas dataset.</p> <p>An artificial dataset where instances belongs to several clusters with a banana shape. There are two attributes that correspond to the x and y axis, respectively.</p> <pre><code>Name  Bananas                                                                                                \nTask  Binary classification\n</code></pre> <p>Samples  5,300                                                                                                 Features  2                                                                                                       Sparse  False                                                                                                     Path  /Users/mastelini/miniconda3/envs/river-benchmark/lib/python3.10/site-packages/river/datasets/banana.zip</p> <p></p> Elec2 <p>Electricity prices in New South Wales.</p> <p>This is a binary classification task, where the goal is to predict if the price of electricity will go up or down.</p> <p>This data was collected from the Australian New South Wales Electricity Market. In this market, prices are not fixed and are affected by demand and supply of the market. They are set every five minutes. Electricity transfers to/from the neighboring state of Victoria were done to alleviate fluctuations.</p> <pre><code>  Name  Elec2                                                      \n  Task  Binary classification\n</code></pre> <p>Samples  45,312                                                      Features  8                                                             Sparse  False                                                           Path  /Users/mastelini/river_data/Elec2/electricity.csv                URL  https://maxhalford.github.io/files/datasets/electricity.zip       Size  2.95 MB                                                   Downloaded  True                                                       </p> <p></p> Phishing <p>Phishing websites.</p> <p>This dataset contains features from web pages that are classified as phishing or not.</p> <pre><code>Name  Phishing                                                                                                    \nTask  Binary classification\n</code></pre> <p>Samples  1,250                                                                                                      Features  9                                                                                                            Sparse  False                                                                                                          Path  /Users/mastelini/miniconda3/envs/river-benchmark/lib/python3.10/site-packages/river/datasets/phishing.csv.gz</p> <p></p> SMTP <p>SMTP dataset from the KDD 1999 cup.</p> <p>The goal is to predict whether or not an SMTP connection is anomalous or not. The dataset only contains 2,211 (0.4%) positive labels.</p> <pre><code>  Name  SMTP                                                \n  Task  Binary classification\n</code></pre> <p>Samples  95,156                                               Features  3                                                      Sparse  False                                                    Path  /Users/mastelini/river_data/SMTP/smtp.csv                 URL  https://maxhalford.github.io/files/datasets/smtp.zip       Size  5.23 MB                                            Downloaded  True                                                </p> <p></p>"},{"location":"benchmarks/Binary%20classification/#models","title":"Models","text":"Logistic regression <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LogisticRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.005\n      )\n    )\n    loss=Log (\n      weight_pos=1.\n      weight_neg=1.\n    )\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre></p> <p></p> Aggregated Mondrian Forest <p><pre>[]</pre></p> <p></p> ALMA <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  ALMAClassifier (\n    p=2\n    alpha=0.9\n    B=1.111111\n    C=1.414214\n  )\n)</pre></p> <p></p> sklearn SGDClassifier <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SKL2RiverClassifier (\n    estimator=SGDClassifier(eta0=0.005, learning_rate='constant', loss='log_loss',\n                penalty=None)\n    classes=[False, True]\n  )\n)</pre></p> <p></p> Vowpal Wabbit logistic regression <p><pre>VW2RiverClassifier ()</pre></p> <p></p> Naive Bayes <p><pre>GaussianNB ()</pre></p> <p></p> Hoeffding Tree <p><pre>HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)</pre></p> <p></p> Hoeffding Adaptive Tree <p><pre>HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=True\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=42\n)</pre></p> <p></p> Adaptive Random Forest <p><pre>[]</pre></p> <p></p> Streaming Random Patches <p><pre>SRPClassifier (\n  model=HoeffdingTreeClassifier (\n    grace_period=50\n    max_depth=inf\n    split_criterion=\"info_gain\"\n    delta=0.01\n    tau=0.05\n    leaf_prediction=\"nba\"\n    nb_threshold=0\n    nominal_attributes=None\n    splitter=GaussianSplitter (\n      n_splits=10\n    )\n    binary_split=False\n    min_branch_fraction=0.01\n    max_share_to_split=0.99\n    max_size=100.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n  )\n  n_models=10\n  subspace_size=0.6\n  training_method=\"patches\"\n  lam=6\n  drift_detector=ADWIN (\n    delta=1e-05\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  warning_detector=ADWIN (\n    delta=0.0001\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  disable_detector=\"off\"\n  disable_weighted_vote=False\n  seed=None\n  metric=Accuracy (\n    cm=ConfusionMatrix (\n      classes=[]\n    )\n  )\n)</pre></p> <p></p> k-Nearest Neighbors <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    weighted=True\n    cleanup_every=0\n    softmax=False\n  )\n)\n\n<p></p>\n\nADWIN Bagging\n<p><pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre></p>\n\n<p></p>\n\nAdaBoost\n<p><pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre></p>\n\n<p></p>\n\nBagging\n<p><pre>[HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n)]</pre></p>\n\n<p></p>\n\nLeveraging Bagging\n<p><pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre></p>\n\n<p></p>\n\nStacking\n<p><pre>[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    weighted=True\n    cleanup_every=0\n    softmax=False\n  )\n)]\n\n<p></p>\n\nVoting\n<p><pre>VotingClassifier (\n  models=[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    weighted=True\n    cleanup_every=0\n    softmax=False\n  )\n)]\n  use_probabilities=True\n)\n\n<p></p>\n\n[baseline] Last Class\n<p><pre>NoChangeClassifier ()</pre></p>\n\n<p></p>"},{"location":"benchmarks/Binary%20classification/#environment","title":"Environment","text":"<pre>Python implementation: CPython\nPython version       : 3.12.12\nIPython version      : 8.29.0\n\nriver       : 0.23.0\nnumpy       : 2.0.2\nscikit-learn: 1.5.1\npandas      : 2.2.3\nscipy       : 1.14.1\n\nCompiler    : GCC 13.3.0\nOS          : Linux\nRelease     : 6.11.0-1018-azure\nMachine     : x86_64\nProcessor   : x86_64\nCPU cores   : 4\nArchitecture: 64bit\n</pre>"},{"location":"benchmarks/Multiclass%20classification/","title":"Multiclass classification","text":""},{"location":"benchmarks/Multiclass%20classification/#imagesegments","title":"ImageSegments","text":""},{"location":"benchmarks/Multiclass%20classification/#summary","title":"Summary","text":"Model Accuracy MicroF1 MacroF1 Memory in Mb Time in s ADWIN Bagging 0.777826 0.777826 0.765011 4.11628 3543.55 AdaBoost 0.804677 0.804677 0.79777 4.09839 3350.88 Adaptive Random Forest 0.818536 0.818536 0.814535 3.06348 1574.18 Aggregated Mondrian Forest 0.901689 0.901689 0.900381 17.0502 2997.7 Bagging 0.77696 0.77696 0.764564 4.15507 3634.88 Hoeffding Adaptive Tree 0.774361 0.774361 0.763362 0.423797 457.311 Hoeffding Tree 0.776094 0.776094 0.763137 0.417154 328.067 Leveraging Bagging 0.778259 0.778259 0.766016 4.1005 8561.3 Naive Bayes 0.731919 0.731919 0.730419 0.390004 248.959 Stacking 0.867908 0.867908 0.865603 9.18162 5416.88 Streaming Random Patches 0.766999 0.766999 0.764707 8.92653 6441.81 Voting 0.80641 0.80641 0.798999 6.07392 3157.94 [baseline] Last Class 0.148116 0.148116 0.148116 0.00136948 31.4159 k-Nearest Neighbors 0.873538 0.873538 0.872136 5.26871 2666.29"},{"location":"benchmarks/Multiclass%20classification/#charts","title":"Charts","text":""},{"location":"benchmarks/Multiclass%20classification/#insects","title":"Insects","text":""},{"location":"benchmarks/Multiclass%20classification/#summary_1","title":"Summary","text":"Model Accuracy MicroF1 MacroF1 Memory in Mb Time in s ADWIN Bagging 0.579465 0.579465 0.570198 15.3074 60279.4 AdaBoost 0.563532 0.563532 0.554622 27.943 60335.7 Adaptive Random Forest 0.745378 0.745378 0.743302 0.361794 25383.5 Aggregated Mondrian Forest 0.646981 0.646981 0.644352 1365.41 76295.7 Bagging 0.606392 0.606392 0.598542 3.69162 65237 Hoeffding Adaptive Tree 0.613337 0.613337 0.604219 0.143826 11292.9 Hoeffding Tree 0.537306 0.537306 0.527364 2.51923 7445.36 Leveraging Bagging 0.695858 0.695858 0.690508 13.831 99120.2 Naive Bayes 0.506897 0.506897 0.493019 0.611693 4263.77 Stacking 0.754745 0.754745 0.752818 10.5864 72115 Streaming Random Patches 0.736163 0.736163 0.734622 9.632 90031.6 Voting 0.648533 0.648533 0.638 9.40652 48163.7 [baseline] Last Class 0.289761 0.289761 0.289763 0.00138664 679.004 k-Nearest Neighbors 0.713115 0.713115 0.711381 6.27269 40639.9"},{"location":"benchmarks/Multiclass%20classification/#charts_1","title":"Charts","text":""},{"location":"benchmarks/Multiclass%20classification/#keystroke","title":"Keystroke","text":""},{"location":"benchmarks/Multiclass%20classification/#summary_2","title":"Summary","text":"Model Accuracy MicroF1 MacroF1 Memory in Mb Time in s ADWIN Bagging 0.81656 0.81656 0.815908 37.8558 41308 AdaBoost 0.834796 0.834796 0.836062 194.794 51861.3 Adaptive Random Forest 0.969116 0.969116 0.969111 1.63546 7363.05 Aggregated Mondrian Forest 0.881073 0.881073 0.879928 338.139 35528.4 Bagging 0.669739 0.669739 0.669981 50.3449 55411.4 Hoeffding Adaptive Tree 0.723124 0.723124 0.721825 0.724475 8998.46 Hoeffding Tree 0.648218 0.648218 0.647249 5.09445 7138.73 Leveraging Bagging 0.956616 0.956616 0.95665 7.40999 37049.1 Naive Bayes 0.652532 0.652532 0.651577 4.86901 3544.69 Stacking 0.975489 0.975489 0.975486 18.7111 42471.8 Streaming Random Patches 0.955929 0.955929 0.95592 39.636 31009.8 Voting 0.779107 0.779107 0.784136 16.3925 29779.2 [baseline] Last Class 0.997549 0.997549 0.997549 0.00504208 274.675 k-Nearest Neighbors 0.910486 0.910486 0.910328 6.32511 21326.5"},{"location":"benchmarks/Multiclass%20classification/#charts_2","title":"Charts","text":""},{"location":"benchmarks/Multiclass%20classification/#datasets","title":"Datasets","text":"ImageSegments <p>Image segments classification.</p> <p>This dataset contains features that describe image segments into 7 classes: brickface, sky, foliage, cement, window, path, and grass.</p> <pre><code>Name  ImageSegments                                                                                               \nTask  Multi-class classification\n</code></pre> <p>Samples  2,310                                                                                                      Features  18                                                                                                          Classes  7                                                                                                            Sparse  False                                                                                                          Path  /Users/mastelini/miniconda3/envs/river-benchmark/lib/python3.10/site-packages/river/datasets/segment.csv.zip</p> <p></p> Insects <p>Insects dataset.</p> <p>This dataset has different variants, which are:</p> <ul> <li>abrupt_balanced</li> <li>abrupt_imbalanced</li> <li>gradual_balanced</li> <li>gradual_imbalanced</li> <li>incremental-abrupt_balanced</li> <li>incremental-abrupt_imbalanced</li> <li>incremental-reoccurring_balanced</li> <li>incremental-reoccurring_imbalanced</li> <li>incremental_balanced</li> <li>incremental_imbalanced</li> <li>out-of-control</li> </ul> <p>The number of samples and the difficulty change from one variant to another. The number of classes is always the same (6), except for the last variant (24).</p> <pre><code>  Name  Insects                                                                                 \n  Task  Multi-class classification\n</code></pre> <p>Samples  52,848                                                                                   Features  33                                                                                        Classes  6                                                                                          Sparse  False                                                                                        Path  /Users/mastelini/river_data/Insects/INSECTS-abrupt_balanced_norm.arff                         URL  http://sites.labic.icmc.usp.br/vsouza/repository/creme/INSECTS-abrupt_balanced_norm.arff       Size  15.66 MB                                                                               Downloaded  True                                                                                      Variant  abrupt_balanced                                                                         </p> <p></p> Keystroke <p>CMU keystroke dataset.</p> <p>Users are tasked to type in a password. The task is to determine which user is typing in the password.</p> <p>The only difference with the original dataset is that the \"sessionIndex\" and \"rep\" attributes have been dropped.</p> <pre><code>  Name  Keystroke                                                       \n  Task  Multi-class classification\n</code></pre> <p>Samples  20,400                                                           Features  31                                                                Classes  51                                                                 Sparse  False                                                                Path  /Users/mastelini/river_data/Keystroke/DSL-StrongPasswordData.csv        URL  http://www.cs.cmu.edu/~keystroke/DSL-StrongPasswordData.csv          Size  4.45 MB                                                        Downloaded  True                                                            </p> <p></p>"},{"location":"benchmarks/Multiclass%20classification/#parameters","title":"Parameters","text":"<pre><code>variant\n    Indicates which variant of the dataset to load.\n</code></pre>"},{"location":"benchmarks/Multiclass%20classification/#models","title":"Models","text":"Naive Bayes <p><pre>GaussianNB ()</pre></p> <p></p> Hoeffding Tree <p><pre>HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)</pre></p> <p></p> Hoeffding Adaptive Tree <p><pre>HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=True\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=42\n)</pre></p> <p></p> Adaptive Random Forest <p><pre>[]</pre></p> <p></p> Aggregated Mondrian Forest <p><pre>[]</pre></p> <p></p> Streaming Random Patches <p><pre>SRPClassifier (\n  model=HoeffdingTreeClassifier (\n    grace_period=50\n    max_depth=inf\n    split_criterion=\"info_gain\"\n    delta=0.01\n    tau=0.05\n    leaf_prediction=\"nba\"\n    nb_threshold=0\n    nominal_attributes=None\n    splitter=GaussianSplitter (\n      n_splits=10\n    )\n    binary_split=False\n    min_branch_fraction=0.01\n    max_share_to_split=0.99\n    max_size=100.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n  )\n  n_models=10\n  subspace_size=0.6\n  training_method=\"patches\"\n  lam=6\n  drift_detector=ADWIN (\n    delta=1e-05\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  warning_detector=ADWIN (\n    delta=0.0001\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  disable_detector=\"off\"\n  disable_weighted_vote=False\n  seed=None\n  metric=Accuracy (\n    cm=ConfusionMatrix (\n      classes=[]\n    )\n  )\n)</pre></p> <p></p> k-Nearest Neighbors <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    weighted=True\n    cleanup_every=0\n    softmax=False\n  )\n)\n\n<p></p>\n\nADWIN Bagging\n<p><pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre></p>\n\n<p></p>\n\nAdaBoost\n<p><pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre></p>\n\n<p></p>\n\nBagging\n<p><pre>[HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n), HoeffdingAdaptiveTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  bootstrap_sampling=False\n  drift_window_threshold=300\n  drift_detector=ADWIN (\n    delta=0.002\n    clock=32\n    max_buckets=5\n    min_window_length=5\n    grace_period=10\n  )\n  switch_significance=0.05\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n  seed=None\n)]</pre></p>\n\n<p></p>\n\nLeveraging Bagging\n<p><pre>[HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n)]</pre></p>\n\n<p></p>\n\nStacking\n<p><pre>[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    weighted=True\n    cleanup_every=0\n    softmax=False\n  )\n)]\n\n<p></p>\n\nVoting\n<p><pre>VotingClassifier (\n  models=[Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SoftmaxRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=CrossEntropy (\n      class_weight={}\n    )\n    l2=0\n  )\n), GaussianNB (), HoeffdingTreeClassifier (\n  grace_period=200\n  max_depth=inf\n  split_criterion=\"info_gain\"\n  delta=1e-07\n  tau=0.05\n  leaf_prediction=\"nba\"\n  nb_threshold=0\n  nominal_attributes=None\n  splitter=GaussianSplitter (\n    n_splits=10\n  )\n  binary_split=False\n  min_branch_fraction=0.01\n  max_share_to_split=0.99\n  max_size=100.\n  memory_estimate_period=1000000\n  stop_mem_management=False\n  remove_poor_attrs=False\n  merit_preprune=True\n), Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNClassifier (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    weighted=True\n    cleanup_every=0\n    softmax=False\n  )\n)]\n  use_probabilities=True\n)\n\n<p></p>\n\n[baseline] Last Class\n<p><pre>NoChangeClassifier ()</pre></p>\n\n<p></p>"},{"location":"benchmarks/Multiclass%20classification/#environment","title":"Environment","text":"<pre>Python implementation: CPython\nPython version       : 3.12.12\nIPython version      : 8.29.0\n\nriver       : 0.23.0\nnumpy       : 2.0.2\nscikit-learn: 1.5.1\npandas      : 2.2.3\nscipy       : 1.14.1\n\nCompiler    : GCC 13.3.0\nOS          : Linux\nRelease     : 6.11.0-1018-azure\nMachine     : x86_64\nProcessor   : x86_64\nCPU cores   : 4\nArchitecture: 64bit\n</pre>"},{"location":"benchmarks/Regression/","title":"Regression","text":""},{"location":"benchmarks/Regression/#chickweights","title":"ChickWeights","text":""},{"location":"benchmarks/Regression/#summary","title":"Summary","text":"Model MAE RMSE R2 Memory in Mb Time in s Adaptive Model Rules 24.1943 37.2166 0.725319 0.046977 5.25855 Adaptive Random Forest 26.1016 40.8094 0.669725 1.19043 56.006 Aggregated Mondrian Forest 25.6742 41.7123 0.65479 8.21412 127.415 Bagging 23.1143 36.6311 0.733893 0.628034 38.0203 Exponentially Weighted Average 121.818 141.004 -2.94294 3.09241 55.8851 Hoeffding Adaptive Tree 23.3739 37.6579 0.718766 0.0947332 7.99029 Hoeffding Tree 23.1619 36.7336 0.732402 0.0440512 6.29305 Linear Regression 23.7587 37.0377 0.727954 0.00421047 3.21471 Linear Regression with l1 regularization 23.7577 37.078 0.727361 0.00444126 9.7485 Linear Regression with l2 regularization 25.2738 38.5885 0.704694 0.00423336 1.22128 Passive-Aggressive Regressor, mode 1 24.3423 37.596 0.71969 0.00345898 1.10187 Passive-Aggressive Regressor, mode 2 100.624 143.066 -3.05911 0.00345898 1.16798 River MLP 51.4078 80.9203 -0.298584 0.0123129 28.2295 Stochastic Gradient Tree 68.7588 80.358 -0.280601 1.12059 22.3803 Streaming Random Patches 23.7097 38.4416 0.706938 0.355182 93.4014 [baseline] Mean predictor 50.2509 71.1144 -0.00292947 0.000490189 0.302835 k-Nearest Neighbors 24.8406 39.2016 0.695236 2.88522 40.0878"},{"location":"benchmarks/Regression/#charts","title":"Charts","text":""},{"location":"benchmarks/Regression/#trumpapproval","title":"TrumpApproval","text":""},{"location":"benchmarks/Regression/#summary_1","title":"Summary","text":"Model MAE RMSE R2 Memory in Mb Time in s Adaptive Model Rules 1.39847 2.43336 -1.02372 0.114429 9.38293 Adaptive Random Forest 0.800378 2.11495 -0.528761 1.28462 87.4457 Aggregated Mondrian Forest 0.268533 0.349421 0.958184 16.9323 186.034 Bagging 0.908203 2.23718 -0.710572 1.31579 82.0689 Exponentially Weighted Average 40.7546 40.7905 -567.663 5.27613 141.452 Hoeffding Adaptive Tree 0.921313 2.23942 -0.713986 0.138225 16.7576 Hoeffding Tree 0.956103 2.24987 -0.730022 0.148639 11.7656 Linear Regression 1.31455 3.91198 -4.23035 0.00497341 11.5379 Linear Regression with l1 regularization 1.15377 3.82872 -4.01007 0.0052042 13.3595 Linear Regression with l2 regularization 1.87151 4.13052 -4.83107 0.0049963 4.15677 Passive-Aggressive Regressor, mode 1 4.98403 6.97667 -15.6354 0.00443554 2.99338 Passive-Aggressive Regressor, mode 2 31.0933 34.6257 -408.765 0.00443554 4.72475 River MLP 1.58058 5.03392 -7.66066 0.0133505 32.2432 Stochastic Gradient Tree 9.42975 17.9379 -108.972 3.08244 52.4507 Streaming Random Patches 0.656697 1.98434 -0.345761 1.06461 134.903 [baseline] Mean predictor 1.56755 2.20286 -0.658483 0.000490189 1.08177 k-Nearest Neighbors 0.641679 1.59417 0.131425 5.03263 123.301"},{"location":"benchmarks/Regression/#charts_1","title":"Charts","text":""},{"location":"benchmarks/Regression/#datasets","title":"Datasets","text":"ChickWeights <p>Chick weights along time.</p> <p>The stream contains 578 items and 3 features. The goal is to predict the weight of each chick along time, according to the diet the chick is on. The data is ordered by time and then by chick.</p> <pre><code>Name  ChickWeights                                                                                                  \nTask  Regression\n</code></pre> <p>Samples  578                                                                                                          Features  3                                                                                                              Sparse  False                                                                                                            Path  /Users/mastelini/miniconda3/envs/river-benchmark/lib/python3.10/site-packages/river/datasets/chick-weights.csv</p> <p></p> TrumpApproval <p>Donald Trump approval ratings.</p> <p>This dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald Trump's approval ratings. It contains 5 features, which are approval ratings collected by 5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of this task is to see if we can reproduce FiveThirtyEight's model.</p> <pre><code>Name  TrumpApproval                                                                                                     \nTask  Regression\n</code></pre> <p>Samples  1,001                                                                                                            Features  6                                                                                                                  Sparse  False                                                                                                                Path  /Users/mastelini/miniconda3/envs/river-benchmark/lib/python3.10/site-packages/river/datasets/trump_approval.csv.gz</p> <p></p>"},{"location":"benchmarks/Regression/#models","title":"Models","text":"Linear Regression <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre></p> <p></p> Linear Regression with l1 regularization <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=1.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre></p> <p></p> Linear Regression with l2 regularization <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=1.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)</pre></p> <p></p> Passive-Aggressive Regressor, mode 1 <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  PARegressor (\n    C=1.\n    mode=1\n    eps=0.1\n    learn_intercept=True\n  )\n)</pre></p> <p></p> Passive-Aggressive Regressor, mode 2 <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  PARegressor (\n    C=1.\n    mode=2\n    eps=0.1\n    learn_intercept=True\n  )\n)</pre></p> <p></p> k-Nearest Neighbors <p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  KNNRegressor (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    aggregation_method=\"mean\"\n  )\n)\n\n<p></p>\n\nHoeffding Tree\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  HoeffdingTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n  )\n)</pre></p>\n\n<p></p>\n\nHoeffding Adaptive Tree\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=True\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=42\n  )\n)</pre></p>\n\n<p></p>\n\nStochastic Gradient Tree\n<p><pre>SGTRegressor (\n  delta=1e-07\n  grace_period=200\n  init_pred=0.\n  max_depth=inf\n  lambda_value=0.1\n  gamma=1.\n  nominal_attributes=[]\n  feature_quantizer=StaticQuantizer (\n    n_bins=64\n    warm_start=100\n    buckets=None\n  )\n)</pre></p>\n\n<p></p>\n\nAdaptive Random Forest\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  []\n)</pre></p>\n\n<p></p>\n\nAggregated Mondrian Forest\n<p><pre>[]</pre></p>\n\n<p></p>\n\nAdaptive Model Rules\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  AMRules (\n    n_min=200\n    delta=1e-07\n    tau=0.05\n    pred_type=\"adaptive\"\n    pred_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    fading_factor=0.99\n    anomaly_threshold=-0.75\n    m_min=30\n    ordered_rule_set=True\n    min_samples_split=5\n  )\n)</pre></p>\n\n<p></p>\n\nStreaming Random Patches\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  SRPRegressor (\n    model=HoeffdingTreeRegressor (\n      grace_period=50\n      max_depth=inf\n      delta=0.01\n      tau=0.05\n      leaf_prediction=\"adaptive\"\n      leaf_model=LinearRegression (\n        optimizer=SGD (\n          lr=Constant (\n            learning_rate=0.01\n          )\n        )\n        loss=Squared ()\n        l2=0.\n        l1=0.\n        intercept_init=0.\n        intercept_lr=Constant (\n          learning_rate=0.01\n        )\n        clip_gradient=1e+12\n        initializer=Zeros ()\n      )\n      model_selector_decay=0.95\n      nominal_attributes=None\n      splitter=TEBSTSplitter (\n        digits=1\n      )\n      min_samples_split=5\n      binary_split=False\n      max_size=500.\n      memory_estimate_period=1000000\n      stop_mem_management=False\n      remove_poor_attrs=False\n      merit_preprune=True\n    )\n    n_models=10\n    subspace_size=0.6\n    training_method=\"patches\"\n    lam=6\n    drift_detector=ADWIN (\n      delta=1e-05\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    warning_detector=ADWIN (\n      delta=0.0001\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    disable_detector=\"off\"\n    disable_weighted_vote=True\n    drift_detection_criteria=\"error\"\n    aggregation_method=\"mean\"\n    seed=42\n    metric=MAE ()\n  )\n)</pre></p>\n\n<p></p>\n\nBagging\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  [HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=False\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  )]\n)</pre></p>\n\n<p></p>\n\nExponentially Weighted Average\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  [LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.01\n      )\n    )\n    loss=Squared ()\n    l2=0.\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  ), HoeffdingAdaptiveTreeRegressor (\n    grace_period=200\n    max_depth=inf\n    delta=1e-07\n    tau=0.05\n    leaf_prediction=\"adaptive\"\n    leaf_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    model_selector_decay=0.95\n    nominal_attributes=None\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    min_samples_split=5\n    bootstrap_sampling=True\n    drift_window_threshold=300\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    switch_significance=0.05\n    binary_split=False\n    max_size=500.\n    memory_estimate_period=1000000\n    stop_mem_management=False\n    remove_poor_attrs=False\n    merit_preprune=True\n    seed=None\n  ), KNNRegressor (\n    n_neighbors=5\n    engine=SWINN (\n      graph_k=20\n      dist_func=FunctionWrapper (\n        distance_function=functools.partial(, p=2)\n      )\n      maxlen=1000\n      warm_up=500\n      max_candidates=50\n      delta=0.0001\n      prune_prob=0.\n      n_iters=10\n      seed=None\n    )\n    aggregation_method=\"mean\"\n  ), AMRules (\n    n_min=200\n    delta=1e-07\n    tau=0.05\n    pred_type=\"adaptive\"\n    pred_model=LinearRegression (\n      optimizer=SGD (\n        lr=Constant (\n          learning_rate=0.01\n        )\n      )\n      loss=Squared ()\n      l2=0.\n      l1=0.\n      intercept_init=0.\n      intercept_lr=Constant (\n        learning_rate=0.01\n      )\n      clip_gradient=1e+12\n      initializer=Zeros ()\n    )\n    splitter=TEBSTSplitter (\n      digits=1\n    )\n    drift_detector=ADWIN (\n      delta=0.002\n      clock=32\n      max_buckets=5\n      min_window_length=5\n      grace_period=10\n    )\n    fading_factor=0.99\n    anomaly_threshold=-0.75\n    m_min=30\n    ordered_rule_set=True\n    min_samples_split=5\n  )]\n)\n\n<p></p>\n\nRiver MLP\n<p><pre>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  MLPRegressor (\n    hidden_dims=(5,)\n    activations=(, , )\n    loss=Squared ()\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.001\n      )\n    )\n    seed=42\n  )\n)\n\n<p></p>\n\n[baseline] Mean predictor\n<p><pre>StatisticRegressor (\n  statistic=Mean ()\n)</pre></p>\n\n<p></p>"},{"location":"benchmarks/Regression/#environment","title":"Environment","text":"<pre>Python implementation: CPython\nPython version       : 3.12.12\nIPython version      : 8.29.0\n\nriver       : 0.23.0\nnumpy       : 2.0.2\nscikit-learn: 1.5.1\npandas      : 2.2.3\nscipy       : 1.14.1\n\nCompiler    : GCC 13.3.0\nOS          : Linux\nRelease     : 6.11.0-1018-azure\nMachine     : x86_64\nProcessor   : x86_64\nCPU cores   : 4\nArchitecture: 64bit\n</pre>"},{"location":"examples/batch-to-online/","title":"From batch to online/stream","text":""},{"location":"examples/batch-to-online/#a-quick-overview-of-batch-learning","title":"A quick overview of batch learning","text":"<p>If you've already delved into machine learning, then you shouldn't have any difficulty in getting to use incremental learning. If you are somewhat new to machine learning, then do not worry! The point of this notebook in particular is to introduce simple notions. We'll also start to show how River fits in and explain how to use it.</p> <p>The whole point of machine learning is to learn from data. In supervised learning you want to learn how to predict a target \\(y\\) given a set of features \\(X\\). Meanwhile in an unsupervised learning there is no target, and the goal is rather to identify patterns and trends in the features \\(X\\). At this point most people tend to imagine \\(X\\) as a somewhat big table where each row is an observation and each column is a feature, and they would be quite right. Learning from tabular data is part of what's called batch learning, which basically that all of the data is available to our learning algorithm at once. Multiple libraries have been created to handle the batch learning regime, with one of the most prominent being Python's scikit-learn.</p> <p>As a simple example of batch learning let's say we want to learn to predict if a women has breast cancer or not. We'll use the breast cancer dataset available with scikit-learn. We'll learn to map a set of features to a binary decision using a logistic regression. Like many other models based on numerical weights, logistic regression is sensitive to the scale of the features. Rescaling the data so that each feature has mean 0 and variance 1 is generally considered good practice. We can apply the rescaling and fit the logistic regression sequentially in an elegant manner using a Pipeline. To measure the performance of the model we'll evaluate the average ROC AUC score using a 5 fold cross-validation. </p> <pre><code>from sklearn import datasets\nfrom sklearn import linear_model\nfrom sklearn import metrics\nfrom sklearn import model_selection\nfrom sklearn import pipeline\nfrom sklearn import preprocessing\n\n\n# Load the data\ndataset = datasets.load_breast_cancer()\nX, y = dataset.data, dataset.target\n\n# Define the steps of the model\nmodel = pipeline.Pipeline([\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LogisticRegression(solver='lbfgs'))\n])\n\n# Define a deterministic cross-validation procedure\ncv = model_selection.KFold(n_splits=5, shuffle=True, random_state=42)\n\n# Compute the MSE values\nscorer = metrics.make_scorer(metrics.roc_auc_score)\nscores = model_selection.cross_val_score(model, X, y, scoring=scorer, cv=cv)\n\n# Display the average score and its standard deviation\nprint(f'ROC AUC: {scores.mean():.3f} (\u00b1 {scores.std():.3f})')\n</code></pre> <pre><code>ROC AUC: 0.975 (\u00b1 0.011)\n</code></pre> <p>This might be a lot to take in if you're not accustomed to scikit-learn, but it probably isn't if you are. Batch learning basically boils down to:</p> <ol> <li>Loading (and preprocessing) the data</li> <li>Fitting a model to the data</li> <li>Computing the performance of the model on unseen data</li> </ol> <p>This is pretty standard and is maybe how most people imagine a machine learning pipeline. However, this way of proceeding has certain downsides. First of all your laptop would crash if the <code>load_boston</code> function returned a dataset who's size exceeds your available amount of RAM. Sometimes you can use some tricks to get around this. For example by optimizing the data types and by using sparse representations when applicable you can potentially save precious gigabytes of RAM. However, like many tricks this only goes so far. If your dataset weighs hundreds of gigabytes then you won't go far without some special hardware. One solution is to do out-of-core learning; that is, algorithms that can learn by being presented the data in chunks or mini-batches. If you want to go down this road then take a look at Dask and Spark's MLlib.</p> <p>Another issue with the batch learning regime is that it can't elegantly learn from new data. Indeed if new data is made available, then the model has to learn from scratch with a new dataset composed of the old data and the new data. This is particularly annoying in a real situation where you might have new incoming data every week, day, hour, minute, or even second. For example if you're building a recommendation engine for an e-commerce app, then you're probably training your model from 0 every week or so. As your app grows in popularity, so does the dataset you're training on. This will lead to longer and longer training times and might require a hardware upgrade.</p> <p>A final downside that isn't very easy to grasp concerns the manner in which features are extracted. Every time you want to train your model you first have to extract features. The trick is that some features might not be accessible at the particular point in time you are at. For example maybe that some attributes in your data warehouse get overwritten with time. In other words maybe that all the features pertaining to a particular observations are not available, whereas they were a week ago. This happens more often than not in real scenarios, and apart if you have a sophisticated data engineering pipeline then you will encounter these issues at some point. </p>"},{"location":"examples/batch-to-online/#a-hands-on-introduction-to-incremental-learning","title":"A hands-on introduction to incremental learning","text":"<p>Incremental learning is also often called online learning or stream learning, but if you google online learning a lot of the results will point to educational websites. Hence, the terms \"incremental learning\" and \"stream learning\" (from which River derives its name) are preferred. The point of incremental learning is to fit a model to a stream of data. In other words, the data isn't available in its entirety, but rather the observations are provided one by one. As an example let's stream through the dataset used previously.</p> <pre><code>for xi, yi in zip(X, y):\n    # This is where the model learns\n    pass\n</code></pre> <p>In this case we're iterating over a dataset that is already in memory, but we could just as well stream from a CSV file, a Kafka stream, an SQL query, etc. If we look at <code>xi</code> we can notice that it is a <code>numpy.ndarray</code>.</p> <pre><code>xi\n</code></pre> <pre><code>array([7.760e+00, 2.454e+01, 4.792e+01, 1.810e+02, 5.263e-02, 4.362e-02,\n       0.000e+00, 0.000e+00, 1.587e-01, 5.884e-02, 3.857e-01, 1.428e+00,\n       2.548e+00, 1.915e+01, 7.189e-03, 4.660e-03, 0.000e+00, 0.000e+00,\n       2.676e-02, 2.783e-03, 9.456e+00, 3.037e+01, 5.916e+01, 2.686e+02,\n       8.996e-02, 6.444e-02, 0.000e+00, 0.000e+00, 2.871e-01, 7.039e-02])\n</code></pre> <p>River by design works with <code>dict</code>s. We believe that <code>dict</code>s are more enjoyable to program with than <code>numpy.ndarray</code>s, at least for when single observations are concerned. <code>dict</code>'s bring the added benefit that each feature can be accessed by name rather than by position.</p> <pre><code>for xi, yi in zip(X, y):\n    xi = dict(zip(dataset.feature_names, xi))\n    pass\n\nxi\n</code></pre> <pre><code>{'mean radius': 7.76,\n 'mean texture': 24.54,\n 'mean perimeter': 47.92,\n 'mean area': 181.0,\n 'mean smoothness': 0.05263,\n 'mean compactness': 0.04362,\n 'mean concavity': 0.0,\n 'mean concave points': 0.0,\n 'mean symmetry': 0.1587,\n 'mean fractal dimension': 0.05884,\n 'radius error': 0.3857,\n 'texture error': 1.428,\n 'perimeter error': 2.548,\n 'area error': 19.15,\n 'smoothness error': 0.007189,\n 'compactness error': 0.00466,\n 'concavity error': 0.0,\n 'concave points error': 0.0,\n 'symmetry error': 0.02676,\n 'fractal dimension error': 0.002783,\n 'worst radius': 9.456,\n 'worst texture': 30.37,\n 'worst perimeter': 59.16,\n 'worst area': 268.6,\n 'worst smoothness': 0.08996,\n 'worst compactness': 0.06444,\n 'worst concavity': 0.0,\n 'worst concave points': 0.0,\n 'worst symmetry': 0.2871,\n 'worst fractal dimension': 0.07039}\n</code></pre> <p>Conveniently, River's <code>stream</code> module has an <code>iter_sklearn_dataset</code> method that we can use instead.</p> <pre><code>from river import stream\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer()):\n    pass\n</code></pre> <p>The simple fact that we are getting the data as a stream means that we can't do a lot of things the same way as in a batch setting. For example let's say we want to scale the data so that it has mean 0 and variance 1, as we did earlier. To do so we simply have to subtract the mean of each feature to each value and then divide the result by the standard deviation of the feature. The problem is that we can't possible know the values of the mean and the standard deviation before actually going through all the data! One way to proceed would be to do a first pass over the data to compute the necessary values and then scale the values during a second pass. The problem is that this defeats our purpose, which is to learn by only looking at the data once. Although this might seem rather restrictive, it reaps sizable benefits down the road.</p> <p>The way we do feature scaling in River involves computing running statistics (also know as moving statistics). The idea is that we use a data structure that estimates the mean and updates itself when it is provided with a value. The same goes for the variance (and thus the standard deviation). For example, if we denote \\(\\mu_t\\) the mean and \\(n_t\\) the count at any moment \\(t\\), then updating the mean can be done as so:</p> \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\end{cases} \\] <p>Likewise, the running variance can be computed as so:</p> \\[ \\begin{cases} n_{t+1} = n_t + 1 \\\\ \\mu_{t+1} = \\mu_t + \\frac{x - \\mu_t}{n_{t+1}} \\\\ s_{t+1} = s_t + (x - \\mu_t) \\times (x - \\mu_{t+1}) \\\\ \\sigma_{t+1} = \\frac{s_{t+1}}{n_{t+1}} \\end{cases} \\] <p>where \\(s_t\\) is a running sum of squares and \\(\\sigma_t\\) is the running variance at time \\(t\\). This might seem a tad more involved than the batch algorithms you learn in school, but it is rather elegant. Implementing this in Python is not too difficult. For example let's compute the running mean and variance of the <code>'mean area'</code> variable.</p> <pre><code>n, mean, sum_of_squares, variance = 0, 0, 0, 0\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer()):\n    n += 1\n    old_mean = mean\n    mean += (xi['mean area'] - mean) / n\n    sum_of_squares += (xi['mean area'] - old_mean) * (xi['mean area'] - mean)\n    variance = sum_of_squares / n\n\nprint(f'Running mean: {mean:.3f}')\nprint(f'Running variance: {variance:.3f}')\n</code></pre> <pre><code>Running mean: 654.889\nRunning variance: 123625.903\n</code></pre> <p>Let's compare this with <code>numpy</code>. But remember, <code>numpy</code> requires access to \"all\" the data.</p> <pre><code>import numpy as np\n\ni = list(dataset.feature_names).index('mean area')\nprint(f'True mean: {np.mean(X[:, i]):.3f}')\nprint(f'True variance: {np.var(X[:, i]):.3f}')\n</code></pre> <pre><code>True mean: 654.889\nTrue variance: 123625.903\n</code></pre> <p>The results seem to be exactly the same! The twist is that the running statistics won't be very accurate for the first few observations. In general though this doesn't matter too much. Some would even go as far as to say that this discrepancy is beneficial and acts as some sort of regularization...</p> <p>Now the idea is that we can compute the running statistics of each feature and scale them as they come along. The way to do this with River is to use the <code>StandardScaler</code> class from the <code>preprocessing</code> module, as so:</p> <pre><code>from river import preprocessing\n\nscaler = preprocessing.StandardScaler()\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer()):\n    scaler.learn_one(xi)\n</code></pre> <p>Now that we are scaling the data, we can start doing some actual machine learning. We're going to implement an online linear regression task. Because all the data isn't available at once, we are obliged to do what is called stochastic gradient descent, which is a popular research topic and has a lot of variants. SGD is commonly used to train neural networks. The idea is that at each step we compute the loss between the target prediction and the truth. We then calculate the gradient, which is simply a set of derivatives with respect to each weight from the linear regression. Once we have obtained the gradient, we can update the weights by moving them in the opposite direction of the gradient. The amount by which the weights are moved typically depends on a learning rate, which is typically set by the user. Different optimizers have different ways of managing the weight update, and some handle the learning rate implicitly. Online linear regression can be done in River with the <code>LinearRegression</code> class from the <code>linear_model</code> module. We'll be using plain and simple SGD using the <code>SGD</code> optimizer from the <code>optim</code> module. During training we'll measure the squared error between the truth and the predictions.</p> <pre><code>from river import linear_model\nfrom river import optim\n\nscaler = preprocessing.StandardScaler()\noptimizer = optim.SGD(lr=0.01)\nlog_reg = linear_model.LogisticRegression(optimizer)\n\ny_true = []\ny_pred = []\n\nfor xi, yi in stream.iter_sklearn_dataset(datasets.load_breast_cancer(), shuffle=True, seed=42):\n\n    # Scale the features\n    scaler.learn_one(xi)\n    xi_scaled = scaler.transform_one(xi)\n\n    # Test the current model on the new \"unobserved\" sample\n    yi_pred = log_reg.predict_proba_one(xi_scaled)\n    # Train the model with the new sample\n    log_reg.learn_one(xi_scaled, yi)\n\n    # Store the truth and the prediction\n    y_true.append(yi)\n    y_pred.append(yi_pred[True])\n\nprint(f'ROC AUC: {metrics.roc_auc_score(y_true, y_pred):.3f}')\n</code></pre> <pre><code>ROC AUC: 0.990\n</code></pre> <p>The ROC AUC is significantly better than the one obtained from the cross-validation of scikit-learn's logisitic regression. However to make things really comparable it would be nice to compare with the same cross-validation procedure. River has a <code>compat</code> module that contains utilities for making River compatible with other Python libraries. Because we're doing regression we'll be using the <code>SKLRegressorWrapper</code>. We'll also be using <code>Pipeline</code> to encapsulate the logic of the <code>StandardScaler</code> and the <code>LogisticRegression</code> in one single object.</p> <pre><code>from river import compat\nfrom river import compose\n\n# We define a Pipeline, exactly like we did earlier for sklearn \nmodel = compose.Pipeline(\n    ('scale', preprocessing.StandardScaler()),\n    ('log_reg', linear_model.LogisticRegression())\n)\n\n# We make the Pipeline compatible with sklearn\nmodel = compat.convert_river_to_sklearn(model)\n\n# We compute the CV scores using the same CV scheme and the same scoring\nscores = model_selection.cross_val_score(model, X, y, scoring=scorer, cv=cv)\n\n# Display the average score and its standard deviation\nprint(f'ROC AUC: {scores.mean():.3f} (\u00b1 {scores.std():.3f})')\n</code></pre> <pre><code>ROC AUC: 0.964 (\u00b1 0.016)\n</code></pre> <p>This time the ROC AUC score is lower, which is what we would expect. Indeed online learning isn't as accurate as batch learning. However it all depends in what you're interested in. If you're only interested in predicting the next observation then the online learning regime would be better. That's why it's a bit hard to compare both approaches: they're both suited to different scenarios.</p>"},{"location":"examples/batch-to-online/#going-further","title":"Going further","text":"<p>Here a few resources if you want to do some reading:</p> <ul> <li>Online learning -- Wikipedia</li> <li>What is online machine learning? -- Max Pagels</li> <li>Introduction to Online Learning -- USC course</li> <li>Online Methods in Machine Learning -- MIT course</li> <li>Online Learning: A Comprehensive Survey</li> <li>Streaming 101: The world beyond batch</li> <li>Machine learning for data streams</li> <li>Data Stream Mining: A Practical Approach</li> </ul>"},{"location":"examples/bike-sharing-forecasting/","title":"Bike-sharing forecasting","text":"<p>In this tutorial we're going to forecast the number of bikes in 5 bike stations from the city of Toulouse. We'll do so by building a simple model step by step. The dataset contains 182,470 observations. Let's first take a peak at the data.</p> <pre><code>from pprint import pprint\nfrom river import datasets\n\ndataset = datasets.Bikes()\n\nfor x, y in dataset:\n    pprint(x)\n    print(f'Number of available bikes: {y}')\n    break\n</code></pre> <pre><code>{'clouds': 75,\n 'description': 'light rain',\n 'humidity': 81,\n 'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n 'pressure': 1017.0,\n 'station': 'metro-canal-du-midi',\n 'temperature': 6.54,\n 'wind': 9.3}\nNumber of available bikes: 1\n</code></pre> <p>Let's start by using a simple linear regression on the numeric features. We can select the numeric features and discard the rest of the features using a <code>Select</code>. Linear regression is very likely to go haywire if we don't scale the data, so we'll use a <code>StandardScaler</code> to do just that. We'll evaluate the model by measuring the mean absolute error. Finally we'll print the score every 20,000 observations. </p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import metrics\nfrom river import evaluate\nfrom river import preprocessing\nfrom river import optim\n\nmodel = compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind')\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression(optimizer=optim.SGD(0.001))\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric, print_every=20_000)\n</code></pre> <pre><code>[20,000] MAE: 4.912763\n[40,000] MAE: 5.333578\n[60,000] MAE: 5.330969\n[80,000] MAE: 5.392334\n[100,000] MAE: 5.423078\n[120,000] MAE: 5.541239\n[140,000] MAE: 5.613038\n[160,000] MAE: 5.622441\n[180,000] MAE: 5.567836\n[182,470] MAE: 5.563905\n\n\n\n\n\nMAE: 5.563905\n</code></pre> <p>The model doesn't seem to be doing that well, but then again we didn't provide a lot of features. Generally, a good idea for this kind of problem is to look at an average of the previous values. For example, for each station we can look at the average number of bikes per hour. To do so we first have to extract the hour from the  <code>moment</code> field. We can then use a <code>TargetAgg</code> to aggregate the values of the target.</p> <pre><code>from river import feature_extraction\nfrom river import stats\n\ndef get_hour(x):\n    x['hour'] = x['moment'].hour\n    return x\n\nmodel = compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind')\nmodel += (\n    get_hour |\n    feature_extraction.TargetAgg(by=['station', 'hour'], how=stats.Mean())\n)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression(optimizer=optim.SGD(0.001))\n\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric, print_every=20_000)\n</code></pre> <pre><code>[20,000] MAE: 3.720766\n[40,000] MAE: 3.829739\n[60,000] MAE: 3.844905\n[80,000] MAE: 3.910137\n[100,000] MAE: 3.888553\n[120,000] MAE: 3.923644\n[140,000] MAE: 3.980882\n[160,000] MAE: 3.949972\n[180,000] MAE: 3.934489\n[182,470] MAE: 3.933442\n\n\n\n\n\nMAE: 3.933442\n</code></pre> <p>By adding a single feature, we've managed to significantly reduce the mean absolute error. At this point you might think that the model is getting slightly complex, and is difficult to understand and test. Pipelines have the advantage of being terse, but they aren't always to debug. Thankfully River has some ways to relieve the pain.</p> <p>The first thing we can do it to visualize the pipeline, to get an idea of how the data flows through it.</p> <pre><code>model\n</code></pre> <pre>['clouds', [...]</pre><code>Select (   clouds   humidity   pressure   temperature   wind ) </code><pre>get_hour</pre><code> def get_hour(x):     x['hour'] = x['moment'].hour     return x  </code><pre>y_mean_by_station_and_hour</pre><code>TargetAgg (   by=['station', 'hour']   how=Mean ()   target_name=\"y\" ) </code><pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>LinearRegression</pre><code>LinearRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.001     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code> <p>We can also use the <code>debug_one</code> method to see what happens to one particular instance. Let's train the model on the first 10,000 observations and then call <code>debug_one</code> on the next one. To do this, we will turn the <code>Bike</code> object into a Python generator with <code>iter()</code> function. The Pythonic way to read the first 10,000 elements of a generator is to use <code>itertools.islice</code>.</p> <pre><code>import itertools\n\nmodel = compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind')\nmodel += (\n    get_hour |\n    feature_extraction.TargetAgg(by=['station', 'hour'], how=stats.Mean())\n)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression()\n\nfor x, y in itertools.islice(dataset, 10000):\n    y_pred = model.predict_one(x)\n    model.learn_one(x, y)\n\nx, y = next(iter(dataset))\nprint(model.debug_one(x))\n</code></pre> <pre><code>0. Input\n--------\nclouds: 75 (int)\ndescription: light rain (str)\nhumidity: 81 (int)\nmoment: 2016-04-01 00:00:07 (datetime)\npressure: 1,017.00000 (float)\nstation: metro-canal-du-midi (str)\ntemperature: 6.54000 (float)\nwind: 9.30000 (float)\n\n1. Transformer union\n--------------------\n    1.0 Select\n    ----------\n    clouds: 75 (int)\n    humidity: 81 (int)\n    pressure: 1,017.00000 (float)\n    temperature: 6.54000 (float)\n    wind: 9.30000 (float)\n\n    1.1 get_hour | y_mean_by_station_and_hour\n    -----------------------------------------\n    y_mean_by_station_and_hour: 4.43243 (float)\n\nclouds: 75 (int)\nhumidity: 81 (int)\npressure: 1,017.00000 (float)\ntemperature: 6.54000 (float)\nwind: 9.30000 (float)\ny_mean_by_station_and_hour: 4.43243 (float)\n\n2. StandardScaler\n-----------------\nclouds: 0.47566 (float)\nhumidity: 0.42247 (float)\npressure: 1.05314 (float)\ntemperature: -1.22098 (float)\nwind: 2.21104 (float)\ny_mean_by_station_and_hour: -0.59098 (float)\n\n3. LinearRegression\n-------------------\nName                         Value      Weight     Contribution  \n                 Intercept    1.00000    6.58252        6.58252  \n                  pressure    1.05314    3.78529        3.98646  \n                  humidity    0.42247    1.44921        0.61225  \ny_mean_by_station_and_hour   -0.59098    0.54167       -0.32011  \n                    clouds    0.47566   -1.92255       -0.91448  \n                      wind    2.21104   -0.77720       -1.71843  \n               temperature   -1.22098    2.47030       -3.01619\n\nPrediction: 5.21201\n</code></pre> <p>The <code>debug_one</code> method shows what happens to an input set of features, step by step.</p> <p>And now comes the catch. Up until now we've been using the <code>progressive_val_score</code> method from the <code>evaluate</code> module. What this does it that it sequentially predicts the output of an observation and updates the model immediately afterwards. This way of proceeding is often used for evaluating online learning models. But in some cases it is the wrong approach.</p> <p>When evaluating a machine learning model, the goal is to simulate production conditions in order to get a trust-worthy assessment of the performance of the model. In our case, we typically want to forecast the number of bikes available in a station, say, 30 minutes ahead. Then, once the 30 minutes have passed, the true number of available bikes will be available and we will be able to update the model using the features available 30 minutes ago.</p> <p>What we really want is to evaluate the model by forecasting 30 minutes ahead and only updating the model once the true values are available. This can be done using the <code>moment</code> and <code>delay</code> parameters in the  <code>progressive_val_score</code> method. The idea is that each observation in the stream of the data is shown twice to the model: once for making a prediction, and once for updating the model when the true value is revealed. The <code>moment</code> parameter determines which variable should be used as a timestamp, while the <code>delay</code> parameter controls the duration to wait before revealing the true values to the model.</p> <pre><code>import datetime as dt\n\nevaluate.progressive_val_score(\n    dataset=dataset,\n    model=model.clone(),\n    metric=metrics.MAE(),\n    moment='moment',\n    delay=dt.timedelta(minutes=30),\n    print_every=20_000\n)\n</code></pre> <pre><code>[20,000] MAE: 20.198137\n[40,000] MAE: 12.199763\n[60,000] MAE: 9.468279\n[80,000] MAE: 8.126625\n[100,000] MAE: 7.273133\n[120,000] MAE: 6.735469\n[140,000] MAE: 6.376704\n[160,000] MAE: 6.06156\n[180,000] MAE: 5.806744\n[182,470] MAE: 5.780772\n\n\n\n\n\nMAE: 5.780772\n</code></pre> <p>The performance is a bit worse, which is to be expected. Indeed, the task is more difficult: the model is only shown the ground truth 30 minutes after making a prediction.</p> <p>The takeaway of this notebook is that the <code>progressive_val_score</code> method can be used to simulate a production scenario, and is thus extremely valuable.</p>"},{"location":"examples/building-a-simple-nowcasting-model/","title":"Building a simple nowcasting model","text":"<p>Nowcasting is a special case of forecasting. It simply consists in predicting the next value in a time series.</p> <p>We'll be using the international airline passenger data available from here. This particular dataset is included with River in the <code>datasets</code> module.</p> <pre><code>from river import datasets\n\nfor x, y in datasets.AirlinePassengers():\n    print(x, y)\n    break\n</code></pre> <pre><code>{'month': datetime.datetime(1949, 1, 1, 0, 0)} 112\n</code></pre> <p>The data is as simple as can be: it consists of a sequence of months and values representing the total number of international airline passengers per month. Our goal is going to be to predict the number of passengers for the next month at each step. Notice that because the dataset is small  -- which is usually the case for time series -- we could just fit a model from scratch each month. However for the sake of example we're going to train a single model online. Although the overall performance might be potentially weaker, training a time series model online has the benefit of being scalable if, say, you have have thousands of time series to manage.</p> <p>We'll start with a very simple model where the only feature will be the ordinal date of each month. This should be able to capture some of the underlying trend. </p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import preprocessing\n\n\ndef get_ordinal_date(x):\n    return {'ordinal_date': x['month'].toordinal()}\n\n\nmodel = compose.Pipeline(\n    ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression())\n)\n</code></pre> <p>We'll write down a function to evaluate the model. This will go through each observation in the dataset and update the model as it goes on. The prior predictions will be stored along with the true values and will be plotted together. </p> <pre><code>from river import metrics\nfrom river import utils\nimport matplotlib.pyplot as plt\n\n\ndef evaluate_model(model): \n\n    metric = utils.Rolling(metrics.MAE(), 12)\n\n    dates = []\n    y_trues = []\n    y_preds = []\n\n    for x, y in datasets.AirlinePassengers():\n\n        # Obtain the prior prediction and update the model in one go\n        y_pred = model.predict_one(x)\n        model.learn_one(x, y)\n\n        # Update the error metric\n        metric.update(y, y_pred)\n\n        # Store the true value and the prediction\n        dates.append(x['month'])\n        y_trues.append(y)\n        y_preds.append(y_pred)\n\n    # Plot the results\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.grid(alpha=0.75)\n    ax.plot(dates, y_trues, lw=3, color='#2ecc71', alpha=0.8, label='Ground truth')\n    ax.plot(dates, y_preds, lw=3, color='#e74c3c', alpha=0.8, label='Prediction')\n    ax.legend()\n    ax.set_title(metric)\n</code></pre> <p>Let's evaluate our first model.</p> <pre><code>evaluate_model(model)\n</code></pre> <p></p> <p>The model has captured a trend but not the right one. Indeed it thinks the trend is linear whereas we can visually see that the growth of the data increases with time. In other words the second derivative of the series is positive. This is a well know problem in time series forecasting and there are thus many ways to handle it; for example by using a Box-Cox transform. However we are going to do something a bit different, and instead linearly detrend the series using a <code>TargetStandardScaler</code>.</p> <pre><code>from river import stats\n\n\nmodel = compose.Pipeline(\n    ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(intercept_lr=0)),\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <p></p> <p>Now let's try and capture the monthly trend by one-hot encoding the month name.</p> <pre><code>import calendar\n\n\ndef get_month(x):\n    return {\n        calendar.month_name[month]: month == x['month'].month\n        for month in range(1, 13)\n    }\n\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n        ('month', compose.FuncTransformer(get_month)),\n    )),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(intercept_lr=0))\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <p></p> <p>This seems pretty decent. We can take a look at the weights of the linear regression to get an idea of the importance of each feature.</p> <pre><code>model.regressor['lin_reg'].weights\n</code></pre> <pre><code>{'January': -0.13808091575141299,\n 'February': -0.18716063793638954,\n 'March': -0.026469206216021102,\n 'April': -0.03500685108350436,\n 'May': -0.013638742192777328,\n 'June': 0.16194267303548826,\n 'July': 0.31995865445067634,\n 'August': 0.2810396556938982,\n 'September': 0.03834350518076595,\n 'October': -0.11655850082390988,\n 'November': -0.2663497734491209,\n 'December': -0.15396048501165746,\n 'ordinal_date': 1.0234863735122575}\n</code></pre> <p>As could be expected the months of July and August have the highest weights because these are the months where people typically go on holiday abroad. The month of December has a low weight because this is a month of festivities in most of the Western world where people usually stay at home.</p> <p>Our model seems to understand which months are important, but it fails to see that the importance of each month grows multiplicatively as the years go on. In other words our model is too shy. We can fix this by increasing the learning rate of the <code>LinearRegression</code>'s optimizer.</p> <pre><code>from river import optim\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n        ('month', compose.FuncTransformer(get_month)),\n    )),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(\n        intercept_lr=0,\n        optimizer=optim.SGD(0.03)\n    ))\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <p></p> <p>This is starting to look good! Naturally in production we would tune the learning rate, ideally in real-time.</p> <p>Before finishing, we're going to introduce a cool feature extraction trick based on radial basis function kernels. The one-hot encoding we did on the month is a good idea but if you think about it is a bit rigid. Indeed the value of each feature is going to be 0 or 1, depending on the month of each observation. We're basically saying that the month of September is as distant to the month of August as it is to the month of March. Of course this isn't true, and it would be nice if our features would reflect this. To do so we can simply calculate the distance between the month of each observation and all the months in the calendar. Instead of simply computing the distance linearly, we're going to use a so-called Gaussian radial basic function kernel. This is a bit of a mouthful but for us it boils down to a simple formula, which is:</p> \\[d(i, j) = exp(-\\frac{(i - j)^2}{2\\sigma^2})\\] <p>Intuitively this computes a similarity between two months -- denoted by \\(i\\) and \\(j\\) -- which decreases the further apart they are from each other. The \\(sigma\\) parameter can be seen as a hyperparameter than can be tuned -- in the following snippet we'll simply ignore it. The thing to take away is that this results in smoother predictions than when using a one-hot encoding scheme, which is often a desirable property. You can also see trick in action in this nice presentation.</p> <pre><code>import math\n\ndef get_month_distances(x):\n    return {\n        calendar.month_name[month]: math.exp(-(x['month'].month - month) ** 2)\n        for month in range(1, 13)\n    }\n\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('ordinal_date', compose.FuncTransformer(get_ordinal_date)),\n        ('month_distances', compose.FuncTransformer(get_month_distances)),\n    )),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression(\n        intercept_lr=0,\n        optimizer=optim.SGD(0.03)\n    ))\n)\n\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <p></p> <p>We've managed to get a good looking prediction curve with a reasonably simple model. What's more our model has the advantage of being interpretable and easy to debug. There surely are more rocks to squeeze (e.g. tune the hyperparameters, use an ensemble model, etc.) but we'll leave that as an exercise to the reader.</p> <p>As a finishing touch we'll rewrite our pipeline using the <code>|</code> operator, which is called a \"pipe\".</p> <pre><code>extract_features = compose.TransformerUnion(get_ordinal_date, get_month_distances)\n\nscale = preprocessing.StandardScaler()\n\nlearn = linear_model.LinearRegression(\n    intercept_lr=0,\n    optimizer=optim.SGD(0.03)\n)\n\nmodel = extract_features | scale | learn\nmodel = preprocessing.TargetStandardScaler(regressor=model)\n\nevaluate_model(model)\n</code></pre> <p></p> <pre><code>model\n</code></pre> <pre>TargetStandardScaler</pre><code>TargetStandardScaler (   regressor=Pipeline (     steps=OrderedDict([('TransformerUnion', TransformerUnion (   FuncTransformer (     func=\"get_ordinal_date\"   ),   FuncTransformer (     func=\"get_month_distances\"   ) )), ('StandardScaler', StandardScaler (   with_std=True )), ('LinearRegression', LinearRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.03     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0   )   clip_gradient=1e+12   initializer=Zeros () ))])   ) ) </code><pre>get_ordinal_date</pre><code> def get_ordinal_date(x):     return {'ordinal_date': x['month'].toordinal()}  </code><pre>get_month_distances</pre><code> def get_month_distances(x):     return {         calendar.month_name[month]: math.exp(-(x['month'].month - month) ** 2)         for month in range(1, 13)     }  </code><pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>LinearRegression</pre><code>LinearRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.03     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0   )   clip_gradient=1e+12   initializer=Zeros () ) </code>"},{"location":"examples/content-personalization/","title":"Content personalization","text":""},{"location":"examples/content-personalization/#without-context","title":"Without context","text":"<p>This example takes inspiration from Vowpal Wabbit's excellent tutorial.</p> <p>Content personalization is about taking into account user preferences. It's a special case of recommender systems. Ideally, side-information should be taken into account in addition to the user. But we'll start with something simpler. We'll assume that each user has stable preferences that are independent of the context. We capture this by implementing a \"reward\" function.</p> <pre><code>def get_reward(user, item, context):\n\n    time_of_day = context['time_of_day']\n\n    USER_LIKED_ARTICLE = 1\n    USER_DISLIKED_ARTICLE = 0\n\n    if user == 'Tom':\n        if time_of_day == 'morning' and item == 'politics':\n            return USER_LIKED_ARTICLE\n        elif time_of_day == 'afternoon' and item == 'music':\n            return USER_LIKED_ARTICLE\n        else:\n            return USER_DISLIKED_ARTICLE\n    elif user == 'Anna':\n        if time_of_day == 'morning' and item == 'sports':\n            return USER_LIKED_ARTICLE\n        elif time_of_day == 'afternoon' and item == 'politics':\n            return USER_LIKED_ARTICLE\n        else:\n            return USER_DISLIKED_ARTICLE\n\nget_reward('Tom', 'politics', {'time_of_day': 'morning'})\n</code></pre> <pre><code>1\n</code></pre> <p>Measuring the performance of a recommendation is not straightforward, mostly because of the interactive aspect of recommender systems. In a real situation, recommendations are presented to a user, and the user gives feedback indicating whether they like what they have been recommended or not. This feedback loop can't be captured entirely by a historical dataset. Some kind of simulator is required to generate recommendations and capture feedback. We already have a reward function. Now let's implement a simulation function.</p> <pre><code>import random\nimport matplotlib.pyplot as plt\n\ndef plot_ctr(ctr):\n    plt.plot(range(1, len(ctr) + 1), ctr)\n    plt.xlabel('n_iterations', fontsize=14)\n    plt.ylabel('CTR', fontsize=14)\n    plt.ylim([0, 1])\n    plt.title(f'final CTR: {ctr[-1]:.2%}', fontsize=14)\n    plt.grid()\n\nusers = ['Tom', 'Anna']\ntimes_of_day = ['morning', 'afternoon']\nitems = {'politics', 'sports', 'music', 'food', 'finance', 'health', 'camping'}\n\ndef simulate(n, reward_func, model, seed):\n\n    rng = random.Random(seed)\n    n_clicks = 0\n    ctr = []  # click-through rate along time\n\n    for i in range(n):\n\n        # Generate a context at random\n        user = rng.choice(users)\n        context = {\n            'time_of_day': rng.choice(times_of_day)\n        }\n\n        # Make a single recommendation\n        item = model.rank(user, items=items, x=context)[0]\n\n        # Measure the reward\n        clicked = reward_func(user, item, context)\n        n_clicks += clicked\n        ctr.append(n_clicks / (i + 1))\n\n        # Update the model\n        model.learn_one(user, item, y=clicked, x=context)\n\n    plot_ctr(ctr)\n</code></pre> <p>This simulation function does quite a few things. It can be seen as a simple reinforcement learning simulation. It samples a user, and then ask the model to provide a single recommendation. The user then gives as to whether they liked the recommendation or not. Crucially, the user doesn't tell us what item they would have liked. We could model this as a multi-class classification problem if that were the case.</p> <p>The strategy parameter determines the mechanism used to generate the recommendations. The <code>'best'</code> strategy means that the items are each scored by the model, and are then ranked from the most preferred to the least preferred. Here the most preferred item is the one which gets recommended. But you could imagine all sorts of alternative ways to proceed.</p> <p>We can first evaluate a recommended which acts completely at random. It assigns a random preference to each item, regardless of the user.</p> <pre><code>from river import reco\n\nmodel = reco.RandomNormal(seed=10)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <p></p> <p>We can see that the click-through rate (CTR) oscillates around 28.74%. In fact, this model is expected to be correct <code>100 * (2 / 7)% = 28.57%</code> of the time. Indeed, each user likes two items, and there are seven items in total.</p> <p>Let's now use the <code>Baseline</code> recommended. This one models each preference as the following sum:</p> \\[preference = \\bar{y} + b_{u} + b_{i}\\] <p>where</p> <ul> <li>\\(\\bar{y}\\) is the average CTR overall</li> <li>\\(b_{u}\\) is the average CTR per user minus \\(\\bar{y}\\) -- it's therefore called a bias</li> <li>\\(b_{i}\\) is the average CTR per item minus \\(\\bar{y}\\)</li> </ul> <p>This model is considered to be a baseline because it doesn't actually learn what items are preferred by each user. Instead it models each user and item separately. We shouldn't expect it to be a strong model. It should however do better than the random model used above.</p> <pre><code>model = reco.Baseline(seed=10)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <p></p> <p>This baseline model seems perfect, which is surprising. The reason why it works so well is because both users have in common that they both like politics. The model therefore learns that the <code>'politics'</code> is a good item to recommend.</p> <pre><code>model.i_biases\n</code></pre> <pre><code>defaultdict(Zeros (),\n            {'politics': 0.06389451550325113,\n             'music': -0.04041254194187752,\n             'camping': -0.040319730234734,\n             'health': -0.03581829597317823,\n             'food': -0.037778771188204816,\n             'finance': -0.04029646665611086,\n             'sports': -0.03661678982763635})\n</code></pre> <p>The model is not as performant if we use a reward function where both users have different preferences.</p> <pre><code>simulate(\n    5_000,\n    reward_func=lambda user, item, context: (\n        item in {'music', 'politics'} if user == \"Tom\" else\n        item in {'food', 'sports'}\n    ),\n    model=model,\n    seed=42\n)\n</code></pre> <p></p> <p>A good recommender model should at the very least understand what kind of items each user prefers. One of the simplest and yet performant way to do this is Simon Funk's SGD method he developed for the Netflix challenge and wrote about here. It models each user and each item as latent vectors. The dot product of these two vectors is the expected preference of the user for the item.</p> <pre><code>model = reco.FunkMF(seed=10)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <p></p> <p>We can see that this model learns what items each user enjoys very well. Of course, there are some caveats. In our simulation, we ask the model to recommend the item most likely to be preferred for each user. Indeed, we rank all the items and pick the item at the top of the list. We do this many times for only two users.</p> <p>This is of course not realistic. Users will get fed up with recommendations if they're always shown the same item. It's important to include diversity into recommendations, and to let the model explore other options instead of always focusing on the item with the highest score. This is where evaluating recommender systems gets tricky: the reward function itself is difficult to model.</p> <p>We will keep ignoring these caveats in this notebook. Instead we will focus on a different concern: making recommendations when context is involved.</p>"},{"location":"examples/content-personalization/#with-context","title":"With context","text":"<p>We'll add some context by making it so that user preferences change depending on the time the day. Very simply, preferences might change from morning to afternoon. This is captured by the following reward function.</p> <pre><code>times_of_day = ['morning', 'afternoon']\n\ndef get_reward(user, item, context):\n    if user == 'Tom':\n        if context['time_of_day'] == 'morning':\n            return item == 'politics'\n        if context['time_of_day'] == 'afternoon':\n            return item == 'music'\n    if user == 'Anna':\n        if context['time_of_day'] == 'morning':\n            return item == 'sports'\n        if context['time_of_day'] == 'afternoon':\n            return item == 'politics'\n</code></pre> <p>We have to update our simulation function to generate a random context at each step. We also want our model to use it for recommending items as well as learning.</p> <pre><code>def simulate(n, reward_func, model, seed):\n\n    rng = random.Random(seed)\n    n_clicks = 0\n    ctr = []\n\n    for i in range(n):\n\n        user = rng.choice(users)\n\n        # New: pass a context\n        context = {'time_of_day': rng.choice(times_of_day)}\n        item = model.rank(user, items, context)[0]\n\n        clicked = reward_func(user, item, context)\n        n_clicks += clicked\n        ctr.append(n_clicks / (i + 1))\n\n        # New: pass a context\n        model.learn_one(user, item, clicked, context)\n\n    plot_ctr(ctr)\n</code></pre> <p>Not all models are capable of taking into account context. For instance, the <code>FunkMF</code> model only models users and items. It completely ignores the context, even when we provide one. All recommender models inherit from the base <code>Recommender</code> class. They also have a property which indicates whether or not they are able to handle context:</p> <pre><code>model = reco.FunkMF(seed=10)\nmodel.is_contextual\n</code></pre> <pre><code>False\n</code></pre> <p>Let's see well it performs.</p> <pre><code>simulate(5_000, get_reward, model, seed=42)\n</code></pre> <p></p> <p>The performance has roughly been divided by half. This is most likely because there are now two times of day, and if the model has learnt preferences for one time of the day, then it's expected to be wrong half of the time.</p> <p>Before delving into recsys models that can handle context, a simple hack is to notice that we can append the time of day to the user. This effectively results in new users which our model can distinguish between. We could apply this trick during the simulation, but we can also override the behavior of the <code>learn_one</code> and <code>rank</code> methods of our model.</p> <pre><code>class FunkMFWithHack(reco.FunkMF):\n\n    def learn_one(self, user, item, reward, context):\n        user = f\"{user}@{context['time_of_day']}\"\n        return super().learn_one(user, item, reward, context)\n\n    def rank(self, user, items, context):\n        user = f\"{user}@{context['time_of_day']}\"\n        return super().rank(user, items, context)\n\nmodel = FunkMFWithHack(seed=29)\nsimulate(5_000, get_reward, model, seed=42)\n</code></pre> <p></p> <p>We can verify that the model has learnt the correct preferences by looking at the expected preference for each <code>(user, item)</code> pair.</p> <pre><code>import pandas as pd\n\n(\n    pd.DataFrame(\n        {\n            'user': user,\n            'item': item,\n            'preference': model.predict_one(user, item)\n        }\n        for user in model.u_latents\n        for item in model.i_latents\n    )\n    .pivot(index='user', columns='item')\n    .style.highlight_max(color='lightgreen', axis='columns')\n)\n</code></pre> preference item camping finance food health music politics sports user Anna@afternoon -0.018105 0.032865 0.069222 -0.059041 0.168353 1.000000 0.195960 Anna@morning -0.117577 0.081131 0.076300 -0.136399 0.154483 0.221890 1.000000 Tom@afternoon 0.057220 -0.027115 -0.074671 -0.233071 1.000000 0.163607 0.141781 Tom@morning -0.028562 -0.005428 0.061163 -0.050107 0.063483 1.000000 0.125515"},{"location":"examples/debugging-a-pipeline/","title":"Debugging a pipeline","text":"<p>River encourages users to make use of pipelines. The biggest pain point of pipelines is that it can be hard to understand what's happening to the data, especially when the pipeline is complex. Fortunately the <code>Pipeline</code> class has a <code>debug_one</code> method that can help out.</p> <p>Let's look at a fairly complex pipeline for predicting the number of bikes in 5 bike stations from the city of Toulouse. It doesn't matter if you understand the pipeline or not; the point of this notebook is to learn how to introspect a pipeline.</p> <pre><code>import datetime as dt\nfrom river import compose\nfrom river import datasets\nfrom river import feature_extraction\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\nfrom river import stats\nfrom river import stream\n\n\nX_y = datasets.Bikes()\nX_y = stream.simulate_qa(X_y, moment='moment', delay=dt.timedelta(minutes=30))\n\ndef add_time_features(x):\n    return {\n        **x,\n        'hour': x['moment'].hour,\n        'day': x['moment'].weekday()\n    }\n\nmodel = add_time_features\nmodel |= (\n    compose.Select('clouds', 'humidity', 'pressure', 'temperature', 'wind') +\n    feature_extraction.TargetAgg(by=['station', 'hour'], how=stats.Mean()) +\n    feature_extraction.TargetAgg(by='station', how=stats.EWMean())\n)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression()\n\nmetric = metrics.MAE()\n\nquestions = {}\n\nfor i, x, y in X_y:\n    # Question\n    is_question = y is None\n    if is_question:\n        y_pred = model.predict_one(x)\n        questions[i] = y_pred\n\n    # Answer\n    else:\n        metric.update(y, questions[i])\n        model.learn_one(x, y)\n\n        if i &gt;= 30000 and i % 30000 == 0:\n            print(i, metric)\n</code></pre> <pre><code>30000 MAE: 13.328051\n60000 MAE: 7.824087\n90000 MAE: 6.003909\n120000 MAE: 5.052855\n150000 MAE: 4.496826\n180000 MAE: 4.140702\n</code></pre> <p>Let's start by looking at the pipeline. You can click each cell to display the current state for each step of the pipeline.</p> <pre><code>model\n</code></pre> <pre>add_time_features</pre><code> def add_time_features(x):     return {         **x,         'hour': x['moment'].hour,         'day': x['moment'].weekday()     }  </code><pre>['clouds', [...]</pre><code>Select (   clouds   humidity   pressure   temperature   wind ) </code><pre>y_mean_by_station_and_hour</pre><code>TargetAgg (   by=['station', 'hour']   how=Mean ()   target_name=\"y\" ) </code><pre>y_ewm_0.5_by_station</pre><code>TargetAgg (   by=['station']   how=EWMean (     fading_factor=0.5   )   target_name=\"y\" ) </code><pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>LinearRegression</pre><code>LinearRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code> <p>As mentioned above the <code>Pipeline</code> class has a <code>debug_one</code> method. You can use this at any point you want to visualize what happen to an input <code>x</code>. For example, let's see what happens to the last seen <code>x</code>.</p> <pre><code>print(model.debug_one(x))\n</code></pre> <pre><code>0. Input\n--------\nclouds: 88 (int)\ndescription: overcast clouds (str)\nhumidity: 84 (int)\nmoment: 2016-10-05 09:57:18 (datetime)\npressure: 1,017.34000 (float)\nstation: pomme (str)\ntemperature: 17.45000 (float)\nwind: 1.95000 (float)\n\n1. add_time_features\n--------------------\nclouds: 88 (int)\nday: 2 (int)\ndescription: overcast clouds (str)\nhour: 9 (int)\nhumidity: 84 (int)\nmoment: 2016-10-05 09:57:18 (datetime)\npressure: 1,017.34000 (float)\nstation: pomme (str)\ntemperature: 17.45000 (float)\nwind: 1.95000 (float)\n\n2. Transformer union\n--------------------\n    2.0 Select\n    ----------\n    clouds: 88 (int)\n    humidity: 84 (int)\n    pressure: 1,017.34000 (float)\n    temperature: 17.45000 (float)\n    wind: 1.95000 (float)\n\n    2.1 TargetAgg\n    -------------\n    y_mean_by_station_and_hour: 7.89396 (float)\n\n    2.2 TargetAgg1\n    --------------\n    y_ewm_0.5_by_station: 11.80372 (float)\n\nclouds: 88 (int)\nhumidity: 84 (int)\npressure: 1,017.34000 (float)\ntemperature: 17.45000 (float)\nwind: 1.95000 (float)\ny_ewm_0.5_by_station: 11.80372 (float)\ny_mean_by_station_and_hour: 7.89396 (float)\n\n3. StandardScaler\n-----------------\nclouds: 1.54778 (float)\nhumidity: 1.16366 (float)\npressure: 0.04916 (float)\ntemperature: -0.51938 (float)\nwind: -0.69426 (float)\ny_ewm_0.5_by_station: 0.19640 (float)\ny_mean_by_station_and_hour: -0.27110 (float)\n\n4. LinearRegression\n-------------------\nName                         Value      Weight     Contribution  \n                 Intercept    1.00000    9.19960        9.19960  \n      y_ewm_0.5_by_station    0.19640    9.19349        1.80562  \n                  humidity    1.16366    1.01680        1.18320  \n               temperature   -0.51938   -0.41575        0.21593  \n                      wind   -0.69426   -0.03810        0.02645  \n                  pressure    0.04916    0.18321        0.00901  \ny_mean_by_station_and_hour   -0.27110    0.19553       -0.05301  \n                    clouds    1.54778   -0.32838       -0.50827\n\nPrediction: 11.87854\n</code></pre> <p>The pipeline does quite a few things, but using <code>debug_one</code> shows what happens step by step. This is really useful for checking that the pipeline is behaving as you're expecting it too. Remember that you can <code>debug_one</code> whenever you wish, be it before, during, or after training a model.</p>"},{"location":"examples/imbalanced-learning/","title":"Working with imbalanced data","text":"<p>In machine learning it is quite usual to have to deal with imbalanced dataset. This is particularly true in online learning for tasks such as fraud detection and spam classification. In these two cases, which are binary classification problems, there are usually many more 0s than 1s, which generally hinders the performance of the classifiers we thrown at them.</p> <p>As an example we'll use the credit card dataset available in River. We'll first use a <code>collections.Counter</code> to count the number of 0s and 1s in order to get an idea of the class balance.</p> <pre><code>import collections\nfrom river import datasets\n\nX_y = datasets.CreditCard()\n\ncounts = collections.Counter(y for _, y in X_y)\n\nfor c, count in counts.items():\n    print(f'{c}: {count} ({count / sum(counts.values()):.5%})')\n</code></pre> <pre><code>0: 284315 (99.82725%)\n1: 492 (0.17275%)\n</code></pre>"},{"location":"examples/imbalanced-learning/#baseline","title":"Baseline","text":"<p>The dataset is quite unbalanced. For each 1 there are about 578 0s. Let's now train a logistic regression with default parameters and see how well it does. We'll measure the ROC AUC score.</p> <pre><code>from river import linear_model\nfrom river import metrics\nfrom river import evaluate\nfrom river import preprocessing\n\n\nX_y = datasets.CreditCard()\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression()\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre><code>ROCAUC: 89.11%\n</code></pre>"},{"location":"examples/imbalanced-learning/#importance-weighting","title":"Importance weighting","text":"<p>The performance is already quite acceptable, but as we will now see we can do even better. The first thing we can do is to add weight to the 1s by using the <code>weight_pos</code> argument of the <code>Log</code> loss function.</p> <pre><code>from river import optim\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(\n        loss=optim.losses.Log(weight_pos=5)\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre><code>ROCAUC: 91.43%\n</code></pre>"},{"location":"examples/imbalanced-learning/#focal-loss","title":"Focal loss","text":"<p>The deep learning for object detection community has produced a special loss function for imbalanced learning called focal loss. We are doing binary classification, so we can plug the binary version of focal loss into our logistic regression and see how well it fairs.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    linear_model.LogisticRegression(loss=optim.losses.BinaryFocalLoss(2, 1))\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre><code>ROCAUC: 91.31%\n</code></pre>"},{"location":"examples/imbalanced-learning/#under-sampling-the-majority-class","title":"Under-sampling the majority class","text":"<p>Adding importance weights only works with gradient-based models (which includes neural networks). A more generic, and potentially more effective approach, is to use undersamplig and oversampling. As an example, we'll under-sample the stream so that our logistic regression encounter 20% of 1s and 80% of 0s. Under-sampling has the additional benefit of requiring less training steps, and thus reduces the total training time.</p> <pre><code>from river import imblearn\n\nmodel = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomUnderSampler(\n        classifier=linear_model.LogisticRegression(),\n        desired_dist={0: .8, 1: .2},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre><code>ROCAUC: 94.75%\n</code></pre> <p>The <code>RandomUnderSampler</code> class is a wrapper for classifiers. This is represented by a rectangle around the logistic regression bubble when we visualize the model.</p> <pre><code>model\n</code></pre> <pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>RandomUnderSampler</pre><code>RandomUnderSampler (   classifier=LogisticRegression (     optimizer=SGD (       lr=Constant (         learning_rate=0.01       )     )     loss=Log (       weight_pos=1.       weight_neg=1.     )     l2=0.     l1=0.     intercept_init=0.     intercept_lr=Constant (       learning_rate=0.01     )     clip_gradient=1e+12     initializer=Zeros ()   )   desired_dist={0: 0.8, 1: 0.2}   seed=42 ) </code><pre>LogisticRegression</pre><code>LogisticRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Log (     weight_pos=1.     weight_neg=1.   )   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code>"},{"location":"examples/imbalanced-learning/#over-sampling-the-minority-class","title":"Over-sampling the minority class","text":"<p>We can also attain the same class distribution by over-sampling the minority class. This will come at cost of having to train with more samples.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomOverSampler(\n        classifier=linear_model.LogisticRegression(),\n        desired_dist={0: .8, 1: .2},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre><code>ROCAUC: 91.71%\n</code></pre>"},{"location":"examples/imbalanced-learning/#sampling-with-a-desired-sample-size","title":"Sampling with a desired sample size","text":"<p>The downside of both <code>RandomUnderSampler</code> and <code>RandomOverSampler</code> is that you don't have any control on the amount of data the classifier trains on. The number of samples is adjusted so that the target distribution can be attained, either by under-sampling or over-sampling. However, you can do both at the same time and choose how much data the classifier will see. To do so, we can use the <code>RandomSampler</code> class. In addition to the desired class distribution, we can specify how much data to train on. The samples will both be under-sampled and over-sampled in order to fit your constraints. This is powerful because it allows you to control both the class distribution and the size of the training data (and thus the training time). In the following example we'll set it so that the model will train with 1 percent of the data.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomSampler(\n        classifier=linear_model.LogisticRegression(),\n        desired_dist={0: .8, 1: .2},\n        sampling_rate=.01,\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre><code>ROCAUC: 94.71%\n</code></pre>"},{"location":"examples/imbalanced-learning/#hybrid-approach","title":"Hybrid approach","text":"<p>As you might have guessed by now, nothing is stopping you from mixing imbalanced learning methods together. As an example, let's combine <code>sampling.RandomUnderSampler</code> and the <code>weight_pos</code> parameter from the <code>optim.losses.Log</code> loss function.</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    imblearn.RandomUnderSampler(\n        classifier=linear_model.LogisticRegression(\n            loss=optim.losses.Log(weight_pos=5)\n        ),\n        desired_dist={0: .8, 1: .2},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(X_y, model, metric)\n</code></pre> <pre><code>ROCAUC: 96.52%\n</code></pre>"},{"location":"examples/quantile-regression-uncertainty/","title":"Handling uncertainty with quantile regression","text":"<pre><code>%matplotlib inline\n</code></pre> <p>Quantile regression is useful when you're not so much interested in the accuracy of your model, but rather you want your model to be good at ranking observations correctly. The typical way to perform quantile regression is to use a special loss function, namely the quantile loss. The quantile loss takes a parameter, \\(\\alpha\\) (alpha), which indicates which quantile the model should be targeting. In the case of \\(\\alpha = 0.5\\), then this is equivalent to asking the model to predict the median value of the target, and not the most likely value which would be the mean. </p> <p>A nice thing we can do with quantile regression is to produce a prediction interval for each prediction. Indeed, if we predict the lower and upper quantiles of the target then we will be able to obtain a \"trust region\" in between which the true value is likely to belong. Of course, the likeliness will depend on the chosen quantiles. For a slightly more detailed explanation see this blog post.</p> <p>As an example, let us take the simple nowcasting model we built in another notebook. Instead of predicting the mean value of the target distribution, we will predict the 5th, 50th, 95th quantiles. This will require training three separate models, so we will encapsulate the model building logic in a function called <code>make_model</code>. We also have to slightly adapt the training loop, but not by much. Finally, we will draw the prediction interval along with the predictions from for 50th quantile (i.e. the median) and the true values.</p> <pre><code>import calendar\nimport math\nimport matplotlib.pyplot as plt\nfrom river import compose\nfrom river import datasets\nfrom river import linear_model\nfrom river import metrics\nfrom river import optim\nfrom river import preprocessing\nfrom river import stats\n\n\ndef get_ordinal_date(x):\n    return {'ordinal_date': x['month'].toordinal()}    \n\n\ndef get_month_distances(x):\n    return {\n        calendar.month_name[month]: math.exp(-(x['month'].month - month) ** 2)\n        for month in range(1, 13)\n    }\n\n\ndef make_model(alpha):\n\n    extract_features = compose.TransformerUnion(get_ordinal_date, get_month_distances)\n\n    scale = preprocessing.StandardScaler()\n\n    learn = linear_model.LinearRegression(\n        intercept_lr=0,\n        optimizer=optim.SGD(0.03),\n        loss=optim.losses.Quantile(alpha=alpha)\n    )\n\n    model = extract_features | scale | learn\n    model = preprocessing.TargetStandardScaler(regressor=model)\n\n    return model\n\nmetric = metrics.MAE()\n\nmodels = {\n    'lower': make_model(alpha=0.05),\n    'center': make_model(alpha=0.5),\n    'upper': make_model(alpha=0.95)\n}\n\ndates = []\ny_trues = []\ny_preds = {\n    'lower': [],\n    'center': [],\n    'upper': []\n}\n\nfor x, y in datasets.AirlinePassengers():\n    y_trues.append(y)\n    dates.append(x['month'])\n\n    for name, model in models.items():\n        y_preds[name].append(model.predict_one(x))\n        model.learn_one(x, y)\n\n    # Update the error metric\n    metric.update(y, y_preds['center'][-1])\n\n# Plot the results\nfig, ax = plt.subplots(figsize=(10, 6))\nax.grid(alpha=0.75)\nax.plot(dates, y_trues, lw=3, color='#2ecc71', alpha=0.8, label='Truth')\nax.plot(dates, y_preds['center'], lw=3, color='#e74c3c', alpha=0.8, label='Prediction')\nax.fill_between(dates, y_preds['lower'], y_preds['upper'], color='#e74c3c', alpha=0.3, label='Prediction interval')\nax.legend()\nax.set_title(metric);\n</code></pre> <p></p> <p>An important thing to note is that the prediction interval we obtained should not be confused with a confidence interval. Simply put, a prediction interval represents uncertainty for where the true value lies, whereas a confidence interval encapsulates the uncertainty on the prediction. You can find out more by reading this CrossValidated post.</p>"},{"location":"examples/sentence-classification/","title":"Sentence classification","text":"<p>In this tutorial we will try to predict whether an SMS is a spam or not. To train our model, we will use the <code>SMSSpam</code> dataset. This dataset is unbalanced, there is only 13.4% spam. Let's look at the data:</p> <pre><code>from river import datasets\n\ndatasets.SMSSpam()\n</code></pre> <pre><code>SMS Spam Collection dataset.\n\nThe data contains 5,574 items and 1 feature (i.e. SMS body). Spam messages represent\n13.4% of the dataset. The goal is to predict whether an SMS is a spam or not.\n\n      Name  SMSSpam                                                                              \n      Task  Binary classification                                                                \n   Samples  5,574                                                                                \n  Features  1                                                                                    \n    Sparse  False                                                                                \n      Path  /Users/max/river_data/SMSSpam/SMSSpamCollection                                      \n       URL  https://archive.ics.uci.edu/ml/machine-learning-databases/00228/smsspamcollection.zip\n      Size  466.71 KB                                                                            \nDownloaded  True\n</code></pre> <pre><code>from pprint import pprint\n\nX_y = datasets.SMSSpam()\n\nfor x, y in X_y:\n    pprint(x)\n    print(f'Spam: {y}')\n    break\n</code></pre> <pre><code>{'body': 'Go until jurong point, crazy.. Available only in bugis n great world '\n         'la e buffet... Cine there got amore wat...\\n'}\nSpam: False\n</code></pre> <p>Let's start by building a simple model like a Naive Bayes classifier. We will first preprocess the sentences with a TF-IDF transform that our model can consume. Then, we will measure the accuracy of our model with the AUC metric. This is the right metric to use when the classes are not balanced. In addition, the Naive Bayes models can perform very well on unbalanced datasets and can be used for both binary and multi-class classification problems.</p> <pre><code>from river import feature_extraction\nfrom river import naive_bayes\nfrom river import metrics\n\nX_y = datasets.SMSSpam()\n\nmodel = (\n    feature_extraction.TFIDF(on='body') | \n    naive_bayes.BernoulliNB(alpha=0)\n)\n\nmetric = metrics.ROCAUC()\ncm = metrics.ConfusionMatrix()\n\nfor x, y in X_y:\n\n    y_pred = model.predict_one(x)\n\n    if y_pred is not None:\n        metric.update(y_pred=y_pred, y_true=y)\n        cm.update(y_pred=y_pred, y_true=y)\n\n    model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 93.00%\n</code></pre> <p>The confusion matrix:</p> <pre><code>cm\n</code></pre> <pre><code>        False   True  \nFalse   4,809     17  \n True     102    645\n</code></pre> <p>The results are quite good with this first model.</p> <p>Since we are working with an imbalanced dataset, we can use the <code>imblearn</code> module to rebalance the classes of our dataset. For more information about the <code>imblearn</code> module, you can find a dedicated tutorial here.</p> <pre><code>from river import imblearn\n\nX_y = datasets.SMSSpam()\n\nmodel = (\n    feature_extraction.TFIDF(on='body') | \n    imblearn.RandomUnderSampler(\n        classifier=naive_bayes.BernoulliNB(alpha=0),\n        desired_dist={0: .5, 1: .5},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\ncm = metrics.ConfusionMatrix()\n\nfor x, y in X_y:\n\n    y_pred = model.predict_one(x)\n\n    if y_pred is not None:\n        metric.update(y_pred=y_pred, y_true=y)\n        cm.update(y_pred=y_pred, y_true=y)\n\n    model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 94.61%\n</code></pre> <p>The <code>imblearn</code> module improved our results. Not bad! We can visualize the pipeline to understand how the data is processed.</p> <p>The confusion matrix:</p> <pre><code>cm\n</code></pre> <pre><code>        False   True  \nFalse   4,570    255  \n True      41    706\n</code></pre> <pre><code>model\n</code></pre> <pre>TFIDF</pre><code>TFIDF (   normalize=True   on=\"body\"   strip_accents=True   lowercase=True   preprocessor=None   tokenizer=None   ngram_range=(1, 1) ) </code><pre>RandomUnderSampler</pre><code>RandomUnderSampler (   classifier=BernoulliNB (     alpha=0     true_threshold=0.   )   desired_dist={0: 0.5, 1: 0.5}   seed=42 ) </code><pre>BernoulliNB</pre><code>BernoulliNB (   alpha=0   true_threshold=0. ) </code> <p>Now let's try to use logistic regression to classify messages. We will use different tips to make my model perform better. As in the previous example, we rebalance the classes of our dataset. The logistics regression will be fed from a TF-IDF.</p> <pre><code>from river import linear_model\nfrom river import optim\nfrom river import preprocessing\n\nX_y = datasets.SMSSpam()\n\nmodel = (\n    feature_extraction.TFIDF(on='body') | \n    preprocessing.Normalizer() | \n    imblearn.RandomUnderSampler(\n        classifier=linear_model.LogisticRegression(\n            optimizer=optim.SGD(.9), \n            loss=optim.losses.Log()\n        ),\n        desired_dist={0: .5, 1: .5},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\ncm = metrics.ConfusionMatrix()\n\nfor x, y in X_y:\n\n    y_pred = model.predict_one(x)\n\n    metric.update(y_pred=y_pred, y_true=y)\n    cm.update(y_pred=y_pred, y_true=y)\n\n    model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 93.80%\n</code></pre> <p>The confusion matrix:</p> <pre><code>cm\n</code></pre> <pre><code>        False   True  \nFalse   4,584    243  \n True      55    692\n</code></pre> <pre><code>model\n</code></pre> <pre>TFIDF</pre><code>TFIDF (   normalize=True   on=\"body\"   strip_accents=True   lowercase=True   preprocessor=None   tokenizer=None   ngram_range=(1, 1) ) </code><pre>Normalizer</pre><code>Normalizer (   order=2 ) </code><pre>RandomUnderSampler</pre><code>RandomUnderSampler (   classifier=LogisticRegression (     optimizer=SGD (       lr=Constant (         learning_rate=0.9       )     )     loss=Log (       weight_pos=1.       weight_neg=1.     )     l2=0.     l1=0.     intercept_init=0.     intercept_lr=Constant (       learning_rate=0.01     )     clip_gradient=1e+12     initializer=Zeros ()   )   desired_dist={0: 0.5, 1: 0.5}   seed=42 ) </code><pre>LogisticRegression</pre><code>LogisticRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.9     )   )   loss=Log (     weight_pos=1.     weight_neg=1.   )   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code> <p>The results of the logistic regression are quite good but still inferior to the naive Bayes model.</p> <p>Let's try to use word embeddings to improve our logistic regression. Word embeddings allow you to represent a word as a vector. Embeddings are developed to build semantically rich vectors. For instance, the vector which represents the word python should be close to the vector which represents the word programming. We will use spaCy to convert our sentence to vectors. spaCy converts a sentence to a vector by calculating the average of the embeddings of the words in the sentence.</p> <p>You can download pre-trained embeddings in many languages. We will use English pre-trained embeddings as our SMS are in English.</p> <p>The command below allows you to download the pre-trained embeddings that spaCy makes available. More information about spaCy and its installation may be found here here.</p> <pre><code>python -m spacy download en_core_web_sm\n</code></pre> <p>Here, we create a custom transformer to convert an input sentence to a dict of floats. We will integrate this transformer into our pipeline.</p> <pre><code>import spacy\n\nfrom river.base import Transformer\n\nclass Embeddings(Transformer):\n    \"\"\"My custom transformer, word embedding using spaCy.\"\"\"\n\n    def __init__(self, on: str):\n        self.on = on\n        self.embeddings = spacy.load('en_core_web_sm')\n\n    def transform_one(self, x, y=None):\n        return {dimension: xi for dimension, xi in enumerate(self.embeddings(x[self.on]).vector)}\n</code></pre> <p>Let's train our logistic regression:</p> <pre><code>X_y = datasets.SMSSpam()\n\nmodel = (\n    Embeddings(on='body') | \n    preprocessing.Normalizer() |\n    imblearn.RandomOverSampler(\n        classifier=linear_model.LogisticRegression(\n            optimizer=optim.SGD(.5), \n            loss=optim.losses.Log()\n        ),\n        desired_dist={0: .5, 1: .5},\n        seed=42\n    )\n)\n\nmetric = metrics.ROCAUC()\ncm = metrics.ConfusionMatrix()\n\nfor x, y in X_y:\n\n    y_pred = model.predict_one(x)\n\n    metric.update(y_pred=y_pred, y_true=y)\n    cm.update(y_pred=y_pred, y_true=y)\n\n    model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 91.31%\n</code></pre> <p>The confusion matrix:</p> <pre><code>cm\n</code></pre> <pre><code>        False   True  \nFalse   4,537    290  \n True      85    662\n</code></pre> <pre><code>model\n</code></pre> <pre>Embeddings</pre><code>Embeddings (   on=\"body\" ) </code><pre>Normalizer</pre><code>Normalizer (   order=2 ) </code><pre>RandomOverSampler</pre><code>RandomOverSampler (   classifier=LogisticRegression (     optimizer=SGD (       lr=Constant (         learning_rate=0.5       )     )     loss=Log (       weight_pos=1.       weight_neg=1.     )     l2=0.     l1=0.     intercept_init=0.     intercept_lr=Constant (       learning_rate=0.01     )     clip_gradient=1e+12     initializer=Zeros ()   )   desired_dist={0: 0.5, 1: 0.5}   seed=42 ) </code><pre>LogisticRegression</pre><code>LogisticRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.5     )   )   loss=Log (     weight_pos=1.     weight_neg=1.   )   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code> <p>The results of the logistic regression using spaCy embeddings are lower than those obtained with TF-IDF values. We could surely improve the results by cleaning up the text. We could also use embeddings more suited to our dataset. However, on this problem, the logistic regression is not better than the Naive Bayes model. No free lunch today.</p>"},{"location":"examples/the-art-of-using-pipelines/","title":"The art of using pipelines","text":"<p>Pipelines are a natural way to think about a machine learning system. Indeed with some practice a data scientist can visualise data \"flowing\" through a series of steps. The input is typically some raw data which has to be processed in some manner. The goal is to represent the data in such a way that is can be ingested by a machine learning algorithm. Along the way some steps will extract features, while others will normalize the data and remove undesirable elements. Pipelines are simple, and yet they are a powerful way of designing sophisticated machine learning systems.</p> <p>Both scikit-learn and pandas make it possible to use pipelines. However it's quite rare to see pipelines being used in practice (at least on Kaggle). Sometimes you get to see people using scikit-learn's <code>pipeline</code> module, however the <code>pipe</code> method from <code>pandas</code> is sadly underappreciated. A big reason why pipelines are not given much love is that it's easier to think of batch learning in terms of a script or a notebook. Indeed many people doing data science seem to prefer a procedural style to a declarative style. Moreover in practice pipelines can be a bit rigid if one wishes to do non-orthodox operations.</p> <p>Although pipelines may be a bit of an odd fit for batch learning, they make complete sense when they are used for online learning. Indeed the UNIX philosophy has advocated the use of pipelines for data processing for many decades. If you can visualise data as a stream of observations then using pipelines should make a lot of sense to you. We'll attempt to convince you by writing a machine learning algorithm in a procedural way and then converting it to a declarative pipeline in small steps. Hopefully by the end you'll be convinced, or not!</p> <p>In this notebook we'll manipulate data from the Kaggle Recruit Restaurants Visitor Forecasting competition. The data is directly available through River's <code>datasets</code> module.</p> <pre><code>from pprint import pprint\nfrom river import datasets\n\nfor x, y in datasets.Restaurants():\n    pprint(x)\n    pprint(y)\n    break\n</code></pre> <pre><code>{'area_name': 'T\u014dky\u014d-to Nerima-ku Toyotamakita',\n 'date': datetime.datetime(2016, 1, 1, 0, 0),\n 'genre_name': 'Izakaya',\n 'is_holiday': True,\n 'latitude': 35.7356234,\n 'longitude': 139.6516577,\n 'store_id': 'air_04341b588bde96cd'}\n10\n</code></pre> <p>We'll start by building and running a model using a procedural coding style. The performance of the model doesn't matter, we're simply interested in the design of the model.</p> <pre><code>from river import feature_extraction\nfrom river import linear_model\nfrom river import metrics\nfrom river import preprocessing\nfrom river import stats\nfrom river import utils\n\nmeans = (\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)),\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)),\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21))\n)\n\nscaler = preprocessing.StandardScaler()\nlin_reg = linear_model.LinearRegression()\nmetric = metrics.MAE()\n\nfor x, y in datasets.Restaurants():\n\n    # Derive date features\n    x['weekday'] = x['date'].weekday()\n    x['is_weekend'] = x['date'].weekday() in (5, 6)\n\n    # Process the rolling means of the target  \n    for mean in means:\n        x = {**x, **mean.transform_one(x)}\n        mean.learn_one(x, y)\n\n    # Remove the key/value pairs that aren't features\n    for key in ['store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude']:\n        x.pop(key)\n\n    # Rescale the data\n    scaler.learn_one(x)\n    x = scaler.transform_one(x)\n\n    # Fit the linear regression\n    y_pred = lin_reg.predict_one(x)\n    lin_reg.learn_one(x, y)\n\n    # Update the metric using the out-of-fold prediction\n    metric.update(y, y_pred)\n\nprint(metric)\n</code></pre> <pre><code>MAE: 8.316538\n</code></pre> <p>We're not using many features. We can print the last <code>x</code> to get an idea of the features (don't forget they've been scaled!)</p> <pre><code>pprint(x)\n</code></pre> <pre><code>{'is_holiday': -0.23103573677646685,\n 'is_weekend': 1.6249280076334165,\n 'weekday': 1.0292832579142892,\n 'y_mean_by_store_id': -1.3980979075298516}\n</code></pre> <p>The above chunk of code is quite explicit but it's a bit verbose. The whole point of libraries such as River is to make life easier for users. Moreover there's too much space for users to mess up the order in which things are done, which increases the chance of there being target leakage. We'll now rewrite our model in a declarative fashion using a pipeline \u00e0 la sklearn.  </p> <pre><code>from river import compose\n\n\ndef get_date_features(x):\n    weekday =  x['date'].weekday()\n    return {'weekday': weekday, 'is_weekend': weekday in (5, 6)}\n\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('date_features', compose.FuncTransformer(get_date_features)),\n        ('last_7_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7))),\n        ('last_14_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14))),\n        ('last_21_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21)))\n    )),\n    ('drop_non_features', compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude')),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression())\n)\n\nmetric = metrics.MAE()\n\nfor x, y in datasets.Restaurants():\n\n    # Make a prediction without using the target\n    y_pred = model.predict_one(x)\n\n    # Update the model using the target\n    model.learn_one(x, y)\n\n    # Update the metric using the out-of-fold prediction\n    metric.update(y, y_pred)\n\nprint(metric)\n</code></pre> <pre><code>MAE: 8.413859\n</code></pre> <p>We use a <code>Pipeline</code> to arrange each step in a sequential order. A <code>TransformerUnion</code> is used to merge multiple feature extractors into a single transformer. The <code>for</code> loop is now much shorter and is thus easier to grok: we get the out-of-fold prediction, we fit the model, and finally we update the metric. This way of evaluating a model is typical of online learning, and so we put it wrapped it inside a function called <code>progressive_val_score</code> part of the <code>evaluate</code> module. We can use it to replace the <code>for</code> loop.</p> <pre><code>from river import evaluate\n\nmodel = compose.Pipeline(\n    ('features', compose.TransformerUnion(\n        ('date_features', compose.FuncTransformer(get_date_features)),\n        ('last_7_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7))),\n        ('last_14_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14))),\n        ('last_21_mean', feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21)))\n    )),\n    ('drop_non_features', compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude')),\n    ('scale', preprocessing.StandardScaler()),\n    ('lin_reg', linear_model.LinearRegression())\n)\n\nevaluate.progressive_val_score(dataset=datasets.Restaurants(), model=model, metric=metrics.MAE())\n</code></pre> <pre><code>MAE: 8.413859\n</code></pre> <p>Notice that you couldn't have used the <code>progressive_val_score</code> method if you wrote the model in a procedural manner.</p> <p>Our code is getting shorter, but it's still a bit difficult on the eyes. Indeed there is a lot of boilerplate code associated with pipelines that can get tedious to write. However River has some special tricks up it's sleeve to save you from a lot of pain.</p> <p>The first trick is that the name of each step in the pipeline can be omitted. If no name is given for a step then River automatically infers one.</p> <pre><code>model = compose.Pipeline(\n    compose.TransformerUnion(\n        compose.FuncTransformer(get_date_features),\n        feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)),\n        feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)),\n        feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21))\n    ),\n    compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude'),\n    preprocessing.StandardScaler(),\n    linear_model.LinearRegression()\n)\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre><code>MAE: 8.413859\n</code></pre> <p>Under the hood a <code>Pipeline</code> inherits from <code>collections.OrderedDict</code>. Indeed this makes sense because if you think about it a <code>Pipeline</code> is simply a sequence of steps where each step has a name. The reason we mention this is because it means you can manipulate a <code>Pipeline</code> the same way you would manipulate an ordinary <code>dict</code>. For instance we can print the name of each step by using the <code>keys</code> method.</p> <pre><code>for name in model.steps:\n    print(name)\n</code></pre> <pre><code>TransformerUnion\nDiscard\nStandardScaler\nLinearRegression\n</code></pre> <p>The first step is a <code>FeatureUnion</code> and it's string representation contains the string representation of each of it's elements. Not having to write names saves up some time and space and is certainly less tedious.</p> <p>The next trick is that we can use mathematical operators to compose our pipeline. For example we can use the <code>+</code> operator to merge <code>Transformer</code>s into a <code>TransformerUnion</code>. </p> <pre><code>model = compose.Pipeline(\n    compose.FuncTransformer(get_date_features) + \\\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)) + \\\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)) + \\\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21)),\n\n    compose.Discard('store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude'),\n    preprocessing.StandardScaler(),\n    linear_model.LinearRegression()\n)\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre><code>MAE: 8.413859\n</code></pre> <p>Likewhise we can use the <code>|</code> operator to assemble steps into a <code>Pipeline</code>. </p> <pre><code>model = (\n    compose.FuncTransformer(get_date_features) +\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 7)) +\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 14)) +\n    feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), 21))\n)\n\nto_discard = ['store_id', 'date', 'genre_name', 'area_name', 'latitude', 'longitude']\n\nmodel = model | compose.Discard(*to_discard) | preprocessing.StandardScaler()\n\nmodel |= linear_model.LinearRegression()\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre><code>MAE: 8.413859\n</code></pre> <p>Hopefully you'll agree that this is a powerful way to express machine learning pipelines. For some people this should be quite remeniscent of the UNIX pipe operator. One final trick we want to mention is that functions are automatically wrapped with a <code>FuncTransformer</code>, which can be quite handy.</p> <pre><code>model = get_date_features\n\nfor n in [7, 14, 21]:\n    model += feature_extraction.TargetAgg(by='store_id', how=utils.Rolling(stats.Mean(), n))\n\nmodel |= compose.Discard(*to_discard)\nmodel |= preprocessing.StandardScaler()\nmodel |= linear_model.LinearRegression()\n\nevaluate.progressive_val_score(datasets.Restaurants(), model, metrics.MAE())\n</code></pre> <pre><code>MAE: 8.413859\n</code></pre> <p>Naturally some may prefer the procedural style we first used because they find it easier to work with. It all depends on your style and you should use what you feel comfortable with. However we encourage you to use operators because we believe that this will increase the readability of your code, which is very important. To each their own!</p> <p>Before finishing we can take an interactive look at our pipeline.</p> <pre><code>model\n</code></pre> <pre>get_date_features</pre><code> def get_date_features(x):     weekday =  x['date'].weekday()     return {'weekday': weekday, 'is_weekend': weekday in (5, 6)}  </code><pre>y_mean_by_store_id</pre><code>TargetAgg (   by=['store_id']   how=Rolling (     obj=Mean ()     window_size=7   )   target_name=\"y\" ) </code><pre>y_mean_by_store_id</pre><code>TargetAgg (   by=['store_id']   how=Rolling (     obj=Mean ()     window_size=14   )   target_name=\"y\" ) </code><pre>y_mean_by_store_id</pre><code>TargetAgg (   by=['store_id']   how=Rolling (     obj=Mean ()     window_size=21   )   target_name=\"y\" ) </code><pre>~['area_name', [...]</pre><code>Discard (   area_name   date   genre_name   latitude   longitude   store_id ) </code><pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>LinearRegression</pre><code>LinearRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/","title":"Part 1","text":"<p>Table of contents of this tutorial series on matrix factorization for recommender systems:</p> <ul> <li>Part 1 - Traditional Matrix Factorization methods for Recommender Systems</li> <li>Part 2 - Factorization Machines and Field-aware Factorization Machines</li> <li>Part 3 - Large scale learning and better predictive power with multiple pass learning</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#introduction","title":"Introduction","text":"<p>A recommender system is a software tool designed to generate and suggest items or entities to the users. Popular large scale examples include:</p> <ul> <li>Amazon (suggesting products)</li> <li>Facebook (suggesting posts in users' news feeds)</li> <li>Spotify (suggesting music)</li> </ul> <p>Social recommendation from graph (mostly used by social networks) are not covered in River. We focus on the general case, item recommendation. This problem can be represented with the user-item matrix:</p> \\[ \\normalsize \\begin{matrix}     &amp; \\begin{matrix} _1 &amp; _\\cdots &amp; _\\cdots &amp; _\\cdots &amp; _I \\end{matrix} \\\\     \\begin{matrix} _1 \\\\ _\\vdots \\\\ _\\vdots \\\\ _\\vdots \\\\ _U \\end{matrix} &amp;          \\begin{bmatrix}             {\\color{Red} ?} &amp; 2 &amp; \\cdots &amp; {\\color{Red} ?} &amp; {\\color{Red} ?} \\\\             {\\color{Red} ?} &amp; {\\color{Red} ?} &amp; \\cdots &amp; {\\color{Red} ?} &amp; 4.5 \\\\             \\vdots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\             3 &amp; {\\color{Red} ?} &amp; \\cdots &amp; {\\color{Red} ?} &amp; {\\color{Red} ?} \\\\             {\\color{Red} ?} &amp; {\\color{Red} ?} &amp; \\cdots &amp; 5 &amp; {\\color{Red} ?}         \\end{bmatrix} \\end{matrix} \\] <p>Where \\(U\\) and \\(I\\) are the number of user and item of the system, respectively. A matrix entry represents a user's preference for an item, it can be a rating, a like or dislike, etc. Because of the huge number of users and items compared to the number of observed entries, those matrices are very sparsed (usually less than 1% filled).</p> <p>Matrix Factorization (MF) is a class of collaborative filtering algorithms derived from Singular Value Decomposition (SVD). MF strength lies in its capacity to able to model high cardinality categorical variables interactions. This subfield boomed during the famous Netflix Prize contest in 2006, when numerous novel variants has been invented and became popular thanks to their attractive accuracy and scalability.</p> <p>MF approach seeks to fill the user-item matrix considering the problem as a matrix completion one. MF core idea assume a latent model learning its own representation of the users and the items in a lower latent dimensional space by factorizing the observed parts of the matrix.</p> <p>A factorized user or item is represented as a vector \\(\\mathbf{v}_u\\) or \\(\\mathbf{v}_i\\) composed of \\(k\\) latent factors, with \\(k &lt;&lt; U, I\\). Those learnt latent variables represent, for an item the various aspects describing it, and for a user its interests in terms of those aspects. The model then assume a user's choice or fondness is composed of a sum of preferences about the various aspects of the concerned item. This sum being the dot product between the latent vectors of a given user-item pair:</p> \\[ \\normalsize \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{u, f} \\cdot \\mathbf{v}_{i, f} \\] <p>MF models weights are learnt in an online fashion, often with stochastic gradient descent as it provides relatively fast running time and good accuracy. There is a great and widely popular library named surprise that implements MF models (and others) but in contrast with River doesn't follow a pure online philosophy (all the data have to be loaded in memory and the API doesn't allow you to update your model with new data).</p> <p>Notes:</p> <ul> <li>In recent years, proposed deep learning techniques for recommendation tasks claim state of the art results. However, recent work (August 2019) showed that those promises can't be taken for granted and traditional MF methods are still relevant today.</li> <li>For more information about how the business value of recommender systems is measured and why they are one of the main success stories of machine learning, see the following literature survey (December 2019).</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#lets-start","title":"Let's start","text":"<p>In this tutorial, we are going to explore MF algorithms available in River and test them on a movie recommendation problem with the MovieLens 100K dataset. This latter is a collection of movie ratings (from 1 to 5) that includes various information about both the items and the users. We can access it from the river.datasets module:</p> <pre><code>import json\n\nfrom river import datasets\n\nfor x, y in datasets.MovieLens100K():\n    print(f'x = {json.dumps(x, indent=4)}')\n    print(f'y = {y}')\n    break\n</code></pre> <pre><code>x = {\n    \"user\": \"259\",\n    \"item\": \"255\",\n    \"timestamp\": 874731910000000000,\n    \"title\": \"My Best Friend's Wedding (1997)\",\n    \"release_date\": 866764800000000000,\n    \"genres\": \"comedy, romance\",\n    \"age\": 21.0,\n    \"gender\": \"M\",\n    \"occupation\": \"student\",\n    \"zip_code\": \"48823\"\n}\ny = 4.0\n</code></pre> <p>Let's define a routine to evaluate our different models on MovieLens 100K. Mean Absolute Error and Root Mean Squared Error will be our metrics printed alongside model's computation time and memory usage:</p> <pre><code>from river import metrics\nfrom river.evaluate import progressive_val_score\n\ndef evaluate(model, unpack_user_and_item=True):\n    X_y = datasets.MovieLens100K(unpack_user_and_item)\n    metric = metrics.MAE() + metrics.RMSE()\n    _ = progressive_val_score(X_y, model, metric, print_every=25_000, show_time=True, show_memory=True)\n</code></pre>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#naive-prediction","title":"Naive prediction","text":"<p>It's good practice in machine learning to start with a naive baseline and then iterate from simple things to complex ones observing progress incrementally. Let's start by predicting the target running mean as a first shot:</p> <pre><code>from river import dummy\nfrom river import stats\n\nmodel = dummy.StatisticRegressor(stats.Mean())\nevaluate(model, unpack_user_and_item=False)\n</code></pre> <pre><code>[25,000] MAE: 0.934259\nRMSE: 1.124469 \u2013 00:00:00 \u2013 898 B\n[50,000] MAE: 0.923893\nRMSE: 1.105 \u2013 00:00:00 \u2013 898 B\n[75,000] MAE: 0.937359\nRMSE: 1.123696 \u2013 00:00:00 \u2013 898 B\n[100,000] MAE: 0.942162\nRMSE: 1.125783 \u2013 00:00:01 \u2013 898 B\n</code></pre>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#baseline-model","title":"Baseline model","text":"<p>Now we can do machine learning and explore available models in river.reco module starting with the baseline model. It extends our naive prediction by adding to the global running mean two bias terms characterizing the user and the item discrepancy from the general tendency. The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} \\] <p>This baseline model can be viewed as a linear regression where the intercept is replaced by the target running mean with the users and the items one hot encoded.</p> <p>All machine learning models in River expect dicts as input with feature names as keys and feature values as values. Specifically, models from <code>river.reco</code> expect a <code>'user'</code> and an <code>'item'</code> entries without any type constraint on their values (i.e. can be strings or numbers), e.g.:</p> <pre><code>x = {\n    'user': 'Guido',\n    'item': \"Monty Python's Flying Circus\"\n}\n</code></pre> <p>Other entries, if exist, are simply ignored. This is quite useful as we don't need to spend time and storage doing one hot encoding.</p> <pre><code>from river import preprocessing\nfrom river import optim\nfrom river import reco\n\nbaseline_params = {\n    'optimizer': optim.SGD(0.025),\n    'l2': 0.,\n    'initializer': optim.initializers.Zeros()\n}\n\nmodel = preprocessing.PredClipper(\n    regressor=reco.Baseline(**baseline_params),\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761844\nRMSE: 0.960972 \u2013 00:00:00 \u2013 161.03 KB\n[50,000] MAE: 0.753292\nRMSE: 0.951223 \u2013 00:00:00 \u2013 216.34 KB\n[75,000] MAE: 0.754177\nRMSE: 0.953376 \u2013 00:00:01 \u2013 254.81 KB\n[100,000] MAE: 0.754651\nRMSE: 0.954148 \u2013 00:00:01 \u2013 278.41 KB\n</code></pre> <p>We won two tenth of MAE compared to our naive prediction (0.7546 vs 0.9421) meaning that significant information has been learnt by the model.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#funk-matrix-factorization-funkmf","title":"Funk Matrix Factorization (FunkMF)","text":"<p>It's the pure form of matrix factorization consisting of only learning the users and items latent representations as discussed in introduction. Simon Funk popularized its stochastic gradient descent optimization in 2006 during the Netflix Prize. The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] <p>Note: FunkMF is sometimes referred as Probabilistic Matrix Factorization which is an extended probabilistic version.</p> <pre><code>funk_mf_params = {\n    'n_factors': 10,\n    'optimizer': optim.SGD(0.05),\n    'l2': 0.1,\n    'initializer': optim.initializers.Normal(mu=0., sigma=0.1, seed=73)\n}\n\nmodel = preprocessing.PredClipper(\n    regressor=reco.FunkMF(**funk_mf_params),\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 1.070136\nRMSE: 1.397014 \u2013 00:00:00 \u2013 557.99 KB\n[50,000] MAE: 0.99174\nRMSE: 1.290666 \u2013 00:00:01 \u2013 690.31 KB\n[75,000] MAE: 0.961072\nRMSE: 1.250842 \u2013 00:00:01 \u2013 813.07 KB\n[100,000] MAE: 0.944883\nRMSE: 1.227688 \u2013 00:00:02 \u2013 914.17 KB\n</code></pre> <p>Results are equivalent to our naive prediction (0.9448 vs 0.9421). By only focusing on the users preferences and the items characteristics, the model is limited in his ability to capture different views of the problem. Despite its poor performance alone, this algorithm is quite useful combined in other models or when we need to build dense representations for other tasks.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-1/#biased-matrix-factorization-biasedmf","title":"Biased Matrix Factorization (BiasedMF)","text":"<p>It's the combination of the Baseline model and FunkMF. The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = \\bar{y} + bu_{u} + bi_{i} + \\langle \\mathbf{v}_u, \\mathbf{v}_i \\rangle \\] <p>Note: Biased Matrix Factorization name is used by some people but some others refer to it by SVD or Funk SVD. It's the case of Yehuda Koren and Robert Bell in Recommender Systems Handbook (Chapter 5 Advances in Collaborative Filtering) and of <code>surprise</code> library. Nevertheless, SVD could be confused with the original Singular Value Decomposition from which it's derived from, and Funk SVD could also be misleading because of the biased part of the model equation which doesn't come from Simon Funk's work. For those reasons, we chose to side with Biased Matrix Factorization which fits more naturally to it.</p> <pre><code>biased_mf_params = {\n    'n_factors': 10,\n    'bias_optimizer': optim.SGD(0.025),\n    'latent_optimizer': optim.SGD(0.05),\n    'weight_initializer': optim.initializers.Zeros(),\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.1, seed=73),\n    'l2_bias': 0.,\n    'l2_latent': 0.\n}\n\nmodel = preprocessing.PredClipper(\n    regressor=reco.BiasedMF(**biased_mf_params),\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761818\nRMSE: 0.961057 \u2013 00:00:00 \u2013 643.81 KB\n[50,000] MAE: 0.751667\nRMSE: 0.949443 \u2013 00:00:01 \u2013 817.72 KB\n[75,000] MAE: 0.749653\nRMSE: 0.948723 \u2013 00:00:01 \u2013 964.02 KB\n[100,000] MAE: 0.748559\nRMSE: 0.947854 \u2013 00:00:02 \u2013 1.05 MB\n</code></pre> <p>Results improved (0.7485 vs 0.7546) demonstrating that users and items latent representations bring additional information.</p> <p>To conclude this first tutorial about factorization models, let's review the important parameters to tune when dealing with this family of methods:</p> <ul> <li><code>n_factors</code>: the number of latent factors. The more you set, the more items aspects and users preferences you are going to learn. Too many will cause overfitting, <code>l2</code> regularization could help.</li> <li><code>*_optimizer</code>: the optimizers. Classic stochastic gradient descent performs well, finding the good learning rate will make the difference.</li> <li><code>initializer</code>: the latent weights initialization. Latent vectors have to be initialized with non-constant values. We generally sample them from a zero-mean normal distribution with small standard deviation.</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/","title":"Part 2","text":"<p>As seen in Part 1, strength of Matrix Factorization (MF) lies in its ability to deal with sparse and high cardinality categorical variables. In this second tutorial we will have a look at Factorization Machines (FM) algorithm and study how it generalizes the power of MF.</p> <p>Table of contents of this tutorial series on matrix factorization for recommender systems:</p> <ul> <li>Part 1 - Traditional Matrix Factorization methods for Recommender Systems</li> <li>Part 2 - Factorization Machines and Field-aware Factorization Machines</li> <li>Part 3 - Large scale learning and better predictive power with multiple pass learning</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#factorization-machines","title":"Factorization Machines","text":"<p>Steffen Rendel came up in 2010 with Factorization Machines, an algorithm able to handle any real valued feature vector, combining the advantages of general predictors with factorization models. It became quite popular in the field of online advertising, notably after winning several Kaggle competitions. The modeling technique starts with a linear regression to capture the effects of each variable individually:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j} \\] <p>Then are added interaction terms to learn features relations. Instead of learning a single and specific weight per interaction (as in polynomial regression), a set of latent factors is learnt per feature (as in MF). An interaction is calculated by multiplying involved features product with their latent vectors dot product. The degree of factorization \u2014 or model order \u2014 represents the maximum number of features per interaction considered. The model equation for a factorization machine of degree \\(d\\) = 2 is defined as:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] <p>Where \\(\\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle\\) is the dot product of \\(j\\) and \\(j'\\) latent vectors:</p> \\[ \\normalsize \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle = \\sum_{f=1}^{k} \\mathbf{v}_{j, f} \\cdot \\mathbf{v}_{j', f} \\] <p>Higher-order FM will be covered in a following section, just note that factorization models express their power in sparse settings, which is also where higher-order interactions are hard to estimate.</p> <p>Strong emphasis must be placed on feature engineering as it allows FM to mimic most factorization models and significantly impact its performance. High cardinality categorical variables one hot encoding is the most frequent step before feeding the model with data. For more efficiency, River FM implementation considers string values as categorical variables and automatically one hot encode them. FM models have their own module river.facto.</p> <p>## Mimic Biased Matrix Factorization (BiasedMF)</p> <p>Let's start with a simple example where we want to reproduce the Biased Matrix Factorization model we trained in the previous tutorial. For a fair comparison with Part 1 example, let's set the same evaluation framework:</p> <pre><code>from river import datasets\nfrom river import metrics\nfrom river.evaluate import progressive_val_score\n\ndef evaluate(model):\n    X_y = datasets.MovieLens100K()\n    metric = metrics.MAE() + metrics.RMSE()\n    _ = progressive_val_score(X_y, model, metric, print_every=25_000, show_time=True, show_memory=True)\n</code></pre> <p>In order to build an equivalent model we need to use the same hyper-parameters. As we can't replace FM intercept by the global running mean we won't be able to build the exact same model:</p> <pre><code>from river import compose\nfrom river import facto\nfrom river import preprocessing\nfrom river import optim\nfrom river import stats\n\nfm_params = {\n    'n_factors': 10,\n    'weight_optimizer': optim.SGD(0.025),\n    'latent_optimizer': optim.SGD(0.05),\n    'sample_normalization': False,\n    'l1_weight': 0.,\n    'l2_weight': 0.,\n    'l1_latent': 0.,\n    'l2_latent': 0.,\n    'intercept': 3,\n    'intercept_lr': .01,\n    'weight_initializer': optim.initializers.Zeros(),\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.1, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor |= facto.FMRegressor(**fm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761778\nRMSE: 0.960803 \u2013 00:00:01 \u2013 778.29 KB\n[50,000] MAE: 0.751986\nRMSE: 0.949941 \u2013 00:00:02 \u2013 908.2 KB\n[75,000] MAE: 0.750044\nRMSE: 0.948911 \u2013 00:00:03 \u2013 1.03 MB\n[100,000] MAE: 0.748609\nRMSE: 0.947994 \u2013 00:00:05 \u2013 1.15 MB\n</code></pre> <p>Both MAE are very close to each other (0.7486 vs 0.7485) showing that we almost reproduced [reco.BiasedMF](../../../api/reco/BiasedMF) algorithm. The cost is a naturally slower running time as FM implementation offers more flexibility.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#feature-engineering-for-fm-models","title":"Feature engineering for FM models","text":"<p>Let's study the basics of how to properly encode data for FM models. We are going to keep using MovieLens 100K as it provides various feature types:</p> <pre><code>import json\n\nfor x, y in datasets.MovieLens100K():\n    print(f'x = {json.dumps(x, indent=4)}\\ny = {y}')\n    break\n</code></pre> <pre><code>x = {\n    \"user\": \"259\",\n    \"item\": \"255\",\n    \"timestamp\": 874731910000000000,\n    \"title\": \"My Best Friend's Wedding (1997)\",\n    \"release_date\": 866764800000000000,\n    \"genres\": \"comedy, romance\",\n    \"age\": 21.0,\n    \"gender\": \"M\",\n    \"occupation\": \"student\",\n    \"zip_code\": \"48823\"\n}\ny = 4.0\n</code></pre> <p>The features we are going to add to our model don't improve its predictive power. Nevertheless, they are useful to illustrate different methods of data encoding:</p> <ol> <li>Set-categorical variables</li> </ol> <p>We have seen that categorical variables are one hot encoded automatically if set to strings, in the other hand, set-categorical variables must be encoded explicitly by the user. A good way of doing so is to assign them a value of \\(1/m\\), where \\(m\\) is the number of elements of the sample set. It gives the feature a constant \"weight\" across all samples preserving model's stability. Let's create a routine to encode movies genres this way:</p> <pre><code>def split_genres(x):\n    genres = x['genres'].split(', ')\n    return {f'genre_{genre}': 1 / len(genres) for genre in genres}\n</code></pre> <ol> <li>Numerical variables</li> </ol> <p>In practice, transforming numerical features into categorical ones works better in most cases. Feature binning is the natural way, but finding good bins is sometimes more an art than a science. Let's encode users age with something simple:</p> <pre><code>def bin_age(x):\n    if x['age'] &lt;= 18:\n        return {'age_0-18': 1}\n    elif x['age'] &lt;= 32:\n        return {'age_19-32': 1}\n    elif x['age'] &lt; 55:\n        return {'age_33-54': 1}\n    else:\n        return {'age_55-100': 1}\n</code></pre> <p>Let's put everything together:</p> <pre><code>fm_params = {\n    'n_factors': 14,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.05, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.FMRegressor(**fm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.759838\nRMSE: 0.961281 \u2013 00:00:03 \u2013 895.78 KB\n[50,000] MAE: 0.751307\nRMSE: 0.951391 \u2013 00:00:08 \u2013 1.02 MB\n[75,000] MAE: 0.750361\nRMSE: 0.951393 \u2013 00:00:12 \u2013 1.18 MB\n[100,000] MAE: 0.749994\nRMSE: 0.951435 \u2013 00:00:16 \u2013 1.33 MB\n</code></pre> <p>Note that using more variables involves factorizing a larger latent space, then increasing the number of latent factors \\(k\\) often helps capturing more information.</p> <p>Some other feature engineering tips from 3 idiots' winning solution for Kaggle Criteo display ads competition in 2014:</p> <ul> <li>Infrequent modalities often bring noise and little information, transforming them into a special tag can help</li> <li>In some cases, sample-wise normalization seems to make the optimization problem easier to be solved</li> </ul>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#higher-order-factorization-machines-hofm","title":"Higher-Order Factorization Machines (HOFM)","text":"<p>The model equation generalized to any order \\(d \\geq 2\\) is defined as:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{l=2}^{d} \\sum_{j_1=1}^{p} \\cdots \\sum_{j_l=j_{l-1}+1}^{p} \\left(\\prod_{j'=1}^{l} x_{j_{j'}} \\right) \\left(\\sum_{f=1}^{k_l} \\prod_{j'=1}^{l} v_{j_{j'}, f}^{(l)} \\right) \\] <pre><code>hofm_params = {\n    'degree': 3,\n    'n_factors': 12,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.05, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.HOFMRegressor(**hofm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761297\nRMSE: 0.962054 \u2013 00:00:15 \u2013 1.67 MB\n[50,000] MAE: 0.751865\nRMSE: 0.951499 \u2013 00:00:31 \u2013 1.97 MB\n[75,000] MAE: 0.750853\nRMSE: 0.951526 \u2013 00:00:47 \u2013 2.3 MB\n[100,000] MAE: 0.750607\nRMSE: 0.951982 \u2013 00:01:03 \u2013 2.6 MB\n</code></pre> <p>As said previously, high-order interactions are often hard to estimate due to too much sparsity, that's why we won't spend too much time here.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#field-aware-factorization-machines-ffm","title":"Field-aware Factorization Machines (FFM)","text":"<p>Field-aware variant of FM (FFM) improved the original method by adding the notion of \"fields\". A \"field\" is a group of features that belong to a specific domain (e.g. the \"users\" field, the \"items\" field, or the \"movie genres\" field).</p> <p>FFM restricts itself to pairwise interactions and factorizes separated latent spaces \u2014 one per combination of fields (e.g. users/items, users/movie genres, or items/movie genres) \u2014 instead of a common one shared by all fields. Therefore, each feature has one latent vector per field it can interact with \u2014 so that it can learn the specific effect with each different field.</p> <p>The model equation is defined by:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} \\langle \\mathbf{v}_{j, f_{j'}}, \\mathbf{v}_{j', f_{j}} \\rangle x_{j} x_{j'} \\] <p>Where \\(f_j\\) and \\(f_{j'}\\) are the fields corresponding to \\(j\\) and \\(j'\\) features, respectively.</p> <pre><code>ffm_params = {\n    'n_factors': 8,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'latent_initializer': optim.initializers.Normal(mu=0., sigma=0.05, seed=73),\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.FFMRegressor(**ffm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.757718\nRMSE: 0.958158 \u2013 00:00:06 \u2013 2.04 MB\n[50,000] MAE: 0.749502\nRMSE: 0.948065 \u2013 00:00:12 \u2013 2.41 MB\n[75,000] MAE: 0.749275\nRMSE: 0.948918 \u2013 00:00:18 \u2013 2.82 MB\n[100,000] MAE: 0.749542\nRMSE: 0.949769 \u2013 00:00:24 \u2013 3.19 MB\n</code></pre> <p>Note that FFM usually needs to learn smaller number of latent factors \\(k\\) than FM as each latent vector only deals with one field.</p>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-2/#field-weighted-factorization-machines-fwfm","title":"Field-weighted Factorization Machines (FwFM)","text":"<p>Field-weighted Factorization Machines (FwFM) address FFM memory issues caused by its large number of parameters, which is in the order of feature number times field number. As FFM, FwFM is an extension of FM restricted to pairwise interactions, but instead of factorizing separated latent spaces, it learns a specific weight \\(r_{f_j, f_{j'}}\\) for each field combination modelling the interaction strength.</p> <p>The model equation is defined as:</p> \\[ \\normalsize \\hat{y}(x) = w_{0} + \\sum_{j=1}^{p} w_{j} x_{j}  + \\sum_{j=1}^{p} \\sum_{j'=j+1}^{p} r_{f_j, f_{j'}} \\langle \\mathbf{v}_j, \\mathbf{v}_{j'} \\rangle x_{j} x_{j'} \\] <pre><code>fwfm_params = {\n    'n_factors': 10,\n    'weight_optimizer': optim.SGD(0.01),\n    'latent_optimizer': optim.SGD(0.025),\n    'intercept': 3,\n    'seed': 73,\n}\n\nregressor = compose.Select('user', 'item')\nregressor += (\n    compose.Select('genres') |\n    compose.FuncTransformer(split_genres)\n)\nregressor += (\n    compose.Select('age') |\n    compose.FuncTransformer(bin_age)\n)\nregressor |= facto.FwFMRegressor(**fwfm_params)\n\nmodel = preprocessing.PredClipper(\n    regressor=regressor,\n    y_min=1,\n    y_max=5\n)\n\nevaluate(model)\n</code></pre> <pre><code>[25,000] MAE: 0.761539\nRMSE: 0.962241 \u2013 00:00:07 \u2013 792.94 KB\n[50,000] MAE: 0.754089\nRMSE: 0.953181 \u2013 00:00:15 \u2013 922.85 KB\n[75,000] MAE: 0.754806\nRMSE: 0.954979 \u2013 00:00:22 \u2013 1.04 MB\n[100,000] MAE: 0.755404\nRMSE: 0.95604 \u2013 00:00:30 \u2013 1.17 MB\n</code></pre>"},{"location":"examples/matrix-factorization-for-recommender-systems/part-3/","title":"Part 3","text":"<p>To do.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#do-all-classifiers-support-multi-class-classification","title":"Do all classifiers support multi-class classification?","text":"<p>No, they don't. Although binary classification can be seen as a special case of multi-class classification, there are many optimizations that can be performed if we know that there are only two classes. It would be annoying to have to check whether this is the case in an online setting. All in all we find that separating both cases leads to much cleaner code. Note that the <code>multiclass</code> module contains wrapper models that enable you to perform multi-class classification with binary classifiers.</p>"},{"location":"faq/#how-do-i-know-if-a-classifier-supports-multi-class-classification","title":"How do I know if a classifier supports multi-class classification?","text":"<p>Each classifier in River inherits from the <code>base.Classifier</code> class. Each classifier therefore has a <code>_multiclass</code> property which indicates whether or not it can process a non-boolean target value.</p> <pre><code>&gt;&gt;&gt; from river import linear_model\n\n&gt;&gt;&gt; classifier = linear_model.LogisticRegression()\n&gt;&gt;&gt; classifier._multiclass\nFalse\n</code></pre>"},{"location":"faq/#why-doesnt-river-do-any-input-validation","title":"Why doesn't river do any input validation?","text":"<p>Python encourages a coding style called EAFP, which stands for \"Easier to Ask for Forgiveness than Permission\". The idea is to assume that runtime errors don't occur, and instead use try/expects to catch errors. The great benefit is that we don't have to drown our code with <code>if</code> statements, which is symptomatic of the LBYL style, which stands for \"look before you leap\". This makes our implementations much more readable than, say, scikit-learn, which does a lot of input validation. The catch is that users have to be careful to use sane inputs. As always, there is no free lunch!</p>"},{"location":"faq/#what-about-reinforcement-learning","title":"What about reinforcement learning?","text":"<p>Reinforcement learning works in an online manner because of the nature of the task. Reinforcement learning can be therefore be seen as a subcase of online machine learning. However, we prefer not to support it because there are already many existing opensource libraries dedicated to it.</p>"},{"location":"faq/#what-are-the-differences-between-scikit-learns-online-learning-algorithm-which-have-a-partial_fit-method-and-their-equivalents-in-river","title":"What are the differences between scikit-learn's online learning algorithm which have a partial_fit method and their equivalents in River?","text":"<p>The algorithms from <code>sklearn</code> that support incremental learning are mostly meant for mini-batch learning. In a pure streaming context where the observations arrive one by one, then River is much faster than <code>sklearn</code>. This is mostly because <code>sklearn</code> incurs a lot of overhead by performing data checks. Also, sklearn assumes that you're always using the same number of features. This is not the case with River because it use dictionaries which allows you to drop and add features as you wish.</p>"},{"location":"faq/#how-do-i-save-and-load-models","title":"How do I save and load models?","text":"<pre><code>&gt;&gt;&gt; from river import ensemble\n&gt;&gt;&gt; import pickle\n\n&gt;&gt;&gt; model = ensemble.AdaptiveRandomForestClassifier()\n\n# save\n&gt;&gt;&gt; with open('model.pkl', 'wb') as f:\n...     pickle.dump(model, f)\n\n# load\n&gt;&gt;&gt; with open('model.pkl', 'rb') as f:\n...     model = pickle.load(f)\n</code></pre> <p>We also encourage you to try out dill and cloudpickle.</p>"},{"location":"faq/#what-about-neural-networks","title":"What about neural networks?","text":"<p>There are many great open-source libraries for building neural network models. We don't feel that we can bring anything of value to the existing Python ecosystem. However, we are open to implementing compatibility wrappers for popular libraries such as PyTorch and Keras.</p>"},{"location":"faq/#who-are-the-authors-of-this-library","title":"Who are the authors of this library?","text":"<p>We are research engineers, graduate students, PhDs and machine learning researchers. The members of the development team are mainly located in France, Brazil and New Zealand.</p>"},{"location":"introduction/basic-concepts/","title":"Basic concepts","text":"<p>Here are some concepts to give you a feel for what problems River addresses.</p>"},{"location":"introduction/basic-concepts/#data-streams","title":"Data streams","text":"<p>River is a library to build online machine learning models. Such models operate on data streams. But a data stream is a bit of a vague concept.</p> <p>In general, a data stream is a sequence of individual elements. In the case of machine learning, each element is a bunch of features. We call these samples, or observations. Each sample might follow a fixed structure and always contain the same features. But features can also appear and disappear over time. That depends on the use case.</p>"},{"location":"introduction/basic-concepts/#reactive-and-proactive-data-streams","title":"Reactive and proactive data streams","text":"<p>The origin of a data stream can vary, and usually it doesn't matter. You should be able to use River regardless of where your data comes from. It is however important to keep in mind the difference between reactive and proactive data streams.</p> <p>Reactive data streams are ones where the data comes to you. For instance, when a user visits your website, that's out of your control. You have no influence on the event. It just happens and you have to react to it.</p> <p>Proactive data streams are ones where you have control on the data stream. For example, you might be reading the data from a file. You decide at which speed you want to read the data, in what order, etc.</p> <p>If you consider data analysis as a whole, you realize that the general approach is to turn reactive streams into proactive datasets. Events are usually logged into a database and are processed offline. Be it for building KPIs or training models.</p> <p>The challenge for machine learning is to ensure models you train offline on proactive datasets will perform correctly in production on reactive data streams.</p>"},{"location":"introduction/basic-concepts/#online-processing","title":"Online processing","text":"<p>Online processing is the act of processing a data stream one element at a time. In the case of machine learning, that means training a model by teaching it one sample at a time. This is completely opposite to the traditional way of doing machine learning, which is to train a model on whole batches of data at a time.</p> <p>An online model is therefore a stateful, dynamic object. It keeps learning and doesn't have to revisit past data. It's a different way of doing things, and therefore has its own set of pros and cons.</p>"},{"location":"introduction/basic-concepts/#tasks","title":"Tasks","text":"<p>Machine learning encompasses many different tasks: classification, regression, anomaly detection, time series forecasting, etc. The ideology behind River is to be a generic machine learning approach which allows these tasks to be performed in a streaming manner. Indeed, many batch machine learning algorithms have online equivalents.</p> <p>Note that River also supports some more basic tasks. For instance, you might just want to calculate a running average of a data stream. These are usually smaller parts of a whole stream processing pipeline.</p>"},{"location":"introduction/basic-concepts/#dictionaries-everywhere","title":"Dictionaries everywhere","text":"<p>River is a Python library. It is composed of a bunch of classes which implement various online processing algorithms. Most of these classes are machine learning models which can process a single sample, be it for learning or for inference.</p> <p>We made the choice to use dictionaries as the basic building block. First of all, online processing is different to batch processing, in that vectorization doesn't bring any speed-up. Therefore numeric processing libraries such as NumPy and PyTorch actually bring too much overhead. Using native Python data structures is faster.</p> <p>Dictionaries are therefore a perfect fit. They're native to Python and have excellent support in the standard library. They allow the naming of each feature. They can hold any kind of data type. They allow transparent support of JSON payloads, allowing seamless integration with web apps.</p>"},{"location":"introduction/basic-concepts/#datasets","title":"Datasets","text":"<p>In production, you're almost always going to face data streams which you have to react to, such as users visiting your website. The advantage of online machine learning is that you can design models that make predictions as well as learn from this data stream as it flows.</p> <p>But of course, when you're developing a model, you don't usually have access to a real-time feed on which to evaluate your model. You usually have an offline dataset which you want to evaluate your model on. River provides some datasets which can be read in online manner, one sample at a time. It is however crucial to keep in mind that the goal is to reproduce a production scenario as closely as possible, in order to ensure your model will perform just as well in production.</p>"},{"location":"introduction/basic-concepts/#model-evaluation","title":"Model evaluation","text":"<p>Online model evaluation differs from its traditional batch counterpart. In the latter, you usually perform cross-validation, whereby your training dataset is split into a learning and an evaluation dataset. This is fine, but it doesn't exactly reflect the data generation process that occurs in production.</p> <p>Online model evaluation involves learning and inference in the same order as what would happen in production. Indeed, if you know the order in which your data arrives, then you can process it the exact same order. This allows you to replay a production scenario and evaluate your model with higher fidelity than cross-validation.</p> <p>This is what makes online machine learning powerful. By replaying datasets in the correct order, you ensure you are designing models which will perform as expected in production.</p>"},{"location":"introduction/basic-concepts/#concept-drift","title":"Concept drift","text":"<p>The main reason why an offline model might not perform as expected in production is because of concept drift. But this is true for all machine learning models, be they offline or online.</p> <p>The advantage of online models over offline models is that they can cope with drift. Indeed, because they can keep learning, they usually adapt to concept drift in a seamless manner. As opposed to batch models which have to be retrained from scratch.</p>"},{"location":"introduction/installation/","title":"Installation","text":"<p>River is meant to work with Python 3.8 and above. Installation can be done via <code>pip</code>:</p> <pre><code>pip install river\n</code></pre> <p>You can install the latest development version from GitHub, as so:</p> <pre><code>pip install git+https://github.com/online-ml/river --upgrade\npip install git+ssh://git@github.com/online-ml/river.git --upgrade  # using SSH\n</code></pre> <p>This method requires having Cython and Rust installed on your machine.</p> <p>Feel welcome to open an issue on GitHub if you are having any trouble.</p>"},{"location":"introduction/next-steps/","title":"Next steps","text":"<p>The Recipes \ud83c\udf71 section is made up of small tutorials. Each one explains how to perform mundane tasks, such as measuring the performance of a model, selecting hyperparameters, etc.</p> <p>The Examples \ud83c\udf36\ufe0f section contains more involved notebooks with less explanations. Each notebook addresses a particular machine learning problem.</p> <p>The API \ud83d\udcda section references all the modules, classes, and functions in River. It is automatically generated from the codebase's Python docstrings.</p> <p>Feel welcome to open a discussion if you have a question. Before that you can check out the FAQ \ud83d\ude4b, which has answers to recurring questions.</p> <p>The released versions are listed in the Releases \ud83c\udfd7 section. Changes that will be part of the next release are listed in the unreleased section of the documentation's development version, which you may find here.</p> <p>We recommend checking out Awesome Online Machine Learning if you want to go deeper. There you will find online machine learning related content: research papers, alternative and complementary software, blog posts, etc.</p>"},{"location":"introduction/related-projects/","title":"Related projects","text":"<p>Here is a list of projects which are more or less coupled with River:</p> <ul> <li>deep-river interfaces PyTorch models with River.</li> <li>light-river implements fast algorithms in rust. </li> <li>river-extra regroups experimental features which have yet to prove themselves to make it into the main River repository. Between us we call this \"the arena\".</li> <li>Beaver is an MLOps tool for covering the whole lifecycle of online machine learning models.</li> </ul>"},{"location":"introduction/why-use-river/","title":"Why use River?","text":""},{"location":"introduction/why-use-river/#processing-one-sample-at-a-time","title":"Processing one sample at a time","text":"<p>All the tools in the library can be updated with a single observation at a time. They can therefore be used to process streaming data. Depending on your use case, this might be more convenient than using a batch model.</p>"},{"location":"introduction/why-use-river/#adapting-to-drift","title":"Adapting to drift","text":"<p>In the streaming setting, data can evolve. Adaptive methods are specifically designed to be robust against concept drift in dynamic environments. Many of River's models can cope with concept drift.</p>"},{"location":"introduction/why-use-river/#general-purpose","title":"General purpose","text":"<p>River supports different machine learning tasks, including regression, classification, and unsupervised learning. It can also be used for ad hoc tasks, such as computing online metrics, as well as concept drift detection.</p>"},{"location":"introduction/why-use-river/#user-experience","title":"User experience","text":"<p>River is not the only library allowing you to do online machine learning. But it might just be the simplest one to use in the Python ecosystem. River plays nicely with Python dictionaries, therefore making it easy to use in the context of web applications where JSON payloads are aplenty.</p>"},{"location":"introduction/getting-started/binary-classification/","title":"Binary classification","text":"<p>Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome.</p> <p>A labeled classification sample is made up of a bunch of features and a class. The class is a boolean in the case of binary classification. We'll use the phishing dataset as an example.</p> <pre><code>from river import datasets\n\ndataset = datasets.Phishing()\ndataset\n</code></pre> <pre><code>Phishing websites.\n\nThis dataset contains features from web pages that are classified as phishing or not.\n\n    Name  Phishing                                                          \n    Task  Binary classification                                             \n Samples  1,250                                                             \nFeatures  9                                                                 \n  Sparse  False                                                             \n    Path  /Users/max/projects/online-ml/river/river/datasets/phishing.csv.gz\n</code></pre> <p>This dataset is a streaming dataset which can be looped over.</p> <pre><code>for x, y in dataset:\n    pass\n</code></pre> <p>Let's take a look at the first sample.</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre><code>{'empty_server_form_handler': 0.0,\n 'popup_window': 0.0,\n 'https': 0.0,\n 'request_from_other_domain': 0.0,\n 'anchor_from_other_domain': 0.0,\n 'is_popular': 0.5,\n 'long_url': 1.0,\n 'age_of_domain': 1,\n 'ip_in_url': 1}\n</code></pre> <pre><code>y\n</code></pre> <pre><code>True\n</code></pre> <p>A binary classifier's goal is to learn to predict a binary target <code>y</code> from some given features <code>x</code>. We'll try to do this with a logistic regression.</p> <pre><code>from river import linear_model\n\nmodel = linear_model.LogisticRegression()\nmodel.predict_proba_one(x)\n</code></pre> <pre><code>{False: 0.5, True: 0.5}\n</code></pre> <p>The model hasn't been trained on any data, and therefore outputs a default probability of 50% for each class.</p> <p>The model can be trained on the sample, which will update the model's state.</p> <pre><code>model.learn_one(x, y)\n</code></pre> <p>If we try to make a prediction on the same sample, we can see that the probabilities are different, because the model has learned something.</p> <pre><code>model.predict_proba_one(x)\n</code></pre> <pre><code>{False: 0.494687699901455, True: 0.505312300098545}\n</code></pre> <p>Note that there is also a <code>predict_one</code> if you're only interested in the most likely class rather than the probability distribution.</p> <pre><code>model.predict_one(x)\n</code></pre> <pre><code>True\n</code></pre> <p>Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation.</p> <pre><code>from river import metrics\n\nmodel = linear_model.LogisticRegression()\n\nmetric = metrics.ROCAUC()\n\nfor x, y in dataset:\n    y_pred = model.predict_proba_one(x)\n    model.learn_one(x, y)\n    metric.update(y, y_pred)\n\nmetric\n</code></pre> <pre><code>ROCAUC: 89.36%\n</code></pre> <p>This is a common way to evaluate an online model. In fact, there is a dedicated <code>evaluate.progressive_val_score</code> function that does this for you.</p> <pre><code>from river import evaluate\n\nmodel = linear_model.LogisticRegression()\nmetric = metrics.ROCAUC()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>ROCAUC: 89.36%\n</code></pre> <p>A common way to improve the performance of a logistic regression is to scale the data. This can be done by using a <code>preprocessing.StandardScaler</code>. In particular, we can define a pipeline to organise our model into a sequence of steps:</p> <pre><code>from river import compose\nfrom river import preprocessing\n\nmodel = compose.Pipeline(\n    preprocessing.StandardScaler(),\n    linear_model.LogisticRegression()\n)\n\nmodel\n</code></pre> <pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>LogisticRegression</pre><code>LogisticRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Log (     weight_pos=1.     weight_neg=1.   )   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code> <pre><code>metric = metrics.ROCAUC()\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>ROCAUC: 95.07%\n</code></pre>"},{"location":"introduction/getting-started/concept-drift-detection/","title":"Concept drift","text":"<p>In online machine learning, it is assumed that data can change over time. When building machine learning models, we assume data has a probability distribution, which is usually fixed, i.e., stationary. Changes in the data distribution give rise to the phenomenon called Concept drift. Such drifts can be either virtual or real. In virtual drifts, only the distribution of the features, \\(P(X)\\), changes, whereas the relationship between \\(X\\) (features) and the target, \\(y\\), remains unchanged. The joint probability of \\(P(X, y)\\) changes in real concept drifts. Consequently, non-supervised online machine learning problems might face only virtual concept drifts.</p> <p>Real concept drits can be further divided in abrupt (happen instantly at a given point) or gradual (one \"concept\" changes to another gradually). There are other possible divisions, but they can be fit into abrupt or gradual drifts.</p>"},{"location":"introduction/getting-started/concept-drift-detection/#examples-of-concept-drift","title":"Examples of concept drift","text":"<p>Concept drifts might happen in the electricity demand across the year, in the stock market, in buying preferences, and in the likelihood of a new movie's success, among others.</p> <p>Let us consider the movie example: two movies made at different epochs can have similar features such as famous actors/directors, storyline, production budget, marketing campaigns, etc., yet it is not certain that both will be similarly successful. What the target audience considers is worth watching (and their money worth spending) is constantly changing, and production companies must adapt accordingly to avoid \"box office flops\".</p> <p>Prior to the pandemic, the usage of hand sanitizers and facial masks was not widespread. When the cases of COVID-19 started increasing, there was a lack of such products for the end consumer. Imagine a batch-learning model deciding how much of each product a supermarket should stock during those times. What a mess!</p>"},{"location":"introduction/getting-started/concept-drift-detection/#impact-of-drift-on-learning","title":"Impact of drift on learning","text":"<p>Concept drift can have a significant impact on predictive performance if not handled properly. Most batch learning models will fail in the presence of concept drift as they are essentially trained on different data. On the other hand, stream learning methods continuously update themselves and adapt to new concepts. Furthermore, drift-aware methods use change detection methods (a.k.a. drift detectors) to trigger mitigation mechanisms if a change in performance is detected.</p>"},{"location":"introduction/getting-started/concept-drift-detection/#detecting-concept-drift","title":"Detecting concept drift","text":"<p>Multiple drift detection methods have been proposed. The goal of a drift detector is to signal an alarm in the presence of drift. A good drift detector maximizes the number of true positives while keeping the number of false positives to a minimum. It must also be resource-wise efficient to work in the context of infinite data streams.</p> <p>For this example, we will generate a synthetic data stream by concatenating 3 distributions of 1000 samples each:</p> <ul> <li>\\(dist_a\\): \\(\\mu=0.8\\), \\(\\sigma=0.05\\)</li> <li>\\(dist_b\\): \\(\\mu=0.4\\), \\(\\sigma=0.02\\)</li> <li>\\(dist_c\\): \\(\\mu=0.6\\), \\(\\sigma=0.1\\).</li> </ul> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\n\n# Generate data for 3 distributions\nrandom_state = np.random.RandomState(seed=42)\ndist_a = random_state.normal(0.8, 0.05, 1000)\ndist_b = random_state.normal(0.4, 0.02, 1000)\ndist_c = random_state.normal(0.6, 0.1, 1000)\n\n# Concatenate data to simulate a data stream with 2 drifts\nstream = np.concatenate((dist_a, dist_b, dist_c))\n\n# Auxiliary function to plot the data\ndef plot_data(dist_a, dist_b, dist_c, drifts=None):\n    fig = plt.figure(figsize=(7,3), tight_layout=True)\n    gs = gridspec.GridSpec(1, 2, width_ratios=[3, 1])\n    ax1, ax2 = plt.subplot(gs[0]), plt.subplot(gs[1])\n    ax1.grid()\n    ax1.plot(stream, label='Stream')\n    ax2.grid(axis='y')\n    ax2.hist(dist_a, label=r'$dist_a$')\n    ax2.hist(dist_b, label=r'$dist_b$')\n    ax2.hist(dist_c, label=r'$dist_c$')\n    if drifts is not None:\n        for drift_detected in drifts:\n            ax1.axvline(drift_detected, color='red')\n    plt.show()\n\nplot_data(dist_a, dist_b, dist_c)\n</code></pre> <p></p>"},{"location":"introduction/getting-started/concept-drift-detection/#drift-detection-test","title":"Drift detection test","text":"<p>We will use the ADaptive WINdowing (<code>ADWIN</code>) drift detection method. Remember that the goal is to indicate that drift has occurred after samples 1000 and 2000 in the synthetic data stream.</p> <pre><code>from river import drift\n\ndrift_detector = drift.ADWIN()\ndrifts = []\n\nfor i, val in enumerate(stream):\n    drift_detector.update(val)   # Data is processed one sample at a time\n    if drift_detector.drift_detected:\n        # The drift detector indicates after each sample if there is a drift in the data\n        print(f'Change detected at index {i}')\n        drifts.append(i)\n\nplot_data(dist_a, dist_b, dist_c, drifts)\n</code></pre> <pre><code>Change detected at index 1055\nChange detected at index 2079\n</code></pre> <p></p> <p>We see that <code>ADWIN</code> successfully indicates the presence of drift (red vertical lines) close to the beginning of a new data distribution.</p> <p>We conclude this example with some remarks regarding concept drift detectors and their usage:</p> <ul> <li>In practice, drift detectors provide stream learning methods with robustness against concept drift. Drift detectors monitor the model usually through a performance metric.</li> <li>Drift detectors work on univariate data. This is why they are used to monitor a model's performance and not the data itself. Remember that concept drift is defined as a change in the relationship between data and the target to learn (in supervised learning).</li> <li>Drift detectors define their expectations regarding input data. It is important to know these expectations to feed a given drift detector with the correct data.</li> </ul>"},{"location":"introduction/getting-started/multiclass-classification/","title":"Multi-class classification","text":"<p>Classification is about predicting an outcome from a fixed list of classes. The prediction is a probability distribution that assigns a probability to each possible outcome.</p> <p>A labeled classification sample is made up of a bunch of features and a class. The class is a usually a string or a number in the case of multiclass classification. We'll use the image segments dataset as an example.</p> <pre><code>from river import datasets\n\ndataset = datasets.ImageSegments()\ndataset\n</code></pre> <pre><code>Image segments classification.\n\nThis dataset contains features that describe image segments into 7 classes: brickface, sky,\nfoliage, cement, window, path, and grass.\n\n    Name  ImageSegments                                                     \n    Task  Multi-class classification                                        \n Samples  2,310                                                             \nFeatures  18                                                                \n Classes  7                                                                 \n  Sparse  False                                                             \n    Path  /Users/max/projects/online-ml/river/river/datasets/segment.csv.zip\n</code></pre> <p>This dataset is a streaming dataset which can be looped over.</p> <pre><code>for x, y in dataset:\n    pass\n</code></pre> <p>Let's take a look at the first sample.</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre><code>{'region-centroid-col': 218,\n 'region-centroid-row': 178,\n 'short-line-density-5': 0.11111111,\n 'short-line-density-2': 0.0,\n 'vedge-mean': 0.8333326999999999,\n 'vegde-sd': 0.54772234,\n 'hedge-mean': 1.1111094,\n 'hedge-sd': 0.5443307,\n 'intensity-mean': 59.629630000000006,\n 'rawred-mean': 52.44444300000001,\n 'rawblue-mean': 75.22222,\n 'rawgreen-mean': 51.22222,\n 'exred-mean': -21.555555,\n 'exblue-mean': 46.77778,\n 'exgreen-mean': -25.222220999999998,\n 'value-mean': 75.22222,\n 'saturation-mean': 0.31899637,\n 'hue-mean': -2.0405545}\n</code></pre> <pre><code>y\n</code></pre> <pre><code>'path'\n</code></pre> <p>A multiclass classifier's goal is to learn how to predict a class <code>y</code> from a bunch of features <code>x</code>. We'll attempt to do this with a decision tree.</p> <pre><code>from river import tree\n\nmodel = tree.HoeffdingTreeClassifier()\nmodel.predict_proba_one(x)\n</code></pre> <pre><code>{}\n</code></pre> <p>The reason why the output dictionary is empty is because the model hasn't seen any data yet. It isn't aware of the dataset whatsoever. If this were a binary classifier, then it would output a probability of 50% for <code>True</code> and <code>False</code> because the classes are implicit. But in this case we're doing multiclass classification.</p> <p>Likewise, the <code>predict_one</code> method initially returns <code>None</code> because the model hasn't seen any labeled data yet.</p> <pre><code>print(model.predict_one(x))\n</code></pre> <pre><code>None\n</code></pre> <p>If we update the model and try again, then we see that a probability of 100% is assigned to the <code>'path'</code> class because that's the only one the model is aware of.</p> <pre><code>model.learn_one(x, y)\nmodel.predict_proba_one(x)\n</code></pre> <pre><code>{'path': 1.0}\n</code></pre> <p>This is a strength of online classifiers: they're able to deal with new classes appearing in the data stream.</p> <p>Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation.</p> <pre><code>from river import metrics\n\nmodel = tree.HoeffdingTreeClassifier()\n\nmetric = metrics.ClassificationReport()\n\nfor x, y in dataset:\n    y_pred = model.predict_one(x)\n    model.learn_one(x, y)\n    if y_pred is not None:\n        metric.update(y, y_pred)\n\nmetric\n</code></pre> <pre><code>            Precision   Recall   F1       Support\n\nbrickface      77.13%   84.85%   80.81%       330  \n   cement      78.92%   83.94%   81.35%       330  \n  foliage      65.69%   20.30%   31.02%       330  \n    grass     100.00%   96.97%   98.46%       330  \n     path      90.63%   91.19%   90.91%       329  \n      sky      99.08%   98.18%   98.63%       330  \n   window      43.50%   67.88%   53.02%       330\n\n    Macro      79.28%   77.62%   76.31%            \n    Micro      77.61%   77.61%   77.61%            \n Weighted      79.27%   77.61%   76.31%\n\n                  77.61% accuracy\n</code></pre> <p>This is a common way to evaluate an online model. In fact, there is a dedicated <code>evaluate.progressive_val_score</code> function that does this for you.</p> <pre><code>from river import evaluate\n\nmodel = tree.HoeffdingTreeClassifier()\nmetric = metrics.ClassificationReport()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>            Precision   Recall   F1       Support\n\nbrickface      77.13%   84.85%   80.81%       330  \n   cement      78.92%   83.94%   81.35%       330  \n  foliage      65.69%   20.30%   31.02%       330  \n    grass     100.00%   96.97%   98.46%       330  \n     path      90.63%   91.19%   90.91%       329  \n      sky      99.08%   98.18%   98.63%       330  \n   window      43.50%   67.88%   53.02%       330\n\n    Macro      79.28%   77.62%   76.31%            \n    Micro      77.61%   77.61%   77.61%            \n Weighted      79.27%   77.61%   76.31%\n\n                  77.61% accuracy\n</code></pre>"},{"location":"introduction/getting-started/regression/","title":"Regression","text":"<p>Regression is about predicting a numeric output for a given sample. A labeled regression sample is made up of a bunch of features and a number. The number is usually continuous, but it may also be discrete. We'll use the Trump approval rating dataset as an example.</p> <pre><code>from river import datasets\n\ndataset = datasets.TrumpApproval()\ndataset\n</code></pre> <pre><code>Donald Trump approval ratings.\n\nThis dataset was obtained by reshaping the data used by FiveThirtyEight for analyzing Donald\nTrump's approval ratings. It contains 5 features, which are approval ratings collected by\n5 polling agencies. The target is the approval rating from FiveThirtyEight's model. The goal of\nthis task is to see if we can reproduce FiveThirtyEight's model.\n\n    Name  TrumpApproval                                                           \n    Task  Regression                                                              \n Samples  1,001                                                                   \nFeatures  6                                                                       \n  Sparse  False                                                                   \n    Path  /Users/max/projects/online-ml/river/river/datasets/trump_approval.csv.gz\n</code></pre> <p>This dataset is a streaming dataset which can be looped over.</p> <pre><code>for x, y in dataset:\n    pass\n</code></pre> <p>Let's take a look at the first sample.</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre><code>{'ordinal_date': 736389,\n 'gallup': 43.843213,\n 'ipsos': 46.19925042857143,\n 'morning_consult': 48.318749,\n 'rasmussen': 44.104692,\n 'you_gov': 43.636914000000004}\n</code></pre> <p>A regression model's goal is to learn to predict a numeric target <code>y</code> from a bunch of features <code>x</code>. We'll attempt to do this with a nearest neighbors model.</p> <pre><code>from river import neighbors\n\nmodel = neighbors.KNNRegressor()\nmodel.predict_one(x)\n</code></pre> <pre><code>0.0\n</code></pre> <p>The model hasn't been trained on any data, and therefore outputs a default value of 0.</p> <p>The model can be trained on the sample, which will update the model's state.</p> <pre><code>model.learn_one(x, y)\n</code></pre> <p>If we try to make a prediction on the same sample, we can see that the output is different, because the model has learned something.</p> <pre><code>model.predict_one(x)\n</code></pre> <pre><code>43.75505\n</code></pre> <p>Typically, an online model makes a prediction, and then learns once the ground truth reveals itself. The prediction and the ground truth can be compared to measure the model's correctness. If you have a dataset available, you can loop over it, make a prediction, update the model, and compare the model's output with the ground truth. This is called progressive validation.</p> <pre><code>from river import metrics\n\nmodel = neighbors.KNNRegressor()\n\nmetric = metrics.MAE()\n\nfor x, y in dataset:\n    y_pred = model.predict_one(x)\n    model.learn_one(x, y)\n    metric.update(y, y_pred)\n\nmetric\n</code></pre> <pre><code>MAE: 0.310353\n</code></pre> <p>This is a common way to evaluate an online model. In fact, there is a dedicated <code>evaluate.progressive_val_score</code> function that does this for you.</p> <pre><code>from river import evaluate\n\nmodel = neighbors.KNNRegressor()\nmetric = metrics.MAE()\n\nevaluate.progressive_val_score(dataset, model, metric)\n</code></pre> <pre><code>MAE: 0.310353\n</code></pre>"},{"location":"license/license/","title":"License","text":"<p>River is free and open-source software licensed under the 3-clause BSD license.</p>"},{"location":"recipes/active-learning/","title":"Active learning","text":"<p>Active learning is a training regime, where the goal is to fit a model on the most discriminative samples. It is usually applied in situations where a limited amount of labeled data is available. In such a case, a human might be asked to annotate a sample. Doing this is expensive, so it's important to ask for labels for the most samples that will have the most impact.</p> <p>Online active learning is active learning done in a streaming fashion. Every time a prediction is made, an active learning strategy decides whether a label should be asked for or not. In case the strategy decides a yes, then the system could ask for a human to intervene. This is well summarized in the following schema from Online Active Learning Methods for Fast Label-Efficient Spam Filtering.</p>"},{"location":"recipes/active-learning/#online-active-learning","title":"Online active learning","text":"<p>River's online active learning strategies are located in the <code>active</code> module. The latter contains wrapper models. These wrappers enrich the <code>predict_one</code> and <code>predict_proba_one</code> methods to include a boolean in the output.</p> <p>The returned boolean indicates whether or not a label should be asked for. In a production system, we could feed this to a web interface, and get the human to annotate the sample. Offline, we can simply use the label in the dataset.</p> <p>We'll implement this basic flow. We'll apply a TFIDF followed by logistic regression to a datasets of spam/ham received by SMS.</p> <pre><code>from river import active\nfrom river import datasets\nfrom river import feature_extraction\nfrom river import linear_model\nfrom river import metrics\n\ndataset = datasets.SMSSpam()\nmetric = metrics.Accuracy()\nmodel = (\n    feature_extraction.TFIDF(on='body') |\n    linear_model.LogisticRegression()\n)\nmodel = active.EntropySampler(model, seed=42)\n\nn_samples_used = 0\nfor x, y in dataset:\n    y_pred, ask = model.predict_one(x)\n    metric.update(y, y_pred)\n    if ask:\n        n_samples_used += 1\n        model.learn_one(x, y)\n\nmetric\n</code></pre> <pre><code>Accuracy: 86.60%\n</code></pre> <p>The performance is reasonable, even though all the dataset wasn't used for training. We can check how many samples were actually used.</p> <pre><code>print(f\"{n_samples_used} / {dataset.n_samples} = {n_samples_used / dataset.n_samples:.2%}\")\n</code></pre> <pre><code>1921 / 5574 = 34.46%\n</code></pre> <p>Note that the above logic can be succinctly reproduced with the <code>progressive_val_score</code> function from the <code>evaluate</code> module. It recognises when an active learning model is provided, and will automatically display the number of samples used.</p> <pre><code>from river import evaluate\n\nevaluate.progressive_val_score(\n    dataset=dataset,\n    model=model.clone(),\n    metric=metric.clone(),\n    print_every=1000\n)\n</code></pre> <pre><code>[1,000] Accuracy: 84.80% \u2013 661 samples used\n[2,000] Accuracy: 86.00% \u2013 1,057 samples used\n[3,000] Accuracy: 86.37% \u2013 1,339 samples used\n[4,000] Accuracy: 86.65% \u2013 1,568 samples used\n[5,000] Accuracy: 86.54% \u2013 1,790 samples used\n[5,574] Accuracy: 86.60% \u2013 1,921 samples used\n\n\n\n\n\nAccuracy: 86.60%\n</code></pre>"},{"location":"recipes/active-learning/#reduce-training-time","title":"Reduce training time","text":"<p>Active learning is primarily used to label data in an efficient manner. However, in an online setting, active learning can also be used simply to speed up training. The point is that you can achieve a very good performance without training on an entire dataset. Active learning is a powerful way to decide which samples to train on.</p>"},{"location":"recipes/active-learning/#_1","title":"Active learning","text":""},{"location":"recipes/active-learning/#production-considerations","title":"Production considerations","text":"<p>In production, you might want to deploy a system where humans may annotate samples queried by an active learning strategy. You have several options at your disposal, all of which go beyond the scope of River.</p> <p>The general idea is to have some kind of queue in which queried samples are fed into. Then you would have a user interface which displays the elements in the queue one-by-one. Each time a sample is labeled, the label would be used to update the model. You might have one or more threads/processes doing inference. You'll want to update the model in each one each time the model learns.</p>"},{"location":"recipes/bandits-101/","title":"Multi-armed bandits","text":"<p>River has a <code>bandit</code> module. It contains several multi-armed bandit policies, bandit environments, and utilities to benchmark policies on bandit problems.</p> <p>Bandit environments in River implement the Gym interface. You can thus load them with <code>gym.make</code>. Note that Gym is intended for reinforcement learning algorithms, while bandit policies are the simplest form of reinforcement learning. Bandit policies learn by receiving a reward after each step, while reinforcement learning algorithms have to learn from feedback that may arrive at the end of a (long) sequence of steps.</p> <pre><code>import gymnasium as gym\n\nfor k in gym.envs.registry:\n    if k.startswith('river_bandits'):\n        print(k)\n</code></pre> <p>River's bandit module offers the <code>bandit.evaluate</code> function to benchmark several policies on a given environment. It takes as input a list of bandit policies, a bandit environment (the problem to solve), and a reward object.</p> <pre><code>import gymnasium as gym\nfrom river import bandit\nimport pandas as pd\nfrom tqdm import tqdm\nfrom river import stats\n\npolicies=[\n    bandit.EpsilonGreedy(epsilon=0.1),\n    bandit.EpsilonGreedy(epsilon=0.01),\n    bandit.EpsilonGreedy(epsilon=0),\n]\n\nenv = gym.make(\n    'river_bandits/KArmedTestbed-v0',\n    max_episode_steps=1000\n)\n\ntrace = bandit.evaluate(\n    policies=policies,\n    env=env,\n    reward_stat=stats.Mean(),\n    n_episodes=(n_episodes := 2000),\n)\n</code></pre> <p>The <code>bandit.evaluate</code> function returns a generator containing the results at each step of the benchmark. This can be wrapped with a <code>pandas.DataFrame</code> to gather all the results.</p> <pre><code>trace_df = pd.DataFrame(tqdm(\n    trace, position=0, total=(\n        n_episodes *\n        len(policies) *\n        env._max_episode_steps\n    )\n))\ntrace_df.sample(5, random_state=42)\n</code></pre> <pre><code>  0%|                                                                                                                                                                   | 0/6000000 [00:00&lt;?, ?it/s]/Users/max/Library/Caches/pypoetry/virtualenvs/river--dXL33ck-py3.11/lib/python3.11/site-packages/gym/utils/passive_env_checker.py:233: DeprecationWarning: `np.bool8` is a deprecated alias for `np.bool_`.  (Deprecated NumPy 1.24)\n  if not isinstance(terminated, (bool, np.bool8)):\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000000/6000000 [00:25&lt;00:00, 236810.21it/s]\n</code></pre> episode step policy_idx arm reward reward_stat 1324896 441 632 0 2 0.226086 0.499848 3566176 1188 725 1 6 2.363962 0.935468 1109043 369 681 0 5 2.780757 1.467402 4286042 1428 680 2 1 2.039255 1.603312 5395174 1798 391 1 8 1.625523 1.232745 <p>It is then straightforward to plot the average reward each policy obtains at each step, by averaging over episodes.</p> <pre><code>policy_names = {\n    0: '\u03b5 = 0.1',\n    1: '\u03b5 = 0.01',\n    2: '\u03b5 = 0 (greedy)'\n}\n\n(\n    trace_df\n    .assign(policy=trace_df.policy_idx.map(policy_names))\n    .groupby(['step', 'policy'])\n    ['reward'].mean()\n    .unstack()\n    .plot()\n)\n</code></pre> <pre><code>&lt;Axes: xlabel='step'&gt;\n</code></pre> <p></p>"},{"location":"recipes/bandits-101/#controlling-the-evaluation-loop","title":"Controlling the evaluation loop","text":"<p>The <code>bandit.evaluate</code> function is useful for benchmarking. But in practice, you'll want to have control over your bandit policy. Indeed you'll want the freedom to pull arms (with the <code>pull</code> method) and update the policy (with the <code>update</code> method) at your discretion.</p> <p>As an example, the following is a possible reimplementation of the <code>bandit.evaluate</code> function. Here we'll be measuring the rate at which each policy selects the optimal arm.</p> <p>Note how the <code>pull</code> and <code>update</code> methods are used.</p> <pre><code>import copy\n\npolicies=[\n    bandit.EpsilonGreedy(epsilon=0.1),\n    bandit.EpsilonGreedy(epsilon=0.01),\n    bandit.EpsilonGreedy(epsilon=0),\n]\n\nenv = gym.make(\n    'river_bandits/KArmedTestbed-v0',\n    max_episode_steps=1000\n)\nn_episodes = 2000\n\ntrace = []\n\nwith tqdm(total=len(policies) * n_episodes * env._max_episode_steps, position=0) as progress:\n    for policy in policies:\n        for episode in range(n_episodes):\n            episode_policy = policy.clone()\n            episode_env = copy.deepcopy(env)\n            episode_env.reset()\n            step = 0\n            while True:\n                action = episode_policy.pull(range(episode_env.action_space.n))\n                observation, reward, terminated, truncated, info = episode_env.step(action)\n                best_action = observation\n                episode_policy.update(action, reward)\n\n                trace.append({\n                    \"episode\": episode,\n                    \"step\": step,\n                    \"policy\": f\"\u03b5 = {policy.epsilon}\",\n                    \"is_action_optimal\": action == best_action\n                })\n                step += 1\n                progress.update()\n\n                if terminated or truncated:\n                    break\n\ntrace_df = pd.DataFrame(trace)\n</code></pre> <pre><code>  0%|                                                                                                                                                                   | 0/6000000 [00:00&lt;?, ?it/s]/Users/max/Library/Caches/pypoetry/virtualenvs/river--dXL33ck-py3.11/lib/python3.11/site-packages/gym/utils/passive_env_checker.py:233: DeprecationWarning: `np.bool8` is a deprecated alias for `np.bool_`.  (Deprecated NumPy 1.24)\n  if not isinstance(terminated, (bool, np.bool8)):\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6000000/6000000 [00:26&lt;00:00, 228987.26it/s]\n</code></pre> <pre><code>colors = {\n    '\u03b5 = 0.1': 'tab:blue',\n    '\u03b5 = 0.01': 'tab:red',\n    '\u03b5 = 0': 'tab:green'\n}\n\n(\n    trace_df\n    .groupby(['step', 'policy'])\n    ['is_action_optimal'].mean()\n    .unstack()\n    .plot()\n)\n</code></pre> <pre><code>&lt;Axes: xlabel='step'&gt;\n</code></pre> <p></p>"},{"location":"recipes/bandits-101/#handling-drift","title":"Handling drift","text":"<p>The environment used above is a toy situation used for introducing bandits. It is stationary, meaning that the expected reward of each arm does not change over time.</p> <p>In practice, arms are dynamic, and their performance can vary over time. A simple example of this is the Candy Cane Contest that was hosted on Kaggle in 2020. The expected reward of each arm diminishes each time it is pulled.</p> <p>The way bandit policies in River deal with drift depends on the method. For the <code>bandit.EpsilonGreedy</code> policy, it makes sense to use a rolling average as the reward object. What this means is that the empirical reward the policy calculates for each arm is a rolling average, rather than a global one.</p> <pre><code>from river import proba, utils\n\npolicies=[\n    bandit.EpsilonGreedy(\n        epsilon=0.1,\n        seed=42\n    ),\n    bandit.EpsilonGreedy(\n        epsilon=0.3,\n        reward_obj=utils.Rolling(stats.Mean(), window_size=50),\n        seed=42\n    ),\n    bandit.ThompsonSampling(\n        reward_obj=proba.Beta(),\n        seed=42\n    )\n]\n\nenv = gym.make('river_bandits/CandyCaneContest-v0')\n\ntrace = bandit.evaluate(\n    policies=policies,\n    env=env,\n    n_episodes=(n_episodes := 30),\n    seed=42\n)\n\ntrace_df = pd.DataFrame(tqdm(\n    trace, position=0, total=(\n        n_episodes *\n        len(policies) *\n        env._max_episode_steps\n    )\n))\n</code></pre> <pre><code>  0%|                                                                                                                                                                    | 0/180000 [00:00&lt;?, ?it/s]/Users/max/Library/Caches/pypoetry/virtualenvs/river--dXL33ck-py3.11/lib/python3.11/site-packages/gym/utils/passive_env_checker.py:233: DeprecationWarning: `np.bool8` is a deprecated alias for `np.bool_`.  (Deprecated NumPy 1.24)\n  if not isinstance(terminated, (bool, np.bool8)):\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 180000/180000 [00:11&lt;00:00, 15839.35it/s]\n</code></pre> <p>We can compare the performance of each policy by checking the average reward at the end of each episode.</p> <pre><code>(\n    trace_df\n    .groupby(['policy_idx', 'episode'])\n    .last()\n    .groupby('policy_idx')\n    .reward_stat.mean()\n)\n</code></pre> <pre><code>policy_idx\n0    736.1\n1    817.0\n2    854.0\nName: reward_stat, dtype: float64\n</code></pre> <p>We see that using a rolling average gives a boost to the epsilon greedy strategy. However, we see that the <code>bandit.ThompsonSampling</code> policy performs even better, even though no particular care was given to drift. A natural next step would thus be to see how it could be improved to handle drift. For instance, its <code>dist</code> parameter could be wrapped with a <code>utils.Rolling</code>:</p> <pre><code>policy = bandit.ThompsonSampling(\n    reward_obj=utils.Rolling(proba.Beta(), window_size=50),\n    seed=42\n)\n</code></pre> <p>Bandits can be used for several tasks. They can be used for content personalization, as well as online model selection (see <code>model_selection.BanditRegressor</code>). The policies in River are therefore designed to be flexible, so that they can be used in conjunction with other River modules. For instance, the <code>reward_obj</code> in <code>bandit.EpsilonGreedy</code> can be a metric, a probability distribution, or a statistic. This works because objects in River adher to a coherent get/update interface.</p>"},{"location":"recipes/cloning-and-mutating/","title":"Cloning and mutating","text":"<p>Sometimes you might want to reset a model, or edit (what we call mutate) its attributes. This can be useful in an online environment. Indeed, if you detect a drift, then you might want to mutate a model's attributes. Or if you see that a model's performance is plummeting, then you might to reset it to its \"factory settings\".</p> <p>Anyway, this is not to convince you, but rather to say that a model's attributes don't have be to set in stone throughout its lifetime. In particular, if you're developing your own model, then you might want to have good tools to do this. This is what this recipe is about.</p>"},{"location":"recipes/cloning-and-mutating/#cloning","title":"Cloning","text":"<p>The first thing you can do is clone a model. This creates a deep copy of the model. The resulting model is entirely independent of the original model. The clone is fresh, in the sense that it is as if it hasn't seen any data.</p> <p>For instance, say you have a linear regression model which you have trained on some data.</p> <pre><code>from river import datasets, linear_model, optim, preprocessing\n\nmodel = (\n    preprocessing.StandardScaler() |\n    linear_model.LinearRegression(\n        optimizer=optim.SGD(3e-2)\n    )\n)\n\nfor x, y in datasets.TrumpApproval():\n    model.predict_one(x)\n    model.learn_one(x, y)\n\nmodel[-1].weights\n</code></pre> <pre><code>{'ordinal_date': 20.59955380229643,\n 'gallup': 0.39114944304212645,\n 'ipsos': 0.4101918314868111,\n 'morning_consult': 0.12042970179504908,\n 'rasmussen': 0.18951231512561392,\n 'you_gov': 0.04991712783831687}\n</code></pre> <p>For whatever reason, we may want to clone this model. This can be done with the <code>clone</code> method.</p> <pre><code>clone = model.clone()\nclone[-1].weights\n</code></pre> <pre><code>{}\n</code></pre> <p>As we can see, there are no weights because the clone is fresh copy that has not seen any data. However, the learning rate we specified is preserved.</p> <pre><code>clone[-1].optimizer.learning_rate\n</code></pre> <pre><code>0.03\n</code></pre> <p>You may also specify parameters you want changed. For instance, let's say we want to clone the model, but we want to change the optimizer:</p> <pre><code>clone = model.clone({\"LinearRegression\": {\"optimizer\": optim.Adam()}})\nclone[-1].optimizer\n</code></pre> <pre><code>Adam({'lr': Constant({'learning_rate': 0.1}), 'n_iterations': 0, 'beta_1': 0.9, 'beta_2': 0.999, 'eps': 1e-08, 'm': None, 'v': None})\n</code></pre> <p>The first key indicates that we want to specify a different parameter for the <code>LinearRegression</code> part of the pipeline. Then the second key accesses the linear regression's <code>optimizer</code> parameter.</p> <p>Finally, note that the <code>clone</code> method isn't reserved to models. Indeed, every object in River has it. That's because they all inherit from the <code>Base</code> class in the <code>base</code> module.</p>"},{"location":"recipes/cloning-and-mutating/#mutating-attributes","title":"Mutating attributes","text":"<p>Cloning a model can be useful, but the fact that it essentially resets the model may not be desired. Instead, you might want to change a attribute while preserving the model's state. For example, let's change the <code>l2</code> attribute, and the optimizer's <code>lr</code> attribute.</p> <pre><code>model.mutate({\n    \"LinearRegression\": {\n        \"l2\": 0.1,\n        \"optimizer\": {\n            \"lr\": optim.schedulers.Constant(25e-3)\n        }\n    }\n})\n\nprint(repr(model))\n</code></pre> <pre><code>Pipeline (\n  StandardScaler (\n    with_std=True\n  ),\n  LinearRegression (\n    optimizer=SGD (\n      lr=Constant (\n        learning_rate=0.025\n      )\n    )\n    loss=Squared ()\n    l2=0.1\n    l1=0.\n    intercept_init=0.\n    intercept_lr=Constant (\n      learning_rate=0.01\n    )\n    clip_gradient=1e+12\n    initializer=Zeros ()\n  )\n)\n</code></pre> <p>We can see the attributes we specified have changed. However, the model's state is preserved:</p> <pre><code>model[-1].weights\n</code></pre> <pre><code>{'ordinal_date': 20.59955380229643,\n 'gallup': 0.39114944304212645,\n 'ipsos': 0.4101918314868111,\n 'morning_consult': 0.12042970179504908,\n 'rasmussen': 0.18951231512561392,\n 'you_gov': 0.04991712783831687}\n</code></pre> <p>In other words, the <code>mutate</code> method does not create a deep copy of the model. It just sets attributes. At this point you may ask:</p> <p>Why can't I just change the attribute directly, without calling <code>mutate</code>?</p> <p>The answer is that you're free to do proceed as such, but it's not the way we recommend. The <code>mutate</code> method is safer, in that it prevents you from mutating attributes you shouldn't be touching. We call these immutable attributes. For instance, there's no reason you should be modifying the weights.</p> <pre><code>try:\n    model.mutate({\n        \"LinearRegression\": {\n            \"weights\": \"this makes no sense\"\n        }\n    })\nexcept ValueError as e:\n    print(e)\n</code></pre> <pre><code>'weights' is not a mutable attribute of LinearRegression\n</code></pre> <p>All attributes are immutable by default. Under the hood, each model can specify a set of mutable attributes via the <code>_mutable_attributes</code> property. In theory this can be overridden. But the general idea is that we will progressively add more and more mutable attributes with time.</p> <p>And that concludes this recipe. Arguably, this recipe caters to advanced users, and in particular users who are developing their own models. And yet, one could also argue that modifying parameters of a model on-the-fly is a great tool to have at your disposal when you're doing online machine learning.</p>"},{"location":"recipes/feature-extraction/","title":"Feature extraction","text":"<p>To do.</p>"},{"location":"recipes/hyperparameter-tuning/","title":"Hyperparameter tuning","text":"<p>To do.</p>"},{"location":"recipes/mini-batching/","title":"Mini-batching","text":"<p>In its purest form, online machine learning encompasses models which learn with one sample at a time. This is the design which is used in River.</p> <p>The main downside of single-instance processing is that it doesn't scale to big data, at least not in the sense of traditional batch learning. Indeed, processing one sample at a time means that we are unable to fully take advantage of vectorisation and other computational tools that are taken for granted in batch learning. On top of this, processing a large dataset in River essentially involves a Python <code>for</code> loop, which might be too slow for some usecases. However, this doesn't mean that River is slow. In fact, for processing a single instance, River is actually a couple of orders of magnitude faster than libraries such as scikit-learn, PyTorch, and Tensorflow. The reason why is because River is designed from the ground up to process a single instance, whereas the majority of other libraries choose to care about batches of data. Both approaches offer different compromises, and the best choice depends on your usecase.</p> <p>In order to propose the best of both worlds, River offers some limited support for mini-batch learning. Some of River's estimators implement <code>*_many</code> methods on top of their <code>*_one</code> counterparts. For instance, <code>preprocessing.StandardScaler</code> has a <code>learn_many</code> method as well as a <code>transform_many</code> method, in addition to <code>learn_one</code> and <code>transform_one</code>. Each mini-batch method takes as input a <code>pandas.DataFrame</code>. Supervised estimators also take as input a <code>pandas.Series</code> of target values. We choose to use <code>pandas.DataFrames</code> over <code>numpy.ndarrays</code> because of the simple fact that the former allows us to name each feature. This in turn allows us to offer a uniform interface for both single instance and mini-batch learning.</p> <p>As an example, we will build a simple pipeline that scales the data and trains a logistic regression. Indeed, the <code>compose.Pipeline</code> class can be applied to mini-batches, as long as each step is able to do so.</p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import preprocessing\n\nmodel = compose.Pipeline(\n    preprocessing.StandardScaler(),\n    linear_model.LogisticRegression()\n)\n</code></pre> <p>For this example, we will use <code>datasets.Higgs</code>.</p> <pre><code>from river import datasets\n\ndataset = datasets.Higgs()\nif not dataset.is_downloaded:\n    dataset.download()\ndataset\n</code></pre> <pre><code>Higgs dataset.\n\nThe data has been produced using Monte Carlo simulations. The first 21 features (columns 2-22)\nare kinematic properties measured by the particle detectors in the accelerator. The last seven\nfeatures are functions of the first 21 features; these are high-level features derived by\nphysicists to help discriminate between the two classes.\n\n      Name  Higgs                                                                       \n      Task  Binary classification                                                       \n   Samples  11,000,000                                                                  \n  Features  28                                                                          \n    Sparse  False                                                                       \n      Path  /Users/max/river_data/Higgs/HIGGS.csv.gz                                    \n       URL  https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz\n      Size  2.62 GB                                                                     \nDownloaded  True\n</code></pre> <p>The easiest way to read the data in a mini-batch fashion is to use the <code>read_csv</code> from <code>pandas</code>.</p> <pre><code>import pandas as pd\n\nnames = [\n    'target', 'lepton pT', 'lepton eta', 'lepton phi',\n    'missing energy magnitude', 'missing energy phi',\n    'jet 1 pt', 'jet 1 eta', 'jet 1 phi', 'jet 1 b-tag',\n    'jet 2 pt', 'jet 2 eta', 'jet 2 phi', 'jet 2 b-tag',\n    'jet 3 pt', 'jet 3 eta', 'jet 3 phi', 'jet 3 b-tag',\n    'jet 4 pt', 'jet 4 eta', 'jet 4 phi', 'jet 4 b-tag',\n    'm_jj', 'm_jjj', 'm_lv', 'm_jlv', 'm_bb', 'm_wbb', 'm_wwbb'\n]\n\nfor x in pd.read_csv(dataset.path, names=names, chunksize=8096, nrows=3e5):\n    y = x.pop('target')\n    y_pred = model.predict_proba_many(x)\n    model.learn_many(x, y)\n</code></pre> <p>If you are familiar with scikit-learn, you might be aware that some of their estimators have a <code>partial_fit</code> method, which is similar to river's <code>learn_many</code> method. Here are some advantages that river has over scikit-learn:</p> <ul> <li>We guarantee that river's is just as fast, if not faster than scikit-learn. The differences are negligeable, but are slightly in favor of river.</li> <li>We take as input dataframes, which allows us to name each feature. The benefit is that you can add/remove/permute features between batches and everything will keep working.</li> <li>Estimators that support mini-batches also support single instance learning. This means that you can enjoy the best of both worlds. For instance, you can train with mini-batches and use <code>predict_one</code> to make predictions.</li> </ul> <p>Note that you can check which estimators can process mini-batches programmatically:</p> <pre><code>import importlib\nimport inspect\n\ndef can_mini_batch(obj):\n    return hasattr(obj, 'learn_many')\n\nfor module in importlib.import_module('river.api').__all__:\n    if module in ['datasets', 'synth']:\n        continue\n    for name, obj in inspect.getmembers(importlib.import_module(f'river.{module}'), can_mini_batch):\n        print(name)\n</code></pre> <pre><code>LocalOutlierFactor\nOneClassSVM\nMiniBatchClassifier\nMiniBatchRegressor\nMiniBatchSupervisedTransformer\nMiniBatchTransformer\nSKL2RiverClassifier\nSKL2RiverRegressor\nFuncTransformer\nPipeline\nSelect\nTransformerProduct\nTransformerUnion\nBagOfWords\nTFIDF\nLinearRegression\nLogisticRegression\nPerceptron\nOneVsRestClassifier\nBernoulliNB\nComplementNB\nMultinomialNB\nMLPRegressor\nOneHotEncoder\nOrdinalEncoder\nStandardScaler\n</code></pre> <p>Because mini-batch learning isn't treated as a first-class citizen, some of the river's functionalities require some work in order to play nicely with mini-batches. For instance, the objects from the <code>metrics</code> module have an <code>update</code> method that take as input a single pair <code>(y_true, y_pred)</code>. This might change in the future, depending on the demand.</p> <p>We plan to promote more models to the mini-batch regime. However, we will only be doing so for the methods that benefit the most from it, as well as those that are most popular. Indeed, River's core philosophy will remain to cater to single instance learning.</p>"},{"location":"recipes/model-evaluation/","title":"Model evaluation","text":"<p>To do.</p>"},{"location":"recipes/on-hoeffding-trees/","title":"Incremental decision trees in river: the Hoeffding Tree case","text":"<p>Decision trees (DT) are popular learning models due to their inherently simplicity, flexibility and self-explainable structure. Moreover, when aggregated in ensembles, high predictive power might be achieved. Bagging and gradient boosting-based tree ensembles are very popular solutions in competition platforms such as Kaggle, and also among researchers.</p> <p>Although fairly lightweight, traditional batch DTs cannot cope with data stream mining/online learning requirements, as they do multiple passes over the data and have to be retrained from scratch every time a new observation appears.</p> <p>The data stream literature has plenty of incremental DT (iDT) families that are better suited to online learning. Nonetheless, Hoeffding Trees (HT) are historically the most popular family of iDTs to date. In fact, HTs have some nice properties:</p> <ul> <li>one-pass learning regime;</li> <li>theoretical guarantees to converge to the batch DT model given enough observations and a stationary data distribution;</li> <li>small memory and running time footprint (in most cases);</li> <li>some of their variations can deal with non-stationary distributions.</li> </ul> <p>And the previous list goes on and on. Besides that, HTs also have the same advantages as batch DTs (<code>C4.5</code>/<code>J48</code>, <code>CART</code>, <code>M5</code>, etc.) do. We can inspect the structure of a HT to understand how decisions were made, which is a nice feature to have in online learning tasks.</p> <p>In River, HTs are first-class citizens, so we have multiple realizations of this framework that are suited to different learning tasks and scenarios.</p> <p>This brief introduction to HT does not aims at being extensive nor delving into algorithmic or implementation details of the HTs. Instead, we intend to provide a high-level overview of the HTs as they are envisioned in River, as well as their shared properties and important hyperparameters.</p> <p>In this guide, we are going to:</p> <ol> <li>summarize the differences across the multiple HT versions available;</li> <li>learn how to inspect tree models;</li> <li>learn how to manage the memory usage of HTs;</li> <li>compare numerical tree splitters and understand their impact on the iDT induction process.</li> </ol> <p>Well, without further ado, let's go! </p> <p>First things first, we are going to start with some imports.</p> <pre><code>import matplotlib.pyplot as plt\nimport datetime as dt\n\nfrom river import datasets\nfrom river import evaluate\nfrom river import metrics\nfrom river import preprocessing  # we are going to use that later\nfrom river.datasets import synth  # we are going to use some synthetic datasets too\nfrom river import tree\n</code></pre>"},{"location":"recipes/on-hoeffding-trees/#1-trees-trees-everywhere-gardening-101-with-river","title":"1. Trees, trees everywhere: gardening 101 with river","text":"<p>At first glance, the amount of iDT algorithms in River might seem too much to handle, but in reality the distinction among them is easy to grasp. To facilitate our lives, here's a neat table listing the available HT models and summarizing their differences:</p> Name Acronym Task Non-stationary? Comments Source Hoeffding Tree Classifier HTC Classification No Basic HT for classification tasks [1] Hoeffding Adaptive Tree Classifier HATC Classification Yes Modifies HTC by adding an instance of ADWIN to each node to detect and react to drift detection [2] Extremely Fast Decision Tree Classifier EFDT Classification No Deploys split decisions as soon as possible and periodically revisit decisions and redo them if necessary. Not as fast in practice as the name implies, but it tends to converge faster than HTC to the model generated by a batch DT [3] Hoeffding Tree Regressor HTR Regression No Basic HT for regression tasks. It is an adaptation of the FIRT/FIMT algorithm that bears some semblance to HTC [4] Hoeffding Adaptive Tree Regressor HATR Regression Yes Modifies HTR by adding an instance of ADWIN to each node to detect and react to drift detection - incremental Structured-Output Prediction Tree Regressor iSOUPT Multi-target regression No Multi-target version of HTR [5] <p>As we can see, although their application fields might overlap sometimes, the HT variations have specific situations in which they are better suited to work. Moreover, in River we provide a standardized API access to all the HT variants since they share many properties in common.</p>"},{"location":"recipes/on-hoeffding-trees/#2-how-to-inspect-tree-models","title":"2. How to inspect tree models?","text":"<p>We provide a handful of tools to inspect trained HTs in River. Here, we will provide some examples of how to access their inner structures, get useful information, and plot the iDT structure.</p> <p>Firstly, let's pick a toy dataset from which our tree will learn from. Here we are going to focus on the classification case, but the same operations apply to other learning tasks. We will select the <code>Phishing</code> dataset from the <code>datasets</code> module to exemplify the HTs' capabilities.</p> <pre><code>dataset = datasets.Phishing()\ndataset\n</code></pre> <pre><code>Phishing websites.\n\nThis dataset contains features from web pages that are classified as phishing or not.\n\n    Name  Phishing                                                       \n    Task  Binary classification                                          \n Samples  1,250                                                          \nFeatures  9                                                              \n  Sparse  False                                                          \n    Path  /Users/mastelini/Documents/river/river/datasets/phishing.csv.gz\n</code></pre> <p>We are going to train an instance of <code>HoeffdingTreeClassifier</code> using this dataset. As everything else in River, training an iDT is a piece of cake!</p> <pre><code>%%time\n\nmodel = tree.HoeffdingTreeClassifier(grace_period=50)\n\nfor x, y in dataset:\n    model.learn_one(x, y)\n\nmodel\n</code></pre> <pre><code>CPU times: user 64.8 ms, sys: 2.75 ms, total: 67.6 ms\nWall time: 68.1 ms\n</code></pre> <pre>HoeffdingTreeClassifier</pre><code>HoeffdingTreeClassifier (   grace_period=50   max_depth=inf   split_criterion=\"info_gain\"   delta=1e-07   tau=0.05   leaf_prediction=\"nba\"   nb_threshold=0   nominal_attributes=None   splitter=GaussianSplitter (     n_splits=10   )   binary_split=False   min_branch_fraction=0.01   max_share_to_split=0.99   max_size=100.   memory_estimate_period=1000000   stop_mem_management=False   remove_poor_attrs=False   merit_preprune=True ) </code> <p>That's it! We are not going to enter into details about some of the available parameters of HTC here. The user can refer to the documentation page for more information about that. Let's talk about model inspection :D</p> <p>At any time, we can easily get some statistics about our trained model by using the <code>summary</code> property:</p> <pre><code>model.summary\n</code></pre> <pre><code>{'n_nodes': 5,\n 'n_branches': 2,\n 'n_leaves': 3,\n 'n_active_leaves': 3,\n 'n_inactive_leaves': 0,\n 'height': 3,\n 'total_observed_weight': 1250.0}\n</code></pre> <p>This property show us the internal structure of the tree, including data concerning the memory-management routines that we are going to check later in this guide. We can also get a representation of the tree model as a <code>pandas.DataFrame</code> object:</p> <pre><code>model.to_dataframe().iloc[:5, :5]\n</code></pre> parent is_leaf depth stats feature node 0 &lt;NA&gt; False 0 {True: 260.0, False: 390.0} empty_server_form_handler 1 0 True 1 {True: 443.4163997711022, False: 59.8769131081... NaN 2 0 False 1 {True: 71.58360022889781, False: 404.123086891... popup_window 3 2 True 2 {False: 31.426538522574834, True: 33.0} NaN 4 2 True 2 {False: 250.57346147742516, True: 6.0} NaN <p>Hmm, maybe not the clearest of the representations. What about drawing the tree structure instead?</p> <pre><code>model.draw()\n</code></pre> <p></p> <p>Much better, huh?</p> <p>Lastly, we can check how the tree predicts one specific instance by using the <code>debug_one</code> method:</p> <pre><code>x, y = next(iter(dataset))  # Let's select the first example in the stream\nx, y\n</code></pre> <pre><code>({'empty_server_form_handler': 0.0,\n  'popup_window': 0.0,\n  'https': 0.0,\n  'request_from_other_domain': 0.0,\n  'anchor_from_other_domain': 0.0,\n  'is_popular': 0.5,\n  'long_url': 1.0,\n  'age_of_domain': 1,\n  'ip_in_url': 1},\n True)\n</code></pre> <pre><code>print(model.debug_one(x))\n</code></pre> <pre><code>empty_server_form_handler \u2264 0.5454545454545454\nClass True:\n    P(False) = 0.1\n    P(True) = 0.9\n</code></pre> <p>Our tree got this one right! The method <code>debug_one</code> is especially useful when we are dealing with a big tree model where drawing might not be the wisest of the choices (we will end up with a tree chart that has too much information to visually understand).</p> <p>Some additional hints:</p> <ul> <li>the <code>max_depth</code> parameter is our friend when building HTs that need to be constantly inspected. This parameter, which is available for every HT variant, triggers a pre-pruning mechanism that stops tree growth when the given depth is reached.</li> <li>we can also limit the depth when using the <code>draw</code> method.</li> <li>in the case of tree ensembles, individual trees can be accessed using the <code>[index]</code> operator. Then, the same set of inspection tools are available to play with!</li> </ul>"},{"location":"recipes/on-hoeffding-trees/#3-advanced-gardening-with-river-grab-your-pruning-shears-and-lets-limit-memory-usage","title":"3. Advanced gardening with river: grab your pruning shears and let's limit memory usage","text":"<p>Online learning is well-suited to highly scalable processing centers with petabytes of data arriving intermittently, but it can also work with Internet of Things (IoT) devices operating at low power and with limited processing capability. Hence, making sure our trees are not going to use too much memory is a nice feature that can impact on both energy usage and the running time. HTs have memory-management routines that put the user in the control of computational resources that are available.</p> <p>In this brief guide, we are going to use a regression tree, since this kind of iDT typically spends more memory than the classification counterparts. However, the user can control the memory usage in the exact same way in River, regardless of the HT variant!</p> <p>We will rely on the <code>Friedman</code> synthetic dataset (data generator) from the <code>synth</code> module in our evaluation. Since data generators can produce instances indefinitely, we will select a sample of size 10K for our tests.</p> <p>We are almost ready to go. Let's first define a simple function that plots the results obtained from a given dataset, metric and </p> <pre><code>def plot_performance(dataset, metric, models):\n    metric_name = metric.__class__.__name__\n\n    # To make the generated data reusable\n    dataset = list(dataset)\n    fig, ax = plt.subplots(figsize=(10, 5), nrows=3, dpi=300)\n    for model_name, model in models.items():\n        step = []\n        error = []\n        r_time = []\n        memory = []\n\n        for checkpoint in evaluate.iter_progressive_val_score(\n            dataset, model, metric, measure_time=True, measure_memory=True, step=100\n        ):\n            step.append(checkpoint[\"Step\"])\n            error.append(checkpoint[metric_name].get())\n\n            # Convert timedelta object into seconds\n            r_time.append(checkpoint[\"Time\"].total_seconds())\n            # Make sure the memory measurements are in MiB\n            raw_memory = checkpoint[\"Memory\"]\n            memory.append(raw_memory * 2**-20)\n\n        ax[0].plot(step, error, label=model_name)\n        ax[1].plot(step, r_time, label=model_name)\n        ax[2].plot(step, memory, label=model_name)\n\n    ax[0].set_ylabel(metric_name)\n    ax[1].set_ylabel('Time (seconds)')\n    ax[2].set_ylabel('Memory (MiB)')\n    ax[2].set_xlabel('Instances')\n\n    ax[0].grid(True)\n    ax[1].grid(True)\n    ax[2].grid(True)\n\n    ax[0].legend(\n        loc='upper center', bbox_to_anchor=(0.5, 1.25),\n        ncol=3, fancybox=True, shadow=True\n    )\n    plt.tight_layout()\n    plt.close()\n\n    return fig\n</code></pre> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"Unbounded HTR\": (\n            preprocessing.StandardScaler() |\n            tree.HoeffdingTreeRegressor(splitter=tree.splitter.EBSTSplitter())\n        )\n    }\n)\n</code></pre> <p></p> <p>In our example we use the <code>EBSTSplitter</code>, which is going to discussed later. For now, is enough to know that it is a mechanism to evaluate split candidates in the trees.</p> <p>As we can see, our tree uses almost 10 MiB to keep its structure. Let's say we wanted to limit our memory usage to 5 MiB. How could we do that?</p> <p>Note that we are using a illustration case here. In real applications, data may be unbounded, so the trees might grow indefinitely.</p> <p>HTs expose some parameters related to memory management. The user can refer to the documentation for more details on that matter. Here, we are going to focus on two parameters:</p> <ul> <li><code>max_size</code>: determines the maximum amount of memory (in MiB) that the HT can use.</li> <li><code>memory_estimate_period</code>: intervals after which the memory-management is triggered.</li> </ul> <p>We are going to limit our HTR to 5 MiB and perform memory checks at intervals of 500 instances.</p> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"Restricted HTR\": (\n            preprocessing.StandardScaler()\n            | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.EBSTSplitter(),\n                max_size=5,\n                memory_estimate_period=500\n            )\n        )\n    }\n)\n</code></pre> <p></p> <p>Note that as soon the memory usage reaches the limit that we determined (at the memory check intervals), HTR starts managing its resource usage to reduce the size. As a consequence, the running time also decreases. For more accurate management, the intervals between memory checks should be decreased. This action, however, has costs since the tree stops the learning process to estimate its size and alter its own structure. Too frequent memory checks might end up result in a slow learning process. Besides, by using fewer resources, the predictive performance can be negatively impacted. So, use this tool with caution!</p> <p>But how that works at all?</p> <p>HTs monitor the incoming feature values to perform split attempts. To do so, they rely on a class of algorithms called Attribute Observers (AO) or Splitters (spoiler alert!). Each leaf node in an HT keeps one AO per incoming feature. After pre-determined intervals (<code>grace_period</code> parameter), leaves query their AOs for split candidates. Well, there are costs to monitor input features (mainly the numerical ones). In fact, AOs correspond to one of the most time and memory-consuming portions of the HTs. To manage memory usage, an HT firstly determines its least promising leaves, w.r.t. how likely they will be split. Then, these leaves' AOs are removed, and the tree nodes are said to be \"deactivated.\" That's it! The deactivated leaves do not perform split attempts anymore, but they continue to be updated to provide responses. They will be kept as leaves as long as there are not available resources to enable tree growth. These leaves can be activated again (meaning that new AOs will be created for them) if there is available memory, so don't worry!</p> <p>Hint: another indirect way to bound memory usage is to limit the tree depth. By default, the trees can grow until they get close to the maximum recursion limit enabled in the system, but the <code>max_depth</code> parameter can control this behavior.</p> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"HTR with at most 5 levels\": (\n            preprocessing.StandardScaler()\n            | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.EBSTSplitter(),\n                max_depth=5\n            )\n        )\n    }\n)\n</code></pre> <p></p>"},{"location":"recipes/on-hoeffding-trees/#4-branching-and-growth-splitters-the-heart-of-the-trees","title":"4. Branching and growth: splitters, the heart of the trees","text":"<p>As previously stated, one of the core operations of iDT is, well, to grow. Plants and gardening-related jokes apart, growth in HTs is guided by their AOs or splitters, as mentioned in the end of Section 3. </p> <p>Nominal features can be easily monitored, since the feature partitions are well-defined beforehand. Numerical features, on the other hand, do not have an explicit best cut point. Still, numerical features are typically split by using a binary test: \\(\\le\\) or \\(&gt;\\). Therefore, numerical splitters must somehow summarize the incoming feature values and be able to evaluate the merit of split point candidates.</p> <p>There are diverse strategies to monitor numerical features and choices related to them, including which data structure will be used to keep a summary of the incoming feature and also how many split points are going to be evaluated during split attempts. Again, this guide does not intend to be an exhaustive delve into the iDT subject. In fact, each of the following aspects of the iDTs could be considered a separate research area: AOs, intervals between split attempts, split heuristics (e.g., info gain, variance reduction, and so on), tree depth and max size, and much more!</p> <p>Let's focus a bit into the AO matter. River provides a handful of splitters for classification and regression trees, which can be chosen using the parameter <code>splitter</code>. We will list the available tree splitters in the following sections and compare some of their chacteristics.</p> <p>Some notation:</p> <ul> <li>\\(n\\): Number of observations seen so far.</li> <li>\\(c\\): the number of classes.</li> <li>\\(s\\): the number of split points to evaluate (which means that this is a user-given parameter).</li> <li>\\(h\\): the number of histogram bins or hash slots. Typically, \\(h \\ll n\\).</li> </ul>"},{"location":"recipes/on-hoeffding-trees/#41-classification-tree-splitters","title":"4.1. Classification tree splitters","text":"<p>The following table summarizes the available classification splitters. The user might refer to the documentation of each splitter for more details about their functioning.</p> Splitter Description Insertion Memory Split candidate query Works with Naive Bayes leaves? Exhaustive Keeps all the observed input values and class counts in a Binary Search Tree (BST) \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\) No Histogram Builds a histogram for each class in order to discretize the input feature \\(O(\\log h)\\) \\(O(c h)\\) \\(O(c h)\\) Yes Gaussian Approximates the class distributions using Gaussian distributions \\(O(1)\\) \\(O(c)\\) \\(O(cs)\\) Yes <p>Note that some of the splitters have configurable parameters that directly impact not only on their time and memory costs, but also on the final predictive performance. Examples:</p> <ul> <li>The number of split points can be configured in the Gaussian splitter. Increasing this number makes this splitter slower, but it also potentially increases the quality of the obtained query points, implying enhanced tree accuracy. </li> <li>The number of stored bins can be selected in the Histogram splitter. Increasing this number increases the memory footprint and running time of this splitter, but it also potentially makes its split candidates more accurate and positively impacts on the tree's final predictive performance.</li> </ul> <p>Next, we provide a brief comparison of the classification splitters using 10K instances of the Random RBF synthetic dataset. Note that the tree equipped with the Exhaustive splitter does not use Naive Bayes leaves.</p> <pre><code>plot_performance(\n    synth.RandomRBF(seed_model=7, seed_sample=42).take(10_000),\n    metrics.Accuracy(),\n    {\n        \"HTC + Exhaustive splitter\": tree.HoeffdingTreeClassifier(\n            splitter=tree.splitter.ExhaustiveSplitter(),\n            leaf_prediction=\"mc\"\n        ),\n        \"HTC + Histogram splitter\": tree.HoeffdingTreeClassifier(\n            splitter=tree.splitter.HistogramSplitter()\n        ),\n        \"HTC + Gaussian splitter\": tree.HoeffdingTreeClassifier(\n            splitter=tree.splitter.GaussianSplitter()\n        )\n    }\n)\n</code></pre> <p></p>"},{"location":"recipes/on-hoeffding-trees/#42-regression-tree-splitters","title":"4.2 Regression tree splitters","text":"<p>The available regression tree splitters are summarized in the next table. The TE-BST costs are expressed in terms of \\(n^*\\) because the number of stored elements can be smaller than or equal to \\(n\\).</p> Splitter Description Insertion Memory Split candidate query Extended Binary Search Tree (E-BST) Stores all the observations and target statistics in a BST \\(O(\\log n)\\) (average) or \\(O(n)\\) (worst case) \\(O(n)\\) \\(O(n)\\) Truncated E-BST (TE-BST) Rounds the incoming data before passing it to the BST \\(O(\\log n^*)\\) (average) or \\(O(n^*)\\) (worst case) \\(O(n^*)\\) \\(O(n^*)\\) Quantization Observer (QO) Uses a hash-like structure to quantize the incoming data \\(O(1)\\) \\(O(h)\\) \\(O(h \\log h)\\) <p>E-BST is an exhaustive algorithm, i.e., it works as batch solutions usually do, which might be prohibitive in real-world online scenarios. TE-BST and QO apply approximations to alleviate the costs involved in monitoring numerical data and performing split attempts. The number of desired decimal places to round the data (TE-BST) and the quantization radius (QO) are directly related to the running time, memory footprint, and error of the resulting tree model.</p> <p>We present a brief comparison of the available regression tree splitters using the 10K instances of the Friedman synthetic dataset.</p> <pre><code>plot_performance(\n    synth.Friedman(seed=42).take(10_000),\n    metrics.MAE(),\n    {\n        \"HTR + E-BST\": (\n            preprocessing.StandardScaler() | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.EBSTSplitter()\n            )\n        ),\n        \"HTR + TE-BST\": (\n            preprocessing.StandardScaler() | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.TEBSTSplitter()\n            )\n        ),\n        \"HTR + QO\": (\n            preprocessing.StandardScaler() | tree.HoeffdingTreeRegressor(\n                splitter=tree.splitter.QOSplitter()\n            )\n        ),\n\n    }\n)\n</code></pre> <p></p>"},{"location":"recipes/on-hoeffding-trees/#wrapping-up","title":"Wrapping up","text":"<p>This guide provides a walkthrough in the HTs available in River. We discussed about model inspection, memory management, and feature splits. Keep in mind that each HT variant has specific details and capabilities that are out-of-the-scope of this introductory material. The user is advised to check the documentation page of the tree models for detailed information.</p>"},{"location":"recipes/pipelines/","title":"Pipelines","text":"<p>Pipelines are an integral part of River. We encourage their usage and apply them in many of their examples.</p> <p>The <code>compose.Pipeline</code> contains all the logic for building and applying pipelines. A pipeline is essentially a list of estimators that are applied in sequence. The only requirement is that the first <code>n - 1</code> steps be transformers. The last step can be a regressor, a classifier, a clusterer, a transformer, etc.</p> <p>Here is an example:</p> <pre><code>from river import compose\nfrom river import linear_model\nfrom river import preprocessing\nfrom river import feature_extraction\n\nmodel = compose.Pipeline(\n    preprocessing.StandardScaler(),\n    feature_extraction.PolynomialExtender(),\n    linear_model.LinearRegression()\n)\n</code></pre> <p>You can also use the <code>|</code> operator, as so:</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    feature_extraction.PolynomialExtender() |\n    linear_model.LinearRegression()\n)\n</code></pre> <p>Or, equally:</p> <pre><code>model = preprocessing.StandardScaler() \nmodel |= feature_extraction.PolynomialExtender()\nmodel |= linear_model.LinearRegression()\n</code></pre> <p>A pipeline, as any River estimator, has a <code>_repr_html_</code> method, which can be used to visualize it in Jupyter-like notebooks:</p> <pre><code>model\n</code></pre> <pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>PolynomialExtender</pre><code>PolynomialExtender (   degree=2   interaction_only=False   include_bias=False   bias_name=\"bias\" ) </code><pre>LinearRegression</pre><code>LinearRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code> <p><code>compose.Pipeline</code> implements a <code>learn_one</code> method which in sequence calls the <code>learn_one</code> of each component and a <code>predict_one</code> (resp <code>predict_proba_one</code>) method which calls <code>transform_one</code> on the first <code>n - 1</code> steps and <code>predict_one</code> (resp <code>predict_proba_one</code>) on the last step.</p> <p>Here is a small example to illustrate the previous point:</p> <pre><code>from river import datasets\n\ndataset = datasets.TrumpApproval()\nx, y = next(iter(dataset))\nx, y\n</code></pre> <pre><code>({'ordinal_date': 736389,\n  'gallup': 43.843213,\n  'ipsos': 46.19925042857143,\n  'morning_consult': 48.318749,\n  'rasmussen': 44.104692,\n  'you_gov': 43.636914000000004},\n 43.75505)\n</code></pre> <p>We can predict the target value of a new sample by calling the <code>predict_one</code> method, however, by default, <code>predict_one</code> does not update any model parameter, therefore the predictions will be 0 and the model parameters will remain the default values (0 for <code>StandardScaler</code> component):</p> <pre><code>for (x, y) in dataset.take(2):\n    print(f\"{model.predict_one(x)=:.2f}, {y=:.2f}\")\n    print(f\"{model['StandardScaler'].means = }\")\n</code></pre> <pre><code>model.predict_one(x)=0.00, y=43.76\nmodel['StandardScaler'].means = defaultdict(&lt;class 'float'&gt;, {'ordinal_date': 0.0, 'gallup': 0.0, 'ipsos': 0.0, 'morning_consult': 0.0, 'rasmussen': 0.0, 'you_gov': 0.0})\nmodel.predict_one(x)=0.00, y=43.71\nmodel['StandardScaler'].means = defaultdict(&lt;class 'float'&gt;, {'ordinal_date': 0.0, 'gallup': 0.0, 'ipsos': 0.0, 'morning_consult': 0.0, 'rasmussen': 0.0, 'you_gov': 0.0})\n</code></pre> <p><code>learn_one</code> updates pipeline stateful steps, parameters and the prediction change:</p> <pre><code>for (x, y) in dataset.take(2):\n    model.learn_one(x, y)\n\n    print(f\"{model.predict_one(x)=:.2f}, {y=:.2f}\")\n    print(f\"{model['StandardScaler'].means = }\")\n</code></pre> <pre><code>model.predict_one(x)=0.88, y=43.76\nmodel['StandardScaler'].means = defaultdict(&lt;class 'float'&gt;, {'ordinal_date': 736389.0, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004})\nmodel.predict_one(x)=9.44, y=43.71\nmodel['StandardScaler'].means = defaultdict(&lt;class 'float'&gt;, {'ordinal_date': 736389.5, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 45.104692, 'you_gov': 42.636914000000004})\n</code></pre> <p>Each component of the pipeline has been updated with the new data point. </p> <p>A pipeline is a very powerful tool that can be used to chain together multiple steps in a machine learning workflow.</p> <p>Notice that it is also possible to call <code>transform_one</code> with a pipeline, this method will run <code>transform_one</code> of each transformer in it, and return the result of the last transformer (which is thus the penultimate step if the last step is a predictor or clusterer, while it is the last step if the last step is a transformer):</p> <pre><code>model.transform_one(x)\n</code></pre> <pre><code>{'ordinal_date': 1.0,\n 'gallup': 0.0,\n 'ipsos': 0.0,\n 'morning_consult': 0.0,\n 'rasmussen': 1.0,\n 'you_gov': -1.0,\n 'ordinal_date*ordinal_date': 1.0,\n 'gallup*ordinal_date': 0.0,\n 'ipsos*ordinal_date': 0.0,\n 'morning_consult*ordinal_date': 0.0,\n 'ordinal_date*rasmussen': 1.0,\n 'ordinal_date*you_gov': -1.0,\n 'gallup*gallup': 0.0,\n 'gallup*ipsos': 0.0,\n 'gallup*morning_consult': 0.0,\n 'gallup*rasmussen': 0.0,\n 'gallup*you_gov': -0.0,\n 'ipsos*ipsos': 0.0,\n 'ipsos*morning_consult': 0.0,\n 'ipsos*rasmussen': 0.0,\n 'ipsos*you_gov': -0.0,\n 'morning_consult*morning_consult': 0.0,\n 'morning_consult*rasmussen': 0.0,\n 'morning_consult*you_gov': -0.0,\n 'rasmussen*rasmussen': 1.0,\n 'rasmussen*you_gov': -1.0,\n 'you_gov*you_gov': 1.0}\n</code></pre> <p>In many cases, you might want to connect a step to multiple steps. For instance, you might to extract different kinds of features from a single input. An elegant way to do this is to use a <code>compose.TransformerUnion</code>. Essentially, the latter is a list of transformers who's results will be merged into a single <code>dict</code> when <code>transform_one</code> is called.</p> <p>As an example let's say that we want to apply a <code>feature_extraction.RBFSampler</code> as well as the <code>feature_extraction.PolynomialExtender</code>. This may be done as so:</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    (feature_extraction.PolynomialExtender() + feature_extraction.RBFSampler()) |\n    linear_model.LinearRegression()\n)\n\nmodel\n</code></pre> <pre>StandardScaler</pre><code>StandardScaler (   with_std=True ) </code><pre>PolynomialExtender</pre><code>PolynomialExtender (   degree=2   interaction_only=False   include_bias=False   bias_name=\"bias\" ) </code><pre>RBFSampler</pre><code>RBFSampler (   gamma=1.   n_components=100   seed=None ) </code><pre>LinearRegression</pre><code>LinearRegression (   optimizer=SGD (     lr=Constant (       learning_rate=0.01     )   )   loss=Squared ()   l2=0.   l1=0.   intercept_init=0.   intercept_lr=Constant (     learning_rate=0.01   )   clip_gradient=1e+12   initializer=Zeros () ) </code> <p>Note that the <code>+</code> symbol acts as a shorthand notation for creating a <code>compose.TransformerUnion</code>, which means that we could have declared the above pipeline as so:</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    compose.TransformerUnion(\n        feature_extraction.PolynomialExtender(),\n        feature_extraction.RBFSampler()\n    ) |\n    linear_model.LinearRegression()\n)\n</code></pre> <p>Pipelines provide the benefit of removing a lot of cruft by taking care of tedious details for you. They also enable to clearly define what steps your model is made of.</p> <p>Finally, having your model in a single object means that you can move it around more easily.</p> <p>Note that you can include user-defined functions in a pipeline by using a <code>compose.FuncTransformer</code>.</p>"},{"location":"recipes/pipelines/#learning-during-predict","title":"Learning during predict","text":"<p>In online machine learning, we can update the unsupervised parts of our model when a sample arrives. We don't really have to wait for the ground truth to arrive in order to update unsupervised estimators that don't depend on it.</p> <p>In other words, in a pipeline, <code>learn_one</code> updates the supervised parts, whilst <code>predict_one</code> (or <code>predict_proba_one</code> for that matter) can update the unsupervised parts, which often yields better results. </p> <p>In river, we can achieve this behavior using a dedicated context manager: <code>compose.learn_during_predict</code>.</p> <p>Here is the same example as before, with the only difference of activating the such learning during predict behavior:</p> <pre><code>model = (\n    preprocessing.StandardScaler() |\n    feature_extraction.PolynomialExtender() |\n    linear_model.LinearRegression()\n)\n</code></pre> <pre><code>with compose.learn_during_predict():\n    for (x, y) in dataset.take(2):\n\n        print(f\"{model.predict_one(x)=:.2f}, {y=:.2f}\")\n        print(f\"{model['StandardScaler'].means = }\")\n</code></pre> <pre><code>model.predict_one(x)=0.00, y=43.76\nmodel['StandardScaler'].means = defaultdict(&lt;class 'float'&gt;, {'ordinal_date': 736389.0, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 44.104692, 'you_gov': 43.636914000000004})\nmodel.predict_one(x)=0.00, y=43.71\nmodel['StandardScaler'].means = defaultdict(&lt;class 'float'&gt;, {'ordinal_date': 736389.5, 'gallup': 43.843213, 'ipsos': 46.19925042857143, 'morning_consult': 48.318749, 'rasmussen': 45.104692, 'you_gov': 42.636914000000004})\n</code></pre> <p>Calling <code>predict_one</code> within this context will update each transformer of the pipeline. For instance here we can see that the mean of each feature of the standard scaler step have been updated.</p> <p>On the other hand, the supervised part of our pipeline, the linear regression, has not been updated or learned anything yet. Hence the prediction on any sample will be nil because each weight is still equal to 0.</p> <pre><code>model.predict_one(x), model[\"LinearRegression\"].weights\n</code></pre> <pre><code>(0.0, {})\n</code></pre>"},{"location":"recipes/pipelines/#performance-comparison","title":"Performance Comparison","text":"<p>One may wonder what is the advantage of learning during predict. Let's compare the performance of a pipeline with and without learning during predict, in two scenarios: one in which the flow of data stays the same, we just update </p> <pre><code>from contextlib import nullcontext\nfrom river import metrics\n\nimport pandas as pd\n</code></pre> <pre><code>def score_pipeline(learn_during_predict: bool, n_learning_samples: int | None = None) -&gt; float:\n    \"\"\"Scores a pipeline on the TrumpApproval dataset.\n\n    Parameters\n    ----------\n    learn_during_predict : bool\n        Whether or not to learn the unsupervided components during the prediction step.\n        If False it will only learn when `learn_one` is explicitly called.\n    n_learning_samples : int | None \n        Number of samples used to `learn_one`.\n\n    Return\n    ------\n    MAE : float\n        Mean absolute error of the pipeline on the dataset\n    \"\"\"\n\n    dataset = datasets.TrumpApproval()\n\n    model = (\n        preprocessing.StandardScaler() |\n        linear_model.LinearRegression()\n        )\n\n    metric = metrics.MAE()\n\n    ctx = compose.learn_during_predict if learn_during_predict else nullcontext\n    n_learning_samples = n_learning_samples or dataset.n_samples\n\n    with ctx():\n        for _idx, (x, y) in enumerate(dataset):\n            y_pred = model.predict_one(x)\n\n            metric.update(y, y_pred)\n\n            if _idx &lt; n_learning_samples:\n                model.learn_one(x, y)\n\n    return metric.get()\n</code></pre> <pre><code>max_samples = datasets.TrumpApproval().n_samples\n\nresults = [\n    {\n        \"learn_during_predict\": learn_during_predict,\n        \"pct_learning_samples\": round(100*n_learning_samples/max_samples, 0),\n        \"mae\": score_pipeline(learn_during_predict=learn_during_predict, n_learning_samples=n_learning_samples)\n    }\n    for learn_during_predict in (True, False)\n    for n_learning_samples in range(max_samples, max_samples//10, -(max_samples//10))\n]\n</code></pre> <pre><code>(pd.DataFrame(results)\n .pivot(columns=\"learn_during_predict\", index=\"pct_learning_samples\", values=\"mae\")\n .sort_index(ascending=False)\n .style.format_index('{0}%')\n)\n</code></pre> learn_during_predict False True pct_learning_samples 100.0% 1.314548 1.347434 90.0% 1.629333 1.355274 80.0% 2.712125 1.371599 70.0% 4.840620 1.440773 60.0% 8.918634 1.498240 50.0% 15.112753 1.878434 40.0% 26.387331 2.105553 30.0% 42.997083 3.654709 20.0% 90.703102 3.504950 10.0% 226.836953 4.803600 <p>As we can see from the resulting table above, the scores are comparable only in the case in which the percentage of learning samples above 90%. After that the score starts to degrade quite fast as the percentage of learning samples decreases, and it is very remarkable (one order of magnitude or more) when less than 50% of the samples are used for learning.</p> <p>Although a simple case, this examplify how powerful it can be to learn unsupervised components during predict.</p>"},{"location":"recipes/reading-data/","title":"Reading data","text":"<p>In River, the features of a sample are stored inside a dictionary, which in Python is called a <code>dict</code> and is a native data structure. In other words, we don't use any sophisticated data structure, such as a <code>numpy.ndarray</code> or a <code>pandas.DataFrame</code>.</p> <p>The main advantage of using plain <code>dict</code>s is that it removes the overhead that comes with using the aforementioned data structures. This is important in a streaming context because we want to be able to process many individual samples in rapid succession. Another advantage is that <code>dict</code>s allow us to give names to our features. Finally, <code>dict</code>s are not typed, and can therefore store heterogeneous data.</p> <p>Another advantage which we haven't mentioned is that <code>dict</code>s play nicely with Python's standard library. Indeed, Python contains many tools that allow manipulating <code>dict</code>s. For instance, the <code>csv.DictReader</code> can be used to read a CSV file and convert each row to a <code>dict</code>. In fact, the <code>stream.iter_csv</code> method from River is just a wrapper on top of <code>csv.DictReader</code> that adds a few bells and whistles.</p> <p>River provides some out-of-the-box datasets to get you started.</p> <pre><code>from river import datasets\n\ndataset = datasets.Bikes()\ndataset\n</code></pre> <pre><code>Bike sharing station information from the city of Toulouse.\n\nThe goal is to predict the number of bikes in 5 different bike stations from the city of\nToulouse.\n\n      Name  Bikes                                                         \n      Task  Regression                                                    \n   Samples  182,470                                                       \n  Features  8                                                             \n    Sparse  False                                                         \n      Path  /Users/max/river_data/Bikes/toulouse_bikes.csv                \n       URL  https://maxhalford.github.io/files/datasets/toulouse_bikes.zip\n      Size  12.52 MB                                                      \nDownloaded  True\n</code></pre> <p>Note that when we say \"loaded\", we don't mean that the actual data is read from the disk. On the contrary, the dataset is a streaming data that can be iterated over one sample at a time. In Python lingo, it's a generator.</p> <p>Let's take a look at the first sample:</p> <pre><code>x, y = next(iter(dataset))\nx\n</code></pre> <pre><code>{'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n 'station': 'metro-canal-du-midi',\n 'clouds': 75,\n 'description': 'light rain',\n 'humidity': 81,\n 'pressure': 1017.0,\n 'temperature': 6.54,\n 'wind': 9.3}\n</code></pre> <p>Each dataset is iterable, which means we can also do:</p> <pre><code>for x, y in dataset:\n    break\nx\n</code></pre> <pre><code>{'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n 'station': 'metro-canal-du-midi',\n 'clouds': 75,\n 'description': 'light rain',\n 'humidity': 81,\n 'pressure': 1017.0,\n 'temperature': 6.54,\n 'wind': 9.3}\n</code></pre> <p>As we can see, the values have different types.</p> <p>Under the hood, calling <code>for x, y in dataset</code> simply iterates over a file and parses each value appropriately. We can do this ourselves by using <code>stream.iter_csv</code>:</p> <pre><code>from river import stream\n\nX_y = stream.iter_csv(dataset.path)\nx, y = next(X_y)\nx, y\n</code></pre> <pre><code>({'moment': '2016-04-01 00:00:07',\n  'bikes': '1',\n  'station': 'metro-canal-du-midi',\n  'clouds': '75',\n  'description': 'light rain',\n  'humidity': '81',\n  'pressure': '1017.0',\n  'temperature': '6.54',\n  'wind': '9.3'},\n None)\n</code></pre> <p>There are a couple things that are wrong. First of all, the numeric features have not been casted into numbers. Indeed, by default, <code>stream.iter_csv</code> assumes that everything is a string. A related issue is that the <code>moment</code> field hasn't been parsed into a <code>datetime</code>. Finally, the target field, which is <code>bikes</code>, hasn't been separated from the rest of the features. We can remedy to these issues by setting a few parameters:</p> <pre><code>X_y = stream.iter_csv(\n    dataset.path,\n    converters={\n        'bikes': int,\n        'clouds': int,\n        'humidity': int,\n        'pressure': float,\n        'temperature': float,\n        'wind': float\n    },\n    parse_dates={'moment': '%Y-%m-%d %H:%M:%S'},\n    target='bikes'\n)\nx, y = next(X_y)\nx, y\n</code></pre> <pre><code>({'moment': datetime.datetime(2016, 4, 1, 0, 0, 7),\n  'station': 'metro-canal-du-midi',\n  'clouds': 75,\n  'description': 'light rain',\n  'humidity': 81,\n  'pressure': 1017.0,\n  'temperature': 6.54,\n  'wind': 9.3},\n 1)\n</code></pre> <p>That's much better. We invite you to take a look at the <code>stream</code> module to see for yourself what other methods are available. Note that River is first and foremost a machine learning library, and therefore isn't as much concerned about reading data as it is about statistical algorithms. We do however believe that the fact that we use dictionary gives you, the user, a lot of freedom and flexibility.</p> <p>The <code>stream</code> module provides helper functions to read data from different formats. For instance, you can use the <code>stream.iter_sklearn_dataset</code> function to turn any scikit-learn dataset into a stream.</p> <pre><code>from sklearn import datasets\n\ndataset = datasets.load_diabetes()\n\nfor x, y in stream.iter_sklearn_dataset(dataset):\n    break\n\nx, y\n</code></pre> <pre><code>({'age': 0.038075906433423026,\n  'sex': 0.05068011873981862,\n  'bmi': 0.061696206518683294,\n  'bp': 0.0218723855140367,\n  's1': -0.04422349842444599,\n  's2': -0.03482076283769895,\n  's3': -0.04340084565202491,\n  's4': -0.002592261998183278,\n  's5': 0.019907486170462722,\n  's6': -0.01764612515980379},\n 151.0)\n</code></pre> <p>To conclude, let us shortly mention the difference between proactive learning and reactive learning in the specific context of online machine learning. When we loop over a data with a <code>for</code> loop, we have the control over the data and the order in which it arrives. We are proactive in the sense that we, the user, are asking for the data to arrive.</p> <p>In contract, in a reactive situation, we don't have control on the data arrival. A typical example of such a situation is a web server, where web requests arrive in an arbitrary order. This is a situation where River shines. For instance, in a Flask application, you could define a route to make predictions with a River model as so:</p> <pre><code>import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/', methods=['GET'])\ndef predict():\n    payload = flask.request.json\n    river_model = load_model()\n    return river_model.predict_proba_one(payload)\n</code></pre> <p>Likewise, a model can be updated whenever a request arrives as so:</p> <pre><code>@app.route('/', methods=['POST'])\ndef learn():\n    payload = flask.request.json\n    river_model = load_model()\n    river_model.learn_one(payload['features'], payload['target'])\n    return {}, 201\n</code></pre> <p>To summarize, River can be used in many different ways. The fact that it uses dictionaries to represent features provides a lot of flexibility and space for creativity.</p>"},{"location":"recipes/rolling-computations/","title":"Rolling computations","text":"<p>You might wonder which classes in River can be wrapped with a <code>utils.Rolling</code>. This can be answered with a bit of metaprogramming.</p> <pre><code>import importlib\nimport inspect\nfrom river.utils.rolling import Rollable\n\nfor submodule in importlib.import_module(\"river.api\").__all__:\n    for _, obj in inspect.getmembers(\n        importlib.import_module(f\"river.{submodule}\"), lambda x: isinstance(x, Rollable)\n    ):\n        print(f'{submodule}.{obj.__name__}')\n</code></pre> <pre><code>[covariance.EmpiricalCovariance](../../api/covariance/EmpiricalCovariance)\n[metrics.Accuracy](../../api/metrics/Accuracy)\n[metrics.AdjustedMutualInfo](../../api/metrics/AdjustedMutualInfo)\n[metrics.AdjustedRand](../../api/metrics/AdjustedRand)\n[metrics.BalancedAccuracy](../../api/metrics/BalancedAccuracy)\n[metrics.ClassificationReport](../../api/metrics/ClassificationReport)\n[metrics.CohenKappa](../../api/metrics/CohenKappa)\n[metrics.Completeness](../../api/metrics/Completeness)\n[metrics.ConfusionMatrix](../../api/metrics/ConfusionMatrix)\n[metrics.CrossEntropy](../../api/metrics/CrossEntropy)\n[metrics.F1](../../api/metrics/F1)\n[metrics.FBeta](../../api/metrics/FBeta)\n[metrics.FowlkesMallows](../../api/metrics/FowlkesMallows)\n[metrics.GeometricMean](../../api/metrics/GeometricMean)\n[metrics.Homogeneity](../../api/metrics/Homogeneity)\n[metrics.Jaccard](../../api/metrics/Jaccard)\n[metrics.LogLoss](../../api/metrics/LogLoss)\n[metrics.MAE](../../api/metrics/MAE)\n[metrics.MAPE](../../api/metrics/MAPE)\n[metrics.MCC](../../api/metrics/MCC)\n[metrics.MSE](../../api/metrics/MSE)\n[metrics.MacroF1](../../api/metrics/MacroF1)\n[metrics.MacroFBeta](../../api/metrics/MacroFBeta)\n[metrics.MacroJaccard](../../api/metrics/MacroJaccard)\n[metrics.MacroPrecision](../../api/metrics/MacroPrecision)\n[metrics.MacroRecall](../../api/metrics/MacroRecall)\n[metrics.MicroF1](../../api/metrics/MicroF1)\n[metrics.MicroFBeta](../../api/metrics/MicroFBeta)\n[metrics.MicroJaccard](../../api/metrics/MicroJaccard)\n[metrics.MicroPrecision](../../api/metrics/MicroPrecision)\n[metrics.MicroRecall](../../api/metrics/MicroRecall)\n[metrics.MultiFBeta](../../api/metrics/MultiFBeta)\n[metrics.MutualInfo](../../api/metrics/MutualInfo)\n[metrics.NormalizedMutualInfo](../../api/metrics/NormalizedMutualInfo)\n[metrics.Precision](../../api/metrics/Precision)\n[metrics.R2](../../api/metrics/R2)\n[metrics.RMSE](../../api/metrics/RMSE)\n[metrics.RMSLE](../../api/metrics/RMSLE)\n[metrics.ROCAUC](../../api/metrics/ROCAUC)\n[metrics.Rand](../../api/metrics/Rand)\n[metrics.Recall](../../api/metrics/Recall)\n[metrics.RollingROCAUC](../../api/metrics/RollingROCAUC)\n[metrics.SMAPE](../../api/metrics/SMAPE)\n[metrics.Silhouette](../../api/metrics/Silhouette)\n[metrics.VBeta](../../api/metrics/VBeta)\n[metrics.WeightedF1](../../api/metrics/WeightedF1)\n[metrics.WeightedFBeta](../../api/metrics/WeightedFBeta)\n[metrics.WeightedJaccard](../../api/metrics/WeightedJaccard)\n[metrics.WeightedPrecision](../../api/metrics/WeightedPrecision)\n[metrics.WeightedRecall](../../api/metrics/WeightedRecall)\n[proba.Beta](../../api/proba/Beta)\n[proba.Gaussian](../../api/proba/Gaussian)\n[proba.Multinomial](../../api/proba/Multinomial)\n[proba.MultivariateGaussian](../../api/proba/MultivariateGaussian)\n[stats.BayesianMean](../../api/stats/BayesianMean)\n[stats.Cov](../../api/stats/Cov)\n[stats.KolmogorovSmirnov](../../api/stats/KolmogorovSmirnov)\n[stats.Mean](../../api/stats/Mean)\n[stats.PearsonCorr](../../api/stats/PearsonCorr)\n[stats.SEM](../../api/stats/SEM)\n[stats.Sum](../../api/stats/Sum)\n[stats.Var](../../api/stats/Var)\n</code></pre>"},{"location":"releases/0.0.2/","title":"0.0.2 - 2019-02-13","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.0.2/#compat","title":"compat","text":"<ul> <li>Added <code>sklearn</code> wrappers.</li> </ul>"},{"location":"releases/0.0.2/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.HedgeClassifier</code>.</li> </ul>"},{"location":"releases/0.0.2/#feature_selection","title":"feature_selection","text":"<ul> <li>Added <code>feature_selection.RandomDiscarder</code>.</li> </ul>"},{"location":"releases/0.0.2/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added <code>feature_extraction.TargetEncoder</code>.</li> </ul>"},{"location":"releases/0.0.2/#impute","title":"impute","text":"<ul> <li>Added <code>impute.NumericImputer</code>.</li> </ul>"},{"location":"releases/0.0.2/#optim","title":"optim","text":"<ul> <li>Added <code>optim.AbsoluteLoss</code>.</li> <li>Added <code>optim.HingeLoss</code>.</li> <li>Added <code>optim.EpsilonInsensitiveHingeLoss</code>.</li> </ul>"},{"location":"releases/0.0.2/#stats","title":"stats","text":"<ul> <li>Added <code>stats.NUnique</code>.</li> <li>Added <code>stats.Min</code>.</li> <li>Added <code>stats.Max</code>.</li> <li>Added <code>stats.PeakToPeak</code>.</li> <li>Added <code>stats.Kurtosis</code>.</li> <li>Added <code>stats.Skew</code>.</li> <li>Added <code>stats.Sum</code>.</li> <li>Added <code>stats.EWMean</code>.</li> <li>Made sure the running statistics produce the same results as <code>pandas.DataFrame.rolling</code> method.</li> </ul>"},{"location":"releases/0.0.3/","title":"0.0.3 - 2019-03-21","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.0.3/#base","title":"base","text":"<ul> <li>Calling <code>fit_one</code> now returns the calling instance, not the out-of-fold prediction/transform; <code>fit_predict_one</code>, <code>fit_predict_proba_one</code>, and <code>fit_transform_one</code> are available to reproduce the previous behavior.</li> <li>Binary classifiers now output a <code>dict</code> with probabilities for <code>False</code> and <code>True</code> when calling <code>predict_proba_one</code>, which solves the interface issues of having multi-class classifiers do binary classification.</li> </ul>"},{"location":"releases/0.0.3/#compat","title":"compat","text":"<ul> <li>Added <code>compat.convert_river_to_sklearn</code>.</li> </ul>"},{"location":"releases/0.0.3/#compose","title":"compose","text":"<ul> <li>Added <code>compose.BoxCoxTransformRegressor</code>.</li> <li>Added <code>compose.TargetModifierRegressor</code>.</li> </ul>"},{"location":"releases/0.0.3/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_restaurants</code>.</li> <li>Added <code>datasets.load_airline</code>.</li> </ul>"},{"location":"releases/0.0.3/#dist","title":"dist","text":"<ul> <li>Added <code>dist.Multinomial</code>.</li> <li>Added <code>dist.Normal</code>.</li> </ul>"},{"location":"releases/0.0.3/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.BaggingRegressor</code>.</li> </ul>"},{"location":"releases/0.0.3/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added <code>feature_extraction.TargetGroupBy</code>.</li> </ul>"},{"location":"releases/0.0.3/#impute","title":"impute","text":"<ul> <li>Added <code>impute.CategoricalImputer</code>.</li> </ul>"},{"location":"releases/0.0.3/#linear_model","title":"linear_model","text":"<ul> <li>Added <code>linear_model.FMRegressor</code>.</li> <li>Removed all the passive-aggressive estimators.</li> </ul>"},{"location":"releases/0.0.3/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.Accuracy</code>.</li> <li>Added <code>metrics.MAE</code>.</li> <li>Added <code>metrics.MSE</code>.</li> <li>Added <code>metrics.RMSE</code>.</li> <li>Added <code>metrics.RMSLE</code>.</li> <li>Added <code>metrics.SMAPE</code>.</li> <li>Added <code>metrics.Precision</code>.</li> <li>Added <code>metrics.Recall</code>.</li> <li>Added <code>metrics.F1</code>.</li> </ul>"},{"location":"releases/0.0.3/#model_selection","title":"model_selection","text":"<ul> <li><code>model_selection.online_score</code> can now be passed a <code>metrics.Metric</code> instead of an <code>sklearn</code> metric; it also checks that the provided metric can be used with the accompanying model.</li> </ul>"},{"location":"releases/0.0.3/#naive_bayes","title":"naive_bayes","text":"<ul> <li>Added <code>naive_bayes.GaussianNB</code>.</li> </ul>"},{"location":"releases/0.0.3/#optim","title":"optim","text":"<ul> <li>Added <code>optim.PassiveAggressiveI</code>.</li> <li>Added <code>optim.PassiveAggressiveII</code>.</li> </ul>"},{"location":"releases/0.0.3/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.Discarder</code>.</li> <li>Added <code>preprocessing.PolynomialExtender</code>.</li> <li>Added <code>preprocessing.FuncTransformer</code>.</li> </ul>"},{"location":"releases/0.0.3/#reco","title":"reco","text":"<ul> <li>Added <code>reco.SVD</code>.</li> </ul>"},{"location":"releases/0.0.3/#stats","title":"stats","text":"<ul> <li>Added <code>stats.Mode</code>.</li> <li>Added <code>stats.Quantile</code>.</li> <li>Added <code>stats.RollingQuantile</code>.</li> <li>Added <code>stats.Entropy</code>.</li> <li>Added <code>stats.RollingMin</code>.</li> <li>Added <code>stats.RollingMax</code>.</li> <li>Added <code>stats.RollingMode</code>.</li> <li>Added <code>stats.RollingSum</code>.</li> <li>Added <code>stats.RollingPeakToPeak</code>.</li> </ul>"},{"location":"releases/0.0.3/#stream","title":"stream","text":"<ul> <li>Added <code>stream.iter_csv</code>.</li> </ul>"},{"location":"releases/0.0.3/#tree","title":"tree","text":"<ul> <li>Added <code>tree.MondrianTreeClassifier</code>.</li> <li>Added <code>tree.MondrianTreeRegressor</code>.</li> </ul>"},{"location":"releases/0.1.0/","title":"0.1.0 - 2019-05-08","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.1.0/#base","title":"base","text":"<ul> <li>Removed the <code>fit_predict_one</code> estimator method.</li> <li>Removed the <code>fit_predict_proba_one</code> estimator method.</li> <li>Removed the <code>fit_transform_one</code> estimator method.</li> </ul>"},{"location":"releases/0.1.0/#compat","title":"compat","text":"<ul> <li>Added <code>compat.convert_sklearn_to_river</code>.</li> <li><code>compat.convert_river_to_sklearn</code> now returns an <code>sklearn.pipeline.Pipeline</code> when provided with a <code>compose.Pipeline</code>.</li> </ul>"},{"location":"releases/0.1.0/#compose","title":"compose","text":"<ul> <li>Added <code>compose.Discard</code>.</li> <li>Added <code>compose.Select</code>.</li> <li>Added <code>compose.SplitRegressor</code>.</li> <li>The <code>draw</code> method of <code>compose.Pipeline</code> now works properly for arbitrary amounts of nesting, including multiple nested <code>compose.FeatureUnion</code>.</li> </ul>"},{"location":"releases/0.1.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_electricity</code>.</li> </ul>"},{"location":"releases/0.1.0/#dummy","title":"dummy","text":"<ul> <li>Added <code>dummy.NoChangeClassifier</code>.</li> <li>Added <code>dummy.PriorClassifier</code>.</li> <li>Added <code>dummy.StatisticRegressor</code>.</li> </ul>"},{"location":"releases/0.1.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added <code>feature_extraction.Differ</code>.</li> <li>Renamed <code>feature_extraction.GroupBy</code> to <code>feature_extraction.Agg</code>.</li> <li>Renamed <code>feature_extraction.TargetGroupBy</code> to <code>feature_extraction.TargetAgg</code>.</li> </ul>"},{"location":"releases/0.1.0/#feature_selection","title":"feature_selection","text":"<ul> <li>Added <code>feature_selection.SelectKBest</code>.</li> <li>Added <code>feature_selection.VarianceThreshold</code>.</li> </ul>"},{"location":"releases/0.1.0/#impute","title":"impute","text":"<ul> <li>Added <code>impute.StatImputer</code>.</li> <li>Removed <code>impute.CategoricalImputer</code>.</li> <li>Removed <code>impute.NumericImputer</code>.</li> </ul>"},{"location":"releases/0.1.0/#linear_model","title":"linear_model","text":"<ul> <li>Added <code>linear_model.PAClassifier</code>.</li> <li>Added <code>linear_model.PARegressor</code>.</li> <li>Added <code>linear_model.SoftmaxRegression</code>.</li> </ul>"},{"location":"releases/0.1.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.ConfusionMatrix</code>.</li> <li>Added <code>metrics.CrossEntropy</code>.</li> <li>Added <code>metrics.MacroF1</code>.</li> <li>Added <code>metrics.MacroPrecision</code>.</li> <li>Added <code>metrics.MacroRecall</code>.</li> <li>Added <code>metrics.MicroF1</code>.</li> <li>Added <code>metrics.MicroPrecision</code>.</li> <li>Added <code>metrics.MicroRecall</code>.</li> <li>Each metric now has a <code>bigger_is_better</code> property to indicate if a high value is better than a low one or not.</li> </ul>"},{"location":"releases/0.1.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.OptimalLR</code>.</li> <li>Added <code>optim.CrossEntropy</code>.</li> <li>Removed <code>optim.PassiveAggressiveI</code>.</li> <li>Removed <code>optim.PassiveAggressiveII</code>.</li> </ul>"},{"location":"releases/0.1.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Removed <code>preprocessing.Discarder</code>.</li> <li>Added <code>on</code> and <code>sparse</code> parameters to <code>preprocessing.OneHotEncoder</code>.</li> </ul>"},{"location":"releases/0.1.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.Covariance</code>.</li> <li>Added <code>stats.PearsonCorrelation</code>.</li> <li>Added <code>stats.SmoothMean</code>.</li> </ul>"},{"location":"releases/0.1.0/#utils","title":"utils","text":"<ul> <li>Added <code>utils.check_estimator</code>.</li> <li>Added <code>utils.Histogram</code>.</li> <li>Added <code>utils.SortedWindow</code>.</li> <li>Added <code>utils.Window</code>.</li> </ul>"},{"location":"releases/0.10.0/","title":"0.10.0 - 2022-02-04","text":""},{"location":"releases/0.10.0/#base","title":"base","text":"<ul> <li>Introduce <code>base.MiniBatchTransformer</code>. Add support for mini-batches to <code>compose.TransformerUnion</code>, <code>compose.Select</code>, and <code>preprocessing.OneHotEncoder</code>.</li> </ul>"},{"location":"releases/0.10.0/#checks","title":"checks","text":"<ul> <li>Created this module to store estimator unit testing, rather than having it in the <code>utils</code> module.</li> </ul>"},{"location":"releases/0.10.0/#compose","title":"compose","text":"<ul> <li>Split <code>compose.Renamer</code> into <code>compose.Prefixer</code> and <code>compose.Suffixer</code> that respectively prepend and append a string to the features' name.</li> <li>Changed <code>compose.Renamer</code> to allow feature renaming following a mapping.</li> </ul>"},{"location":"releases/0.10.0/#evaluate","title":"evaluate","text":"<ul> <li>Refactored <code>evaluate.progressive_validation</code> to work with <code>api.anomaly.base.AnomalyDetector</code>s.</li> </ul>"},{"location":"releases/0.10.0/#facto","title":"facto","text":"<ul> <li>Added <code>debug_one</code> method to <code>BaseFM</code>.</li> </ul>"},{"location":"releases/0.10.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Make the <code>by</code> parameter in <code>feature_extraction.Agg</code> and <code>feature_extraction.TargetAgg</code> to be optional, allowing to calculate aggregates over the whole data.</li> <li>Removed <code>feature_extraction.Lagger</code> and <code>feature_extraction.TargetLagger</code>. Their functionality can be reproduced by combining <code>feature_extraction.Agg</code> and <code>stats.Shift</code>.</li> <li><code>feature_extraction.Agg</code> and <code>feature_extraction.Target</code> now have a <code>state</code> property. It returns a <code>pandas.Series</code> representing the current aggregates values within each group.</li> </ul>"},{"location":"releases/0.10.0/#metrics","title":"metrics","text":"<ul> <li><code>metrics.ROCAUC</code> works with <code>base.AnomalyDetectors</code>s.</li> </ul>"},{"location":"releases/0.10.0/#misc","title":"misc","text":"<ul> <li>Created this module to store some stuff that was in the <code>utils</code> module but wasn't necessarily shared between modules.</li> <li>Implement <code>misc.CovMatrix</code>.</li> </ul>"},{"location":"releases/0.10.0/#reco","title":"reco","text":"<ul> <li>Renamed the <code>Recommender</code> base class into <code>Ranker</code>.</li> <li>Added a <code>rank</code> method to each recommender.</li> <li>Removed <code>reco.SurpriseWrapper</code> as it wasn't really useful.</li> <li>Added an <code>is_contextual</code> property to each ranker to indicate if a model makes use of contextual features or not.</li> </ul>"},{"location":"releases/0.10.0/#stats","title":"stats","text":"<ul> <li><code>stats.Mean</code>, <code>stats.Var</code>, and <code>stats.Cov</code> each now have an <code>update_many</code> method which accepts numpy arrays.</li> </ul>"},{"location":"releases/0.10.0/#utils","title":"utils","text":"<ul> <li>Removed <code>utils.Window</code> and use <code>collections.deque</code> instead where necessary.</li> </ul>"},{"location":"releases/0.10.1/","title":"0.10.1 - 2022-02-05","text":""},{"location":"releases/0.10.1/#evaluate","title":"evaluate","text":"<p><code>evaluate.progressive_val_score</code> can now handle models which use <code>**kwargs</code> in their <code>learn_one</code> and <code>predict_one</code> methods. For instance, this is useful for <code>reco.Ranker</code> models which require passing a user and an item.</p>"},{"location":"releases/0.11.0/","title":"0.11.0 - 2022-05-28","text":"<ul> <li>Moved all metrics in <code>metrics.cluster</code> except <code>metrics.Silhouette</code> to river-extra.</li> </ul>"},{"location":"releases/0.11.0/#anomaly","title":"anomaly","text":"<ul> <li>There is now a <code>anomaly.base.SupervisedAnomalyDetector</code> base class for supervised anomaly detection.</li> <li>Added <code>api.anomaly.GaussianScorer</code>, which is the first supervised anomaly detector.</li> <li>There is now a <code>anomaly.base.AnomalyFilter</code> base class for anomaly filtering methods. These allow to classify anomaly scores. They can also prevent models from learning on anomalous data, for instance by putting them as an initial step of a pipeline.</li> <li>Added <code>anomaly.ConstantFilter</code> and <code>QuantileFilter</code>, which are the first anomaly filters.</li> <li>Removed <code>anomaly.ConstantThresholder</code> and <code>anomaly.QuantileThresholder</code>, as they overlap with the new anomaly filtering mechanism.</li> </ul>"},{"location":"releases/0.11.0/#base","title":"base","text":"<ul> <li>Fixed an issue where the <code>_raw_memory_usage</code> property would spin into an infinite loop if a model's property was an <code>itertools.count</code>.</li> </ul>"},{"location":"releases/0.11.0/#dataset","title":"dataset","text":"<ul> <li>Added the <code>datasets.WaterFlow</code> dataset.</li> </ul>"},{"location":"releases/0.11.0/#dist","title":"dist","text":"<ul> <li>A <code>revert</code> method has been added to <code>stats.Gaussian</code>.</li> <li>A <code>revert</code> method has been added to <code>stats.Multinomial</code>.</li> <li>Added <code>dist.TimeRolling</code> to measure probability distributions over windows of time.</li> </ul>"},{"location":"releases/0.11.0/#drift","title":"drift","text":"<ul> <li>Add the <code>PeriodicTrigger</code> detector, a baseline capable of producing drift signals in regular or random intervals.</li> <li>The numpy usage was removed in <code>drift.KSWIN</code> in favor of <code>collections.deque</code>. Appending or deleting elements to numpy arrays imply creating another object.</li> <li>Added the seed parameter to <code>drift.KSWIN</code> to control reproducibility.</li> <li>The Kolmogorov-Smirnov test mode was changed to the default (<code>\"auto\"</code>) to suppress warnings (<code>drift.KSWIN</code>).</li> <li>Unnecessary usage of numpy was also removed in other concept drift detectors.</li> </ul>"},{"location":"releases/0.11.0/#ensemble","title":"ensemble","text":"<ul> <li>Streamline <code>SRP{Classifier,Regressor}</code>, remove unneeded numpy usage, make SRP variants robust against missing features, and fix bugs.</li> <li>Remove unneeded numpy usage <code>AdaptiveRandomForest{Classifier,Regressor}</code>.</li> </ul>"},{"location":"releases/0.11.0/#evaluate","title":"evaluate","text":"<ul> <li>Added a <code>iter_progressive_val_score</code> function, which does the same as <code>progressive_val_score</code>, except that it yields rather than prints results at each step, which give more control to the user.</li> </ul>"},{"location":"releases/0.11.0/#imblearn","title":"imblearn","text":"<ul> <li>Added <code>imblearn.ChebyshevUnderSampler</code> and <code>imblearn.ChebyshevOverSampler</code> for imbalanced regression.</li> </ul>"},{"location":"releases/0.11.0/#linear_model","title":"linear_model","text":"<ul> <li><code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code> now correctly apply the <code>l2</code> regularization when their <code>learn_many</code> method is used.</li> <li>Added <code>l1</code> regularization (implementation with cumulative penalty, see paper) for <code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code></li> </ul>"},{"location":"releases/0.11.0/#neighbors","title":"neighbors","text":"<ul> <li><code>neighbors.KNNADWINClassifier</code> and <code>neighbors.SAMKNNClassifier</code> have been deprecated.</li> <li>Introduced <code>neighbors.NearestNeighbors</code> for searching nearest neighbors.</li> <li>Vastly refactored and simplified the nearest neighbors logic.</li> </ul>"},{"location":"releases/0.11.0/#proba","title":"proba","text":"<ul> <li>Added <code>proba.Rolling</code> to measure a probability distribution over a window.</li> </ul>"},{"location":"releases/0.11.0/#rules","title":"rules","text":"<ul> <li>AMRules's <code>debug_one</code> explicitly indicates the prediction strategy used by each rule.</li> <li>Fix bug in <code>debug_one</code> (AMRules) where prediction explanations were incorrectly displayed when <code>ordered_rule_set=True</code>.</li> </ul>"},{"location":"releases/0.11.0/#time_series","title":"time_series","text":"<ul> <li>Added an <code>iter_evaluate</code> function to trace the evaluation at each sample in a dataset.</li> </ul>"},{"location":"releases/0.11.0/#tree","title":"tree","text":"<ul> <li>Fix bug in Naive Bayes-based leaf prediction.</li> <li>Remove unneeded numpy usage in <code>HoeffdingAdaptiveTree{Classifier,Regressor}</code>.</li> </ul>"},{"location":"releases/0.11.0/#stats","title":"stats","text":"<ul> <li>A <code>revert</code> method has been added to <code>stats.Var</code>.</li> </ul>"},{"location":"releases/0.11.1/","title":"0.11.1 - 2022-06-06","text":"<p>A small release to introduce benchmarks.</p>"},{"location":"releases/0.11.1/#anomaly","title":"anomaly","text":"<ul> <li>Fixed a bug where anomaly filters were never updated.</li> </ul>"},{"location":"releases/0.12.0/","title":"0.12.0 - 2022-09-02","text":"<ul> <li>Moved all the public modules imports from <code>river/__init__.py</code> to <code>river/api.py</code> and removed unnecessary dependencies between modules enabling faster cherry-picked import times (~3x).</li> <li>Adding wheels for Python 3.11.</li> </ul>"},{"location":"releases/0.12.0/#base","title":"base","text":"<ul> <li>Introduced an <code>mutate</code> method to the <code>base.Base</code> class. This allows setting attributes in a controlled manner, which paves the way for online AutoML. See the recipe for more information.</li> </ul>"},{"location":"releases/0.12.0/#compat","title":"compat","text":"<ul> <li>Moved the PyTorch wrappers to river-extra.</li> </ul>"},{"location":"releases/0.12.0/#covariance","title":"covariance","text":"<ul> <li>Created a new <code>covariance</code> module to hold everything related to covariance and inversion covariance matrix estimation.</li> <li>Moved <code>misc.CovarianceMatrix</code> to <code>covariance.EmpiricalCovariance</code>.</li> <li>Added <code>covariance.EmpiricalPrecision</code> to estimate the inverse covariance matrix.</li> </ul>"},{"location":"releases/0.12.0/#compose","title":"compose","text":"<ul> <li>Moved <code>utils.pure_inference_mode</code> to <code>compose.pure_inference_mode</code> and <code>utils.warm_up_mode</code> to <code>compose.warm_up_mode</code>.</li> <li>Pipeline parts can now be accessed by integer positions as well as by name.</li> </ul>"},{"location":"releases/0.12.0/#datasets","title":"datasets","text":"<ul> <li>Imports <code>synth</code>, enabling `from river import datasets; datasets.synth.</li> </ul>"},{"location":"releases/0.12.0/#drift","title":"drift","text":"<ul> <li>Refactor the concept drift detectors to match the remaining of River's API. Warnings are only issued by detectors that support this feature.</li> <li>Drifts can be assessed via the property <code>drift_detected</code>. Warning signals can be accessed by the property <code>warning_detected</code>. The <code>update</code> now returns <code>self</code>.</li> <li>Ensure all detectors automatically reset their inner states after a concept drift detection.</li> <li>Streamline <code>DDM</code>, <code>EDDM</code>, <code>HDDM_A</code>, and <code>HDDM_W</code>. Make the configurable parameters names match their respective papers.</li> <li>Fix bugs in <code>EDDM</code> and <code>HDDM_W</code>.</li> <li>Enable two-sided tests in <code>PageHinkley</code>.</li> <li>Improve documentation and update tests.</li> </ul>"},{"location":"releases/0.12.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Added a <code>tokenizer_pattern</code> parameter to <code>feature_extraction.BagOfWords</code> and <code>feature_extraction.TFIDF</code> to override the default pattern used for tokenizing text.</li> <li>Added a <code>stop_words</code> parameter to <code>feature_extraction.BagOfWords</code> and <code>feature_extraction.TFIDF</code> for removing stop words once the text has been tokenized.</li> </ul>"},{"location":"releases/0.12.0/#linear_model","title":"linear_model","text":"<ul> <li>After long ado, we've finally implemented <code>linear_model.BayesianLinearRegression</code>.</li> </ul>"},{"location":"releases/0.12.0/#metrics","title":"metrics","text":"<ul> <li>Removed dependency to <code>optim</code>.</li> <li>Removed <code>metrics.Rolling</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>metrics.TimeRolling</code>, due to the addition of <code>utils.Rolling</code>.</li> </ul>"},{"location":"releases/0.12.0/#proba","title":"proba","text":"<ul> <li>Removed <code>proba.Rolling</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>proba.TimeRolling</code>, due to the addition of <code>utils.Rolling</code>.</li> </ul>"},{"location":"releases/0.12.0/#rule","title":"rule","text":"<ul> <li>The default <code>splitter</code> was changed to <code>tree.splitter.TEBST</code> for memory and running time efficiency.</li> </ul>"},{"location":"releases/0.12.0/#stats","title":"stats","text":"<ul> <li>Removed <code>stats.RollingMean</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>stats.RollingVar</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>stats.RollingCov</code>, due to the addition of <code>utils.Rolling</code>.</li> <li>Removed <code>stats.RollingPearsonCorr</code>, due to the addition of <code>utils.Rolling</code>.</li> </ul>"},{"location":"releases/0.12.0/#stream","title":"stream","text":"<ul> <li><code>stream.iter_array</code> now handles text data.</li> <li>Added <code>stream.TwitterLiveStream</code>, to listen to a filtered live stream of Tweets.</li> </ul>"},{"location":"releases/0.12.0/#time_series","title":"time_series","text":"<ul> <li>Added <code>time_series.HorizonAggMetric</code>.</li> <li>Fixed a bug in <code>time_series.SNARIMAX</code> where the number of seasonal components was not correct when <code>sp</code> or <code>sq</code> were specified.</li> <li>Fixed the differencing logic in <code>time_series.SNARIMAX</code> when <code>d</code> or <code>sd</code> were specified.</li> </ul>"},{"location":"releases/0.12.0/#tree","title":"tree","text":"<ul> <li>Rename <code>split_confidence</code> and <code>tie_threshold</code> to <code>delta</code> and <code>tau</code>, respectively. This way, the parameters are not misleading and match what the research papers have used for decades.</li> <li>Refactor <code>HoeffdingAdaptiveTree{Classifier,Regressor}</code> to allow the usage of any drift detector. Expose the significance level of the test used to switch between subtrees as a user-defined parameter.</li> <li>Correct test used to switch between foreground and background subtrees in <code>HoeffdingAdaptiveTreeRegressor</code>. Due to the continuous and unbounded nature of the monitored errors, a z-test is now performed to decide which subtree to keep.</li> <li>The default <code>leaf_prediction</code> value was changed to <code>\"adaptive\"</code>, as this often results in the smallest errors in practice.</li> <li>The default <code>splitter</code> was changed to <code>tree.splitter.TEBST</code> for memory and running time efficiency.</li> </ul>"},{"location":"releases/0.12.0/#utils","title":"utils","text":"<ul> <li>Removed dependencies to <code>anomaly</code> and <code>compose</code>.</li> <li>Added <code>utils.Rolling</code> and <code>utils.TimeRolling</code>, which are generic wrappers for computing over a window (of time).</li> <li>Use binary search to speed-up element removal in <code>utils.SortedWindow</code>.</li> </ul>"},{"location":"releases/0.12.1/","title":"0.12.1 - 2022-09-02","text":""},{"location":"releases/0.12.1/#base","title":"base","text":"<ul> <li>Fix the way the <code>clone</code> method handles positional arguments.</li> </ul>"},{"location":"releases/0.13.0/","title":"0.13.0 - 2022-09-15","text":""},{"location":"releases/0.13.0/#compose","title":"compose","text":"<ul> <li><code>compose.TransformerUnion</code> parts can now be accessed by index as well as by name.</li> </ul>"},{"location":"releases/0.13.0/#stats","title":"stats","text":"<ul> <li>Added the <code>LossyCount</code> for tracking frequent itemsets. This implementation also supports a forgetting factor to reduce the influence of old elements.</li> <li>The following statistics are now implemented in Rust:</li> <li><code>Quantile</code></li> <li><code>EWMean</code></li> <li><code>EWVar</code></li> <li><code>IQR</code></li> <li><code>Kurtosis</code></li> <li><code>PeaktoPeak</code></li> <li><code>Skew</code></li> <li><code>RollingQuantile</code></li> <li><code>RollingIQR</code></li> </ul>"},{"location":"releases/0.13.0/#stream","title":"stream","text":"<ul> <li>Implemented <code>stream.TwitchChatStream</code>.</li> </ul>"},{"location":"releases/0.14.0/","title":"0.14.0 - 2022-10-26","text":"<ul> <li>Introducing the <code>bandit</code> module for running multi-armed bandits</li> <li>Introducing the <code>sketch</code> module with summarization tools and data sketches working in a streaming fashion!</li> </ul>"},{"location":"releases/0.14.0/#bandit","title":"bandit","text":"<ul> <li>Added <code>bandit.EpsilonGreedy</code>.</li> <li>Added <code>bandit.UCB</code>.</li> <li>Added <code>bandit.ThomsonSampling</code>.</li> <li>Added a <code>bandit.base</code> module.</li> <li>Added <code>bandit.envs.CandyCaneContest</code>, which implements the Gym interface.</li> <li>Added <code>bandit.envs.KArmedTestbed</code>, which implements the Gym interface.</li> <li>Added <code>bandit.evaluate</code> for basic benchmarking of bandit policies on a Gym environment.</li> </ul>"},{"location":"releases/0.14.0/#drift","title":"drift","text":"<ul> <li>Exposed more parameters in ADWIN: <code>clock</code>, <code>max_buckets</code>, <code>min_window_length</code>, and <code>grace_period</code>.</li> </ul>"},{"location":"releases/0.14.0/#model_selection","title":"model_selection","text":"<ul> <li>Added <code>model_selection.BanditRegressor</code>, which is a generic model selection method that works with any bandit policy.</li> <li>Removed <code>model_selection.EpsilonGreedyRegressor</code> due to the addition of <code>model_selection.BanditRegressor</code>.</li> <li>Removed <code>model_selection.UCBRegressor</code> due to the addition of <code>model_selection.BanditRegressor</code>.</li> </ul>"},{"location":"releases/0.14.0/#proba","title":"proba","text":"<ul> <li>Added <code>proba.Beta</code>.</li> <li>Added a <code>sample</code> method to each distribution.</li> <li>Added a <code>mode</code> property to each distribution.</li> <li>Replaced the <code>pmf</code> and <code>pdf</code> methods with a <code>__call__</code> method.</li> </ul>"},{"location":"releases/0.14.0/#sketch","title":"sketch","text":"<ul> <li>Moved <code>misc.Histogram</code> to <code>sketch.Histogram</code>.</li> <li>Moved <code>stats.LossyCount</code> to <code>sketch.HeavyHitters</code> and update its API to better match <code>collections.Counter</code>.</li> <li>Added missing return <code>self</code> in <code>HeavyHitters</code>.</li> <li>Added the Count-Min Sketch (<code>sketch.Counter</code>) algorithm for approximate element counting.</li> <li>Added an implementation of Bloom filter (<code>sketch.Set</code>) to provide approximate set-like operations.</li> </ul>"},{"location":"releases/0.15.0/","title":"0.15.0 - 2023-01-29","text":""},{"location":"releases/0.15.0/#active","title":"active","text":"<ul> <li>Created this module dedicated to online active learning.</li> <li>Added <code>api.active.EntropySampler</code>.</li> </ul>"},{"location":"releases/0.15.0/#base","title":"base","text":"<ul> <li>Fixed an issue where an estimator that has attribute a pipeline could not be cloned.</li> <li>Added a <code>base.DriftAndWarningDetector</code> to clarify the difference between drift detectors that have a <code>warning_detected</code> property and those that don't.</li> <li>Added <code>MultiLabelClassifier</code>.</li> <li>Added <code>MultiTargetRegressor</code>.</li> <li>Added <code>drift.BinaryDriftDetector</code>.</li> <li>Added <code>drift.BinaryDriftAndWarningDetector</code>.</li> </ul>"},{"location":"releases/0.15.0/#conf","title":"conf","text":"<ul> <li>Introduced this new module to perform conformal predictions.</li> <li>Added a <code>conf.Interval</code> dataclass to represent predictive intervals.</li> <li>Added <code>conf.RegressionJackknife</code>.</li> </ul>"},{"location":"releases/0.15.0/#datasets","title":"datasets","text":"<ul> <li>Removed unnecessary Numpy usage in the <code>synth</code> submodule.</li> <li>Changed <code>np.random.RandomState</code> to <code>np.random.default_rng</code> where necessary.</li> </ul>"},{"location":"releases/0.15.0/#drift","title":"drift","text":"<ul> <li>Added <code>drift.DriftRetrainingClassifier</code>.</li> <li>Renamed <code>drift.PeriodicTrigger</code> to <code>drift.DummyDriftDetector</code> to clarify it is a naive baseline.</li> <li>Created a <code>binary</code> submodule to organize all drift detectors which only apply to binary inputs.</li> </ul>"},{"location":"releases/0.15.0/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.ADWINBoostingClassifier</code>.</li> <li>Added <code>ensemble.BOLEClassifier</code>.</li> </ul>"},{"location":"releases/0.15.0/#evaluate","title":"evaluate","text":"<ul> <li><code>evaluate.progressive_val_score</code> and <code>evaluate.iter_progressive_val_score</code> will now also produce a report once the last sample has been processed, in addition to every <code>print_every</code> steps.</li> </ul>"},{"location":"releases/0.15.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li><code>feature_extraction.BagOfWords</code> now outputs a dictionary, and not a <code>collections.Counter</code>.</li> </ul>"},{"location":"releases/0.15.0/#forest","title":"forest","text":"<ul> <li>Created this new module to host all models based on an ensemble of decision trees.</li> <li>Moved <code>ensemble.AdaptiveRandomForestClassifier</code> to <code>forest.ARFClassifier</code>.</li> <li>Moved <code>ensemble.AdaptiveRandomForestRegressor</code> to <code>forest.ARFRegressor</code>.</li> <li>Added <code>forest.AMFClassifier</code>.</li> <li>Added <code>forest.OXTRegressor</code>.</li> </ul>"},{"location":"releases/0.15.0/#linear_model","title":"linear_model","text":"<ul> <li>Renamed <code>use_dist</code> to <code>with_dist</code> in <code>linear_model.BayesianLinearRegression</code>'s <code>predict_one</code> method.</li> </ul>"},{"location":"releases/0.15.0/#multiclass","title":"multiclass","text":"<ul> <li>Added a <code>coding_method</code> method to <code>multiclass.OCC</code> to control how the codes are randomly generated.</li> </ul>"},{"location":"releases/0.15.0/#multioutput","title":"multioutput","text":"<ul> <li>Added <code>MultiClassEncoder</code> to convert multi-label tasks into multi-class problems.</li> </ul>"},{"location":"releases/0.15.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>preprocessing.AdaptiveStandardScaler</code>.</li> </ul>"},{"location":"releases/0.15.0/#rules","title":"rules","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>rules.AMRules</code>.</li> </ul>"},{"location":"releases/0.15.0/#sketch","title":"sketch","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>sketch.HeavyHitters</code>.</li> </ul>"},{"location":"releases/0.15.0/#stats","title":"stats","text":"<ul> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>stats.Entropy</code>.</li> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>stats.EWMean</code>.</li> <li>Renamed <code>alpha</code> to <code>fading_factor</code> in <code>stats.EWVar</code>.</li> </ul>"},{"location":"releases/0.15.0/#stream","title":"stream","text":"<ul> <li>Upgraded <code>stream.iter_sql</code> to SQLAlchemy 2.0.</li> </ul>"},{"location":"releases/0.15.0/#tree","title":"tree","text":"<ul> <li>Remove <code>LabelCombinationHoeffdingTreeClassifier</code>. New code should use <code>multioutput.MulticlassEncoder</code> instead.</li> </ul>"},{"location":"releases/0.15.0/#utils","title":"utils","text":"<ul> <li>Removed artifacts from the merger.</li> </ul>"},{"location":"releases/0.16.0/","title":"0.16.0 - 2023-05-08","text":"<p>Added wheels for Python 3.11.</p>"},{"location":"releases/0.16.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li><code>feature_extraction.Agg</code> and <code>feature_extraction.TargetAgg</code> can now be passed an optional <code>t</code> in its <code>learn_one</code> method, which allows it to work with <code>utils.TimeRolling</code>.</li> </ul>"},{"location":"releases/0.16.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.MAPE</code>.</li> <li>Added <code>metrics.RollingROCAUC</code>.</li> </ul>"},{"location":"releases/0.16.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.GaussianRandomProjector</code>.</li> <li>Added <code>preprocessing.SparseRandomProjector</code>.</li> </ul>"},{"location":"releases/0.16.0/#stats","title":"stats","text":"<ul> <li>Fixed randomness issue with the first few outputs of <code>stats.Quantile</code>.</li> </ul>"},{"location":"releases/0.17.0/","title":"0.17.0 - 2023-05-27","text":""},{"location":"releases/0.17.0/#bandit","title":"bandit","text":"<ul> <li>Bandit policies now return a single arm when the <code>pull</code> method is called, instead of yielding or one more arms at a time. This is simpler to understand. We will move back to multi-armed pulls in the future.</li> <li>Added <code>bandit.Exp3</code>.</li> <li><code>bandit.UCB</code> and <code>bandit.Exp3</code> have an extra <code>reward_scaler</code> parameter, which can be any object that inherits from <code>compose.TargetTransformRegressor</code>. This allows scaling rewards before updating arms.</li> </ul>"},{"location":"releases/0.17.0/#compose","title":"compose","text":"<ul> <li><code>compose.TransformerProduct</code> now correctly returns a <code>compose.TransformerUnion</code> when a transformer is added to it.</li> <li>Fixed <code>compose.TransformerProduct</code>'s <code>transform_many</code> behavior.</li> <li><code>compose.TransformerUnion</code> and <code>compose.TransformerProduct</code> will now clone the provided estimators, so that shallow copies aren't shared in different places.</li> </ul>"},{"location":"releases/0.17.0/#model_selection","title":"model_selection","text":"<ul> <li>Added <code>model_selection.BanditClassifier</code>, which is the classification equivalent to <code>bandit.BanditRegressor</code>. Both are methods to perform online model selection via a bandit policy.</li> </ul>"},{"location":"releases/0.17.0/#multioutput","title":"multioutput","text":"<ul> <li><code>metrics.multioutput.MacroAverage</code> and <code>metrics.multioutput.MicroAverage</code> now loop over the keys of <code>y_true</code> instead of <code>y_pred</code>. This ensures a <code>KeyError</code> is correctly raised if <code>y_pred</code> is missing an output that is present in <code>y_true</code>.</li> </ul>"},{"location":"releases/0.17.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.TargetMinMaxScaler</code>, which operates the same as <code>preprocessing.TargetStandardScaler</code>, but instead uses min-max scaling.</li> </ul>"},{"location":"releases/0.18.0/","title":"0.18.0 - 2023-06-26","text":""},{"location":"releases/0.18.0/#bandit","title":"bandit","text":"<ul> <li>Added <code>bandit.BayesUCB</code>.</li> <li>Added <code>bandit.evaluate_offline</code>, for evaluating bandits on historical (logged) data.</li> </ul>"},{"location":"releases/0.18.0/#cluster","title":"cluster","text":"<ul> <li><code>DBStream</code> will now only recluster on demand, rather than at every call to <code>learn_one</code>.</li> </ul>"},{"location":"releases/0.18.0/#compat","title":"compat","text":"<ul> <li>The <code>predict_many</code> method scikit-learn models wrapped with <code>compat.convert_sklearn_to_river</code> raised an exception if the model had not been fitted on any data yet. Instead, default predictions will be produced, which is consistent with the rest of River.</li> <li><code>compat.SKL2RiverRegressor</code> and <code>compat.SKL2RiverClassifier</code> didn't check whether features were ordered in the same way at each method call. They now store the list of feature names at the first function call, and align subsequent inputs in the same order.</li> </ul>"},{"location":"releases/0.18.0/#compose","title":"compose","text":"<ul> <li><code>compose.TransformerProduct</code> will now preserve the density of sparse columns.</li> <li>Added a <code>transform_many</code> method to <code>compose.FuncTransformer</code>, allowing it to be used in mini-batch pipelines.</li> <li>The <code>compose.pure_inference_mode</code> now works with mini-batching.</li> </ul>"},{"location":"releases/0.18.0/#neighbors","title":"neighbors","text":"<ul> <li>Added <code>neighbors.SWINN</code> to power-up approximate nearest neighbor search. SWINN uses graphs to speed up nearest neighbor search in large sliding windows of data.</li> <li>Renamed <code>neighbors.NearestNeighbors</code> to <code>neighbors.LazySearch</code>.</li> <li>Standardize and create base classes for generic nearest neighbor search utilities.</li> <li>The user can now select the nearest neighbor search engine to use in <code>neighbors.KNNClassifier</code> and <code>neighbors.KNNRegressor</code>.</li> </ul>"},{"location":"releases/0.18.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Rename <code>sparse</code> parameter to <code>drop_zeros</code> in <code>preprocessing.OneHotEncoder</code>.</li> <li>The <code>transform_many</code> method of <code>preprocessing.OneHotEncoder</code> will now return a sparse dataframe, rather than a dense one, which will consume much less memory.</li> </ul>"},{"location":"releases/0.18.0/#proba","title":"proba","text":"<ul> <li>Added a <code>cdf</code> method to <code>proba.Beta</code>.</li> </ul>"},{"location":"releases/0.18.0/#tree","title":"tree","text":"<ul> <li>Expose the <code>min_branch_fraction</code> parameter to avoid splits where most of the data goes to a single branch. Affects   classification trees.</li> <li>Added the <code>max_share_to_split</code> parameter to Hoeffding Tree classifiers. This parameters avoids splitting when the majority   class has most of the data.</li> </ul>"},{"location":"releases/0.18.0/#utils","title":"utils","text":"<ul> <li>Fixed <code>utils.math.minkowski_distance</code>.</li> </ul>"},{"location":"releases/0.19.0/","title":"0.19.0 - 2023-08-02","text":"<p>Calling <code>learn_one</code> in a pipeline will now update each part of the pipeline in turn. Before the unsupervised parts of the pipeline were updated during <code>predict_one</code>. This is more intuitive for new users. The old behavior, which yields better results, can be restored by calling <code>learn_one</code> with the new <code>compose.learn_during_predict</code> context manager.</p>"},{"location":"releases/0.19.0/#bandit","title":"bandit","text":"<ul> <li>Added a <code>bandit.datasets</code> submodule, which is meant to contain contextual bandit datasets.</li> <li>Added <code>bandit.base.ContextualPolicy</code>.</li> <li>Added <code>bandit.datasets.NewsArticles</code>.</li> <li>Added <code>bandit.LinUCBDisjoint</code>, which is River's first contextual bandit policy.</li> <li>Added <code>bandit.RandomPolicy</code>.</li> </ul>"},{"location":"releases/0.19.0/#compose","title":"compose","text":"<ul> <li>Removed the <code>compose.warm_up_mode</code> context manager.</li> <li>Removed the <code>compose.pure_inference_mode</code> context manager.</li> <li>The last step of a pipeline will be correctly updated if it is unsupervised, which wasn't the case before.</li> <li>Fixed an edge-case where <code>compose.TransformerProduct</code> would not work when chained more than twice.</li> </ul>"},{"location":"releases/0.19.0/#drift","title":"drift","text":"<ul> <li>Added a <code>datasets</code> submodule, which contains datasets that are useful for concept drift experiments.</li> <li>Fix bugs in <code>drift.binary.HDDM_A</code> and <code>drift.binary.HDDM_W</code>.</li> </ul>"},{"location":"releases/0.19.0/#linear_model","title":"linear_model","text":"<ul> <li>Added a <code>predict_many</code> method to <code>linear_model.BayesianLinearRegression</code>.</li> <li>Added a <code>smoothing</code> parameter to <code>linear_model.BayesianLinearRegression</code>, which allows it to cope with concept drift.</li> </ul>"},{"location":"releases/0.19.0/#forest","title":"forest","text":"<ul> <li>Fixed issue with <code>forest.ARFClassifier</code> which couldn't be passed a <code>CrossEntropy</code> metric.</li> <li>Fixed a bug in <code>forest.AMFClassifier</code> which slightly improves predictive accuracy.</li> <li>Added <code>forest.AMFRegressor</code>.</li> </ul>"},{"location":"releases/0.19.0/#multioutput","title":"multioutput","text":"<ul> <li>Added <code>metrics.multioutput.SampleAverage</code>, which is equivalent to using <code>average='samples'</code> in scikit-learn.</li> </ul>"},{"location":"releases/0.19.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.OrdinalEncoder</code>, to map string features to integers.</li> <li>The <code>transform_many</code> method of <code>preprocessing.StandardScaler</code> now uses the dtype of the input for the output.</li> </ul>"},{"location":"releases/0.19.0/#proba","title":"proba","text":"<ul> <li>Added <code>proba.MultivariateGaussian</code>.</li> </ul>"},{"location":"releases/0.19.0/#stream","title":"stream","text":"<ul> <li><code>stream.iter_arff</code> now supports sparse data.</li> <li><code>stream.iter_arff</code> now supports multi-output targets.</li> <li><code>stream.iter_arff</code> now supports missing values indicated with question marks.</li> </ul>"},{"location":"releases/0.19.0/#utils","title":"utils","text":"<ul> <li>Added <code>utils.random.exponential</code> to retrieve random samples following an exponential distribution.</li> </ul>"},{"location":"releases/0.2.0/","title":"0.2.0 - 2019-05-27","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.2.0/#compose","title":"compose","text":"<ul> <li><code>compose.Pipeline</code> now has a <code>debug_one</code>.</li> <li><code>compose.Discard</code> and <code>compose.Select</code> now take variadic inputs, which means you don't have to provide a list of features to exclude/include.</li> </ul>"},{"location":"releases/0.2.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_bikes</code></li> </ul>"},{"location":"releases/0.2.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Classes that inherit from <code>feature_extraction.VectorizerMixin</code> can now directly be passed <code>str</code> instances instead of <code>dict</code> instances.</li> <li><code>feature_extraction.Agg</code> and <code>feature_extraction.TargetAgg</code> can now aggregate on multiple attributes.</li> </ul>"},{"location":"releases/0.2.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>RollingAccuracy</code></li> <li>Added <code>RollingCrossEntropy</code></li> <li>Added <code>RollingF1</code></li> <li>Added <code>RollingLogLoss</code></li> <li>Added <code>RollingMacroF1</code></li> <li>Added <code>RollingMacroPrecision</code></li> <li>Added <code>RollingMacroRecall</code></li> <li>Added <code>RollingMAE</code></li> <li>Added <code>RollingMicroF1</code></li> <li>Added <code>RollingMicroPrecision</code></li> <li>Added <code>RollingMicroRecall</code></li> <li>Added <code>RollingMSE</code></li> <li>Added <code>RollingPrecision</code></li> <li>Added <code>RollingRecall</code></li> <li>Added <code>RollingRMSE</code></li> <li>Added <code>RollingRMSLE</code></li> <li>Added <code>RollingSMAPE</code></li> </ul>"},{"location":"releases/0.2.0/#model_selection","title":"model_selection","text":"<ul> <li>Added <code>model_selection.online_qa_score</code>.</li> </ul>"},{"location":"releases/0.2.0/#proba","title":"proba","text":"<p>The <code>dist</code> module has been renamed to <code>proba</code> and is now public, for the moment it contains a single distribution called <code>proba.Gaussian</code>.</p>"},{"location":"releases/0.2.0/#naive_bayes","title":"naive_bayes","text":"<ul> <li>Added <code>naive_bayes.BernoulliNB</code>.</li> <li>Added <code>naive_bayes.ComplementNB</code>.</li> </ul>"},{"location":"releases/0.2.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.AdaBound</code>.</li> </ul>"},{"location":"releases/0.2.0/#tree","title":"tree","text":"<ul> <li>Added <code>tree.DecisionTreeClassifier</code>.</li> <li>Removed <code>tree.MondrianTreeClassifier</code> and <code>tree.MondrianTreeRegressor</code> because their performance wasn't good enough.</li> </ul>"},{"location":"releases/0.2.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.AutoCorrelation</code>.</li> <li>Added <code>stats.EWVar</code>.</li> <li>Rename <code>stats.Variance</code> to <code>stats.Var</code> and <code>stats.RollingVariance</code> to <code>stats.RollingVar</code>.</li> </ul>"},{"location":"releases/0.2.0/#stream","title":"stream","text":"<ul> <li>Added <code>stream.simulate_qa</code>.</li> </ul>"},{"location":"releases/0.2.0/#utils","title":"utils","text":"<ul> <li>Added <code>utils.SDFT</code>.</li> <li>Added <code>utils.Skyline</code>.</li> <li>Renamed the <code>window_size</code> parameter to <code>size</code> in <code>utils.Window</code> and <code>utils.SortedWindow</code>.</li> </ul>"},{"location":"releases/0.20.0/","title":"0.20.0 - 2023-11-09","text":"<ul> <li>River's mini-batch methods now support pandas v2. In particular, River conforms to pandas' new sparse API.</li> <li>Dropped support for Python 3.8.</li> <li>Added support for Python 3.12.</li> </ul>"},{"location":"releases/0.20.0/#anomaly","title":"anomaly","text":"<ul> <li>Added <code>api.anomaly.LocalOutlierFactor</code>, which is an online version of the LOF algorithm for anomaly detection that matches the scikit-learn implementation.</li> <li>Made <code>score_one</code> method of <code>api.anomaly.LocalOutlierFactor</code> stateless</li> <li>Defined default score for uninitialized detector</li> <li>Implementation of the <code>api.anomaly.StandardAbsoluteDeviation</code> algorithm, which is a uni-variate anomaly detection algorithm, based on the implementation in PySAD (Python Streaming Anomaly Detection)</li> </ul>"},{"location":"releases/0.20.0/#covariance","title":"covariance","text":"<ul> <li>Added <code>_from_state</code> method to <code>covariance.EmpiricalCovariance</code> to warm start from previous knowledge.</li> </ul>"},{"location":"releases/0.20.0/#clustering","title":"clustering","text":"<ul> <li>Add fixes to <code>cluster.DBSTREAM</code> algorithm, including:</li> <li>Addition of the <code>-</code> sign before the <code>fading_factor</code> in accordance with the algorithm 2 proposed by Hashler and Bolanos (2016) to allow clusters with low weights to be removed.</li> <li>The new <code>micro_cluster</code> is added with the key derived from the maximum key of the existing micro clusters. If the set of micro clusters is still empty (<code>len = 0</code>), a new micro cluster is added with key 0.</li> <li><code>cluster_is_up_to_date</code> is set to <code>True</code> at the end of the <code>self._recluster()</code> function.</li> <li>Shared density graph update timestamps are initialized with the current timestamp value</li> <li><code>neighbour_neighbours</code> are appended correctly to the <code>seed_set</code> when generating cluster labels</li> <li>When building weighted adjacency matrix the algorithm accounts for possibly orphaned entries in shared density graph</li> </ul>"},{"location":"releases/0.20.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.WebTraffic</code>, which is a dataset that counts the occurrences of events on a website. It is a multi-output regression dataset with two outputs.</li> </ul>"},{"location":"releases/0.20.0/#drift","title":"drift","text":"<ul> <li>Add <code>drift.NoDrift</code> to allow disabling the drift detection capabilities of models. This detector does nothing and always returns <code>False</code> when queried whether or not a concept drift was detected.</li> </ul>"},{"location":"releases/0.20.0/#evaluate","title":"evaluate","text":"<ul> <li>Added a <code>yield_predictions</code> parameter to <code>evaluate.iter_progressive_val_score</code>, which allows including predictions in the output.</li> </ul>"},{"location":"releases/0.20.0/#forest","title":"forest","text":"<ul> <li>Simplify inner the structures of <code>forest.ARFClassifier</code> and <code>forest.ARFRegressor</code> by removing redundant class hierarchy. Simplify how concept drift logging can be accessed in individual trees and in the forest as a whole.</li> </ul>"},{"location":"releases/0.20.0/#metrics","title":"metrics","text":"<ul> <li><code>metrics.ConfusionMatrix</code> may now be used with <code>evaluate.progressive_val_score</code> and <code>evaluate.iter_progressive_val_score</code>.</li> </ul>"},{"location":"releases/0.20.0/#proba","title":"proba","text":"<ul> <li>Added <code>_from_state</code> method to <code>proba.MultivariateGaussian</code> to warm start from previous knowledge.</li> </ul>"},{"location":"releases/0.20.0/#tree","title":"tree","text":"<ul> <li>Fix a bug in <code>tree.splitter.NominalSplitterClassif</code> that generated a mismatch between the number of existing tree branches and the number of tracked branches.</li> <li>Fix a bug in <code>tree.ExtremelyFastDecisionTreeClassifier</code> where the split re-evaluation failed when the current branch's feature was not available as a split option. The fix also enables the tree to pre-prune a leaf via the tie-breaking mechanism.</li> </ul>"},{"location":"releases/0.20.0/#stats","title":"stats","text":"<ul> <li>Implementation of the incremental Kolmogorov-Smirnov statistics (at <code>stats.KolmogorovSmirnov</code>), with the option to calculate either the original KS or Kuiper's test.</li> </ul>"},{"location":"releases/0.20.0/#utils","title":"utils","text":"<ul> <li>Removed <code>utils.dict2numpy</code> and <code>utils.numpy2dict</code> functions. They were not used anywhere in the library.</li> <li><code>utils.TimeRolling</code> now works correctly if two samples with the same timestamp are added in a row.</li> </ul>"},{"location":"releases/0.20.1/","title":"0.20.1 - 2023-11-09","text":"<p>Dummy release to make wheels available. No actual difference with v0.20.0.</p>"},{"location":"releases/0.21.0/","title":"0.21.0 - 2023-12-04","text":"<ul> <li>The <code>learn_one</code> and <code>learn_many</code> methods of each estimator don't not return anything anymore. This is to emphasize that the estimators are stateful.</li> <li>The <code>update</code> and <code>revert</code> method of classes that have also cease to return anything.</li> <li><code>sample_weight</code> has been renamed to <code>w</code>.</li> </ul>"},{"location":"releases/0.21.0/#covariance","title":"covariance","text":"<ul> <li>Fixed an issue where <code>update_many</code> would reset <code>covariance.EmpiricalCovariance</code> each time it was called.</li> </ul>"},{"location":"releases/0.21.1/","title":"0.21.1 - 2024-03-28","text":"<p>This release should fix some of the installation issues when building the River wheel from scratch.</p>"},{"location":"releases/0.21.1/#anomaly","title":"anomaly","text":"<ul> <li>Added <code>PredictiveAnomalyDetection</code>, a semi-supervised technique that employs a predictive model for anomaly detection.</li> </ul>"},{"location":"releases/0.21.1/#drift","title":"drift","text":"<ul> <li>Added <code>FHDDM</code> drift detector.</li> <li>Added a <code>iter_polars</code> function to iterate over the rows of a polars DataFrame.</li> </ul>"},{"location":"releases/0.21.1/#neighbors","title":"neighbors","text":"<ul> <li>Simplified <code>neighbors.SWINN</code> to avoid recursion limit and pickling issues.</li> </ul>"},{"location":"releases/0.21.2/","title":"0.21.2 - 2024-07-08","text":"<p>This release makes Polars an optional dependency instead of a required one.</p>"},{"location":"releases/0.21.2/#cluster","title":"cluster","text":"<ul> <li>Added <code>ODAC</code> (Online Divisive-Agglomerative Clustering) for clustering time series.</li> </ul>"},{"location":"releases/0.21.2/#forest","title":"forest","text":"<ul> <li>Fix error in <code>forest.ARFClassifer</code> and <code>forest.ARFRegressor</code> where the algorithms would crash in case the number of features available for learning went below the value of the <code>max_features</code> parameter (#1560).</li> </ul>"},{"location":"releases/0.22.0/","title":"0.22.0 - 2024-11-23","text":"<ul> <li>Dropped support for Python 3.9 and added support for Python 3.13.</li> <li>The methods <code>learn_one</code>, <code>learn_many</code>, <code>update</code>, <code>revert</code>, and <code>append</code> now return <code>None</code>.</li> <li>The units used in River have been corrected to be based on powers of 2 (KiB, MiB). This only changes the display, the behaviour is unchanged.</li> </ul>"},{"location":"releases/0.22.0/#cluster","title":"cluster","text":"<ul> <li>Update the description of <code>cluster.ODAC</code>.</li> <li>Change <code>draw</code> in <code>cluster.ODAC</code> to draw the hierarchical cluster's structure as a Graphviz graph.</li> <li>Add <code>render_ascii</code> in <code>cluster.ODAC</code> to render the hierarchical cluster's structure in text format.</li> <li>Work with <code>stats.Var</code> in <code>cluster.ODAC</code> when cluster has only one time series.</li> </ul>"},{"location":"releases/0.22.0/#drift","title":"drift","text":"<ul> <li>Make <code>drift.ADWIN</code> comply with the reference MOA implementation.</li> </ul>"},{"location":"releases/0.22.0/#feature-extraction","title":"feature extraction","text":"<ul> <li>The mini-batch methods for <code>feature_extraction.TFIDF</code> now systematically raise an exception, as they are not implemented.</li> </ul>"},{"location":"releases/0.22.0/#stats","title":"stats","text":"<ul> <li>Removed the unexported class <code>stats.CentralMoments</code>.</li> </ul>"},{"location":"releases/0.22.0/#tree","title":"tree","text":"<ul> <li>Instead of letting trees grow indefinitely, setting the <code>max_depth</code> parameter to <code>None</code> will stop the trees from growing when they reach the system recursion limit.</li> <li>Added <code>tree.LASTClassifier</code> (Local Adaptive Streaming Tree Classifier).</li> </ul>"},{"location":"releases/0.22.0/#stream","title":"stream","text":"<ul> <li><code>stream.iter_arff</code> now supports blank values (treated as missing values).</li> </ul>"},{"location":"releases/0.23.0/","title":"0.23.0 - 2025-09-07","text":""},{"location":"releases/0.23.0/#base","title":"base","text":"<ul> <li>The <code>tags</code> and <code>more_tags</code> properties of <code>base.Estimator</code> are now both a set of strings.</li> <li>The <code>base</code> module is now fully type-annotated. Some type hints have changed, but this does not impact the behaviour of the code. For instance, the regression target is now indicated as a float instead of a Number.</li> <li><code>base.Ensemble</code>, <code>base.Wrapper</code>, and <code>base.WrapperEnsemble</code> became generic with regard to the type they encapsulate.</li> </ul>"},{"location":"releases/0.23.0/#misc","title":"misc","text":"<ul> <li>The <code>misc</code> module is now fully type-annotated.</li> </ul>"},{"location":"releases/0.23.0/#neighbors","title":"neighbors","text":"<ul> <li>Remove the <code>itertools.cycle</code> usage from the <code>neighbors.ann.SWINN</code> search engine, as pickling <code>cycle</code> objects will not be supported anymore, starting from Python 3.14. This change has no effect from the user standpoint, as the 'cycle' usage was more of a gimmick than a necessity.</li> </ul>"},{"location":"releases/0.23.0/#feature-selection","title":"feature selection","text":"<ul> <li><code>feature_selection.SelectKBest</code> now supports <code>use_abs</code> parameter for the absolute value of the score statistics.</li> </ul>"},{"location":"releases/0.3.0/","title":"0.3.0 - 2019-06-23","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.3.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.load_chick_weights</code>.</li> </ul>"},{"location":"releases/0.3.0/#decomposition","title":"decomposition","text":"<ul> <li>Added <code>decomposition.LDA</code>.</li> </ul>"},{"location":"releases/0.3.0/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.HedgeRegressor</code>.</li> <li>Added <code>ensemble.StackingBinaryClassifier</code>.</li> </ul>"},{"location":"releases/0.3.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.FBeta</code></li> <li>Added <code>metrics.MacroFBeta</code></li> <li>Added <code>metrics.MicroFBeta</code></li> <li>Added <code>metrics.MultiFBeta</code></li> <li>Added <code>metrics.RollingFBeta</code></li> <li>Added <code>metrics.RollingMacroFBeta</code></li> <li>Added <code>metrics.RollingMicroFBeta</code></li> <li>Added <code>metrics.RollingMultiFBeta</code></li> <li>Added <code>metrics.Jaccard</code></li> <li>Added <code>metrics.RollingConfusionMatrix</code></li> <li>Added <code>metrics.RegressionMultiOutput</code></li> <li>Added <code>metrics.MCC</code></li> <li>Added <code>metrics.RollingMCC</code></li> <li>Added <code>metrics.ROCAUC</code></li> <li>Renamed <code>metrics.F1Score</code> to <code>metrics.F1</code>.</li> </ul>"},{"location":"releases/0.3.0/#multioutput","title":"multioutput","text":"<ul> <li>Added <code>multioutput.ClassifierChain</code>.</li> <li>Added <code>multioutput.RegressorChain</code>.</li> </ul>"},{"location":"releases/0.3.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.QuantileLoss</code></li> <li>Added <code>optim.MiniBatcher</code>.</li> </ul>"},{"location":"releases/0.3.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.Normalizer</code>.</li> </ul>"},{"location":"releases/0.3.0/#proba","title":"proba","text":"<ul> <li>Added <code>proba.Multinomial</code>.</li> </ul>"},{"location":"releases/0.4.1/","title":"0.4.1 - 2019-10-23","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.4.1/#base","title":"base","text":"<ul> <li>Tests are now much more extensive, thanks mostly to the newly added estimator tags.</li> </ul>"},{"location":"releases/0.4.1/#compose","title":"compose","text":"<ul> <li>Added <code>compose.Renamer</code>.</li> </ul>"},{"location":"releases/0.4.1/#datasets","title":"datasets","text":"<ul> <li>Added <code>fetch_kdd99_http</code>.</li> <li>Added <code>fetch_sms</code>.</li> <li>Added <code>fetch_trec07p</code>.</li> </ul>"},{"location":"releases/0.4.1/#ensemble","title":"ensemble","text":"<ul> <li>Removed <code>ensemble.HedgeBinaryClassifier</code> because its performance was subpar.</li> <li>Removed <code>ensemble.GroupRegressor</code>, as this should be a special case of <code>ensemble.StackingRegressor</code>.</li> </ul>"},{"location":"releases/0.4.1/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Fixed a bug where <code>feature_extraction.CountVectorizer</code> and <code>feature_extraction.TFIDFVectorizer</code> couldn't be pickled.</li> </ul>"},{"location":"releases/0.4.1/#linear_model","title":"linear_model","text":"<ul> <li><code>linear_model.LogisticRegression</code> and <code>linear_model.LinearRegression</code> now have an <code>intercept_lr</code> parameter.</li> </ul>"},{"location":"releases/0.4.1/#metrics","title":"metrics","text":"<ul> <li>Metrics can now be composed using the <code>+</code> operator, which is useful for evaluating multiple metrics at the same time.</li> <li>Added <code>metrics.Rolling</code>, which eliminates the need for a specific rolling implementation for each metric.</li> <li>Each metric can now be passed a <code>sample_weight</code> argument.</li> <li>Added <code>metrics.WeightedF1</code>.</li> <li>Added <code>metrics.WeightedFBeta</code>.</li> <li>Added <code>metrics.WeightedPrecision</code>.</li> <li>Added <code>metrics.WeightedRecall</code>.</li> </ul>"},{"location":"releases/0.4.1/#neighbors","title":"neighbors","text":"<ul> <li>Added <code>neighbors.KNeighborsRegressor</code>.</li> <li>Added <code>neighbors.KNeighborsClassifier</code>.</li> </ul>"},{"location":"releases/0.4.1/#optim","title":"optim","text":"<ul> <li>Added <code>optim.AdaMax</code>.</li> <li>The <code>optim</code> module has been reorganized into submodules; namely <code>optim.schedulers</code>, <code>optim.initializers</code>, and <code>optim.losses</code>. The top-level now only contains optimizers. Some classes have been renamed accordingly. See the documentation for details.</li> <li>Renamed <code>optim.VanillaSGD</code> to <code>optim.SGD</code>.</li> </ul>"},{"location":"releases/0.4.1/#stats","title":"stats","text":"<ul> <li>Added <code>stats.IQR</code>.</li> <li>Added <code>stats.RollingIQR</code>.</li> <li>Cythonized <code>stats.Mean</code> and <code>stats.Var</code>.</li> </ul>"},{"location":"releases/0.4.1/#stream","title":"stream","text":"<ul> <li>Added <code>stream.shuffle</code>.</li> <li><code>stream.iter_csv</code> now has <code>fraction</code> and <code>seed</code> parameters to sample rows, deterministically or not.</li> <li>Renamed <code>stream.iter_numpy</code> to <code>stream.iter_array</code>.</li> <li><code>stream.iter_csv</code> can now read from gzipped files.</li> </ul>"},{"location":"releases/0.4.1/#time_series","title":"time_series","text":"<ul> <li><code>time_series.Detrender</code> now has a <code>window_size</code> parameter for detrending with a rolling mean.</li> </ul>"},{"location":"releases/0.4.1/#tree","title":"tree","text":"<ul> <li>Added <code>tree.RandomForestClassifier</code>.</li> </ul>"},{"location":"releases/0.4.1/#utils","title":"utils","text":"<ul> <li>Fixed a bug where <code>utils.dot</code> could take longer than necessary.</li> </ul>"},{"location":"releases/0.4.3/","title":"0.4.3 - 2019-10-27","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.4.3/#base","title":"base","text":"<ul> <li>Model that inherit from <code>base.Wrapper</code> (e.g. <code>tree.RandomForestClassifier</code>) can now be pickled.</li> </ul>"},{"location":"releases/0.4.3/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.fetch_credit_card</code>.</li> </ul>"},{"location":"releases/0.4.3/#utils","title":"utils","text":"<ul> <li>Added the <code>utils.math</code> sub-module.</li> </ul>"},{"location":"releases/0.4.3/#tree","title":"tree","text":"<ul> <li>Fixed the <code>debug_one</code> method of <code>tree.DecisionTreeClassifier</code>.</li> </ul>"},{"location":"releases/0.4.4/","title":"0.4.4 - 2019-11-11","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul> <p>This release was mainly made to provide access to <code>wheels &lt;https://pythonwheels.com/&gt;</code>_ for Windows and MacOS.</p>"},{"location":"releases/0.4.4/#ensemble","title":"ensemble","text":"<ul> <li>Added <code>ensemble.AdaBoostClassifier</code>.</li> </ul>"},{"location":"releases/0.4.4/#linear_model","title":"linear_model","text":"<ul> <li>Added a <code>clip_gradient</code> parameter to <code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code>. Gradient clipping was already implemented, but the maximum absolute value can now be set by the user.</li> <li>The <code>intercept_lr</code> parameter of <code>linear_model.LinearRegression</code> and <code>linear_model.LogisticRegression</code> can now be passed an instance of <code>optim.schedulers.Scheduler</code> as well as a <code>float</code>.</li> </ul>"},{"location":"releases/0.4.4/#metrics","title":"metrics","text":"<ul> <li>Fixed <code>metrics.SMAPE</code>, the implementation was missing a multiplication by 2.</li> </ul>"},{"location":"releases/0.4.4/#optim","title":"optim","text":"<ul> <li>Added <code>optim.schedulers.Optimal</code> produces results that are identical to <code>sklearn.linear_model.SGDRegressor</code> and <code>sklearn.linear_model.SGDClassifier</code> when setting their <code>learning_rate</code> parameter to <code>'optimal'</code>.</li> </ul>"},{"location":"releases/0.4.4/#time_series","title":"time_series","text":"<ul> <li>Added <code>time_series.SNARIMAX</code>, a generic model which encompasses well-known time series models such as ARIMA and NARX.</li> </ul>"},{"location":"releases/0.5.0/","title":"0.5.0 - 2020-03-13","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.5.0/#compat","title":"compat","text":"<ul> <li>Added <code>compat.PyTorch2CremeRegressor</code>.</li> <li><code>compat.SKL2CremeRegressor</code> and <code>compat.SKL2CremeClassifier</code> now have an optional <code>batch_size</code> parameter in order to perform mini-batching.</li> </ul>"},{"location":"releases/0.5.0/#compose","title":"compose","text":"<ul> <li>Renamed <code>compose.Whitelister</code> to <code>compose.Select</code>.</li> <li>Renamed <code>compose.Blacklister</code> to <code>compose.Discard</code>.</li> </ul>"},{"location":"releases/0.5.0/#facto","title":"facto","text":"<ul> <li>Added <code>facto.FFMClassifier</code>.</li> <li>Added <code>facto.FFMRegressor</code>.</li> <li>Added <code>facto.FwFMClassifier</code>.</li> <li>Added <code>facto.FwFMRegressor</code>.</li> <li>Added <code>facto.HOFMClassifier</code>.</li> <li>Added <code>facto.HOFMRegressor</code>.</li> <li>Refactored <code>facto.FMClassifier</code>.</li> <li>Refactored <code>facto.FMRegressor</code>.</li> </ul>"},{"location":"releases/0.5.0/#feature_selection","title":"feature_selection","text":"<ul> <li>Added <code>feature_selection.PoissonInclusion</code>.</li> <li>Removed <code>feature_selection.RandomDiscarder</code> as it didn't make much sense.</li> </ul>"},{"location":"releases/0.5.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Renamed <code>feature_extraction.CountVectorizer</code> to <code>feature_extraction.BagOfWords</code>.</li> <li>Renamed <code>feature_extraction.TFIDFVectorizer</code> to <code>feature_extraction.TFIDF</code>.</li> <li>Added <code>preprocessor</code> and <code>ngram_range</code> parameters to <code>feature_extraction.BagOfWords</code>.</li> <li>Added <code>preprocessor</code> and <code>ngram_range</code> parameters to <code>feature_extraction.TFIDF</code>.</li> </ul>"},{"location":"releases/0.5.0/#datasets","title":"datasets","text":"<ul> <li>The <code>datasets</code> module has been overhauled. Each dataset is now a class (e.g. <code>fetch_electricity</code> has become <code>datasets.Elec2</code>).</li> <li>Added <code>datasets.TrumpApproval</code>.</li> <li>Added <code>datasets.MaliciousURL</code>.</li> <li>Added <code>datasets.gen.SEA</code>.</li> <li>Added <code>datasets.Higgs</code>.</li> <li>Added <code>datasets.MovieLens100K</code>.</li> <li>Added <code>datasets.Bananas</code>.</li> <li>Added <code>datasets.Taxis</code>.</li> <li>Added <code>datasets.ImageSegments</code>.</li> <li>Added <code>datasets.SMTP</code></li> </ul>"},{"location":"releases/0.5.0/#impute","title":"impute","text":"<ul> <li>Added <code>impute.PreviousImputer</code>.</li> </ul>"},{"location":"releases/0.5.0/#linear_model","title":"linear_model","text":"<ul> <li><code>linear_model.FMClassifier</code> has been moved to the <code>facto</code> module.</li> <li><code>linear_model.FMRegressor</code> has been  moved to the <code>facto</code> module.</li> <li>Added <code>linear_model.ALMAClassifier</code>.</li> </ul>"},{"location":"releases/0.5.0/#metrics","title":"metrics","text":"<ul> <li>Added <code>metrics.ClassificationReport</code>.</li> <li>Added <code>metrics.TimeRolling</code>.</li> <li>The implementation of <code>metrics.ROCAUC</code> was incorrect. Using the trapezoidal rule instead of Simpson's rule seems to be more robust.</li> <li><code>metrics.PerClass</code> has been removed; it is recommended that you use <code>metrics.ClassificationReport</code> instead as it gives a better overview.</li> </ul>"},{"location":"releases/0.5.0/#meta","title":"meta","text":"<ul> <li>Moved <code>meta.TransformedTargetRegressor</code> and <code>meta.BoxCoxRegressor</code> to this module (they were previously in the <code>compose</code> module).</li> <li>Added <code>meta.PredClipper</code></li> </ul>"},{"location":"releases/0.5.0/#model_selection","title":"model_selection","text":"<ul> <li>Added <code>model_selection.expand_param_grid</code> to generate a list of models from a grid of parameters.</li> <li>Added the <code>model_selection.successive_halving</code> method for selecting hyperparameters.</li> <li>The <code>online_score</code> and <code>online_qa_score</code> methods have been merged into a single method named <code>model_selection.progressive_val_score</code>.</li> </ul>"},{"location":"releases/0.5.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added <code>preprocessing.RBFSampler</code>.</li> <li>Added <code>preprocessing.MaxAbsScaler</code>.</li> <li>Added <code>preprocessing.RobustScaler</code>.</li> <li>Added <code>preprocessing.Binarizer</code>.</li> <li>Added <code>with_mean</code> and <code>with_std</code> parameters to <code>preprocessing.StandardScaler</code>.</li> </ul>"},{"location":"releases/0.5.0/#optim","title":"optim","text":"<ul> <li>Added <code>optim.losses.BinaryFocalLoss</code>.</li> <li>Added the <code>optim.AMSGrad</code> optimizer.</li> <li>Added the <code>optim.Nadam</code> optimizer.</li> <li>Added <code>optim.losses.Poisson</code>.</li> <li>Fixed a performance bug in <code>optim.NesterovMomentum</code>.</li> </ul>"},{"location":"releases/0.5.0/#reco","title":"reco","text":"<ul> <li>Added <code>reco.FunkMF</code>.</li> <li>Renamed <code>reco.SVD</code> to <code>reco.BiasedMF</code>.</li> <li>Renamed <code>reco.SGDBaseline</code> to <code>reco.Baseline</code>.</li> <li>Models now expect a <code>dict</code> input with <code>user</code> and <code>item</code> fields.</li> </ul>"},{"location":"releases/0.5.0/#sampling","title":"sampling","text":"<ul> <li>Added <code>sampling.RandomUnderSampler</code>.</li> <li>Added <code>sampling.RandomOverSampler</code>.</li> <li>Added <code>sampling.RandomSampler</code>.</li> <li>Added <code>sampling.HardSamplingClassifier</code>.</li> <li>Added <code>sampling.HardSamplingRegressor</code>.</li> </ul>"},{"location":"releases/0.5.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.AbsMax</code>.</li> <li>Added <code>stats.RollingAbsMax</code>.</li> </ul>"},{"location":"releases/0.5.0/#stream","title":"stream","text":"<ul> <li>Added <code>stream.iter_libsvm</code>.</li> <li><code>stream.iter_csv</code> now supports reading from '.zip' files.</li> <li>Added <code>stream.Cache</code>.</li> <li>Added a <code>drop</code> parameter to <code>stream.iter_csv</code> to discard fields.</li> </ul>"},{"location":"releases/0.5.1/","title":"0.5.1 - 2020-03-29","text":"<ul> <li>PyPI</li> <li>GitHub</li> </ul>"},{"location":"releases/0.5.1/#compose","title":"compose","text":"<ul> <li><code>compose.Pipeline</code> and <code>compose.TransformerUnion</code> now variadic arguments as input instead of a list. This doesn't change anything when using the shorthand operators <code>|</code> and <code>+</code>.</li> </ul>"},{"location":"releases/0.5.1/#model_selection","title":"model_selection","text":"<ul> <li>Removed <code>model_selection.successive_halving</code></li> <li>Added <code>model_selection.SuccessiveHalvingRegressor</code> and <code>model_selection.SuccessiveHalvingClassifier</code></li> </ul>"},{"location":"releases/0.5.1/#stream","title":"stream","text":"<ul> <li>Added a <code>copy</code> parameter to <code>stream.simulate_qa</code> in order to handle unwanted feature modifications.</li> </ul>"},{"location":"releases/0.5.1/#tree","title":"tree","text":"<ul> <li>Added a <code>curtail_under</code> parameter to <code>tree.DecisionTreeClassifier</code>.</li> <li>The speed and accuracy of both <code>tree.DecisionTreeClassifier</code> and <code>tree.RandomForestClassifier</code> has been slightly improved for numerical attributes.</li> <li>The esthetics of the <code>tree.DecisionTreeClassifier.draw</code> method have been improved.</li> </ul>"},{"location":"releases/0.6.0/","title":"0.6.0 - 2020-06-09","text":""},{"location":"releases/0.6.0/#base","title":"base","text":"<ul> <li>Added a new base class called <code>SupervisedTransformer</code> from which supervised transformers inherit from. Before this, supervised transformers has a <code>is_supervised</code> property.</li> </ul>"},{"location":"releases/0.6.0/#compose","title":"compose","text":"<ul> <li>Added <code>compose.SelectType</code>, which allows selecting feature subsets based on their type.</li> <li>Added a <code>score_one</code> method to <code>compose.Pipeline</code> so that estimators from the <code>anomaly</code> module can be pipelined.</li> <li>Added <code>compose.Grouper</code>, which allows applying transformers within different subgroups.</li> </ul>"},{"location":"releases/0.6.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.Music</code>, which is a dataset for multi-output binary classification.</li> <li>Added <code>datasets.synth.Friedman</code>, which is synthetic regression dataset.</li> <li>The <code>datasets.gen</code> module has been renamed to <code>datasets.synth</code></li> <li>Each dataset now has a <code>__repr__</code> method which displays some descriptive information.</li> <li>Added <code>datasets.Insects</code>, which has 10 variants.</li> </ul>"},{"location":"releases/0.6.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li><code>feature_extraction.Differ</code> has been deprecated. We might put it back in a future if we find a better design.</li> </ul>"},{"location":"releases/0.6.0/#impute","title":"impute","text":"<ul> <li><code>impute.StatImputer</code> has been completely refactored.</li> </ul>"},{"location":"releases/0.6.0/#metrics","title":"metrics","text":"<ul> <li>In <code>metrics.SMAPE</code>, instead of raising a <code>ZeroDivisionError</code>, the convention is now to use 0 when both <code>y_true</code> and <code>y_pred</code> are equal to 0.</li> </ul>"},{"location":"releases/0.6.0/#model_selection","title":"model_selection","text":"<ul> <li>Added the possibility to configure how the progress is printed in <code>model_selection.progressive_val_score</code>. For instance, the progress can now be printed to a file by providing the <code>file</code> argument.</li> </ul>"},{"location":"releases/0.6.0/#multiclass","title":"multiclass","text":"<ul> <li>Added <code>multiclass.OutputCodeClassifier</code>.</li> <li>Added <code>multiclass.OneVsOneClassifier</code>.</li> </ul>"},{"location":"releases/0.6.0/#multioutput","title":"multioutput","text":"<ul> <li>Fixed a bug where <code>multioutput.ClassifierChain</code> and <code>multioutput.RegressorChain</code> could not be pickled.</li> </ul>"},{"location":"releases/0.6.0/#stats","title":"stats","text":"<ul> <li>Added <code>stats.Shift</code>, which can be used to compute statistics over a shifted version of a variable.</li> <li>Added <code>stats.Link</code>, which can be used to compose univariate statistics. Univariate statistics can now be composed via the <code>|</code> operator.</li> <li>Renamed <code>stats.Covariance</code> to <code>stats.Cov</code>.</li> <li>Renamed <code>stats.PearsonCorrelation</code> to <code>stats.PearsonCorr</code>.</li> <li>Renamed <code>stats.AutoCorrelation</code> to <code>stats.AutoCorr</code>.</li> <li>Added <code>stats.RollingCov</code>, which computes covariance between two variables over a window.</li> <li>Added <code>stats.RollingPearsonCorr</code>, which computes the Pearson correlation over a window.</li> </ul>"},{"location":"releases/0.6.0/#stream","title":"stream","text":"<ul> <li>Added a <code>stream.iter_sql</code> utility method to work with SQLAlchemy.</li> <li>The <code>target_name</code> parameter of <code>stream.iter_csv</code> has been renamed to <code>target</code>. It can now be passed a list of values in order to support multi-output scenarios.</li> <li>Added <code>stream.iter_arff</code> for handling ARFF files.</li> </ul>"},{"location":"releases/0.6.0/#tree","title":"tree","text":"<ul> <li>Cancelled the behavior where <code>tree.DecisionTreeRegressor</code> would raise an exception when no split was found.</li> </ul>"},{"location":"releases/0.6.1/","title":"0.6.1 - 2020-06-10","text":""},{"location":"releases/0.6.1/#compose","title":"compose","text":"<ul> <li>Fixed a bug that occurred when part of a <code>compose.Transformer</code> was a <code>compose.Pipeline</code> and wasn't properly handled.</li> </ul>"},{"location":"releases/0.7.0/","title":"0.7.0 - 2021-04-16","text":"<p>Alas, no release notes for this one.</p>"},{"location":"releases/0.7.1/","title":"0.7.1 - 2021-06-13","text":"<p>Fixed an issue where scikit-learn was imported in <code>sam_knn.py</code> but wasn't specified as a dependency.</p>"},{"location":"releases/0.7.1/#expert","title":"expert","text":"<ul> <li>Each expert model will now raise a <code>NotEnoughModels</code> exception if only a single model is passed.</li> </ul>"},{"location":"releases/0.7.1/#stream","title":"stream","text":"<ul> <li>Added <code>drop_nones</code> parameter to <code>stream.iter_csv</code>.</li> </ul>"},{"location":"releases/0.8.0/","title":"0.8.0 - 2021-08-31","text":""},{"location":"releases/0.8.0/#base","title":"base","text":"<ul> <li>The <code>predict_many</code> and <code>predict_proba_many</code> methods have been removed from <code>base.Classifier</code>. They're part of <code>base.MiniBatchClassifier</code>.</li> </ul>"},{"location":"releases/0.8.0/#ensemble","title":"ensemble","text":"<ul> <li>Implemented <code>ensemble.VotingClassifier</code>.</li> <li>Implemented <code>ensemble.SRPRegressor</code>.</li> </ul>"},{"location":"releases/0.8.0/#meta","title":"meta","text":"<ul> <li>Renamed <code>meta.TransformedTargetRegressor</code> to <code>meta.TargetTransformRegressor</code>.</li> <li>Added <code>meta.TargetStandardScaler</code>.</li> </ul>"},{"location":"releases/0.8.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Added a <code>with_std</code> parameter to <code>StandardScaler</code>.</li> </ul>"},{"location":"releases/0.8.0/#rules","title":"rules","text":"<ul> <li>Added <code>rules.AMRules</code></li> </ul>"},{"location":"releases/0.8.0/#stats","title":"stats","text":"<ul> <li>Make <code>stats.RollingQuantile</code> match the default behavior of Numpy's <code>quantile</code> function.</li> </ul>"},{"location":"releases/0.8.0/#tree","title":"tree","text":"<ul> <li>Unified base class structure applied to all tree models.</li> <li>Bug fixes.</li> <li>Added <code>tree.SGTClassifier</code> and <code>tree.SGTRegressor</code>.</li> </ul>"},{"location":"releases/0.9.0/","title":"0.9.0 - 2021-11-30","text":"<ul> <li>Wheels for Python 3.6 have been dropped.</li> <li>Wheels for Python 3.9 have been added.</li> </ul>"},{"location":"releases/0.9.0/#anomaly","title":"anomaly","text":"<ul> <li>Moved <code>api.anomaly.base.AnomalyDetector</code> to <code>anomaly.AnomalyDetector</code>.</li> <li>Implemented <code>anomaly.ConstantThresholder</code>.</li> <li>Implemented <code>anomaly.QuantileThresholder</code>.</li> <li>Implemented <code>api.anomaly.OneClassSVM</code>.</li> </ul>"},{"location":"releases/0.9.0/#base","title":"base","text":"<ul> <li>Renamed <code>base.WrapperMixin</code> to <code>base.Wrapper</code>.</li> <li>Introduced <code>base.WrapperEnsemble</code>.</li> <li>Clarified the difference between a <code>base.typing.Dataset</code> and a <code>base.typing.Stream</code>. A <code>Stream</code> is an instance of a <code>Dataset</code> and is stateful. A <code>Dataset</code> is stateless. It's essentially the same difference between an <code>Iterable</code> and an <code>Iterator</code> in the Python standard library.</li> </ul>"},{"location":"releases/0.9.0/#compat","title":"compat","text":"<ul> <li>Added <code>compat.PyTorch2RiverClassifier</code></li> <li>Implemented median absolute deviation in <code>stats.MAD</code>.</li> <li>Refactored <code>compat.PyTorch2RiverRegressor</code></li> <li>Fixed an issue where some statistics could not be printed if they had not seen any data yet.</li> </ul>"},{"location":"releases/0.9.0/#compose","title":"compose","text":"<ul> <li>You can now use a <code>list</code> as a shorthand to build a <code>TransformerUnion</code>.</li> <li>Fixed a visualization issue when using a pipeline with multiple feature unions.</li> <li>The prejudiced terms <code>blacklist</code> and <code>whitelist</code> have both been renamed to <code>keys</code>.</li> <li>Removed <code>learn_unsupervised</code> parameter from pipeline methods.</li> <li>Implemented <code>compose.TransformerProduct</code>.</li> </ul>"},{"location":"releases/0.9.0/#datasets","title":"datasets","text":"<ul> <li>Added <code>datasets.Keystroke</code>.</li> </ul>"},{"location":"releases/0.9.0/#ensemble","title":"ensemble","text":"<ul> <li>Bug fixes in <code>ensemble.SRPClassifier</code> and <code>ensemble.SRPRegressor</code>.</li> <li>Some estimators have been moved into the <code>ensemble</code> module.</li> </ul>"},{"location":"releases/0.9.0/#feature_extraction","title":"feature_extraction","text":"<ul> <li>Implemented <code>feature_extraction.Lagger</code>.</li> <li>Implemented <code>feature_extraction.TargetLagger</code>.</li> </ul>"},{"location":"releases/0.9.0/#meta","title":"meta","text":"<p>This module has been deleted.</p> <ul> <li>Move <code>meta.PredClipper</code> to the <code>preprocessing</code> module.</li> <li>Removed <code>meta.BoxCoxRegressor</code>.</li> <li>Moved <code>meta.TargetTransformRegressor</code> to <code>compose.TargetTransformRegressor</code>.</li> <li>Moved <code>meta.TargetStandardScaler</code> to <code>preprocessing.TargetStandardScaler</code>.</li> </ul>"},{"location":"releases/0.9.0/#model_selection","title":"model_selection","text":"<ul> <li>This new module replaces the <code>expert</code> module.</li> <li>Implemented <code>model_selection.GreedyRegressor</code>.</li> <li>Added <code>ModelSelector</code> base class.</li> </ul>"},{"location":"releases/0.9.0/#optim","title":"optim","text":"<ul> <li><code>optim.Adam</code> and <code>optim.RMSProp</code> now work with <code>utils.VectorDict</code>s as well as <code>numpy.ndarray</code>s.</li> <li>Added <code>optim.losses.Huber</code>.</li> </ul>"},{"location":"releases/0.9.0/#preprocessing","title":"preprocessing","text":"<ul> <li>Enabled <code>preprocessing.OneHotEncoder</code> to one-hot encode values that are list or sets.</li> </ul>"},{"location":"releases/0.9.0/#reco","title":"reco","text":"<ul> <li>Added a <code>debug_one</code> method to <code>reco.FMRegressor</code>.</li> </ul>"},{"location":"releases/0.9.0/#selection","title":"selection","text":"<ul> <li>This new module replaces the <code>expert</code> module.</li> <li>Implemented <code>selection.GreedyExpertRegressor</code>.</li> </ul>"},{"location":"releases/0.9.0/#stats","title":"stats","text":"<ul> <li>Fixed an issue where some statistics could not be printed if they had not seen any data yet.</li> <li>Implemented median absolute deviation in <code>stats.MAD</code>.</li> <li>The <code>stats.Mean</code> and <code>stats.Var</code> implementations have been made more numerically stable.</li> </ul>"},{"location":"releases/0.9.0/#time_series","title":"time_series","text":"<ul> <li><code>time_series.Detrender</code> and <code>time_series.GroupDetrender</code> have been removed as they overlap with <code>preprocessing.TargetStandardScaler</code>.</li> <li>Implemented a <code>time_series.evaluate</code> method, which performs progressive validation for time series scenarios.</li> <li>Implemented <code>time_series.HorizonMetric</code> class to evaluate the performance of a forecasting model at each time step along a horizon.</li> <li>Implemented <code>time_series.HoltWinters</code>.</li> </ul>"},{"location":"releases/0.9.0/#utils","title":"utils","text":"<ul> <li>Moved <code>model_selection.expand_param_grid</code> to <code>utils.expand_param_grid</code>.</li> <li>Added <code>utils.poisson</code>.</li> <li>Added the <code>utils.log_method_calls</code> context manager.</li> <li>Added the <code>utils.warm_up_mode</code> context manager.</li> <li>Added the <code>utils.pure_inference_model</code> context manager.</li> </ul>"},{"location":"releases/unreleased/","title":"Unreleased","text":""},{"location":"releases/unreleased/#datasets","title":"datasets","text":"<ul> <li>Fixed download in Insects dataset. The datasets incremental_abrupt_imbalanced, incremental_imbalanced, incremental_reoccurring_imbalanced and out-of-control are not supported anymore.</li> <li>Refactored <code>benchmarks</code> and added plotly dependency for interactive plots</li> </ul>"},{"location":"releases/unreleased/#stats","title":"stats","text":"<ul> <li>Added <code>update_many</code> method to <code>stats.PearsonCorr</code>.</li> <li>Changed the calculation of the Kuiper statistic in <code>base.KolmogorovSmirnov</code> to correspond to the reference implementation. The Kuiper statistic uses the difference between the maximum value and the minimum value.</li> </ul>"},{"location":"releases/unreleased/#tree","title":"tree","text":"<ul> <li>Added handling for division by zero in <code>tree.hoeffding_tree</code> for leaf size estimation.</li> </ul>"}]}